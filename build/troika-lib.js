var troika = (function (exports) {
	'use strict';

	/**
	 * @license
	 * Copyright 2010-2021 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */
	/**
	 * @license
	 * Copyright 2010-2021 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */
	const REVISION = '156dev';
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBAIntegerFormat = 1033;

	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const RED_RGTC1_Format = 36283;
	const SIGNED_RED_RGTC1_Format = 36284;
	const RED_GREEN_RGTC2_Format = 36285;
	const SIGNED_RED_GREEN_RGTC2_Format = 36286;
	/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */
	const LinearEncoding = 3000;
	/** @deprecated Use SRGBColorSpace in three.js r152+. */
	const sRGBEncoding = 3001;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;

	// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
	const NoColorSpace = '';
	const SRGBColorSpace = 'srgb';
	const LinearSRGBColorSpace = 'srgb-linear';
	const DisplayP3ColorSpace = 'display-p3';

	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;

	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;

	const NeverCompare = 512;
	const LessCompare = 513;
	const EqualCompare = 514;
	const LessEqualCompare = 515;
	const GreaterCompare = 516;
	const NotEqualCompare = 517;
	const GreaterEqualCompare = 518;
	const AlwaysCompare = 519;

	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const GLSL3 = '300 es';

	const _SRGBAFormat = 1035; // fallback for WebGL 1

	const WebGLCoordinateSystem = 2000;
	const WebGPUCoordinateSystem = 2001;

	const _lut$1 = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

	let _seed = 1234567;


	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI;

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID$1() {

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut$1[ d0 & 0xff ] + _lut$1[ d0 >> 8 & 0xff ] + _lut$1[ d0 >> 16 & 0xff ] + _lut$1[ d0 >> 24 & 0xff ] + '-' +
				_lut$1[ d1 & 0xff ] + _lut$1[ d1 >> 8 & 0xff ] + '-' + _lut$1[ d1 >> 16 & 0x0f | 0x40 ] + _lut$1[ d1 >> 24 & 0xff ] + '-' +
				_lut$1[ d2 & 0x3f | 0x80 ] + _lut$1[ d2 >> 8 & 0xff ] + '-' + _lut$1[ d2 >> 16 & 0xff ] + _lut$1[ d2 >> 24 & 0xff ] +
				_lut$1[ d3 & 0xff ] + _lut$1[ d3 >> 8 & 0xff ] + _lut$1[ d3 >> 16 & 0xff ] + _lut$1[ d3 >> 24 & 0xff ];

		// .toLowerCase() here flattens concatenated strings to save heap memory space.
		return uuid.toLowerCase();

	}

	function clamp$1( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	}

	// compute euclidean modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo( n, m ) {

		return ( ( n % m ) + m ) % m;

	}

	// Linear mapping from range <a1, a2> to range <b1, b2>
	function mapLinear( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	}

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
	function inverseLerp( x, y, value ) {

		if ( x !== y ) {

			return ( value - x ) / ( y - x );

		} else {

			return 0;

		}

	}

	// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	}

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	function damp( x, y, lambda, dt ) {

		return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

	}

	// https://www.desmos.com/calculator/vcsjnyz7x4
	function pingpong( x, length = 1 ) {

		return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

	}

	// http://en.wikipedia.org/wiki/Smoothstep
	function smoothstep$1( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	}

	function smootherstep( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	}

	// Random integer from <low, high> interval
	function randInt( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	}

	// Random float from <low, high> interval
	function randFloat( low, high ) {

		return low + Math.random() * ( high - low );

	}

	// Random float from <-range/2, range/2> interval
	function randFloatSpread( range ) {

		return range * ( 0.5 - Math.random() );

	}

	// Deterministic pseudo-random float in the interval [ 0, 1 ]
	function seededRandom( s ) {

		if ( s !== undefined ) _seed = s;

		// Mulberry32 generator

		let t = _seed += 0x6D2B79F5;

		t = Math.imul( t ^ t >>> 15, t | 1 );

		t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

		return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

	}

	function degToRad( degrees ) {

		return degrees * DEG2RAD;

	}

	function radToDeg( radians ) {

		return radians * RAD2DEG;

	}

	function isPowerOfTwo( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	function ceilPowerOfTwo( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	}

	function floorPowerOfTwo( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

	function setQuaternionFromProperEuler( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

		}

	}

	function denormalize( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint32Array:

				return value / 4294967295.0;

			case Uint16Array:

				return value / 65535.0;

			case Uint8Array:

				return value / 255.0;

			case Int32Array:

				return Math.max( value / 2147483647.0, - 1.0 );

			case Int16Array:

				return Math.max( value / 32767.0, - 1.0 );

			case Int8Array:

				return Math.max( value / 127.0, - 1.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	function normalize$1( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint32Array:

				return Math.round( value * 4294967295.0 );

			case Uint16Array:

				return Math.round( value * 65535.0 );

			case Uint8Array:

				return Math.round( value * 255.0 );

			case Int32Array:

				return Math.round( value * 2147483647.0 );

			case Int16Array:

				return Math.round( value * 32767.0 );

			case Int8Array:

				return Math.round( value * 127.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	const MathUtils = {
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID$1,
		clamp: clamp$1,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep$1,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler,
		normalize: normalize$1,
		denormalize: denormalize
	};

	var MathUtils$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID$1,
		clamp: clamp$1,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep$1,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler,
		normalize: normalize$1,
		denormalize: denormalize,
		MathUtils: MathUtils
	});

	class Matrix3 {

		constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			Matrix3.prototype.isMatrix3 = true;

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( n11 !== undefined ) {

				this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

			}

		}

		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).invert().transpose();

		}

		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		//

		scale( sx, sy ) {

			this.premultiply( _m3.makeScale( sx, sy ) );

			return this;

		}

		rotate( theta ) {

			this.premultiply( _m3.makeRotation( - theta ) );

			return this;

		}

		translate( tx, ty ) {

			this.premultiply( _m3.makeTranslation( tx, ty ) );

			return this;

		}

		// for 2D Transforms

		makeTranslation( x, y ) {

			if ( x.isVector2 ) {

				this.set(

					1, 0, x.x,
					0, 1, x.y,
					0, 0, 1

				);

			} else {

				this.set(

					1, 0, x,
					0, 1, y,
					0, 0, 1

				);

			}

			return this;

		}

		makeRotation( theta ) {

			// counterclockwise

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			this.set(

				c, - s, 0,
				s, c, 0,
				0, 0, 1

			);

			return this;

		}

		makeScale( x, y ) {

			this.set(

				x, 0, 0,
				0, y, 0,
				0, 0, 1

			);

			return this;

		}

		//

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

		clone() {

			return new this.constructor().fromArray( this.elements );

		}

	}

	const _m3 = /*@__PURE__*/ new Matrix3();

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	/**
	 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
	 * or clipping. Based on W3C specifications for sRGB and Display P3,
	 * and ICC specifications for the D50 connection space. Values in/out
	 * are _linear_ sRGB and _linear_ Display P3.
	 *
	 * Note that both sRGB and Display P3 use the sRGB transfer functions.
	 *
	 * Reference:
	 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
	 */

	const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().fromArray( [
		0.8224621, 0.0331941, 0.0170827,
		0.1775380, 0.9668058, 0.0723974,
		- 0.0000001, 0.0000001, 0.9105199
	] );

	const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().fromArray( [
		1.2249401, - 0.0420569, - 0.0196376,
		- 0.2249404, 1.0420571, - 0.0786361,
		0.0000001, 0.0000000, 1.0982735
	] );

	function DisplayP3ToLinearSRGB( color ) {

		// Display P3 uses the sRGB transfer functions
		return color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB );

	}

	function LinearSRGBToDisplayP3( color ) {

		// Display P3 uses the sRGB transfer functions
		return color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB();

	}

	// Conversions from <source> to Linear-sRGB reference space.
	const TO_LINEAR = {
		[ LinearSRGBColorSpace ]: ( color ) => color,
		[ SRGBColorSpace ]: ( color ) => color.convertSRGBToLinear(),
		[ DisplayP3ColorSpace ]: DisplayP3ToLinearSRGB,
	};

	// Conversions to <target> from Linear-sRGB reference space.
	const FROM_LINEAR = {
		[ LinearSRGBColorSpace ]: ( color ) => color,
		[ SRGBColorSpace ]: ( color ) => color.convertLinearToSRGB(),
		[ DisplayP3ColorSpace ]: LinearSRGBToDisplayP3,
	};

	const ColorManagement = {

		enabled: true,

		get legacyMode() {

			return ! this.enabled;

		},

		set legacyMode( legacyMode ) {

			this.enabled = ! legacyMode;

		},

		get workingColorSpace() {

			return LinearSRGBColorSpace;

		},

		set workingColorSpace( colorSpace ) {

		},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			const sourceToLinear = TO_LINEAR[ sourceColorSpace ];
			const targetFromLinear = FROM_LINEAR[ targetColorSpace ];

			if ( sourceToLinear === undefined || targetFromLinear === undefined ) {

				throw new Error( `Unsupported color space conversion, "${ sourceColorSpace }" to "${ targetColorSpace }".` );

			}

			return targetFromLinear( sourceToLinear( color ) );

		},

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

	};

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	class Color {

		constructor( r, g, b ) {

			this.isColor = true;

			this.r = 1;
			this.g = 1;
			this.b = 1;

			return this.set( r, g, b );

		}

		set( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string

				const value = r;

				if ( value && value.isColor ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

			} else {

				this.setRGB( r, g, b );

			}

			return this;

		}

		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		setHex( hex, colorSpace = SRGBColorSpace ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

			this.r = r;
			this.g = g;
			this.b = b;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo( h, 1 );
			s = clamp$1( s, 0, 1 );
			l = clamp$1( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setStyle( style, colorSpace = SRGBColorSpace ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

			}


			let m;

			if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)

							handleAlpha( color[ 4 ] );

							return this.setRGB(
								Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
								Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
								Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
								colorSpace
							);

						}

						if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

							handleAlpha( color[ 4 ] );

							return this.setRGB(
								Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
								Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
								Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
								colorSpace
							);

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

							handleAlpha( color[ 4 ] );

							return this.setHSL(
								parseFloat( color[ 1 ] ) / 360,
								parseFloat( color[ 2 ] ) / 100,
								parseFloat( color[ 3 ] ) / 100,
								colorSpace
							);

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					return this.setRGB(
						parseInt( hex.charAt( 0 ), 16 ) / 15,
						parseInt( hex.charAt( 1 ), 16 ) / 15,
						parseInt( hex.charAt( 2 ), 16 ) / 15,
						colorSpace
					);

				} else if ( size === 6 ) {

					// #ff0000
					return this.setHex( parseInt( hex, 16 ), colorSpace );

				} else ;

			} else if ( style && style.length > 0 ) {

				return this.setColorName( style, colorSpace );

			}

			return this;

		}

		setColorName( style, colorSpace = SRGBColorSpace ) {

			// color keywords
			const hex = _colorKeywords[ style.toLowerCase() ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex, colorSpace );

			}

			return this;

		}

		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		getHex( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			return Math.round( clamp$1( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp$1( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp$1( _color.b * 255, 0, 255 ) );

		}

		getHexString( colorSpace = SRGBColorSpace ) {

			return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

		}

		getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			const r = _color.r, g = _color.g, b = _color.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			target.r = _color.r;
			target.g = _color.g;
			target.b = _color.b;

			return target;

		}

		getStyle( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			const r = _color.r, g = _color.g, b = _color.b;

			if ( colorSpace !== SRGBColorSpace ) {

				// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
				return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

			}

			return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

		}

		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		}

		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		lerpColors( color1, color2, alpha ) {

			this.r = color1.r + ( color2.r - color1.r ) * alpha;
			this.g = color1.g + ( color2.g - color1.g ) * alpha;
			this.b = color1.b + ( color2.b - color1.b ) * alpha;

			return this;

		}

		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = lerp( _hslA.h, _hslB.h, alpha );
			const s = lerp( _hslA.s, _hslB.s, alpha );
			const l = lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		setFromVector3( v ) {

			this.r = v.x;
			this.g = v.y;
			this.b = v.z;

			return this;

		}

		applyMatrix3( m ) {

			const r = this.r, g = this.g, b = this.b;
			const e = m.elements;

			this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
			this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
			this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

			return this;

		}

		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			return this;

		}

		toJSON() {

			return this.getHex();

		}

		*[ Symbol.iterator ]() {

			yield this.r;
			yield this.g;
			yield this.b;

		}

	}

	const _color = /*@__PURE__*/ new Color();

	Color.NAMES = _colorKeywords;

	class Quaternion {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this.isQuaternion = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( t === 0 ) {

				dst[ dstOffset + 0 ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
				return;

			}

			if ( t === 1 ) {

				dst[ dstOffset + 0 ] = x1;
				dst[ dstOffset + 1 ] = y1;
				dst[ dstOffset + 2 ] = z1;
				dst[ dstOffset + 3 ] = w1;
				return;

			}

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					const sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		setFromEuler( euler, update ) {

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			let r = vFrom.dot( vTo ) + 1;

			if ( r < Number.EPSILON ) {

				// vFrom and vTo point in opposite directions

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		angleTo( q ) {

			return 2 * Math.acos( Math.abs( clamp$1( this.dot( q ), - 1, 1 ) ) );

		}

		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		invert() {

			// quaternion is assumed to have unit length

			return this.conjugate();

		}

		conjugate() {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		}

		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		multiply( q ) {

			return this.multiplyQuaternions( this, q );

		}

		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		slerp( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			const x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		}

		slerpQuaternions( qa, qb, t ) {

			return this.copy( qa ).slerp( qb, t );

		}

		random() {

			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.

			const u1 = Math.random();
			const sqrt1u1 = Math.sqrt( 1 - u1 );
			const sqrtu1 = Math.sqrt( u1 );

			const u2 = 2 * Math.PI * Math.random();

			const u3 = 2 * Math.PI * Math.random();

			return this.set(
				sqrt1u1 * Math.cos( u2 ),
				sqrtu1 * Math.sin( u3 ),
				sqrtu1 * Math.cos( u3 ),
				sqrt1u1 * Math.sin( u2 ),
			);

		}

		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		}

		toJSON() {

			return this.toArray();

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._w;

		}

	}

	class Vector3 {

		constructor( x = 0, y = 0, z = 0 ) {

			Vector3.prototype.isVector3 = true;

			this.x = x;
			this.y = y;
			this.z = z;

		}

		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		applyEuler( euler ) {

			return this.applyQuaternion( _quaternion$2.setFromEuler( euler ) );

		}

		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion$2.setFromAxisAngle( axis, angle ) );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		applyQuaternion( q ) {

			const x = this.x, y = this.y, z = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}

		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		cross( v ) {

			return this.crossVectors( this, v );

		}

		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		projectOnPlane( planeNormal ) {

			_vector$9.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector$9 );

		}

		reflect( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector$9.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp$1( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		setFromEuler( e ) {

			this.x = e._x;
			this.y = e._y;
			this.z = e._z;

			return this;

		}

		setFromColor( c ) {

			this.x = c.r;
			this.y = c.g;
			this.z = c.b;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

		randomDirection() {

			// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

			const u = ( Math.random() - 0.5 ) * 2;
			const t = Math.random() * Math.PI * 2;
			const f = Math.sqrt( 1 - u ** 2 );

			this.x = f * Math.cos( t );
			this.y = f * Math.sin( t );
			this.z = u;

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;

		}

	}

	const _vector$9 = /*@__PURE__*/ new Vector3();
	const _quaternion$2 = /*@__PURE__*/ new Quaternion();

	class Box3 {

		constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

			this.isBox3 = true;

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromArray( array ) {

			this.makeEmpty();

			for ( let i = 0, il = array.length; i < il; i += 3 ) {

				this.expandByPoint( _vector$8.fromArray( array, i ) );

			}

			return this;

		}

		setFromBufferAttribute( attribute ) {

			this.makeEmpty();

			for ( let i = 0, il = attribute.count; i < il; i ++ ) {

				this.expandByPoint( _vector$8.fromBufferAttribute( attribute, i ) );

			}

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$8.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		setFromObject( object, precise = false ) {

			this.makeEmpty();

			return this.expandByObject( object, precise );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		expandByObject( object, precise = false ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			if ( object.boundingBox !== undefined ) {

				if ( object.boundingBox === null ) {

					object.computeBoundingBox();

				}

				_box$2.copy( object.boundingBox );
				_box$2.applyMatrix4( object.matrixWorld );

				this.union( _box$2 );

			} else {

				const geometry = object.geometry;

				if ( geometry !== undefined ) {

					if ( precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined ) {

						const position = geometry.attributes.position;
						for ( let i = 0, l = position.count; i < l; i ++ ) {

							_vector$8.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
							this.expandByPoint( _vector$8 );

						}

					} else {

						if ( geometry.boundingBox === null ) {

							geometry.computeBoundingBox();

						}

						_box$2.copy( geometry.boundingBox );
						_box$2.applyMatrix4( object.matrixWorld );

						this.union( _box$2 );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ], precise );

			}

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		}

		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$8 );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$8.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0$1.subVectors( triangle.a, _center );
			_v1$5.subVectors( triangle.b, _center );
			_v2$3.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$5, _v0$1 );
			_f1.subVectors( _v2$3, _v1$5 );
			_f2.subVectors( _v0$1, _v2$3 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0$1, _v1$5, _v2$3, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0$1, _v1$5, _v2$3, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0$1, _v1$5, _v2$3, _extents );

		}

		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			return this.clampPoint( point, _vector$8 ).distanceTo( point );

		}

		getBoundingSphere( target ) {

			if ( this.isEmpty() ) {

				target.makeEmpty();

			} else {

				this.getCenter( target.center );

				target.radius = this.getSize( _vector$8 ).length() * 0.5;

			}

			return target;

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$8 = /*@__PURE__*/ new Vector3();

	const _box$2 = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$5 = /*@__PURE__*/ new Vector3();
	const _v2$3 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the separating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the separating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is separating and we can exit
				return false;

			}

		}

		return true;

	}

	const _box$1 = /*@__PURE__*/ new Box3();
	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _v2$2 = /*@__PURE__*/ new Vector3();

	class Sphere {

		constructor( center = new Vector3(), radius = - 1 ) {

			this.center = center;
			this.radius = radius;

		}

		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$1.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		isEmpty() {

			return ( this.radius < 0 );

		}

		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = - 1;

			return this;

		}

		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		getBoundingBox( target ) {

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		expandByPoint( point ) {

			if ( this.isEmpty() ) {

				this.center.copy( point );

				this.radius = 0;

				return this;

			}

			_v1$4.subVectors( point, this.center );

			const lengthSq = _v1$4.lengthSq();

			if ( lengthSq > ( this.radius * this.radius ) ) {

				// calculate the minimal sphere

				const length = Math.sqrt( lengthSq );

				const delta = ( length - this.radius ) * 0.5;

				this.center.addScaledVector( _v1$4, delta / length );

				this.radius += delta;

			}

			return this;

		}

		union( sphere ) {

			if ( sphere.isEmpty() ) {

				return this;

			}

			if ( this.isEmpty() ) {

				this.copy( sphere );

				return this;

			}

			if ( this.center.equals( sphere.center ) === true ) {

				 this.radius = Math.max( this.radius, sphere.radius );

			} else {

				_v2$2.subVectors( sphere.center, this.center ).setLength( sphere.radius );

				this.expandByPoint( _v1$4.copy( sphere.center ).add( _v2$2 ) );

				this.expandByPoint( _v1$4.copy( sphere.center ).sub( _v2$2 ) );

			}

			return this;

		}

		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	class Plane {

		constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

			this.isPlane = true;

			// normal is assumed to be normalized

			this.normal = normal;
			this.constant = constant;

		}

		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		negate() {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		}

		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		projectPoint( point, target ) {

			return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

		}

		intersectLine( line, target ) {

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return null;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return null;

			}

			return target.copy( line.start ).addScaledVector( direction, t );

		}

		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		coplanarPoint( target ) {

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _sphere$2 = /*@__PURE__*/ new Sphere();
	const _vector$7 = /*@__PURE__*/ new Vector3();

	class Frustum {

		constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

			this.planes = [ p0, p1, p2, p3, p4, p5 ];

		}

		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

			} else {

				throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

			}

			return this;

		}

		intersectsObject( object ) {

			if ( object.boundingSphere !== undefined ) {

				if ( object.boundingSphere === null ) object.computeBoundingSphere();

				_sphere$2.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

			} else {

				const geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			}

			return this.intersectsSphere( _sphere$2 );

		}

		intersectsSprite( sprite ) {

			_sphere$2.center.set( 0, 0, 0 );
			_sphere$2.radius = 0.7071067811865476;
			_sphere$2.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$2 );

		}

		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class Matrix4 {

		constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			Matrix4.prototype.isMatrix4 = true;

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( n11 !== undefined ) {

				this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

			}

		}

		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		setFromMatrix3( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ], 0,
				me[ 1 ], me[ 4 ], me[ 7 ], 0,
				me[ 2 ], me[ 5 ], me[ 8 ], 0,
				0, 0, 0, 1

			);

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		extractRotation( m ) {

			// this method does not support reflection matrices

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$3.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1$3.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1$3.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromEuler( euler ) {

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		makeTranslation( x, y, z ) {

			if ( x.isVector3 ) {

				this.set(

					1, 0, 0, x.x,
					0, 1, 0, x.y,
					0, 0, 1, x.z,
					0, 0, 0, 1

				);

			} else {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

			}

			return this;

		}

		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeShear( xy, xz, yx, yz, zx, zy ) {

			this.set(

				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1$3.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1$3.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1$3.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1$2.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1$2.elements[ 0 ] *= invSX;
			_m1$2.elements[ 1 ] *= invSX;
			_m1$2.elements[ 2 ] *= invSX;

			_m1$2.elements[ 4 ] *= invSY;
			_m1$2.elements[ 5 ] *= invSY;
			_m1$2.elements[ 6 ] *= invSY;

			_m1$2.elements[ 8 ] *= invSZ;
			_m1$2.elements[ 9 ] *= invSZ;
			_m1$2.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1$2 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

			const te = this.elements;
			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );

			let c, d;

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				c = - ( far + near ) / ( far - near );
				d = ( - 2 * far * near ) / ( far - near );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				c = - far / ( far - near );
				d = ( - far * near ) / ( far - near );

			} else {

				throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

			}

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		}

		makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

			const te = this.elements;
			const w = 1.0 / ( right - left );
			const h = 1.0 / ( top - bottom );
			const p = 1.0 / ( far - near );

			const x = ( right + left ) * w;
			const y = ( top + bottom ) * h;

			let z, zInv;

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				z = ( far + near ) * p;
				zInv = - 2 * p;

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				z = near * p;
				zInv = - 1 * p;

			} else {

				throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

			}

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
			te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
			te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
			te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _m1$2 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	class Vector2 {

		constructor( x = 0, y = 0 ) {

			Vector2.prototype.isVector2 = true;

			this.x = x;
			this.y = y;

		}

		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		angle() {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp$1( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;

		}

	}

	class Vector4 {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			Vector4.prototype.isVector4 = true;

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

		}

		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setW( w ) {

			this.w = w;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;
			yield this.w;

		}

	}

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = gl.HALF_FLOAT;

					} else {

						throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = gl.UNSIGNED_SHORT;

				}

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			} else if ( array instanceof Uint8ClampedArray ) {

				type = gl.UNSIGNED_BYTE;

			} else {

				throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

			attribute.onUploadCallback();

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	class EventDispatcher {

		addEventListener( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		}

		hasEventListener( type, listener ) {

			if ( this._listeners === undefined ) return false;

			const listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		}

		removeEventListener( type, listener ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		}

		dispatchEvent( event ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

				event.target = null;

			}

		}

	}

	// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

	const _tables = /*@__PURE__*/ _generateTables();

	function _generateTables() {

		// float32 to float16 helpers

		const buffer = new ArrayBuffer( 4 );
		const floatView = new Float32Array( buffer );
		const uint32View = new Uint32Array( buffer );

		const baseTable = new Uint32Array( 512 );
		const shiftTable = new Uint32Array( 512 );

		for ( let i = 0; i < 256; ++ i ) {

			const e = i - 127;

			// very small number (0, -0)

			if ( e < - 27 ) {

				baseTable[ i ] = 0x0000;
				baseTable[ i | 0x100 ] = 0x8000;
				shiftTable[ i ] = 24;
				shiftTable[ i | 0x100 ] = 24;

				// small number (denorm)

			} else if ( e < - 14 ) {

				baseTable[ i ] = 0x0400 >> ( - e - 14 );
				baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
				shiftTable[ i ] = - e - 1;
				shiftTable[ i | 0x100 ] = - e - 1;

				// normal number

			} else if ( e <= 15 ) {

				baseTable[ i ] = ( e + 15 ) << 10;
				baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
				shiftTable[ i ] = 13;
				shiftTable[ i | 0x100 ] = 13;

				// large number (Infinity, -Infinity)

			} else if ( e < 128 ) {

				baseTable[ i ] = 0x7c00;
				baseTable[ i | 0x100 ] = 0xfc00;
				shiftTable[ i ] = 24;
				shiftTable[ i | 0x100 ] = 24;

				// stay (NaN, Infinity, -Infinity)

			} else {

				baseTable[ i ] = 0x7c00;
				baseTable[ i | 0x100 ] = 0xfc00;
				shiftTable[ i ] = 13;
				shiftTable[ i | 0x100 ] = 13;

			}

		}

		// float16 to float32 helpers

		const mantissaTable = new Uint32Array( 2048 );
		const exponentTable = new Uint32Array( 64 );
		const offsetTable = new Uint32Array( 64 );

		for ( let i = 1; i < 1024; ++ i ) {

			let m = i << 13; // zero pad mantissa bits
			let e = 0; // zero exponent

			// normalized
			while ( ( m & 0x00800000 ) === 0 ) {

				m <<= 1;
				e -= 0x00800000; // decrement exponent

			}

			m &= ~ 0x00800000; // clear leading 1 bit
			e += 0x38800000; // adjust bias

			mantissaTable[ i ] = m | e;

		}

		for ( let i = 1024; i < 2048; ++ i ) {

			mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

		}

		for ( let i = 1; i < 31; ++ i ) {

			exponentTable[ i ] = i << 23;

		}

		exponentTable[ 31 ] = 0x47800000;
		exponentTable[ 32 ] = 0x80000000;

		for ( let i = 33; i < 63; ++ i ) {

			exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

		}

		exponentTable[ 63 ] = 0xc7800000;

		for ( let i = 1; i < 64; ++ i ) {

			if ( i !== 32 ) {

				offsetTable[ i ] = 1024;

			}

		}

		return {
			floatView: floatView,
			uint32View: uint32View,
			baseTable: baseTable,
			shiftTable: shiftTable,
			mantissaTable: mantissaTable,
			exponentTable: exponentTable,
			offsetTable: offsetTable
		};

	}

	// float32 to float16

	function toHalfFloat( val ) {

		val = clamp$1( val, - 65504, 65504 );

		_tables.floatView[ 0 ] = val;
		const f = _tables.uint32View[ 0 ];
		const e = ( f >> 23 ) & 0x1ff;
		return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

	}

	// float16 to float32

	function fromHalfFloat( val ) {

		const m = val >> 10;
		_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
		return _tables.floatView[ 0 ];

	}

	const _vector$6 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector2();

	class BufferAttribute {

		constructor( array, itemSize, normalized = false ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.isBufferAttribute = true;

			this.name = '';

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };
			this.gpuType = FloatType;

			this.version = 0;

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;
			this.gpuType = source.gpuType;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		copyArray( array ) {

			this.array.set( array );

			return this;

		}

		applyMatrix3( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2.fromBufferAttribute( this, i );
					_vector2.applyMatrix3( m );

					this.setXY( i, _vector2.x, _vector2.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$6.fromBufferAttribute( this, i );
					_vector$6.applyMatrix3( m );

					this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

				}

			}

			return this;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.fromBufferAttribute( this, i );

				_vector$6.applyMatrix4( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.fromBufferAttribute( this, i );

				_vector$6.applyNormalMatrix( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.fromBufferAttribute( this, i );

				_vector$6.transformDirection( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		}

		set( value, offset = 0 ) {

			// Matching BufferAttribute constructor, do not normalize the array.
			this.array.set( value, offset );

			return this;

		}

		getComponent( index, component ) {

			let value = this.array[ index * this.itemSize + component ];

			if ( this.normalized ) value = denormalize( value, this.array );

			return value;

		}

		setComponent( index, component, value ) {

			if ( this.normalized ) value = normalize$1( value, this.array );

			this.array[ index * this.itemSize + component ] = value;

			return this;

		}

		getX( index ) {

			let x = this.array[ index * this.itemSize ];

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		setX( index, x ) {

			if ( this.normalized ) x = normalize$1( x, this.array );

			this.array[ index * this.itemSize ] = x;

			return this;

		}

		getY( index ) {

			let y = this.array[ index * this.itemSize + 1 ];

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		setY( index, y ) {

			if ( this.normalized ) y = normalize$1( y, this.array );

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		}

		getZ( index ) {

			let z = this.array[ index * this.itemSize + 2 ];

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		setZ( index, z ) {

			if ( this.normalized ) z = normalize$1( z, this.array );

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		}

		getW( index ) {

			let w = this.array[ index * this.itemSize + 3 ];

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		setW( index, w ) {

			if ( this.normalized ) w = normalize$1( w, this.array );

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		}

		setXY( index, x, y ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );
				z = normalize$1( z, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );
				z = normalize$1( z, this.array );
				w = normalize$1( w, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		clone() {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

		toJSON() {

			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.from( this.array ),
				normalized: this.normalized
			};

			if ( this.name !== '' ) data.name = this.name;
			if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
			if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

			return data;

		}

	}

	class Uint16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

		}

	}

	class Uint32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint32Array( array ), itemSize, normalized );

		}

	}

	class Float16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

			this.isFloat16BufferAttribute = true;

		}

		getX( index ) {

			let x = fromHalfFloat( this.array[ index * this.itemSize ] );

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		setX( index, x ) {

			if ( this.normalized ) x = normalize$1( x, this.array );

			this.array[ index * this.itemSize ] = toHalfFloat( x );

			return this;

		}

		getY( index ) {

			let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		setY( index, y ) {

			if ( this.normalized ) y = normalize$1( y, this.array );

			this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

			return this;

		}

		getZ( index ) {

			let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		setZ( index, z ) {

			if ( this.normalized ) z = normalize$1( z, this.array );

			this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

			return this;

		}

		getW( index ) {

			let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		setW( index, w ) {

			if ( this.normalized ) w = normalize$1( w, this.array );

			this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

			return this;

		}

		setXY( index, x, y ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );

			}

			this.array[ index + 0 ] = toHalfFloat( x );
			this.array[ index + 1 ] = toHalfFloat( y );

			return this;

		}

		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );
				z = normalize$1( z, this.array );

			}

			this.array[ index + 0 ] = toHalfFloat( x );
			this.array[ index + 1 ] = toHalfFloat( y );
			this.array[ index + 2 ] = toHalfFloat( z );

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );
				z = normalize$1( z, this.array );
				w = normalize$1( w, this.array );

			}

			this.array[ index + 0 ] = toHalfFloat( x );
			this.array[ index + 1 ] = toHalfFloat( y );
			this.array[ index + 2 ] = toHalfFloat( z );
			this.array[ index + 3 ] = toHalfFloat( w );

			return this;

		}

	}


	class Float32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Float32Array( array ), itemSize, normalized );

		}

	}

	const _matrix = /*@__PURE__*/ new Matrix4();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion();

	class Euler {

		constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

			this.isEuler = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		set( x, y, z, order = this._order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m, order = this._order, update = true ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp$1( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp$1( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp$1( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp$1( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp$1( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp$1( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

			}

			this._order = order;

			if ( update === true ) this._onChangeCallback();

			return this;

		}

		setFromQuaternion( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		}

		setFromVector3( v, order = this._order ) {

			return this.set( v.x, v.y, v.z, order );

		}

		reorder( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$1.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$1, newOrder );

		}

		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._order;

		}

	}

	Euler.DEFAULT_ORDER = 'XYZ';

	class Layers {

		constructor() {

			this.mask = 1 | 0;

		}

		set( channel ) {

			this.mask = ( 1 << channel | 0 ) >>> 0;

		}

		enable( channel ) {

			this.mask |= 1 << channel | 0;

		}

		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		toggle( channel ) {

			this.mask ^= 1 << channel | 0;

		}

		disable( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		}

		disableAll() {

			this.mask = 0;

		}

		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

		isEnabled( channel ) {

			return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

		}

	}

	let _object3DId = 0;

	const _v1$2 = /*@__PURE__*/ new Vector3();
	const _q1 = /*@__PURE__*/ new Quaternion();
	const _m1$1 = /*@__PURE__*/ new Matrix4();
	const _target = /*@__PURE__*/ new Vector3();

	const _position = /*@__PURE__*/ new Vector3();
	const _scale = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion();

	const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
	const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

	const _addedEvent = { type: 'added' };
	const _removedEvent = { type: 'removed' };

	class Object3D extends EventDispatcher {

		constructor() {

			super();

			this.isObject3D = true;

			Object.defineProperty( this, 'id', { value: _object3DId ++ } );

			this.uuid = generateUUID$1();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DEFAULT_UP.clone();

			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation._onChange( onRotationChange );
			quaternion._onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
			this.matrixWorldNeedsUpdate = false;

			this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.animations = [];

			this.userData = {};

		}

		onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		applyMatrix4( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		}

		applyQuaternion( q ) {

			this.quaternion.premultiply( q );

			return this;

		}

		setRotationFromAxisAngle( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		}

		setRotationFromEuler( euler ) {

			this.quaternion.setFromEuler( euler, true );

		}

		setRotationFromMatrix( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		}

		setRotationFromQuaternion( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		}

		rotateOnAxis( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		}

		rotateOnWorldAxis( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		}

		rotateX( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		}

		rotateY( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		}

		rotateZ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		}

		translateOnAxis( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$2.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$2.multiplyScalar( distance ) );

			return this;

		}

		translateX( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		}

		translateY( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		}

		translateZ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		}

		localToWorld( vector ) {

			this.updateWorldMatrix( true, false );

			return vector.applyMatrix4( this.matrixWorld );

		}

		worldToLocal( vector ) {

			this.updateWorldMatrix( true, false );

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		}

		lookAt( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		}

		add( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			}

			return this;

		}

		remove( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		}

		removeFromParent() {

			const parent = this.parent;

			if ( parent !== null ) {

				parent.remove( this );

			}

			return this;

		}

		clear() {

			for ( let i = 0; i < this.children.length; i ++ ) {

				const object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		}

		attach( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			this.add( object );

			object.updateWorldMatrix( false, true );

			return this;

		}

		getObjectById( id ) {

			return this.getObjectByProperty( 'id', id );

		}

		getObjectByName( name ) {

			return this.getObjectByProperty( 'name', name );

		}

		getObjectByProperty( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		}

		getObjectsByProperty( name, value ) {

			let result = [];

			if ( this[ name ] === value ) result.push( this );

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const childResult = this.children[ i ].getObjectsByProperty( name, value );

				if ( childResult.length > 0 ) {

					result = result.concat( childResult );

				}

			}

			return result;

		}

		getWorldPosition( target ) {

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		}

		getWorldQuaternion( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, target, _scale );

			return target;

		}

		getWorldScale( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, _quaternion, target );

			return target;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		}

		raycast( /* raycaster, intersects */ ) {}

		traverse( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		}

		traverseVisible( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		}

		traverseAncestors( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		}

		updateMatrix() {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		}

		updateMatrixWorld( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				if ( child.matrixWorldAutoUpdate === true || force === true ) {

					child.updateMatrixWorld( force );

				}

			}

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					const child = children[ i ];

					if ( child.matrixWorldAutoUpdate === true ) {

						child.updateWorldMatrix( false, true );

					}

				}

			}

		}

		toJSON( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				};

				output.metadata = {
					version: 4.6,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			object.up = this.up.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isScene ) {

				if ( this.background ) {

					if ( this.background.isColor ) {

						object.background = this.background.toJSON();

					} else if ( this.background.isTexture ) {

						object.background = this.background.toJSON( meta ).uuid;

					}

				}

				if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

					object.environment = this.environment.toJSON( meta ).uuid;

				}

			} else if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );
				const nodes = extractFromCache( meta.nodes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;
				if ( nodes.length > 0 ) output.nodes = nodes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		}

		clone( recursive ) {

			return new this.constructor().copy( this, recursive );

		}

		copy( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.animations = source.animations.slice();

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	}

	Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
	Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

	function arrayNeedsUint32$1( array ) {

		// assumes larger values usually on last

		for ( let i = array.length - 1; i >= 0; -- i ) {

			if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

		}

		return false;

	}

	function createElementNS( name ) {

		return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

	}

	const _cache = {};

	function warnOnce( message ) {

		if ( message in _cache ) return;

		_cache[ message ] = true;

	}

	let _id$1 = 0;

	const _m1 = /*@__PURE__*/ new Matrix4();
	const _obj = /*@__PURE__*/ new Object3D();
	const _offset = /*@__PURE__*/ new Vector3();
	const _box = /*@__PURE__*/ new Box3();
	const _boxMorphTargets = /*@__PURE__*/ new Box3();
	const _vector$5 = /*@__PURE__*/ new Vector3();

	class BufferGeometry extends EventDispatcher {

		constructor() {

			super();

			this.isBufferGeometry = true;

			Object.defineProperty( this, 'id', { value: _id$1 ++ } );

			this.uuid = generateUUID$1();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};
			this.morphTargetsRelative = false;

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

			this.userData = {};

		}

		getIndex() {

			return this.index;

		}

		setIndex( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayNeedsUint32$1( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		}

		getAttribute( name ) {

			return this.attributes[ name ];

		}

		setAttribute( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		}

		deleteAttribute( name ) {

			delete this.attributes[ name ];

			return this;

		}

		hasAttribute( name ) {

			return this.attributes[ name ] !== undefined;

		}

		addGroup( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		}

		clearGroups() {

			this.groups = [];

		}

		setDrawRange( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		}

		applyMatrix4( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		}

		applyQuaternion( q ) {

			_m1.makeRotationFromQuaternion( q );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateX( angle ) {

			// rotate geometry around world x-axis

			_m1.makeRotationX( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateY( angle ) {

			// rotate geometry around world y-axis

			_m1.makeRotationY( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateZ( angle ) {

			// rotate geometry around world z-axis

			_m1.makeRotationZ( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		translate( x, y, z ) {

			// translate geometry

			_m1.makeTranslation( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		scale( x, y, z ) {

			// scale geometry

			_m1.makeScale( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		lookAt( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		}

		center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		}

		setFromPoints( points ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		}

		computeBoundingBox() {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$5.addVectors( this.boundingBox.min, _box.min );
							this.boundingBox.expandByPoint( _vector$5 );

							_vector$5.addVectors( this.boundingBox.max, _box.max );
							this.boundingBox.expandByPoint( _vector$5 );

						} else {

							this.boundingBox.expandByPoint( _box.min );
							this.boundingBox.expandByPoint( _box.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) ;

		}

		computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$5.addVectors( _box.min, _boxMorphTargets.min );
							_box.expandByPoint( _vector$5 );

							_vector$5.addVectors( _box.max, _boxMorphTargets.max );
							_box.expandByPoint( _vector$5 );

						} else {

							_box.expandByPoint( _boxMorphTargets.min );
							_box.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$5.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$5 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$5.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$5.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$5 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) ;

			}

		}

		computeTangents() {

			const index = this.index;
			const attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {
				return;

			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;

			const nVertices = positions.length / 3;

			if ( this.hasAttribute( 'tangent' ) === false ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			const tangents = this.getAttribute( 'tangent' ).array;

			const tan1 = [], tan2 = [];

			for ( let i = 0; i < nVertices; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) return;

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			let groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: indices.length
				} ];

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						indices[ j + 0 ],
						indices[ j + 1 ],
						indices[ j + 2 ]
					);

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3();
			const n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				const t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				const test = tmp2.dot( tan2[ v ] );
				const w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4 ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleVertex( indices[ j + 0 ] );
					handleVertex( indices[ j + 1 ] );
					handleVertex( indices[ j + 2 ] );

				}

			}

		}

		computeVertexNormals() {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		}

		normalizeNormals() {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$5.fromBufferAttribute( normals, i );

				_vector$5.normalize();

				normals.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

		}

		toNonIndexed() {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					if ( attribute.isInterleavedBufferAttribute ) {

						index = indices[ i ] * attribute.data.stride + attribute.offset;

					} else {

						index = indices[ i ] * itemSize;

					}

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.6,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				data.data.attributes[ key ] = attribute.toJSON( data.data );

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					array.push( attribute.toJSON( data.data ) );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	class BoxGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

		}

	}

	class PlaneGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

		}

	}

	let materialId = 0;

	class Material extends EventDispatcher {

		constructor() {

			super();

			this.isMaterial = true;

			Object.defineProperty( this, 'id', { value: materialId ++ } );

			this.uuid = generateUUID$1();

			this.name = '';
			this.type = 'Material';

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;

			this.opacity = 1;
			this.transparent = false;
			this.alphaHash = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.shadowSide = null;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.dithering = false;

			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;
			this.forceSinglePass = false;

			this.visible = true;

			this.toneMapped = true;

			this.userData = {};

			this.version = 0;

			this._alphaTest = 0;

		}

		get alphaTest() {

			return this._alphaTest;

		}

		set alphaTest( value ) {

			if ( this._alphaTest > 0 !== value > 0 ) {

				this.version ++;

			}

			this._alphaTest = value;

		}

		onBuild( /* shaderobject, renderer */ ) {}

		onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

		onBeforeCompile( /* shaderobject, renderer */ ) {}

		customProgramCacheKey() {

			return this.onBeforeCompile.toString();

		}

		setValues( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( isRootObject ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.6,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen !== undefined ) data.sheen = this.sheen;
			if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
			if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
			if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
			if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
			if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

			if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

				data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

			}

			if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

				data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

			}

			if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
			if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

			if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

				data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
			if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;

				if ( this.combine !== undefined ) data.combine = this.combine;

			}

			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
			if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
			if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.transmission !== undefined ) data.transmission = this.transmission;
			if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
			if ( this.thickness !== undefined ) data.thickness = this.thickness;
			if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
			if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
			if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.alphaHash === true ) data.alphaHash = this.alphaHash;
			if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
			if ( this.forceSinglePass === true ) data.forceSinglePass = this.forceSinglePass;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.flatShading === true ) data.flatShading = this.flatShading;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( this.fog === false ) data.fog = false;

			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRootObject ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.alphaHash = source.alphaHash;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.forceSinglePass = source.forceSinglePass;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					if ( property.isRenderTargetTexture ) {
						dst[ u ][ p ] = null;

					} else {

						dst[ u ][ p ] = property.clone();

					}

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	function cloneUniformsGroups( src ) {

		const dst = [];

		for ( let u = 0; u < src.length; u ++ ) {

			dst.push( src[ u ].clone() );

		}

		return dst;

	}

	function getUnlitUniformColorSpace( renderer ) {

		if ( renderer.getRenderTarget() === null ) {

			// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
			return renderer.outputColorSpace;

		}

		return LinearSRGBColorSpace;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	class ShaderMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isShaderMaterial = true;

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};
			this.uniformsGroups = [];

			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.forceSinglePass = true;

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv1': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;

			this.glslVersion = null;

			if ( parameters !== undefined ) {

				this.setValues( parameters );

			}

		}

		copy( source ) {

			super.copy( source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = cloneUniforms( source.uniforms );
			this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

			this.defines = Object.assign( {}, source.defines );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.fog = source.fog;
			this.lights = source.lights;
			this.clipping = source.clipping;

			this.extensions = Object.assign( {}, source.extensions );

			this.glslVersion = source.glslVersion;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for ( const name in this.uniforms ) {

				const uniform = this.uniforms[ name ];
				const value = uniform.value;

				if ( value && value.isTexture ) {

					data.uniforms[ name ] = {
						type: 't',
						value: value.toJSON( meta ).uuid
					};

				} else if ( value && value.isColor ) {

					data.uniforms[ name ] = {
						type: 'c',
						value: value.getHex()
					};

				} else if ( value && value.isVector2 ) {

					data.uniforms[ name ] = {
						type: 'v2',
						value: value.toArray()
					};

				} else if ( value && value.isVector3 ) {

					data.uniforms[ name ] = {
						type: 'v3',
						value: value.toArray()
					};

				} else if ( value && value.isVector4 ) {

					data.uniforms[ name ] = {
						type: 'v4',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix3 ) {

					data.uniforms[ name ] = {
						type: 'm3',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix4 ) {

					data.uniforms[ name ] = {
						type: 'm4',
						value: value.toArray()
					};

				} else {

					data.uniforms[ name ] = {
						value: value
					};

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			data.lights = this.lights;
			data.clipping = this.clipping;

			const extensions = {};

			for ( const key in this.extensions ) {

				if ( this.extensions[ key ] === true ) extensions[ key ] = true;

			}

			if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

			return data;

		}

	}

	const _vector$4 = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();

	class Ray {

		constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

			this.origin = origin;
			this.direction = direction;

		}

		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		at( t, target ) {

			return target.copy( this.origin ).addScaledVector( this.direction, t );

		}

		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		recast( t ) {

			this.origin.copy( this.at( t, _vector$4 ) );

			return this;

		}

		closestPointToPoint( point, target ) {

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		}

		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		distanceSqToPoint( point ) {

			const directionDistance = _vector$4.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector$4.copy( this.origin ).addScaledVector( this.direction, directionDistance );

			return _vector$4.distanceToSquared( point );

		}

		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

			}

			return sqrDist;

		}

		intersectSphere( sphere, target ) {

			_vector$4.subVectors( sphere.center, this.origin );
			const tca = _vector$4.dot( this.direction );
			const d2 = _vector$4.dot( _vector$4 ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if t1 is behind the ray - if so, return null
			if ( t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		intersectsSphere( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

			if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		intersectsBox( box ) {

			return this.intersectBox( box, _vector$4 ) !== null;

		}

		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _v0 = /*@__PURE__*/ new Vector3();
	const _v1$1 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();
	const _v3$1 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	class Triangle {

		constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

			this.a = a;
			this.b = b;
			this.c = c;

		}

		static getNormal( a, b, c, target ) {

			target.subVectors( c, b );
			_v0.subVectors( a, b );
			target.cross( _v0 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord( point, a, b, c, target ) {

			_v0.subVectors( c, a );
			_v1$1.subVectors( b, a );
			_v2$1.subVectors( point, a );

			const dot00 = _v0.dot( _v0 );
			const dot01 = _v0.dot( _v1$1 );
			const dot02 = _v0.dot( _v2$1 );
			const dot11 = _v1$1.dot( _v1$1 );
			const dot12 = _v1$1.dot( _v2$1 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		static containsPoint( point, a, b, c ) {

			this.getBarycoord( point, a, b, c, _v3$1 );

			return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

		}

		static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) { // @deprecated, r151

			return this.getInterpolation( point, p1, p2, p3, uv1, uv2, uv3, target );

		}

		static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3$1 );

			target.setScalar( 0 );
			target.addScaledVector( v1, _v3$1.x );
			target.addScaledVector( v2, _v3$1.y );
			target.addScaledVector( v3, _v3$1.z );

			return target;

		}

		static isFrontFacing( a, b, c, direction ) {

			_v0.subVectors( c, b );
			_v1$1.subVectors( a, b );

			// strictly front facing
			return ( _v0.cross( _v1$1 ).dot( direction ) < 0 ) ? true : false;

		}

		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

			this.a.fromBufferAttribute( attribute, i0 );
			this.b.fromBufferAttribute( attribute, i1 );
			this.c.fromBufferAttribute( attribute, i2 );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		getArea() {

			_v0.subVectors( this.c, this.b );
			_v1$1.subVectors( this.a, this.b );

			return _v0.cross( _v1$1 ).length() * 0.5;

		}

		getMidpoint( target ) {

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		getPlane( target ) {

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		getUV( point, uv1, uv2, uv3, target ) { // @deprecated, r151

			return Triangle.getInterpolation( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		}

		getInterpolation( point, v1, v2, v3, target ) {

			return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

		}

		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		closestPointToPoint( p, target ) {

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	class MeshBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshBasicMaterial = true;

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _ray$1 = /*@__PURE__*/ new Ray();
	const _sphere$1 = /*@__PURE__*/ new Sphere();
	const _sphereHitAt = /*@__PURE__*/ new Vector3();

	const _vA = /*@__PURE__*/ new Vector3();
	const _vB = /*@__PURE__*/ new Vector3();
	const _vC = /*@__PURE__*/ new Vector3();

	const _tempA = /*@__PURE__*/ new Vector3();
	const _morphA = /*@__PURE__*/ new Vector3();

	const _uvA = /*@__PURE__*/ new Vector2();
	const _uvB = /*@__PURE__*/ new Vector2();
	const _uvC = /*@__PURE__*/ new Vector2();

	const _normalA = /*@__PURE__*/ new Vector3();
	const _normalB = /*@__PURE__*/ new Vector3();
	const _normalC = /*@__PURE__*/ new Vector3();

	const _intersectionPoint = /*@__PURE__*/ new Vector3();
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

	class Mesh extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

			super();

			this.isMesh = true;

			this.type = 'Mesh';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

		getVertexPosition( index, target ) {

			const geometry = this.geometry;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;

			target.fromBufferAttribute( position, index );

			const morphInfluences = this.morphTargetInfluences;

			if ( morphPosition && morphInfluences ) {

				_morphA.set( 0, 0, 0 );

				for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

					const influence = morphInfluences[ i ];
					const morphAttribute = morphPosition[ i ];

					if ( influence === 0 ) continue;

					_tempA.fromBufferAttribute( morphAttribute, index );

					if ( morphTargetsRelative ) {

						_morphA.addScaledVector( _tempA, influence );

					} else {

						_morphA.addScaledVector( _tempA.sub( target ), influence );

					}

				}

				target.add( _morphA );

			}

			return target;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// test with bounding sphere in world space

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );

			// check distance from ray origin to bounding sphere

			_ray$1.copy( raycaster.ray ).recast( raycaster.near );

			if ( _sphere$1.containsPoint( _ray$1.origin ) === false ) {

				if ( _ray$1.intersectSphere( _sphere$1, _sphereHitAt ) === null ) return;

				if ( _ray$1.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

			}

			// convert ray to local space of mesh

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			// test with bounding box in local space

			if ( geometry.boundingBox !== null ) {

				if ( _ray$1.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			// test for intersections with geometry

			this._computeIntersections( raycaster, intersects, _ray$1 );

		}

		_computeIntersections( raycaster, intersects, rayLocalSpace ) {

			let intersection;

			const geometry = this.geometry;
			const material = this.material;

			const index = geometry.index;
			const position = geometry.attributes.position;
			const uv = geometry.attributes.uv;
			const uv1 = geometry.attributes.uv1;
			const normal = geometry.attributes.normal;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		}

	}

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

		object.getVertexPosition( a, _vA );
		object.getVertexPosition( b, _vB );
		object.getVertexPosition( c, _vC );

		const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA.fromBufferAttribute( uv, a );
				_uvB.fromBufferAttribute( uv, b );
				_uvC.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			if ( uv1 ) {

				_uvA.fromBufferAttribute( uv1, a );
				_uvB.fromBufferAttribute( uv1, b );
				_uvC.fromBufferAttribute( uv1, c );

				intersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );
				intersection.uv2 = intersection.uv1; // @deprecated, r152

			}

			if ( normal ) {

				_normalA.fromBufferAttribute( normal, a );
				_normalB.fromBufferAttribute( normal, b );
				_normalC.fromBufferAttribute( normal, c );

				intersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );

				if ( intersection.normal.dot( ray.direction ) > 0 ) {

					intersection.normal.multiplyScalar( - 1 );

				}

			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA, _vB, _vC, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

	var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

	var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var colorspace_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

	var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

	var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

	var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

	var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

	var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

	const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

	const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

	const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

	const ShaderChunk = {
		alphahash_fragment: alphahash_fragment,
		alphahash_pars_fragment: alphahash_pars_fragment,
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		iridescence_fragment: iridescence_fragment,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		colorspace_fragment: colorspace_fragment,
		colorspace_pars_fragment: colorspace_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_fragment: lights_lambert_fragment,
		lights_lambert_pars_fragment: lights_lambert_pars_fragment,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphcolor_vertex: morphcolor_vertex,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		iridescence_pars_fragment: iridescence_pars_fragment,
		opaque_fragment: opaque_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		worldpos_vertex: worldpos_vertex,

		background_vert: vertex$h,
		background_frag: fragment$h,
		backgroundCube_vert: vertex$g,
		backgroundCube_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },

			map: { value: null },
			mapTransform: { value: /*@__PURE__*/ new Matrix3() },

			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

			alphaTest: { value: 0 }

		},

		specularmap: {

			specularMap: { value: null },
			specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 }, // basic, lambert, phong
			ior: { value: 1.5 }, // physical
			refractionRatio: { value: 0.98 }, // basic, lambert, phong

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 },
			aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 },
			lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		emissivemap: {

			emissiveMap: { value: null },
			emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		metalnessmap: {

			metalnessMap: { value: null },
			metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		roughnessmap: {

			roughnessMap: { value: null },
			roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotLightMap: { value: [] },
			spotShadowMap: { value: [] },
			spotLightMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaTest: { value: 0 },
			uvTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		sprite: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			mapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaTest: { value: 0 }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag

		},

		sprite: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: /*@__PURE__*/ new Matrix3() },
				t2D: { value: null },
				backgroundIntensity: { value: 1 }
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},

		backgroundCube: {

			uniforms: {
				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				backgroundBlurriness: { value: 0 },
				backgroundIntensity: { value: 1 }
			},

			vertexShader: ShaderChunk.backgroundCube_vert,
			fragmentShader: ShaderChunk.backgroundCube_frag

		},

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: /*@__PURE__*/ new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				clearcoatNormalMap: { value: null },
				clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				iridescence: { value: 0 },
				iridescenceMap: { value: null },
				iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				iridescenceIOR: { value: 1.3 },
				iridescenceThicknessMinimum: { value: 100 },
				iridescenceThicknessMaximum: { value: 400 },
				iridescenceThicknessMap: { value: null },
				iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				sheen: { value: 0 },
				sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				sheenColorMap: { value: null },
				sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				sheenRoughness: { value: 1 },
				sheenRoughnessMap: { value: null },
				sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				attenuationDistance: { value: 0 },
				attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
				specularColorMap: { value: null },
				specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				specularIntensity: { value: 1 },
				specularIntensityMap: { value: null },
				specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
				anisotropyMap: { value: null },
				anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	const _rgb = { r: 0, b: 0, g: 0 };

	function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = alpha === true ? 0 : 1;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render( renderList, scene ) {

			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
				background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

			if ( environmentBlendMode === 'additive' ) {

				state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

			} else if ( environmentBlendMode === 'alpha-blend' ) {

				state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
							vertexShader: ShaderLib.backgroundCube.vertexShader,
							fragmentShader: ShaderLib.backgroundCube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// add "envMap" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
				boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
				boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				boxMesh.material.toneMapped = ( background.colorSpace === SRGBColorSpace ) ? false : true;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				boxMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// add "map" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;
				planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				planeMesh.material.toneMapped = ( background.colorSpace === SRGBColorSpace ) ? false : true;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				planeMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

			state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

		const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;
		let forceUpdate = false;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			if ( vaoAvailable ) {

				const state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( object, geometry, program, index );

				if ( updateBuffers ) saveCache( object, geometry, program, index );

			} else {

				const wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			if ( updateBuffers || forceUpdate ) {

				forceUpdate = false;

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) return gl.createVertexArray();

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( object, geometry, program, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					const cachedAttribute = cachedAttributes[ name ];
					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( cachedAttribute === undefined ) return true;

					if ( cachedAttribute.attribute !== geometryAttribute ) return true;

					if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

					attributesNum ++;

				}

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( object, geometry, program, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let attribute = attributes[ name ];

					if ( attribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

					}

					const data = {};
					data.attribute = attribute;

					if ( attribute && attribute.data ) {

						data.data = attribute.data;

					}

					cache[ name ] = data;

					attributesNum ++;

				}

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

			if ( integer === true ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						// check for integer attributes (WebGL 2 only)

						const integer = ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType ) );

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data.isInstancedInterleavedBuffer ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									stride * bytesPerElement,
									( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
									integer
								);

							}

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									size * bytesPerElement,
									( size / programAttribute.locationSize ) * i * bytesPerElement,
									integer
								);

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute.location, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute.location, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute.location, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute.location, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();
			forceUpdate = true;

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatibility

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl.constructor.name === 'WebGL2RenderingContext';

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {
			precision = maxPrecision;

		}

		const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		const maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

		return {

			isWebGL2: isWebGL2,

			drawBuffers: drawBuffers,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;

		};

		this.setGlobalState = function ( planes, camera ) {

			globalState = projectPlanes( planes, camera, 0 );

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	let _canvas;

	class ImageUtils {

		static getDataURL( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement === 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		static sRGBToLinear( image ) {

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const canvas = createElementNS( 'canvas' );

				canvas.width = image.width;
				canvas.height = image.height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height );

				const imageData = context.getImageData( 0, 0, image.width, image.height );
				const data = imageData.data;

				for ( let i = 0; i < data.length; i ++ ) {

					data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

				}

				context.putImageData( imageData, 0, 0 );

				return canvas;

			} else if ( image.data ) {

				const data = image.data.slice( 0 );

				for ( let i = 0; i < data.length; i ++ ) {

					if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

						data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

					} else {

						// assuming float

						data[ i ] = SRGBToLinear( data[ i ] );

					}

				}

				return {
					data: data,
					width: image.width,
					height: image.height
				};

			} else {
				return image;

			}

		}

	}

	let sourceId = 0;

	class Source {

		constructor( data = null ) {

			this.isSource = true;

			Object.defineProperty( this, 'id', { value: sourceId ++ } );

			this.uuid = generateUUID$1();

			this.data = data;

			this.version = 0;

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

				return meta.images[ this.uuid ];

			}

			const output = {
				uuid: this.uuid,
				url: ''
			};

			const data = this.data;

			if ( data !== null ) {

				let url;

				if ( Array.isArray( data ) ) {

					// cube texture

					url = [];

					for ( let i = 0, l = data.length; i < l; i ++ ) {

						if ( data[ i ].isDataTexture ) {

							url.push( serializeImage( data[ i ].image ) );

						} else {

							url.push( serializeImage( data[ i ] ) );

						}

					}

				} else {

					// texture

					url = serializeImage( data );

				}

				output.url = url;

			}

			if ( ! isRootObject ) {

				meta.images[ this.uuid ] = output;

			}

			return output;

		}

	}

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.from( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {
				return {};

			}

		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {

		constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

			super();

			this.isTexture = true;

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = generateUUID$1();

			this.name = '';

			this.source = new Source( image );
			this.mipmaps = [];

			this.mapping = mapping;
			this.channel = 0;

			this.wrapS = wrapS;
			this.wrapT = wrapT;

			this.magFilter = magFilter;
			this.minFilter = minFilter;

			this.anisotropy = anisotropy;

			this.format = format;
			this.internalFormat = null;
			this.type = type;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			if ( typeof colorSpace === 'string' ) {

				this.colorSpace = colorSpace;

			} else { // @deprecated, r152

				warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );
				this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

			}


			this.userData = {};

			this.version = 0;
			this.onUpdate = null;

			this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
			this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

		}

		get image() {

			return this.source.data;

		}

		set image( value = null ) {

			this.source.data = value;

		}

		updateMatrix() {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.source = source.source;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;
			this.channel = source.channel;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.colorSpace = source.colorSpace;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.needsUpdate = true;

			return this;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.6,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				image: this.source.toJSON( meta ).uuid,

				mapping: this.mapping,
				channel: this.channel,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				internalFormat: this.internalFormat,
				type: this.type,
				colorSpace: this.colorSpace,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				generateMipmaps: this.generateMipmaps,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		transformUv( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

		set needsUpdate( value ) {

			if ( value === true ) {

				this.version ++;
				this.source.needsUpdate = true;

			}

		}

		get encoding() { // @deprecated, r152

			warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );
			return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;

		}

		set encoding( encoding ) { // @deprecated, r152

			warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );
			this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

		}

	}

	Texture.DEFAULT_IMAGE = null;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.DEFAULT_ANISOTROPY = 1;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class RenderTarget extends EventDispatcher {

		constructor( width = 1, height = 1, options = {} ) {

			super();

			this.isRenderTarget = true;

			this.width = width;
			this.height = height;
			this.depth = 1;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			const image = { width: width, height: height, depth: 1 };

			if ( options.encoding !== undefined ) {

				// @deprecated, r152
				warnOnce( 'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.' );
				options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

			}

			this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );
			this.texture.isRenderTargetTexture = true;

			this.texture.flipY = false;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

			this.samples = options.samples !== undefined ? options.samples : 0;

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.scissor.copy( source.scissor );
			this.scissorTest = source.scissorTest;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();
			this.texture.isRenderTargetTexture = true;

			// ensure image object is not shared, see #20328

			const image = Object.assign( {}, source.texture.image );
			this.texture.source = new Source( image );

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

			this.samples = source.samples;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	class WebGLRenderTarget extends RenderTarget {

		constructor( width = 1, height = 1, options = {} ) {

			super( width, height, options );

			this.isWebGLRenderTarget = true;

		}

	}

	class Camera extends Object3D {

		constructor() {

			super();

			this.isCamera = true;

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();

			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();

			this.coordinateSystem = WebGLCoordinateSystem;

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			this.coordinateSystem = source.coordinateSystem;

			return this;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			super.updateWorldMatrix( updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class PerspectiveCamera extends Camera {

		constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

			super();

			this.isPerspectiveCamera = true;

			this.type = 'PerspectiveCamera';

			this.fov = fov;
			this.zoom = 1;

			this.near = near;
			this.far = far;
			this.focus = 10;

			this.aspect = aspect;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		}

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		}

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength() {

			const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		}

		getEffectiveFOV() {

			return RAD2DEG * 2 * Math.atan(
				Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

		}

		getFilmWidth() {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		}

		getFilmHeight() {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const near = this.near;
			let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = - 0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	}

	const fov = - 90; // negative fov is not an error
	const aspect = 1;

	class CubeCamera extends Object3D {

		constructor( near, far, renderTarget ) {

			super();

			this.type = 'CubeCamera';

			this.renderTarget = renderTarget;
			this.coordinateSystem = null;

			const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			this.add( cameraPX );

			const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			this.add( cameraNX );

			const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			this.add( cameraPY );

			const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			this.add( cameraNY );

			const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			this.add( cameraPZ );

			const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			this.add( cameraNZ );

		}

		updateCoordinateSystem() {

			const coordinateSystem = this.coordinateSystem;

			const cameras = this.children.concat();

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

			for ( const camera of cameras ) this.remove( camera );

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				cameraPX.up.set( 0, 1, 0 );
				cameraPX.lookAt( 1, 0, 0 );

				cameraNX.up.set( 0, 1, 0 );
				cameraNX.lookAt( - 1, 0, 0 );

				cameraPY.up.set( 0, 0, - 1 );
				cameraPY.lookAt( 0, 1, 0 );

				cameraNY.up.set( 0, 0, 1 );
				cameraNY.lookAt( 0, - 1, 0 );

				cameraPZ.up.set( 0, 1, 0 );
				cameraPZ.lookAt( 0, 0, 1 );

				cameraNZ.up.set( 0, 1, 0 );
				cameraNZ.lookAt( 0, 0, - 1 );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				cameraPX.up.set( 0, - 1, 0 );
				cameraPX.lookAt( - 1, 0, 0 );

				cameraNX.up.set( 0, - 1, 0 );
				cameraNX.lookAt( 1, 0, 0 );

				cameraPY.up.set( 0, 0, 1 );
				cameraPY.lookAt( 0, 1, 0 );

				cameraNY.up.set( 0, 0, - 1 );
				cameraNY.lookAt( 0, - 1, 0 );

				cameraPZ.up.set( 0, - 1, 0 );
				cameraPZ.lookAt( 0, 0, 1 );

				cameraNZ.up.set( 0, - 1, 0 );
				cameraNZ.lookAt( 0, 0, - 1 );

			} else {

				throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

			}

			for ( const camera of cameras ) {

				this.add( camera );

				camera.updateMatrixWorld();

			}

		}

		update( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const renderTarget = this.renderTarget;

			if ( this.coordinateSystem !== renderer.coordinateSystem ) {

				this.coordinateSystem = renderer.coordinateSystem;

				this.updateCoordinateSystem();

			}

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

			const currentRenderTarget = renderer.getRenderTarget();

			const currentXrEnabled = renderer.xr.enabled;

			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.xr.enabled = currentXrEnabled;

			renderTarget.texture.needsPMREMUpdate = true;

		}

	}

	class CubeTexture extends Texture {

		constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

			this.isCubeTexture = true;

			this.flipY = false;

		}

		get images() {

			return this.image;

		}

		set images( value ) {

			this.image = value;

		}

	}

	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		constructor( size = 1, options = {} ) {

			super( size, size, options );

			this.isWebGLCubeRenderTarget = true;

			const image = { width: size, height: size, depth: 1 };
			const images = [ image, image, image, image, image, image ];

			if ( options.encoding !== undefined ) {

				// @deprecated, r152
				warnOnce( 'THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.' );
				options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

			}

			this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture.isRenderTargetTexture = true;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		}

		fromEquirectangularTexture( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.colorSpace = texture.colorSpace;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};

			const geometry = new BoxGeometry( 5, 5, 5 );

			const material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			const mesh = new Mesh( geometry, material );

			const currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

		clear( renderer, color, depth, stencil ) {

			const currentRenderTarget = renderer.getRenderTarget();

			for ( let i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		}

	}

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class OrthographicCamera extends Camera {

		constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

			super();

			this.isOrthographicCamera = true;

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = near;
			this.far = far;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		}

		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	}

	const LOD_MIN = 4;

	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20;

	const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
	const _clearColor$1 = /*@__PURE__*/ new Color();
	let _oldTarget = null;

	// Golden Ratio
	const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
	const INV_PHI = 1 / PHI;

	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/ new Vector3( 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
		/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
		/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
		/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	class PMREMGenerator {

		constructor( renderer ) {

			this._renderer = renderer;
			this._pingPongRenderTarget = null;

			this._lodMax = 0;
			this._cubeSize = 0;
			this._lodPlanes = [];
			this._sizeLods = [];
			this._sigmas = [];

			this._blurMaterial = null;
			this._cubemapMaterial = null;
			this._equirectMaterial = null;

			this._compileMaterial( this._blurMaterial );

		}

		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */
		fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

			_oldTarget = this._renderer.getRenderTarget();

			this._setSize( 256 );

			const cubeUVRenderTarget = this._allocateTargets();
			cubeUVRenderTarget.depthBuffer = true;

			this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

			if ( sigma > 0 ) {

				this._blur( cubeUVRenderTarget, 0, 0, sigma );

			}

			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromEquirectangular( equirectangular, renderTarget = null ) {

			return this._fromTexture( equirectangular, renderTarget );

		}

		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromCubemap( cubemap, renderTarget = null ) {

			return this._fromTexture( cubemap, renderTarget );

		}

		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader() {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();
				this._compileMaterial( this._cubemapMaterial );

			}

		}

		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader() {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();
				this._compileMaterial( this._equirectMaterial );

			}

		}

		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose() {

			this._dispose();

			if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
			if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

		}

		// private interface

		_setSize( cubeSize ) {

			this._lodMax = Math.floor( Math.log2( cubeSize ) );
			this._cubeSize = Math.pow( 2, this._lodMax );

		}

		_dispose() {

			if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

			if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

			for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

				this._lodPlanes[ i ].dispose();

			}

		}

		_cleanup( outputTarget ) {

			this._renderer.setRenderTarget( _oldTarget );
			outputTarget.scissorTest = false;
			_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

		}

		_fromTexture( texture, renderTarget ) {

			if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

				this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

			} else { // Equirectangular

				this._setSize( texture.image.width / 4 );

			}

			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();
			this._textureToCubeUV( texture, cubeUVRenderTarget );
			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_allocateTargets() {

			const width = 3 * Math.max( this._cubeSize, 16 * 7 );
			const height = 4 * this._cubeSize;

			const params = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: false,
				type: HalfFloatType,
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget( width, height, params );

			if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

				if ( this._pingPongRenderTarget !== null ) {

					this._dispose();

				}

				this._pingPongRenderTarget = _createRenderTarget( width, height, params );

				const { _lodMax } = this;
				( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

				this._blurMaterial = _getBlurShader( _lodMax, width, height );

			}

			return cubeUVRenderTarget;

		}

		_compileMaterial( material ) {

			const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
			this._renderer.compile( tmpMesh, _flatCamera );

		}

		_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
			const upSign = [ 1, - 1, 1, 1, 1, 1 ];
			const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
			const renderer = this._renderer;

			const originalAutoClear = renderer.autoClear;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor( _clearColor$1 );

			renderer.toneMapping = NoToneMapping;
			renderer.autoClear = false;

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false,
			} );

			const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

			let useSolidColor = false;
			const background = scene.background;

			if ( background ) {

				if ( background.isColor ) {

					backgroundMaterial.color.copy( background );
					scene.background = null;
					useSolidColor = true;

				}

			} else {

				backgroundMaterial.color.copy( _clearColor$1 );
				useSolidColor = true;

			}

			for ( let i = 0; i < 6; i ++ ) {

				const col = i % 3;

				if ( col === 0 ) {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

				} else if ( col === 1 ) {

					cubeCamera.up.set( 0, 0, upSign[ i ] );
					cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

				} else {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

				}

				const size = this._cubeSize;

				_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

				renderer.setRenderTarget( cubeUVRenderTarget );

				if ( useSolidColor ) {

					renderer.render( backgroundBox, cubeCamera );

				}

				renderer.render( scene, cubeCamera );

			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();

			renderer.toneMapping = toneMapping;
			renderer.autoClear = originalAutoClear;
			scene.background = background;

		}

		_textureToCubeUV( texture, cubeUVRenderTarget ) {

			const renderer = this._renderer;

			const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

			if ( isCubeTexture ) {

				if ( this._cubemapMaterial === null ) {

					this._cubemapMaterial = _getCubemapMaterial();

				}

				this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

			} else {

				if ( this._equirectMaterial === null ) {

					this._equirectMaterial = _getEquirectMaterial();

				}

			}

			const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
			const mesh = new Mesh( this._lodPlanes[ 0 ], material );

			const uniforms = material.uniforms;

			uniforms[ 'envMap' ].value = texture;

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( mesh, _flatCamera );

		}

		_applyPMREM( cubeUVRenderTarget ) {

			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

				const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

				const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

				this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

			}

			renderer.autoClear = autoClear;

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis );

			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis );

		}

		_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3;

			const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
			const blurUniforms = blurMaterial.uniforms;

			const pixels = this._sizeLods[ lodIn ] - 1;
			const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

			const weights = [];
			let sum = 0;

			for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

				const x = i / sigmaPixels;
				const weight = Math.exp( - x * x / 2 );
				weights.push( weight );

				if ( i === 0 ) {

					sum += weight;

				} else if ( i < samples ) {

					sum += 2 * weight;

				}

			}

			for ( let i = 0; i < weights.length; i ++ ) {

				weights[ i ] = weights[ i ] / sum;

			}

			blurUniforms[ 'envMap' ].value = targetIn.texture;
			blurUniforms[ 'samples' ].value = samples;
			blurUniforms[ 'weights' ].value = weights;
			blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

			if ( poleAxis ) {

				blurUniforms[ 'poleAxis' ].value = poleAxis;

			}

			const { _lodMax } = this;
			blurUniforms[ 'dTheta' ].value = radiansPerPixel;
			blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

			const outputSize = this._sizeLods[ lodOut ];
			const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
			const y = 4 * ( this._cubeSize - outputSize );

			_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
			renderer.setRenderTarget( targetOut );
			renderer.render( blurMesh, _flatCamera );

		}

	}



	function _createPlanes( lodMax ) {

		const lodPlanes = [];
		const sizeLods = [];
		const sigmas = [];

		let lod = lodMax;

		const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

		for ( let i = 0; i < totalLods; i ++ ) {

			const sizeLod = Math.pow( 2, lod );
			sizeLods.push( sizeLod );
			let sigma = 1.0 / sizeLod;

			if ( i > lodMax - LOD_MIN ) {

				sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

			} else if ( i === 0 ) {

				sigma = 0;

			}

			sigmas.push( sigma );

			const texelSize = 1.0 / ( sizeLod - 2 );
			const min = - texelSize;
			const max = 1 + texelSize;
			const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;

			const position = new Float32Array( positionSize * vertices * cubeFaces );
			const uv = new Float32Array( uvSize * vertices * cubeFaces );
			const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

			for ( let face = 0; face < cubeFaces; face ++ ) {

				const x = ( face % 3 ) * 2 / 3 - 1;
				const y = face > 2 ? 0 : - 1;
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				];
				position.set( coordinates, positionSize * vertices * face );
				uv.set( uv1, uvSize * vertices * face );
				const fill = [ face, face, face, face, face, face ];
				faceIndex.set( fill, faceIndexSize * vertices * face );

			}

			const planes = new BufferGeometry();
			planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
			planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
			planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
			lodPlanes.push( planes );

			if ( lod > LOD_MIN ) {

				lod --;

			}

		}

		return { lodPlanes, sizeLods, sigmas };

	}

	function _createRenderTarget( width, height, params ) {

		const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;

	}

	function _setViewport( target, x, y, width, height ) {

		target.viewport.set( x, y, width, height );
		target.scissor.set( x, y, width, height );

	}

	function _getBlurShader( lodMax, width, height ) {

		const weights = new Float32Array( MAX_SAMPLES );
		const poleAxis = new Vector3( 0, 1, 0 );
		const shaderMaterial = new ShaderMaterial( {

			name: 'SphericalGaussianBlur',

			defines: {
				'n': MAX_SAMPLES,
				'CUBEUV_TEXEL_WIDTH': 1.0 / width,
				'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
				'CUBEUV_MAX_MIP': `${lodMax}.0`,
			},

			uniforms: {
				'envMap': { value: null },
				'samples': { value: 1 },
				'weights': { value: weights },
				'latitudinal': { value: false },
				'dTheta': { value: 0 },
				'mipInt': { value: 0 },
				'poleAxis': { value: poleAxis }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

		return shaderMaterial;

	}

	function _getEquirectMaterial() {

		return new ShaderMaterial( {

			name: 'EquirectangularToCubeUV',

			uniforms: {
				'envMap': { value: null }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCubemapMaterial() {

		return new ShaderMaterial( {

			name: 'CubemapToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'flipEnvMap': { value: - 1 }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCommonVertexShader() {

		return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

	}

	function WebGLCubeUVMaps( renderer ) {

		let cubeUVmaps = new WeakMap();

		let pmremGenerator = null;

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
				const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

				// equirect/cube map to cubeUV conversion

				if ( isEquirectMap || isCubeMap ) {

					if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

						texture.needsPMREMUpdate = false;

						let renderTarget = cubeUVmaps.get( texture );

						if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
						cubeUVmaps.set( texture, renderTarget );

						return renderTarget.texture;

					} else {

						if ( cubeUVmaps.has( texture ) ) {

							return cubeUVmaps.get( texture ).texture;

						} else {

							const image = texture.image;

							if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

								if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

								const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
								cubeUVmaps.set( texture, renderTarget );

								texture.addEventListener( 'dispose', onTextureDispose );

								return renderTarget.texture;

							} else {

								// image not yet ready. try the conversion next frame

								return null;

							}

						}

					}

				}

			}

			return texture;

		}

		function isCubeTextureComplete( image ) {

			let count = 0;
			const length = 6;

			for ( let i = 0; i < length; i ++ ) {

				if ( image[ i ] !== undefined ) count ++;

			}

			return count === length;


		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemapUV = cubeUVmaps.get( texture );

			if ( cubemapUV !== undefined ) {

				cubeUVmaps.delete( texture );
				cubemapUV.dispose();

			}

		}

		function dispose() {

			cubeUVmaps = new WeakMap();

			if ( pmremGenerator !== null ) {

				pmremGenerator.dispose();
				pmremGenerator = null;

			}

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function ( capabilities ) {

				if ( capabilities.isWebGL2 ) {

					getExtension( 'EXT_color_buffer_float' );

				} else {

					getExtension( 'WEBGL_depth_texture' );
					getExtension( 'OES_texture_float' );
					getExtension( 'OES_texture_half_float' );
					getExtension( 'OES_texture_half_float_linear' );
					getExtension( 'OES_standard_derivatives' );
					getExtension( 'OES_element_index_uint' );
					getExtension( 'OES_vertex_array_object' );
					getExtension( 'ANGLE_instanced_arrays' );

				}

				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );
				getExtension( 'WEBGL_multisampled_render_to_texture' );

			},

			get: function ( name ) {

				const extension = getExtension( name );

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( const name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			for ( const name in geometry.morphAttributes ) {

				const array = geometry.morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.remove( array[ i ] );

				}

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			const attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) return geometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else if ( geometryPosition !== undefined ) {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			} else {

				return;

			}

			const attribute = new ( arrayNeedsUint32$1( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

			}

		}

		function reset() {

			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	class DataArrayTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			super( null );

			this.isDataArrayTexture = true;

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl, capabilities, textures ) {

		const influencesList = {};
		const morphInfluences = new Float32Array( 8 );
		const morphTextures = new WeakMap();
		const morph = new Vector4();

		const workInfluences = [];

		for ( let i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, program ) {

			const objectInfluences = object.morphTargetInfluences;

			if ( capabilities.isWebGL2 === true ) {

				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				let entry = morphTextures.get( geometry );

				if ( entry === undefined || entry.count !== morphTargetsCount ) {

					if ( entry !== undefined ) entry.texture.dispose();

					const hasMorphPosition = geometry.morphAttributes.position !== undefined;
					const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					const hasMorphColors = geometry.morphAttributes.color !== undefined;

					const morphTargets = geometry.morphAttributes.position || [];
					const morphNormals = geometry.morphAttributes.normal || [];
					const morphColors = geometry.morphAttributes.color || [];

					let vertexDataCount = 0;

					if ( hasMorphPosition === true ) vertexDataCount = 1;
					if ( hasMorphNormals === true ) vertexDataCount = 2;
					if ( hasMorphColors === true ) vertexDataCount = 3;

					let width = geometry.attributes.position.count * vertexDataCount;
					let height = 1;

					if ( width > capabilities.maxTextureSize ) {

						height = Math.ceil( width / capabilities.maxTextureSize );
						width = capabilities.maxTextureSize;

					}

					const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

					const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
					texture.type = FloatType;
					texture.needsUpdate = true;

					// fill buffer

					const vertexDataStride = vertexDataCount * 4;

					for ( let i = 0; i < morphTargetsCount; i ++ ) {

						const morphTarget = morphTargets[ i ];
						const morphNormal = morphNormals[ i ];
						const morphColor = morphColors[ i ];

						const offset = width * height * 4 * i;

						for ( let j = 0; j < morphTarget.count; j ++ ) {

							const stride = j * vertexDataStride;

							if ( hasMorphPosition === true ) {

								morph.fromBufferAttribute( morphTarget, j );

								buffer[ offset + stride + 0 ] = morph.x;
								buffer[ offset + stride + 1 ] = morph.y;
								buffer[ offset + stride + 2 ] = morph.z;
								buffer[ offset + stride + 3 ] = 0;

							}

							if ( hasMorphNormals === true ) {

								morph.fromBufferAttribute( morphNormal, j );

								buffer[ offset + stride + 4 ] = morph.x;
								buffer[ offset + stride + 5 ] = morph.y;
								buffer[ offset + stride + 6 ] = morph.z;
								buffer[ offset + stride + 7 ] = 0;

							}

							if ( hasMorphColors === true ) {

								morph.fromBufferAttribute( morphColor, j );

								buffer[ offset + stride + 8 ] = morph.x;
								buffer[ offset + stride + 9 ] = morph.y;
								buffer[ offset + stride + 10 ] = morph.z;
								buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

							}

						}

					}

					entry = {
						count: morphTargetsCount,
						texture: texture,
						size: new Vector2( width, height )
					};

					morphTextures.set( geometry, entry );

					function disposeTexture() {

						texture.dispose();

						morphTextures.delete( geometry );

						geometry.removeEventListener( 'dispose', disposeTexture );

					}

					geometry.addEventListener( 'dispose', disposeTexture );

				}

				//

				let morphInfluencesSum = 0;

				for ( let i = 0; i < objectInfluences.length; i ++ ) {

					morphInfluencesSum += objectInfluences[ i ];

				}

				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

				program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
				program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


			} else {

				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

				const length = objectInfluences === undefined ? 0 : objectInfluences.length;

				let influences = influencesList[ geometry.id ];

				if ( influences === undefined || influences.length !== length ) {

					// initialise list

					influences = [];

					for ( let i = 0; i < length; i ++ ) {

						influences[ i ] = [ i, 0 ];

					}

					influencesList[ geometry.id ] = influences;

				}

				// Collect influences

				for ( let i = 0; i < length; i ++ ) {

					const influence = influences[ i ];

					influence[ 0 ] = i;
					influence[ 1 ] = objectInfluences[ i ];

				}

				influences.sort( absNumericalSort );

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < length && influences[ i ][ 1 ] ) {

						workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
						workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

					} else {

						workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
						workInfluences[ i ][ 1 ] = 0;

					}

				}

				workInfluences.sort( numericalSort );

				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal;

				let morphInfluencesSum = 0;

				for ( let i = 0; i < 8; i ++ ) {

					const influence = workInfluences[ i ];
					const index = influence[ 0 ];
					const value = influence[ 1 ];

					if ( index !== Number.MAX_SAFE_INTEGER && value ) {

						if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

							geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

						}

						if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

							geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

						}

						morphInfluences[ i ] = value;
						morphInfluencesSum += value;

					} else {

						if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

							geometry.deleteAttribute( 'morphTarget' + i );

						}

						if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

							geometry.deleteAttribute( 'morphNormal' + i );

						}

						morphInfluences[ i ] = 0;

					}

				}

				// GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

			}

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				if ( updateMap.get( object ) !== frame ) {

					attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

					if ( object.instanceColor !== null ) {

						attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

					}

					updateMap.set( object, frame );

				}

			}

			if ( object.isSkinnedMesh ) {

				const skeleton = object.skeleton;

				if ( updateMap.get( skeleton ) !== frame ) {

					skeleton.update();

					updateMap.set( skeleton, frame );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	class Data3DTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super( null );

			this.isData3DTexture = true;

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = /*@__PURE__*/ new Texture();
	const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
	const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
	const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual$1( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual$1( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual$1( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual$1( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single integer / boolean

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single integer / boolean vector (from flat array or THREE.VectorN)

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2i( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform2iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3i( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform3iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform4iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single unsigned integer

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single unsigned integer vector (from flat array or THREE.VectorN)

	function setValueV2ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2ui( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform2uiv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3ui( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform3uiv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual$1( cache, v ) ) return;

			gl.uniform4uiv( this.addr, v );

			copyArray( cache, v );

		}

	}


	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || empty3dTexture, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTextureCube( v || emptyCubeTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyArrayTexture, unit );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT
			case 0x8dc6: return setValueV2ui; // _VEC2
			case 0x8dc7: return setValueV3ui; // _VEC3
			case 0x8dc8: return setValueV4ui; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}


	// Array of scalars

	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of integer / boolean

	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Array of unsigned integer

	function setValueV1uiArray( gl, v ) {

		gl.uniform1uiv( this.addr, v );

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray( gl, v ) {

		gl.uniform2uiv( this.addr, v );

	}

	function setValueV3uiArray( gl, v ) {

		gl.uniform3uiv( this.addr, v );

	}

	function setValueV4uiArray( gl, v ) {

		gl.uniform4uiv( this.addr, v );

	}


	// Array of textures (2D / 3D / Cube / 2DArray)

	function setValueT1Array( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual$1( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT3DArray( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual$1( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual$1( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	function setValueT2DArrayArray( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual$1( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

		}

	}


	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x1405: return setValueV1uiArray; // UINT
			case 0x8dc6: return setValueV2uiArray; // _VEC2
			case 0x8dc7: return setValueV3uiArray; // _VEC3
			case 0x8dc8: return setValueV4uiArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;

		}

	}

	// --- Uniform Classes ---

	class SingleUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class PureArrayUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class StructuredUniform {

		constructor( id ) {

			this.id = id;

			this.seq = [];
			this.map = {};

		}

		setValue( gl, value, textures ) {

			const seq = this.seq;

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				u.setValue( gl, value[ u.id ], textures );

			}

		}

	}

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	class WebGLUniforms {

		constructor( gl, program ) {

			this.seq = [];
			this.map = {};

			const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( let i = 0; i < n; ++ i ) {

				const info = gl.getActiveUniform( program, i ),
					addr = gl.getUniformLocation( program, info.name );

				parseUniform( info, addr, this );

			}

		}

		setValue( gl, name, value, textures ) {

			const u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, textures );

		}

		setOptional( gl, object, name ) {

			const v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		}

		static upload( gl, seq, values, textures ) {

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {

					// note: always updating when .needsUpdate is undefined
					u.setValue( gl, v.value, textures );

				}

			}

		}

		static seqWithValue( seq, values ) {

			const r = [];

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		}

	}

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	let programIdCount = 0;

	function handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	function getEncodingComponents( colorSpace ) {

		switch ( colorSpace ) {

			case LinearSRGBColorSpace:
				return [ 'Linear', '( value )' ];
			case SRGBColorSpace:
				return [ 'sRGB', '( value )' ];
			default:
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			// --enable-privileged-webgl-extension
			// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	function getTexelEncodingFunction( functionName, colorSpace ) {

		const components = getEncodingComponents( colorSpace );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		const chunks = [
			( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			let locationSize = 1;
			if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
			if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
			if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = {
				type: info.type,
				location: gl.getAttribLocation( program, name ),
				locationSize: locationSize
			};

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
			.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	const shaderChunkMap = new Map( [
		[ 'encodings_fragment', 'colorspace_fragment' ], // @deprecated, r154
		[ 'encodings_pars_fragment', 'colorspace_pars_fragment' ], // @deprecated, r154
		[ 'output_fragment', 'opaque_fragment' ], // @deprecated, r154
	] );

	function includeReplacer( match, include ) {

		let string = ShaderChunk[ include ];

		if ( string === undefined ) {

			const newInclude = shaderChunkMap.get( include );

			if ( newInclude !== undefined ) {

				string = ShaderChunk[ newInclude ];

			} else {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string.replace( unrollLoopPattern, loopReplacer );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function generateCubeUVSize( parameters ) {

		const imageHeight = parameters.envMapCubeUVHeight;

		if ( imageHeight === null ) return null;

		const maxMip = Math.log2( imageHeight ) - 2;

		const texelHeight = 1.0 / imageHeight;

		const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

		return { texelWidth, texelHeight, maxMip };

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
		const envMapCubeUVSize = generateCubeUVSize( parameters );

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

				parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

				//

				parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
				parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
				parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
				parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
				parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
				parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
				parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
				parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

				parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
				parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

				parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

				parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
				parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
				parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

				parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
				parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

				parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
				parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

				parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
				parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
				parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

				parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
				parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

				//

				parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUv1s ? '#define USE_UV1' : '',
				parameters.vertexUv2s ? '#define USE_UV2' : '',
				parameters.vertexUv3s ? '#define USE_UV3' : '',

				parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_UV1',

				'	attribute vec2 uv1;',

				'#endif',

				'#ifdef USE_UV2',

				'	attribute vec2 uv2;',

				'#endif',

				'#ifdef USE_UV3',

				'	attribute vec2 uv3;',

				'#endif',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
				envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

				parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
				parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

				parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaTest ? '#define USE_ALPHATEST' : '',
				parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUv1s ? '#define USE_UV1' : '',
				parameters.vertexUv2s ? '#define USE_UV2' : '',
				parameters.vertexUv3s ? '#define USE_UV3' : '',

				parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',
				parameters.opaque ? '#define OPAQUE' : '',

				ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),

				parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'precision mediump sampler2DArray;',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				if ( typeof renderer.debug.onShaderError === 'function' ) {

					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					getShaderErrors( gl, glVertexShader, 'vertex' );
					getShaderErrors( gl, glFragmentShader, 'fragment' );

				}

			} else if ( programLog !== '' ) ; else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.type = parameters.shaderType;
		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	let _id$2 = 0;

	class WebGLShaderCache {

		constructor() {

			this.shaderCache = new Map();
			this.materialCache = new Map();

		}

		update( material ) {

			const vertexShader = material.vertexShader;
			const fragmentShader = material.fragmentShader;

			const vertexShaderStage = this._getShaderStage( vertexShader );
			const fragmentShaderStage = this._getShaderStage( fragmentShader );

			const materialShaders = this._getShaderCacheForMaterial( material );

			if ( materialShaders.has( vertexShaderStage ) === false ) {

				materialShaders.add( vertexShaderStage );
				vertexShaderStage.usedTimes ++;

			}

			if ( materialShaders.has( fragmentShaderStage ) === false ) {

				materialShaders.add( fragmentShaderStage );
				fragmentShaderStage.usedTimes ++;

			}

			return this;

		}

		remove( material ) {

			const materialShaders = this.materialCache.get( material );

			for ( const shaderStage of materialShaders ) {

				shaderStage.usedTimes --;

				if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

			}

			this.materialCache.delete( material );

			return this;

		}

		getVertexShaderID( material ) {

			return this._getShaderStage( material.vertexShader ).id;

		}

		getFragmentShaderID( material ) {

			return this._getShaderStage( material.fragmentShader ).id;

		}

		dispose() {

			this.shaderCache.clear();
			this.materialCache.clear();

		}

		_getShaderCacheForMaterial( material ) {

			const cache = this.materialCache;
			let set = cache.get( material );

			if ( set === undefined ) {

				set = new Set();
				cache.set( material, set );

			}

			return set;

		}

		_getShaderStage( code ) {

			const cache = this.shaderCache;
			let stage = cache.get( code );

			if ( stage === undefined ) {

				stage = new WebGLShaderStage( code );
				cache.set( code, stage );

			}

			return stage;

		}

	}

	class WebGLShaderStage {

		constructor( code ) {

			this.id = _id$2 ++;

			this.code = code;
			this.usedTimes = 0;

		}

	}

	function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

		const _programLayers = new Layers();
		const _customShaders = new WebGLShaderCache();
		const programs = [];

		const IS_WEBGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getChannel( value ) {

			if ( value === 0 ) return 'uv';

			return `uv${ value }`;

		}

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const geometry = object.geometry;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) ;

			}

			//

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let morphTextureStride = 0;

			if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
			if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
			if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

			//

			let vertexShader, fragmentShader;
			let customVertexShaderID, customFragmentShaderID;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

				_customShaders.update( material );

				customVertexShaderID = _customShaders.getVertexShaderID( material );
				customFragmentShaderID = _customShaders.getFragmentShaderID( material );

			}

			const currentRenderTarget = renderer.getRenderTarget();

			const IS_INSTANCEDMESH = object.isInstancedMesh === true;

			const HAS_MAP = !! material.map;
			const HAS_MATCAP = !! material.matcap;
			const HAS_ENVMAP = !! envMap;
			const HAS_AOMAP = !! material.aoMap;
			const HAS_LIGHTMAP = !! material.lightMap;
			const HAS_BUMPMAP = !! material.bumpMap;
			const HAS_NORMALMAP = !! material.normalMap;
			const HAS_DISPLACEMENTMAP = !! material.displacementMap;
			const HAS_EMISSIVEMAP = !! material.emissiveMap;

			const HAS_METALNESSMAP = !! material.metalnessMap;
			const HAS_ROUGHNESSMAP = !! material.roughnessMap;

			const HAS_ANISOTROPY = material.anisotropy > 0;
			const HAS_CLEARCOAT = material.clearcoat > 0;
			const HAS_IRIDESCENCE = material.iridescence > 0;
			const HAS_SHEEN = material.sheen > 0;
			const HAS_TRANSMISSION = material.transmission > 0;

			const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

			const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
			const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
			const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

			const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
			const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

			const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
			const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

			const HAS_SPECULARMAP = !! material.specularMap;
			const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
			const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

			const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
			const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

			const HAS_GRADIENTMAP = !! material.gradientMap;

			const HAS_ALPHAMAP = !! material.alphaMap;

			const HAS_ALPHATEST = material.alphaTest > 0;

			const HAS_ALPHAHASH = !! material.alphaHash;

			const HAS_EXTENSIONS = !! material.extensions;

			const HAS_ATTRIBUTE_UV1 = !! geometry.attributes.uv1;
			const HAS_ATTRIBUTE_UV2 = !! geometry.attributes.uv2;
			const HAS_ATTRIBUTE_UV3 = !! geometry.attributes.uv3;

			let toneMapping = NoToneMapping;

			if ( material.toneMapped ) {

				if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

					toneMapping = renderer.toneMapping;

				}

			}

			const parameters = {

				isWebGL2: IS_WEBGL2,

				shaderID: shaderID,
				shaderType: material.type,
				shaderName: material.name,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: IS_INSTANCEDMESH,
				instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,

				supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
				outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),

				map: HAS_MAP,
				matcap: HAS_MATCAP,
				envMap: HAS_ENVMAP,
				envMapMode: HAS_ENVMAP && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				aoMap: HAS_AOMAP,
				lightMap: HAS_LIGHTMAP,
				bumpMap: HAS_BUMPMAP,
				normalMap: HAS_NORMALMAP,
				displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
				emissiveMap: HAS_EMISSIVEMAP,

				normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
				normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

				metalnessMap: HAS_METALNESSMAP,
				roughnessMap: HAS_ROUGHNESSMAP,

				anisotropy: HAS_ANISOTROPY,
				anisotropyMap: HAS_ANISOTROPYMAP,

				clearcoat: HAS_CLEARCOAT,
				clearcoatMap: HAS_CLEARCOATMAP,
				clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
				clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

				iridescence: HAS_IRIDESCENCE,
				iridescenceMap: HAS_IRIDESCENCEMAP,
				iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

				sheen: HAS_SHEEN,
				sheenColorMap: HAS_SHEEN_COLORMAP,
				sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

				specularMap: HAS_SPECULARMAP,
				specularColorMap: HAS_SPECULAR_COLORMAP,
				specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

				transmission: HAS_TRANSMISSION,
				transmissionMap: HAS_TRANSMISSIONMAP,
				thicknessMap: HAS_THICKNESSMAP,

				gradientMap: HAS_GRADIENTMAP,

				opaque: material.transparent === false && material.blending === NormalBlending,

				alphaMap: HAS_ALPHAMAP,
				alphaTest: HAS_ALPHATEST,
				alphaHash: HAS_ALPHAHASH,

				combine: material.combine,

				//

				mapUv: HAS_MAP && getChannel( material.map.channel ),
				aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
				lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
				bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
				normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
				displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
				emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

				metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
				roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

				anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

				clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
				clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
				clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

				iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
				iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

				sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
				sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

				specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
				specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
				specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

				transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
				thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

				alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

				//

				vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
				vertexUv1s: HAS_ATTRIBUTE_UV1,
				vertexUv2s: HAS_ATTRIBUTE_UV2,
				vertexUv3s: HAS_ATTRIBUTE_UV3,

				pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

				fog: !! fog,
				useFog: material.fog === true,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading === true,

				sizeAttenuation: material.sizeAttenuation === true,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: object.isSkinnedMesh === true,

				morphTargets: geometry.morphAttributes.position !== undefined,
				morphNormals: geometry.morphAttributes.normal !== undefined,
				morphColors: geometry.morphAttributes.color !== undefined,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numSpotLightMaps: lights.spotLightMap.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: toneMapping,
				useLegacyLights: renderer._useLegacyLights,

				premultipliedAlpha: material.premultipliedAlpha,

				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				useDepthPacking: material.depthPacking >= 0,
				depthPacking: material.depthPacking || 0,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
				extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
				extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
				extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,

				rendererExtensionFragDepth: IS_WEBGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.customVertexShaderID );
				array.push( parameters.customFragmentShaderID );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				getProgramCacheKeyParameters( array, parameters );
				getProgramCacheKeyBooleans( array, parameters );
				array.push( renderer.outputColorSpace );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getProgramCacheKeyParameters( array, parameters ) {

			array.push( parameters.precision );
			array.push( parameters.outputColorSpace );
			array.push( parameters.envMapMode );
			array.push( parameters.envMapCubeUVHeight );
			array.push( parameters.mapUv );
			array.push( parameters.alphaMapUv );
			array.push( parameters.lightMapUv );
			array.push( parameters.aoMapUv );
			array.push( parameters.bumpMapUv );
			array.push( parameters.normalMapUv );
			array.push( parameters.displacementMapUv );
			array.push( parameters.emissiveMapUv );
			array.push( parameters.metalnessMapUv );
			array.push( parameters.roughnessMapUv );
			array.push( parameters.anisotropyMapUv );
			array.push( parameters.clearcoatMapUv );
			array.push( parameters.clearcoatNormalMapUv );
			array.push( parameters.clearcoatRoughnessMapUv );
			array.push( parameters.iridescenceMapUv );
			array.push( parameters.iridescenceThicknessMapUv );
			array.push( parameters.sheenColorMapUv );
			array.push( parameters.sheenRoughnessMapUv );
			array.push( parameters.specularMapUv );
			array.push( parameters.specularColorMapUv );
			array.push( parameters.specularIntensityMapUv );
			array.push( parameters.transmissionMapUv );
			array.push( parameters.thicknessMapUv );
			array.push( parameters.combine );
			array.push( parameters.fogExp2 );
			array.push( parameters.sizeAttenuation );
			array.push( parameters.morphTargetsCount );
			array.push( parameters.morphAttributeCount );
			array.push( parameters.numDirLights );
			array.push( parameters.numPointLights );
			array.push( parameters.numSpotLights );
			array.push( parameters.numSpotLightMaps );
			array.push( parameters.numHemiLights );
			array.push( parameters.numRectAreaLights );
			array.push( parameters.numDirLightShadows );
			array.push( parameters.numPointLightShadows );
			array.push( parameters.numSpotLightShadows );
			array.push( parameters.numSpotLightShadowsWithMaps );
			array.push( parameters.shadowMapType );
			array.push( parameters.toneMapping );
			array.push( parameters.numClippingPlanes );
			array.push( parameters.numClipIntersection );
			array.push( parameters.depthPacking );

		}

		function getProgramCacheKeyBooleans( array, parameters ) {

			_programLayers.disableAll();

			if ( parameters.isWebGL2 )
				_programLayers.enable( 0 );
			if ( parameters.supportsVertexTextures )
				_programLayers.enable( 1 );
			if ( parameters.instancing )
				_programLayers.enable( 2 );
			if ( parameters.instancingColor )
				_programLayers.enable( 3 );
			if ( parameters.matcap )
				_programLayers.enable( 4 );
			if ( parameters.envMap )
				_programLayers.enable( 5 );
			if ( parameters.normalMapObjectSpace )
				_programLayers.enable( 6 );
			if ( parameters.normalMapTangentSpace )
				_programLayers.enable( 7 );
			if ( parameters.clearcoat )
				_programLayers.enable( 8 );
			if ( parameters.iridescence )
				_programLayers.enable( 9 );
			if ( parameters.alphaTest )
				_programLayers.enable( 10 );
			if ( parameters.vertexColors )
				_programLayers.enable( 11 );
			if ( parameters.vertexAlphas )
				_programLayers.enable( 12 );
			if ( parameters.vertexUv1s )
				_programLayers.enable( 13 );
			if ( parameters.vertexUv2s )
				_programLayers.enable( 14 );
			if ( parameters.vertexUv3s )
				_programLayers.enable( 15 );
			if ( parameters.vertexTangents )
				_programLayers.enable( 16 );
			if ( parameters.anisotropy )
				_programLayers.enable( 17 );

			array.push( _programLayers.mask );
			_programLayers.disableAll();

			if ( parameters.fog )
				_programLayers.enable( 0 );
			if ( parameters.useFog )
				_programLayers.enable( 1 );
			if ( parameters.flatShading )
				_programLayers.enable( 2 );
			if ( parameters.logarithmicDepthBuffer )
				_programLayers.enable( 3 );
			if ( parameters.skinning )
				_programLayers.enable( 4 );
			if ( parameters.morphTargets )
				_programLayers.enable( 5 );
			if ( parameters.morphNormals )
				_programLayers.enable( 6 );
			if ( parameters.morphColors )
				_programLayers.enable( 7 );
			if ( parameters.premultipliedAlpha )
				_programLayers.enable( 8 );
			if ( parameters.shadowMapEnabled )
				_programLayers.enable( 9 );
			if ( parameters.useLegacyLights )
				_programLayers.enable( 10 );
			if ( parameters.doubleSided )
				_programLayers.enable( 11 );
			if ( parameters.flipSided )
				_programLayers.enable( 12 );
			if ( parameters.useDepthPacking )
				_programLayers.enable( 13 );
			if ( parameters.dithering )
				_programLayers.enable( 14 );
			if ( parameters.transmission )
				_programLayers.enable( 15 );
			if ( parameters.sheen )
				_programLayers.enable( 16 );
			if ( parameters.opaque )
				_programLayers.enable( 17 );
			if ( parameters.pointsUvs )
				_programLayers.enable( 18 );

			array.push( _programLayers.mask );

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		function releaseShaderCache( material ) {

			_customShaders.remove( material );

		}

		function dispose() {

			_customShaders.dispose();

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			releaseShaderCache: releaseShaderCache,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs,
			dispose: dispose
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable$1( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable$1( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transmissive = [];
		const transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.push( renderItem );

			} else if ( material.transparent === true ) {

				transparent.push( renderItem );

			} else {

				opaque.push( renderItem );

			}

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.unshift( renderItem );

			} else if ( material.transparent === true ) {

				transparent.unshift( renderItem );

			} else {

				opaque.unshift( renderItem );

			}

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable$1 );
			if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable$1 );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable$1 );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		let lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			const listArray = lists.get( scene );
			let list;

			if ( listArray === undefined ) {

				list = new WebGLRenderList();
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= listArray.length ) {

					list = new WebGLRenderList();
					listArray.push( list );

				} else {

					list = listArray[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1,
				numSpotMaps: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights, useLegacyLights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			let numSpotMaps = 0;
			let numSpotShadowsWithMaps = 0;

			// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
			lights.sort( shadowCastingAndTexturingLightsFirst );

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					state.spot[ spotLength ] = uniforms;

					const shadow = light.shadow;

					if ( light.map ) {

						state.spotLightMap[ numSpotMaps ] = light.map;
						numSpotMaps ++;

						// make sure the lightMatrix is up to date
						// TODO : do it if required only
						shadow.updateMatrices( light );

						if ( light.castShadow ) numSpotShadowsWithMaps ++;

					}

					state.spotLightMatrix[ spotLength ] = shadow.matrix;

					if ( light.castShadow ) {

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;

						numSpotShadows ++;

					}

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else ;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ||
				hash.numSpotMaps !== numSpotMaps ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
				state.spotLightMap.length = numSpotMaps;
				state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				hash.numSpotMaps = numSpotMaps;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		const lights = new WebGLLights( extensions, capabilities );

		const lightsArray = [];
		const shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( useLegacyLights ) {

			lights.setup( lightsArray, useLegacyLights );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			const renderStateArray = renderStates.get( scene );
			let renderState;

			if ( renderStateArray === undefined ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStateArray.length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStateArray.push( renderState );

				} else {

					renderState = renderStateArray[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class MeshDepthMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshDepthMaterial = true;

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.depthPacking = source.depthPacking;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		}

	}

	class MeshDistanceMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshDistanceMaterial = true;

			this.type = 'MeshDistanceMaterial';

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		}

	}

	const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap( _renderer, _objects, _capabilities ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
			_distanceMaterial = new MeshDistanceMaterial(),

			_materialCache = {},

			_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vertex,
			fragmentShader: fragment

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;
		let _previousType = this.type;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// check for shadow map type changes

			const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
			const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

					if ( _shadowMapSize.x > _maxTextureSize ) {

						_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > _maxTextureSize ) {

						_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null || toVSM === true || fromVSM === true ) {

					const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

					if ( shadow.map !== null ) {

						shadow.map.dispose();

					}

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			_previousType = this.type;

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = _objects.update( fullScreenMesh );

			if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;

			}

			if ( shadow.mapPass === null ) {

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

			}

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterial( object, material, light, type ) {

			let result = null;

			const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

			if ( customMaterial !== undefined ) {

				result = customMaterial;

			} else {

				result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

				if ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
					( material.displacementMap && material.displacementScale !== 0 ) ||
					( material.alphaMap && material.alphaTest > 0 ) ||
					( material.map && material.alphaTest > 0 ) ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					const keyA = result.uuid, keyB = material.uuid;

					let materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					let cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;

					}

					result = cachedMaterial;

				}

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;
			result.map = material.map;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				const materialProperties = _renderer.properties.get( result );
				materialProperties.light = light;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = _objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, material, light, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		const uboBindings = new WeakMap();
		const uboProgramMap = new WeakMap();

		let enabledCapabilities = {};

		let currentBoundFramebuffers = {};
		let currentDrawbuffers = new WeakMap();
		let defaultDrawbuffers = [];

		let currentProgram = null;

		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
		const viewportParam = gl.getParameter( gl.VIEWPORT );

		const currentScissor = new Vector4().fromArray( scissorParam );
		const currentViewport = new Vector4().fromArray( viewportParam );

		function createTexture( type, target, count, dimensions ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( let i = 0; i < count; i ++ ) {

				if ( isWebGL2 && ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) ) {

					gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				} else {

					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				}

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		if ( isWebGL2 ) {

			emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
			emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

		}

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function bindFramebuffer( target, framebuffer ) {

			if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

				gl.bindFramebuffer( target, framebuffer );

				currentBoundFramebuffers[ target ] = framebuffer;

				if ( isWebGL2 ) {

					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

					if ( target === gl.DRAW_FRAMEBUFFER ) {

						currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

					}

					if ( target === gl.FRAMEBUFFER ) {

						currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

					}

				}

				return true;

			}

			return false;

		}

		function drawBuffers( renderTarget, framebuffer ) {

			let drawBuffers = defaultDrawbuffers;

			let needsUpdate = false;

			if ( renderTarget ) {

				drawBuffers = currentDrawbuffers.get( framebuffer );

				if ( drawBuffers === undefined ) {

					drawBuffers = [];
					currentDrawbuffers.set( framebuffer, drawBuffers );

				}

				if ( renderTarget.isWebGLMultipleRenderTargets ) {

					const textures = renderTarget.texture;

					if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

						}

						drawBuffers.length = textures.length;

						needsUpdate = true;

					}

				} else {

					if ( drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

						drawBuffers[ 0 ] = gl.COLOR_ATTACHMENT0;

						needsUpdate = true;

					}

				}

			} else {

				if ( drawBuffers[ 0 ] !== gl.BACK ) {

					drawBuffers[ 0 ] = gl.BACK;

					needsUpdate = true;

				}

			}

			if ( needsUpdate ) {

				if ( capabilities.isWebGL2 ) {

					gl.drawBuffers( drawBuffers );

				} else {

					extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

				}

			}


		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = gl.MIN;
			equationToGL[ MaxEquation ] = gl.MAX;

		} else {

			const extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		const factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( gl.BLEND );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( gl.BLEND );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( gl.FUNC_ADD );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.ONE, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
								break;

							case MultiplyBlending:
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = false;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			material.alphaToCoverage === true
				? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
				: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture, webglSlot ) {

			if ( webglSlot === undefined ) {

				if ( currentTextureSlot === null ) {

					webglSlot = gl.TEXTURE0 + maxTextures - 1;

				} else {

					webglSlot = currentTextureSlot;

				}

			}

			let boundTexture = currentBoundTextures[ webglSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ webglSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function compressedTexImage3D() {

			try {

				gl.compressedTexImage3D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function texSubImage2D() {

			try {

				gl.texSubImage2D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function texSubImage3D() {

			try {

				gl.texSubImage3D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function compressedTexSubImage2D() {

			try {

				gl.compressedTexSubImage2D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function compressedTexSubImage3D() {

			try {

				gl.compressedTexSubImage3D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function texStorage2D() {

			try {

				gl.texStorage2D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function texStorage3D() {

			try {

				gl.texStorage3D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		function updateUBOMapping( uniformsGroup, program ) {

			let mapping = uboProgramMap.get( program );

			if ( mapping === undefined ) {

				mapping = new WeakMap();

				uboProgramMap.set( program, mapping );

			}

			let blockIndex = mapping.get( uniformsGroup );

			if ( blockIndex === undefined ) {

				blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

				mapping.set( uniformsGroup, blockIndex );

			}

		}

		function uniformBlockBinding( uniformsGroup, program ) {

			const mapping = uboProgramMap.get( program );
			const blockIndex = mapping.get( uniformsGroup );

			if ( uboBindings.get( program ) !== blockIndex ) {

				// bind shader specific block index to global block point
				gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

				uboBindings.set( program, blockIndex );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( gl.BLEND );
			gl.disable( gl.CULL_FACE );
			gl.disable( gl.DEPTH_TEST );
			gl.disable( gl.POLYGON_OFFSET_FILL );
			gl.disable( gl.SCISSOR_TEST );
			gl.disable( gl.STENCIL_TEST );
			gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.ONE, gl.ZERO );
			gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( gl.LESS );
			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
			gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
			gl.clearStencil( 0 );

			gl.cullFace( gl.BACK );
			gl.frontFace( gl.CCW );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( gl.TEXTURE0 );

			gl.bindFramebuffer( gl.FRAMEBUFFER, null );

			if ( isWebGL2 === true ) {

				gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
				gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

			}

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentBoundFramebuffers = {};
			currentDrawbuffers = new WeakMap();
			defaultDrawbuffers = [];

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
			currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			drawBuffers: drawBuffers,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			compressedTexImage3D: compressedTexImage3D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			updateUBOMapping: updateUBOMapping,
			uniformBlockBinding: uniformBlockBinding,

			texStorage2D: texStorage2D,
			texStorage3D: texStorage3D,
			texSubImage2D: texSubImage2D,
			texSubImage3D: texSubImage3D,
			compressedTexSubImage2D: compressedTexSubImage2D,
			compressedTexSubImage3D: compressedTexSubImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const isWebGL2 = capabilities.isWebGL2;
		capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;
		const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
		const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

		const _videoTextures = new WeakMap();
		let _canvas;

		const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				// eslint-disable-next-line compat/compat
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				// eslint-disable-next-line compat/compat
				new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			let scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

					const width = floor( scale * image.width );
					const height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					return canvas;

				} else {

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo$1( image ) {

			return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target ) {

			_gl.generateMipmap( target );

		}

		function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			}

			let internalFormat = glFormat;

			if ( glFormat === _gl.RED ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

			}

			if ( glFormat === _gl.RED_INTEGER ) {

				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
				if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
				if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
				if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
				if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
				if ( glType === _gl.INT ) internalFormat = _gl.R32I;

			}

			if ( glFormat === _gl.RG ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

			}

			if ( glFormat === _gl.RGBA ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
				if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
				if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

			}

			if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
				internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
				internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		function getMipLevels( texture, image, supportsMips ) {

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

				return Math.log2( Math.max( image.width, image.height ) ) + 1;

			} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

				// user-defined mipmaps

				return texture.mipmaps.length;

			} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

				return image.mipmaps.length;

			} else {

				// texture without mipmaps (only base level)

				return 1;

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			// check if it's necessary to remove the WebGLTexture object

			const source = texture.source;
			const webglTextures = _sources.get( source );

			if ( webglTextures ) {

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];
				webglTexture.usedTimes --;

				// the WebGLTexture object is not used anymore, remove it

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

				// remove the weak map entry if no WebGLTexture uses the source anymore

				if ( Object.keys( webglTextures ).length === 0 ) {

					_sources.delete( source );

				}

			}

			properties.remove( texture );

		}

		function deleteTexture( texture ) {

			const textureProperties = properties.get( texture );
			_gl.deleteTexture( textureProperties.__webglTexture );

			const source = texture.source;
			const webglTextures = _sources.get( source );
			delete webglTextures[ textureProperties.__cacheKey ];

			info.memory.textures --;

		}

		function deallocateRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

				info.memory.textures --;

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

						for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

					} else {

						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

					}

					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

				}

				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

				if ( renderTargetProperties.__webglColorRenderbuffer ) {

					for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

						if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

				}

				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				for ( let i = 0, il = texture.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( texture[ i ] );

					if ( attachmentProperties.__webglTexture ) {

						_gl.deleteTexture( attachmentProperties.__webglTexture );

						info.memory.textures --;

					}

					properties.remove( texture[ i ] );

				}

			}

			properties.remove( texture );
			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			textureUnits += 1;

			return textureUnit;

		}

		function getTextureCacheKey( texture ) {

			const array = [];

			array.push( texture.wrapS );
			array.push( texture.wrapT );
			array.push( texture.wrapR || 0 );
			array.push( texture.magFilter );
			array.push( texture.minFilter );
			array.push( texture.anisotropy );
			array.push( texture.internalFormat );
			array.push( texture.format );
			array.push( texture.type );
			array.push( texture.generateMipmaps );
			array.push( texture.premultiplyAlpha );
			array.push( texture.flipY );
			array.push( texture.unpackAlignment );
			array.push( texture.colorSpace );

			return array.join();

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === null ) ; else if ( image.complete === false ) ; else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: _gl.REPEAT,
			[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
		};

		const filterToGL = {
			[ NearestFilter ]: _gl.NEAREST,
			[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: _gl.LINEAR,
			[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
		};

		const compareToGL = {
			[ NeverCompare ]: _gl.NEVER,
			[ AlwaysCompare ]: _gl.ALWAYS,
			[ LessCompare ]: _gl.LESS,
			[ LessEqualCompare ]: _gl.LEQUAL,
			[ EqualCompare ]: _gl.EQUAL,
			[ GreaterEqualCompare ]: _gl.GEQUAL,
			[ GreaterCompare ]: _gl.GREATER,
			[ NotEqualCompare ]: _gl.NOTEQUAL
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ;

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ;

			}

			if ( texture.compareFunction ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
				_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( texture.magFilter === NearestFilter ) return;
				if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
				if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			let forceUpload = false;

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

			}

			// create Source <-> WebGLTextures mapping if necessary

			const source = texture.source;
			let webglTextures = _sources.get( source );

			if ( webglTextures === undefined ) {

				webglTextures = {};
				_sources.set( source, webglTextures );

			}

			// check if there is already a WebGLTexture object for the given texture parameters

			const textureCacheKey = getTextureCacheKey( texture );

			if ( textureCacheKey !== textureProperties.__cacheKey ) {

				// if not, create a new instance of WebGLTexture

				if ( webglTextures[ textureCacheKey ] === undefined ) {

					// create new entry

					webglTextures[ textureCacheKey ] = {
						texture: _gl.createTexture(),
						usedTimes: 0
					};

					info.memory.textures ++;

					// when a new instance of WebGLTexture was created, a texture upload is required
					// even if the image contents are identical

					forceUpload = true;

				}

				webglTextures[ textureCacheKey ].usedTimes ++;

				// every time the texture cache key changes, it's necessary to check if an instance of
				// WebGLTexture can be deleted in order to avoid a memory leak.

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];

				if ( webglTexture !== undefined ) {

					webglTextures[ textureProperties.__cacheKey ].usedTimes --;

					if ( webglTexture.usedTimes === 0 ) {

						deleteTexture( texture );

					}

				}

				// store references to cache key and WebGLTexture object

				textureProperties.__cacheKey = textureCacheKey;
				textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

			}

			return forceUpload;

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = _gl.TEXTURE_2D;

			if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
			if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

			const sourceProperties = properties.get( source );

			if ( source.version !== sourceProperties.__version || forceUpload === true ) {

				state.activeTexture( _gl.TEXTURE0 + slot );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
				_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

				const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
				let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
				image = verifyColorSpace( texture, image );

				const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.colorSpace );

				let glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

				setTextureParameters( textureType, texture, supportsMips );

				let mipmap;
				const mipmaps = texture.mipmaps;

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
				const levels = getMipLevels( texture, image, supportsMips );

				if ( texture.isDepthTexture ) {

					// populate depth texture with dummy data

					glInternalFormat = _gl.DEPTH_COMPONENT;

					if ( isWebGL2 ) {

						if ( texture.type === FloatType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT32F;

						} else if ( texture.type === UnsignedIntType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT24;

						} else if ( texture.type === UnsignedInt248Type ) {

							glInternalFormat = _gl.DEPTH24_STENCIL8;

						} else {

							glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D

						}

					} else {

						if ( texture.type === FloatType ) ;

					}

					// validation checks for WebGL 1

					if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

							texture.type = UnsignedIntType;
							glType = utils.convert( texture.type );

						}

					}

					if ( texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

						// Depth stencil textures need the DEPTH_STENCIL internal format
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						glInternalFormat = _gl.DEPTH_STENCIL;

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {

							texture.type = UnsignedInt248Type;
							glType = utils.convert( texture.type );

						}

					}

					//

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

						}

					}

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

						}

					}

				} else if ( texture.isCompressedTexture ) {

					if ( texture.isCompressedArrayTexture ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

									} else {

										state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

									}

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

								} else {

									state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					} else {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									} else {

										state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								} else {

									state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else if ( texture.isDataArrayTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isData3DTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isFramebufferTexture ) {

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

						} else {

							let width = image.width, height = image.height;

							for ( let i = 0; i < levels; i ++ ) {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

								width >>= 1;
								height >>= 1;

							}

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( textureType );

				}

				sourceProperties.__version = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

			const sourceProperties = properties.get( source );

			if ( source.version !== sourceProperties.__version || forceUpload === true ) {

				state.activeTexture( _gl.TEXTURE0 + slot );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
				_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

				const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
				const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				const cubeImage = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

					cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

				}

				const image = cubeImage[ 0 ],
					supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.colorSpace ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
				let levels = getMipLevels( texture, image, supportsMips );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

				let mipmaps;

				if ( isCompressed ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						mipmaps = cubeImage[ i ].mipmaps;

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									} else {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else {

					mipmaps = texture.mipmaps;

					if ( useTexStorage && allocateMemory ) {

						// TODO: Uniformly handle mipmap definitions
						// Normal textures and compressed cube textures define base level + mips with their mipmap array
						// Uncompressed cube textures use their mipmap array only for mips (no base level)

						if ( mipmaps.length > 0 ) levels ++;

						state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						if ( isDataTexture ) {

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];
								const mipmapImage = mipmap.image[ i ].image;

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

								}

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

								}

							}

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					// We assume images for cube map have the same size.
					generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				sourceProperties.__version = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

			const glFormat = utils.convert( texture.format, texture.colorSpace );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
			const renderTargetProperties = properties.get( renderTarget );

			if ( ! renderTargetProperties.__hasExternalTextures ) {

				const width = Math.max( 1, renderTarget.width >> level );
				const height = Math.max( 1, renderTarget.height >> level );

				if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

					state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

				} else {

					state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

				}

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

			} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, level );

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}


		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

					const depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT32F;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT24;

						}

					}

					const samples = getRenderTargetSamples( renderTarget );

					if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];

					const glFormat = utils.convert( texture.format, texture.colorSpace );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
					const samples = getRenderTargetSamples( renderTarget );

					if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				}

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
			const samples = getRenderTargetSamples( renderTarget );

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				}

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				}

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// rebind framebuffer with external textures
		function rebindTextures( renderTarget, colorTexture, depthTexture ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( colorTexture !== undefined ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

			}

			if ( depthTexture !== undefined ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

				if ( textureProperties.__webglTexture === undefined ) {

					textureProperties.__webglTexture = _gl.createTexture();

				}

				textureProperties.__version = texture.version;
				info.memory.textures ++;

			}

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0 ) {

						renderTargetProperties.__webglFramebuffer[ i ] = [];

						for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

							renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

						}

					} else {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

					}

				}

			} else {

				if ( isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0 ) {

					renderTargetProperties.__webglFramebuffer = [];

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				}

				if ( isMultipleRenderTargets ) {

					if ( capabilities.drawBuffers ) {

						const textures = renderTarget.texture;

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							const attachmentProperties = properties.get( textures[ i ] );

							if ( attachmentProperties.__webglTexture === undefined ) {

								attachmentProperties.__webglTexture = _gl.createTexture();

								info.memory.textures ++;

							}

						}

					}

				}

				if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

					const textures = isMultipleRenderTargets ? texture : [ texture ];

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = [];

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const glFormat = utils.convert( texture.format, texture.colorSpace );
						const glType = utils.convert( texture.type );
						const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
						const samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( _gl.FRAMEBUFFER, null );

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

				for ( let i = 0; i < 6; i ++ ) {

					if ( isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0 ) {

						for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

							setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

						}

					} else {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				state.unbindTexture();

			} else if ( isMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachment = textures[ i ];
					const attachmentProperties = properties.get( attachment );

					state.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, attachment, supportsMips );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );

					if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

						generateMipmap( _gl.TEXTURE_2D );

					}

				}

				state.unbindTexture();

			} else {

				let glTextureType = _gl.TEXTURE_2D;

				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

					if ( isWebGL2 ) {

						glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

					}

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture, supportsMips );

				if ( isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0 ) {

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

					}

				} else {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( glTextureType );

				}

				state.unbindTexture();

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const texture = textures[ i ];

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					const webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					generateMipmap( target );
					state.unbindTexture();

				}

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const invalidationArray = [];
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get( renderTarget );
				const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );

				// If MRT we need to remove FBO attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					invalidationArray.push( _gl.COLOR_ATTACHMENT0 + i );

					if ( renderTarget.depthBuffer ) {

						invalidationArray.push( depthStyle );

					}

					const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

					if ( ignoreDepthValues === false ) {

						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;
						if ( renderTarget.stencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					}

					if ( isMultipleRenderTargets ) {

						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					if ( ignoreDepthValues === true ) {

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, [ depthStyle ] );
						_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

					}

					if ( isMultipleRenderTargets ) {

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

					}

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					if ( supportsInvalidateFramebuffer ) {

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArray );

					}


				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

					}

				}

				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return Math.min( maxSamples, renderTarget.samples );

		}

		function useMultisampledRTT( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		function verifyColorSpace( texture, image ) {

			const colorSpace = texture.colorSpace;
			const format = texture.format;
			texture.type;

			if ( texture.isCompressedTexture === true || texture.format === _SRGBAFormat ) return image;

			if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

				// sRGB

				if ( colorSpace === SRGBColorSpace ) {

					if ( isWebGL2 === false ) {

						// in WebGL 1, try to use EXT_sRGB extension and unsized formats

						if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

							texture.format = _SRGBAFormat;

							// it's not possible to generate mips in WebGL 1 with this extension

							texture.minFilter = LinearFilter;
							texture.generateMipmaps = false;

						} else {

							// slow fallback (CPU decode)

							image = ImageUtils.sRGBToLinear( image );

						}

					}

				}

			}

			return image;

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.useMultisampledRTT = useMultisampledRTT;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function convert( p, colorSpace = NoColorSpace ) {

			let extension;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return gl.HALF_FLOAT;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			// WebGL 1 sRGB fallback

			if ( p === _SRGBAFormat ) {

				extension = extensions.get( 'EXT_sRGB' );

				if ( extension !== null ) {

					return extension.SRGB_ALPHA_EXT;

				} else {

					return null;

				}

			}

			// WebGL2 formats.

			if ( p === RedFormat ) return gl.RED;
			if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
			if ( p === RGFormat ) return gl.RG;
			if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
			if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

			// S3TC

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				if ( colorSpace === SRGBColorSpace ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				} else {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				}

			}

			// PVRTC

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			// ETC1

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			// ETC2

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

				} else {

					return null;

				}

			}

			// ASTC

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					if ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

				} else {

					return null;

				}

			}

			// BPTC

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

				} else {

					return null;

				}

			}

			// RGTC

			if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

				extension = extensions.get( 'EXT_texture_compression_rgtc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
					if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

				} else {

					return null;

				}

			}

			//

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return gl.UNSIGNED_INT_24_8;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

			// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

			return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

		}

		return { convert: convert };

	}

	class ArrayCamera extends PerspectiveCamera {

		constructor( array = [] ) {

			super();

			this.isArrayCamera = true;

			this.cameras = array;

		}

	}

	class Group extends Object3D {

		constructor() {

			super();

			this.isGroup = true;

			this.type = 'Group';

		}

	}

	const _moveEvent = { type: 'move' };

	class WebXRController {

		constructor() {

			this._targetRay = null;
			this._grip = null;
			this._hand = null;

		}

		getHandSpace() {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		}

		getTargetRaySpace() {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();

			}

			return this._targetRay;

		}

		getGripSpace() {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();

			}

			return this._grip;

		}

		dispatchEvent( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		}

		connect( inputSource ) {

			if ( inputSource && inputSource.hand ) {

				const hand = this._hand;

				if ( hand ) {

					for ( const inputjoint of inputSource.hand.values() ) {

						// Initialize hand with joints when connected
						this._getHandJoint( hand, inputjoint );

					}

				}

			}

			this.dispatchEvent( { type: 'connected', data: inputSource } );

			return this;

		}

		disconnect( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		}

		update( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( const inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputjoint, referenceSpace );

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = this._getHandJoint( hand, inputjoint );

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.matrixWorldNeedsUpdate = true;
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints[ 'index-finger-tip' ];
					const thumbTip = hand.joints[ 'thumb-tip' ];
					const distance = indexTip.position.distanceTo( thumbTip.position );

					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
							grip.matrixWorldNeedsUpdate = true;

							if ( gripPose.linearVelocity ) {

								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy( gripPose.linearVelocity );

							} else {

								grip.hasLinearVelocity = false;

							}

							if ( gripPose.angularVelocity ) {

								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy( gripPose.angularVelocity );

							} else {

								grip.hasAngularVelocity = false;

							}

						}

					}

				}

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
					if ( inputPose === null && gripPose !== null ) {

						inputPose = gripPose;

					}

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
						targetRay.matrixWorldNeedsUpdate = true;

						if ( inputPose.linearVelocity ) {

							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy( inputPose.linearVelocity );

						} else {

							targetRay.hasLinearVelocity = false;

						}

						if ( inputPose.angularVelocity ) {

							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy( inputPose.angularVelocity );

						} else {

							targetRay.hasAngularVelocity = false;

						}

						this.dispatchEvent( _moveEvent );

					}

				}


			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

		// private method

		_getHandJoint( hand, inputjoint ) {

			if ( hand.joints[ inputjoint.jointName ] === undefined ) {

				const joint = new Group();
				joint.matrixAutoUpdate = false;
				joint.visible = false;
				hand.joints[ inputjoint.jointName ] = joint;

				hand.add( joint );

			}

			return hand.joints[ inputjoint.jointName ];

		}

	}

	class DepthTexture extends Texture {

		constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

			}

			if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isDepthTexture = true;

			this.image = { width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps = false;

			this.compareFunction = null;

		}


		copy( source ) {

			super.copy( source );

			this.compareFunction = source.compareFunction;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

			return data;

		}

	}

	class WebXRManager extends EventDispatcher {

		constructor( renderer, gl ) {

			super();

			const scope = this;

			let session = null;

			let framebufferScaleFactor = 1.0;

			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			// Set default foveation to maximum.
			let foveation = 1.0;
			let customReferenceSpace = null;

			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let xrFrame = null;
			const attributes = gl.getContextAttributes();
			let initialRenderTarget = null;
			let newRenderTarget = null;

			const controllers = [];
			const controllerInputSources = [];

			//

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable( 1 );
			cameraL.viewport = new Vector4();

			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable( 2 );
			cameraR.viewport = new Vector4();

			const cameras = [ cameraL, cameraR ];

			const cameraXR = new ArrayCamera();
			cameraXR.layers.enable( 1 );
			cameraXR.layers.enable( 2 );

			let _currentDepthNear = null;
			let _currentDepthFar = null;

			//

			this.cameraAutoUpdate = true;
			this.enabled = false;

			this.isPresenting = false;

			this.getController = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getTargetRaySpace();

			};

			this.getControllerGrip = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getGripSpace();

			};

			this.getHand = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getHandSpace();

			};

			//

			function onSessionEvent( event ) {

				const controllerIndex = controllerInputSources.indexOf( event.inputSource );

				if ( controllerIndex === - 1 ) {

					return;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller !== undefined ) {

					controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
					controller.dispatchEvent( { type: event.type, data: event.inputSource } );

				}

			}

			function onSessionEnd() {

				session.removeEventListener( 'select', onSessionEvent );
				session.removeEventListener( 'selectstart', onSessionEvent );
				session.removeEventListener( 'selectend', onSessionEvent );
				session.removeEventListener( 'squeeze', onSessionEvent );
				session.removeEventListener( 'squeezestart', onSessionEvent );
				session.removeEventListener( 'squeezeend', onSessionEvent );
				session.removeEventListener( 'end', onSessionEnd );
				session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];

					if ( inputSource === null ) continue;

					controllerInputSources[ i ] = null;

					controllers[ i ].disconnect( inputSource );

				}

				_currentDepthNear = null;
				_currentDepthFar = null;

				// restore framebuffer/rendering state

				renderer.setRenderTarget( initialRenderTarget );

				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null;

				//

				animation.stop();

				scope.isPresenting = false;

				scope.dispatchEvent( { type: 'sessionend' } );

			}

			this.setFramebufferScaleFactor = function ( value ) {

				framebufferScaleFactor = value;

				if ( scope.isPresenting === true ) ;

			};

			this.setReferenceSpaceType = function ( value ) {

				referenceSpaceType = value;

				if ( scope.isPresenting === true ) ;

			};

			this.getReferenceSpace = function () {

				return customReferenceSpace || referenceSpace;

			};

			this.setReferenceSpace = function ( space ) {

				customReferenceSpace = space;

			};

			this.getBaseLayer = function () {

				return glProjLayer !== null ? glProjLayer : glBaseLayer;

			};

			this.getBinding = function () {

				return glBinding;

			};

			this.getFrame = function () {

				return xrFrame;

			};

			this.getSession = function () {

				return session;

			};

			this.setSession = async function ( value ) {

				session = value;

				if ( session !== null ) {

					initialRenderTarget = renderer.getRenderTarget();

					session.addEventListener( 'select', onSessionEvent );
					session.addEventListener( 'selectstart', onSessionEvent );
					session.addEventListener( 'selectend', onSessionEvent );
					session.addEventListener( 'squeeze', onSessionEvent );
					session.addEventListener( 'squeezestart', onSessionEvent );
					session.addEventListener( 'squeezeend', onSessionEvent );
					session.addEventListener( 'end', onSessionEnd );
					session.addEventListener( 'inputsourceschange', onInputSourcesChange );

					if ( attributes.xrCompatible !== true ) {

						await gl.makeXRCompatible();

					}

					if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

						const layerInit = {
							antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
							alpha: true,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};

						glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

						session.updateRenderState( { baseLayer: glBaseLayer } );

						newRenderTarget = new WebGLRenderTarget(
							glBaseLayer.framebufferWidth,
							glBaseLayer.framebufferHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								colorSpace: renderer.outputColorSpace,
								stencilBuffer: attributes.stencil
							}
						);

					} else {

						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;

						if ( attributes.depth ) {

							glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

						}

						const projectionlayerInit = {
							colorFormat: gl.RGBA8,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};

						glBinding = new XRWebGLBinding( session, gl );

						glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

						session.updateRenderState( { layers: [ glProjLayer ] } );

						newRenderTarget = new WebGLRenderTarget(
							glProjLayer.textureWidth,
							glProjLayer.textureHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
								stencilBuffer: attributes.stencil,
								colorSpace: renderer.outputColorSpace,
								samples: attributes.antialias ? 4 : 0
							} );

						const renderTargetProperties = renderer.properties.get( newRenderTarget );
						renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

					}

					newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

					this.setFoveation( foveation );

					customReferenceSpace = null;
					referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

					animation.setContext( session );
					animation.start();

					scope.isPresenting = true;

					scope.dispatchEvent( { type: 'sessionstart' } );

				}

			};

			this.getEnvironmentBlendMode = function () {

				if ( session !== null ) {

					return session.environmentBlendMode;

				}

			};

			function onInputSourcesChange( event ) {

				// Notify disconnected

				for ( let i = 0; i < event.removed.length; i ++ ) {

					const inputSource = event.removed[ i ];
					const index = controllerInputSources.indexOf( inputSource );

					if ( index >= 0 ) {

						controllerInputSources[ index ] = null;
						controllers[ index ].disconnect( inputSource );

					}

				}

				// Notify connected

				for ( let i = 0; i < event.added.length; i ++ ) {

					const inputSource = event.added[ i ];

					let controllerIndex = controllerInputSources.indexOf( inputSource );

					if ( controllerIndex === - 1 ) {

						// Assign input source a controller that currently has no input source

						for ( let i = 0; i < controllers.length; i ++ ) {

							if ( i >= controllerInputSources.length ) {

								controllerInputSources.push( inputSource );
								controllerIndex = i;
								break;

							} else if ( controllerInputSources[ i ] === null ) {

								controllerInputSources[ i ] = inputSource;
								controllerIndex = i;
								break;

							}

						}

						// If all controllers do currently receive input we ignore new ones

						if ( controllerIndex === - 1 ) break;

					}

					const controller = controllers[ controllerIndex ];

					if ( controller ) {

						controller.connect( inputSource );

					}

				}

			}

			//

			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion( camera, cameraL, cameraR ) {

				cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
				cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

				const ipd = cameraLPos.distanceTo( cameraRPos );

				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements;

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
				const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
				const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
				const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

				const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
				const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
				const left = near * leftFov;
				const right = near * rightFov;

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / ( - leftFov + rightFov );
				const xOffset = zOffset * - leftFov;

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
				camera.translateX( xOffset );
				camera.translateZ( zOffset );
				camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + ( ipd - xOffset );
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;

				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
				camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

			}

			function updateCamera( camera, parent ) {

				if ( parent === null ) {

					camera.matrixWorld.copy( camera.matrix );

				} else {

					camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

				}

				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			}

			this.updateCamera = function ( camera ) {

				if ( session === null ) return;

				cameraXR.near = cameraR.near = cameraL.near = camera.near;
				cameraXR.far = cameraR.far = cameraL.far = camera.far;

				if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState( {
						depthNear: cameraXR.near,
						depthFar: cameraXR.far
					} );

					_currentDepthNear = cameraXR.near;
					_currentDepthFar = cameraXR.far;

				}

				const parent = camera.parent;
				const cameras = cameraXR.cameras;

				updateCamera( cameraXR, parent );

				for ( let i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update projection matrix for proper view frustum culling

				if ( cameras.length === 2 ) {

					setProjectionFromUnion( cameraXR, cameraL, cameraR );

				} else {

					// assume single camera setup (AR)

					cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

				}

				// update user camera and its children

				updateUserCamera( camera, cameraXR, parent );

			};

			function updateUserCamera( camera, cameraXR, parent ) {

				if ( parent === null ) {

					camera.matrix.copy( cameraXR.matrixWorld );

				} else {

					camera.matrix.copy( parent.matrixWorld );
					camera.matrix.invert();
					camera.matrix.multiply( cameraXR.matrixWorld );

				}

				camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
				camera.updateMatrixWorld( true );

				const children = camera.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				camera.projectionMatrix.copy( cameraXR.projectionMatrix );
				camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

				if ( camera.isPerspectiveCamera ) {

					camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
					camera.zoom = 1;

				}

			}

			this.getCamera = function () {

				return cameraXR;

			};

			this.getFoveation = function () {

				if ( glProjLayer === null && glBaseLayer === null ) {

					return undefined;

				}

				return foveation;

			};

			this.setFoveation = function ( value ) {

				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				foveation = value;

				if ( glProjLayer !== null ) {

					glProjLayer.fixedFoveation = value;

				}

				if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

					glBaseLayer.fixedFoveation = value;

				}

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time, frame ) {

				pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
				xrFrame = frame;

				if ( pose !== null ) {

					const views = pose.views;

					if ( glBaseLayer !== null ) {

						renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
						renderer.setRenderTarget( newRenderTarget );

					}

					let cameraXRNeedsUpdate = false;

					// check if it's necessary to rebuild cameraXR's camera list

					if ( views.length !== cameraXR.cameras.length ) {

						cameraXR.cameras.length = 0;
						cameraXRNeedsUpdate = true;

					}

					for ( let i = 0; i < views.length; i ++ ) {

						const view = views[ i ];

						let viewport = null;

						if ( glBaseLayer !== null ) {

							viewport = glBaseLayer.getViewport( view );

						} else {

							const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
							viewport = glSubImage.viewport;

							// For side-by-side projection, we only produce a single texture for both eyes.
							if ( i === 0 ) {

								renderer.setRenderTargetTextures(
									newRenderTarget,
									glSubImage.colorTexture,
									glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

								renderer.setRenderTarget( newRenderTarget );

							}

						}

						let camera = cameras[ i ];

						if ( camera === undefined ) {

							camera = new PerspectiveCamera();
							camera.layers.enable( i );
							camera.viewport = new Vector4();
							cameras[ i ] = camera;

						}

						camera.matrix.fromArray( view.transform.matrix );
						camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
						camera.projectionMatrix.fromArray( view.projectionMatrix );
						camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
						camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

						if ( i === 0 ) {

							cameraXR.matrix.copy( camera.matrix );
							cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

						}

						if ( cameraXRNeedsUpdate === true ) {

							cameraXR.cameras.push( camera );

						}

					}

				}

				//

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];
					const controller = controllers[ i ];

					if ( inputSource !== null && controller !== undefined ) {

						controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

					}

				}

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

				if ( frame.detectedPlanes ) {

					scope.dispatchEvent( { type: 'planesdetected', data: frame } );

				}

				xrFrame = null;

			}

			const animation = new WebGLAnimation();

			animation.setAnimationLoop( onAnimationFrame );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;

			};

			this.dispose = function () {};

		}

	}

	function WebGLMaterials( renderer, properties ) {

		function refreshTransformUniform( map, uniform ) {

			if ( map.matrixAutoUpdate === true ) {

				map.updateMatrix();

			}

			uniform.value.copy( map.matrix );

		}

		function refreshFogUniforms( uniforms, fog ) {

			fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsStandard( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;

				refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

				uniforms.bumpScale.value = material.bumpScale;

				if ( material.side === BackSide ) {

					uniforms.bumpScale.value *= - 1;

				}

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;

				refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

				uniforms.normalScale.value.copy( material.normalScale );

				if ( material.side === BackSide ) {

					uniforms.normalScale.value.negate();

				}

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;

				refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

				refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

				refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;

				// artist-friendly light intensity scaling factor
				const scaleFactor = ( renderer._useLegacyLights === true ) ? Math.PI : 1;

				uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

				refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

				refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.uvTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.metalness.value = material.metalness;

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

				refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

			}

			uniforms.roughness.value = material.roughness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

				refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

			uniforms.ior.value = material.ior; // also part of uniforms common

			if ( material.sheen > 0 ) {

				uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

				uniforms.sheenRoughness.value = material.sheenRoughness;

				if ( material.sheenColorMap ) {

					uniforms.sheenColorMap.value = material.sheenColorMap;

					refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

				}

				if ( material.sheenRoughnessMap ) {

					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

					refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

				}

			}

			if ( material.clearcoat > 0 ) {

				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if ( material.clearcoatMap ) {

					uniforms.clearcoatMap.value = material.clearcoatMap;

					refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

				}

				if ( material.clearcoatRoughnessMap ) {

					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

					refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

				}

				if ( material.clearcoatNormalMap ) {

					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

					uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

					if ( material.side === BackSide ) {

						uniforms.clearcoatNormalScale.value.negate();

					}

				}

			}

			if ( material.iridescence > 0 ) {

				uniforms.iridescence.value = material.iridescence;
				uniforms.iridescenceIOR.value = material.iridescenceIOR;
				uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
				uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

				if ( material.iridescenceMap ) {

					uniforms.iridescenceMap.value = material.iridescenceMap;

					refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

				}

				if ( material.iridescenceThicknessMap ) {

					uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

					refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

				}

			}

			if ( material.transmission > 0 ) {

				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

				if ( material.transmissionMap ) {

					uniforms.transmissionMap.value = material.transmissionMap;

					refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

				}

				uniforms.thickness.value = material.thickness;

				if ( material.thicknessMap ) {

					uniforms.thicknessMap.value = material.thicknessMap;

					refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy( material.attenuationColor );

			}

			if ( material.anisotropy > 0 ) {

				uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

				if ( material.anisotropyMap ) {

					uniforms.anisotropyMap.value = material.anisotropyMap;

					refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

				}

			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy( material.specularColor );

			if ( material.specularColorMap ) {

				uniforms.specularColorMap.value = material.specularColorMap;

				refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

			}

			if ( material.specularIntensityMap ) {

				uniforms.specularIntensityMap.value = material.specularIntensityMap;

				refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			const light = properties.get( material ).light;

			uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
			uniforms.nearDistance.value = light.shadow.camera.near;
			uniforms.farDistance.value = light.shadow.camera.far;

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function WebGLUniformsGroups( gl, info, capabilities, state ) {

		let buffers = {};
		let updateList = {};
		let allocatedBindingPoints = [];

		const maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ) : 0; // binding points are global whereas block indices are per shader program

		function bind( uniformsGroup, program ) {

			const webglProgram = program.program;
			state.uniformBlockBinding( uniformsGroup, webglProgram );

		}

		function update( uniformsGroup, program ) {

			let buffer = buffers[ uniformsGroup.id ];

			if ( buffer === undefined ) {

				prepareUniformsGroup( uniformsGroup );

				buffer = createBuffer( uniformsGroup );
				buffers[ uniformsGroup.id ] = buffer;

				uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

			}

			// ensure to update the binding points/block indices mapping for this program

			const webglProgram = program.program;
			state.updateUBOMapping( uniformsGroup, webglProgram );

			// update UBO once per frame

			const frame = info.render.frame;

			if ( updateList[ uniformsGroup.id ] !== frame ) {

				updateBufferData( uniformsGroup );

				updateList[ uniformsGroup.id ] = frame;

			}

		}

		function createBuffer( uniformsGroup ) {

			// the setup of an UBO is independent of a particular shader program but global

			const bindingPointIndex = allocateBindingPointIndex();
			uniformsGroup.__bindingPointIndex = bindingPointIndex;

			const buffer = gl.createBuffer();
			const size = uniformsGroup.__size;
			const usage = uniformsGroup.usage;

			gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
			gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
			gl.bindBuffer( gl.UNIFORM_BUFFER, null );
			gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

			return buffer;

		}

		function allocateBindingPointIndex() {

			for ( let i = 0; i < maxBindingPoints; i ++ ) {

				if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

					allocatedBindingPoints.push( i );
					return i;

				}

			}

			return 0;

		}

		function updateBufferData( uniformsGroup ) {

			const buffer = buffers[ uniformsGroup.id ];
			const uniforms = uniformsGroup.uniforms;
			const cache = uniformsGroup.__cache;

			gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

			for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

				const uniform = uniforms[ i ];

				// partly update the buffer if necessary

				if ( hasUniformChanged( uniform, i, cache ) === true ) {

					const offset = uniform.__offset;

					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

					let arrayOffset = 0;

					for ( let i = 0; i < values.length; i ++ ) {

						const value = values[ i ];

						const info = getUniformSize( value );

						if ( typeof value === 'number' ) {

							uniform.__data[ 0 ] = value;
							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

						} else if ( value.isMatrix3 ) {

							// manually converting 3x3 to 3x4

							uniform.__data[ 0 ] = value.elements[ 0 ];
							uniform.__data[ 1 ] = value.elements[ 1 ];
							uniform.__data[ 2 ] = value.elements[ 2 ];
							uniform.__data[ 3 ] = value.elements[ 0 ];
							uniform.__data[ 4 ] = value.elements[ 3 ];
							uniform.__data[ 5 ] = value.elements[ 4 ];
							uniform.__data[ 6 ] = value.elements[ 5 ];
							uniform.__data[ 7 ] = value.elements[ 0 ];
							uniform.__data[ 8 ] = value.elements[ 6 ];
							uniform.__data[ 9 ] = value.elements[ 7 ];
							uniform.__data[ 10 ] = value.elements[ 8 ];
							uniform.__data[ 11 ] = value.elements[ 0 ];

						} else {

							value.toArray( uniform.__data, arrayOffset );

							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

						}

					}

					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

				}

			}

			gl.bindBuffer( gl.UNIFORM_BUFFER, null );

		}

		function hasUniformChanged( uniform, index, cache ) {

			const value = uniform.value;

			if ( cache[ index ] === undefined ) {

				// cache entry does not exist so far

				if ( typeof value === 'number' ) {

					cache[ index ] = value;

				} else {

					const values = Array.isArray( value ) ? value : [ value ];

					const tempValues = [];

					for ( let i = 0; i < values.length; i ++ ) {

						tempValues.push( values[ i ].clone() );

					}

					cache[ index ] = tempValues;

				}

				return true;

			} else {

				// compare current value with cached entry

				if ( typeof value === 'number' ) {

					if ( cache[ index ] !== value ) {

						cache[ index ] = value;
						return true;

					}

				} else {

					const cachedObjects = Array.isArray( cache[ index ] ) ? cache[ index ] : [ cache[ index ] ];
					const values = Array.isArray( value ) ? value : [ value ];

					for ( let i = 0; i < cachedObjects.length; i ++ ) {

						const cachedObject = cachedObjects[ i ];

						if ( cachedObject.equals( values[ i ] ) === false ) {

							cachedObject.copy( values[ i ] );
							return true;

						}

					}

				}

			}

			return false;

		}

		function prepareUniformsGroup( uniformsGroup ) {

			// determine total buffer size according to the STD140 layout
			// Hint: STD140 is the only supported layout in WebGL 2

			const uniforms = uniformsGroup.uniforms;

			let offset = 0; // global buffer offset in bytes
			const chunkSize = 16; // size of a chunk in bytes
			let chunkOffset = 0; // offset within a single chunk in bytes

			for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

				const uniform = uniforms[ i ];

				const infos = {
					boundary: 0, // bytes
					storage: 0 // bytes
				};

				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

				for ( let j = 0, jl = values.length; j < jl; j ++ ) {

					const value = values[ j ];

					const info = getUniformSize( value );

					infos.boundary += info.boundary;
					infos.storage += info.storage;

				}

				// the following two properties will be used for partial buffer updates

				uniform.__data = new Float32Array( infos.storage / Float32Array.BYTES_PER_ELEMENT );
				uniform.__offset = offset;

				//

				if ( i > 0 ) {

					chunkOffset = offset % chunkSize;

					const remainingSizeInChunk = chunkSize - chunkOffset;

					// check for chunk overflow

					if ( chunkOffset !== 0 && ( remainingSizeInChunk - infos.boundary ) < 0 ) {

						// add padding and adjust offset

						offset += ( chunkSize - chunkOffset );
						uniform.__offset = offset;

					}

				}

				offset += infos.storage;

			}

			// ensure correct final padding

			chunkOffset = offset % chunkSize;

			if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

			//

			uniformsGroup.__size = offset;
			uniformsGroup.__cache = {};

			return this;

		}

		function getUniformSize( value ) {

			const info = {
				boundary: 0, // bytes
				storage: 0 // bytes
			};

			// determine sizes according to STD140

			if ( typeof value === 'number' ) {

				// float/int

				info.boundary = 4;
				info.storage = 4;

			} else if ( value.isVector2 ) {

				// vec2

				info.boundary = 8;
				info.storage = 8;

			} else if ( value.isVector3 || value.isColor ) {

				// vec3

				info.boundary = 16;
				info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

			} else if ( value.isVector4 ) {

				// vec4

				info.boundary = 16;
				info.storage = 16;

			} else if ( value.isMatrix3 ) {

				// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

				info.boundary = 48;
				info.storage = 48;

			} else if ( value.isMatrix4 ) {

				// mat4

				info.boundary = 64;
				info.storage = 64;

			} else if ( value.isTexture ) ; else ;

			return info;

		}

		function onUniformsGroupsDispose( event ) {

			const uniformsGroup = event.target;

			uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

			const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
			allocatedBindingPoints.splice( index, 1 );

			gl.deleteBuffer( buffers[ uniformsGroup.id ] );

			delete buffers[ uniformsGroup.id ];
			delete updateList[ uniformsGroup.id ];

		}

		function dispose() {

			for ( const id in buffers ) {

				gl.deleteBuffer( buffers[ id ] );

			}

			allocatedBindingPoints = [];
			buffers = {};
			updateList = {};

		}

		return {

			bind: bind,
			update: update,

			dispose: dispose

		};

	}

	function createCanvasElement() {

		const canvas = createElementNS( 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	class WebGLRenderer {

		constructor( parameters = {} ) {

			const {
				canvas = createCanvasElement(),
				context = null,
				depth = true,
				stencil = true,
				alpha = false,
				antialias = false,
				premultipliedAlpha = true,
				preserveDrawingBuffer = false,
				powerPreference = 'default',
				failIfMajorPerformanceCaveat = false,
			} = parameters;

			this.isWebGLRenderer = true;

			let _alpha;

			if ( context !== null ) {

				_alpha = context.getContextAttributes().alpha;

			} else {

				_alpha = alpha;

			}

			const uintClearColor = new Uint32Array( 4 );
			const intClearColor = new Int32Array( 4 );

			let currentRenderList = null;
			let currentRenderState = null;

			// render() can be called from within a callback triggered by another render.
			// We track this so that the nested render call gets its list and state isolated from the parent render call.

			const renderListStack = [];
			const renderStateStack = [];

			// public properties

			this.domElement = canvas;

			// Debug configuration container
			this.debug = {

				/**
				 * Enables error checking and reporting when shader programs are being compiled
				 * @type {boolean}
				 */
				checkShaderErrors: true,
				/**
				 * Callback for custom error reporting.
				 * @type {?Function}
				 */
				onShaderError: null
			};

			// clearing

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			// scene graph

			this.sortObjects = true;

			// user-defined clipping

			this.clippingPlanes = [];
			this.localClippingEnabled = false;

			// physically based shading

			this.outputColorSpace = SRGBColorSpace;

			// physical lights

			this._useLegacyLights = false;

			// tone mapping

			this.toneMapping = NoToneMapping;
			this.toneMappingExposure = 1.0;

			// internal properties

			const _this = this;

			let _isContextLost = false;

			// internal state cache

			let _currentActiveCubeFace = 0;
			let _currentActiveMipmapLevel = 0;
			let _currentRenderTarget = null;
			let _currentMaterialId = - 1;

			let _currentCamera = null;

			const _currentViewport = new Vector4();
			const _currentScissor = new Vector4();
			let _currentScissorTest = null;

			const _currentClearColor = new Color( 0x000000 );
			let _currentClearAlpha = 0;

			//

			let _width = canvas.width;
			let _height = canvas.height;

			let _pixelRatio = 1;
			let _opaqueSort = null;
			let _transparentSort = null;

			const _viewport = new Vector4( 0, 0, _width, _height );
			const _scissor = new Vector4( 0, 0, _width, _height );
			let _scissorTest = false;

			// frustum

			const _frustum = new Frustum();

			// clipping

			let _clippingEnabled = false;
			let _localClippingEnabled = false;

			// transmission

			let _transmissionRenderTarget = null;

			// camera matrices cache

			const _projScreenMatrix = new Matrix4();

			const _vector2 = new Vector2();
			const _vector3 = new Vector3();

			const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			// initialize

			let _gl = context;

			function getContext( contextNames, contextAttributes ) {

				for ( let i = 0; i < contextNames.length; i ++ ) {

					const contextName = contextNames[ i ];
					const context = canvas.getContext( contextName, contextAttributes );
					if ( context !== null ) return context;

				}

				return null;

			}

			try {

				const contextAttributes = {
					alpha: true,
					depth,
					stencil,
					antialias,
					premultipliedAlpha,
					preserveDrawingBuffer,
					powerPreference,
					failIfMajorPerformanceCaveat,
				};

				// OffscreenCanvas does not have setAttribute, see #22811
				if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

				// event listeners must be registered before WebGL context is created, see #12753
				canvas.addEventListener( 'webglcontextlost', onContextLost, false );
				canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
				canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

				if ( _gl === null ) {

					const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

					if ( _this.isWebGL1Renderer === true ) {

						contextNames.shift();

					}

					_gl = getContext( contextNames, contextAttributes );

					if ( _gl === null ) {

						if ( getContext( contextNames ) ) {

							throw new Error( 'Error creating WebGL context with your selected attributes.' );

						} else {

							throw new Error( 'Error creating WebGL context.' );

						}

					}

				}

				if ( typeof WebGLRenderingContext !== 'undefined' && _gl instanceof WebGLRenderingContext ) { // @deprecated, r153

				}

				// Some experimental-webgl implementations do not have getShaderPrecisionFormat

				if ( _gl.getShaderPrecisionFormat === undefined ) {

					_gl.getShaderPrecisionFormat = function () {

						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

					};

				}

			} catch ( error ) {
				throw error;

			}

			let extensions, capabilities, state, info;
			let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
			let programCache, materials, renderLists, renderStates, clipping, shadowMap;

			let background, morphtargets, bufferRenderer, indexedBufferRenderer;

			let utils, bindingStates, uniformsGroups;

			function initGLContext() {

				extensions = new WebGLExtensions( _gl );

				capabilities = new WebGLCapabilities( _gl, extensions, parameters );

				extensions.init( capabilities );

				utils = new WebGLUtils( _gl, extensions, capabilities );

				state = new WebGLState( _gl, extensions, capabilities );

				info = new WebGLInfo( _gl );
				properties = new WebGLProperties();
				textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
				cubemaps = new WebGLCubeMaps( _this );
				cubeuvmaps = new WebGLCubeUVMaps( _this );
				attributes = new WebGLAttributes( _gl, capabilities );
				bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
				geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
				objects = new WebGLObjects( _gl, geometries, attributes, info );
				morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
				clipping = new WebGLClipping( properties );
				programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
				materials = new WebGLMaterials( _this, properties );
				renderLists = new WebGLRenderLists();
				renderStates = new WebGLRenderStates( extensions, capabilities );
				background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
				shadowMap = new WebGLShadowMap( _this, objects, capabilities );
				uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

				bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
				indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

				info.programs = programCache.programs;

				_this.capabilities = capabilities;
				_this.extensions = extensions;
				_this.properties = properties;
				_this.renderLists = renderLists;
				_this.shadowMap = shadowMap;
				_this.state = state;
				_this.info = info;

			}

			initGLContext();

			// xr

			const xr = new WebXRManager( _this, _gl );

			this.xr = xr;

			// API

			this.getContext = function () {

				return _gl;

			};

			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			this.forceContextLoss = function () {

				const extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.loseContext();

			};

			this.forceContextRestore = function () {

				const extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.restoreContext();

			};

			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) return;

				_pixelRatio = value;

				this.setSize( _width, _height, false );

			};

			this.getSize = function ( target ) {

				return target.set( _width, _height );

			};

			this.setSize = function ( width, height, updateStyle = true ) {

				if ( xr.isPresenting ) {
					return;

				}

				_width = width;
				_height = height;

				canvas.width = Math.floor( width * _pixelRatio );
				canvas.height = Math.floor( height * _pixelRatio );

				if ( updateStyle === true ) {

					canvas.style.width = width + 'px';
					canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			this.getDrawingBufferSize = function ( target ) {

				return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

			};

			this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

				_width = width;
				_height = height;

				_pixelRatio = pixelRatio;

				canvas.width = Math.floor( width * pixelRatio );
				canvas.height = Math.floor( height * pixelRatio );

				this.setViewport( 0, 0, width, height );

			};

			this.getCurrentViewport = function ( target ) {

				return target.copy( _currentViewport );

			};

			this.getViewport = function ( target ) {

				return target.copy( _viewport );

			};

			this.setViewport = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_viewport.set( x.x, x.y, x.z, x.w );

				} else {

					_viewport.set( x, y, width, height );

				}

				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

			};

			this.getScissor = function ( target ) {

				return target.copy( _scissor );

			};

			this.setScissor = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_scissor.set( x.x, x.y, x.z, x.w );

				} else {

					_scissor.set( x, y, width, height );

				}

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

			};

			this.getScissorTest = function () {

				return _scissorTest;

			};

			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			this.setOpaqueSort = function ( method ) {

				_opaqueSort = method;

			};

			this.setTransparentSort = function ( method ) {

				_transparentSort = method;

			};

			// Clearing

			this.getClearColor = function ( target ) {

				return target.copy( background.getClearColor() );

			};

			this.setClearColor = function () {

				background.setClearColor.apply( background, arguments );

			};

			this.getClearAlpha = function () {

				return background.getClearAlpha();

			};

			this.setClearAlpha = function () {

				background.setClearAlpha.apply( background, arguments );

			};

			this.clear = function ( color = true, depth = true, stencil = true ) {

				let bits = 0;

				if ( color ) {

					// check if we're trying to clear an integer target
					let isIntegerFormat = false;
					if ( _currentRenderTarget !== null ) {

						const targetFormat = _currentRenderTarget.texture.format;
						isIntegerFormat = targetFormat === RGBAIntegerFormat ||
							targetFormat === RGIntegerFormat ||
							targetFormat === RedIntegerFormat;

					}

					// use the appropriate clear functions to clear the target if it's a signed
					// or unsigned integer target
					if ( isIntegerFormat ) {

						const targetType = _currentRenderTarget.texture.type;
						const isUnsignedType = targetType === UnsignedByteType ||
							targetType === UnsignedIntType ||
							targetType === UnsignedShortType ||
							targetType === UnsignedInt248Type ||
							targetType === UnsignedShort4444Type ||
							targetType === UnsignedShort5551Type;

						const clearColor = background.getClearColor();
						const a = background.getClearAlpha();
						const r = clearColor.r;
						const g = clearColor.g;
						const b = clearColor.b;

						if ( isUnsignedType ) {

							uintClearColor[ 0 ] = r;
							uintClearColor[ 1 ] = g;
							uintClearColor[ 2 ] = b;
							uintClearColor[ 3 ] = a;
							_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

						} else {

							intClearColor[ 0 ] = r;
							intClearColor[ 1 ] = g;
							intClearColor[ 2 ] = b;
							intClearColor[ 3 ] = a;
							_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

						}

					} else {

						bits |= _gl.COLOR_BUFFER_BIT;

					}

				}

				if ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

				_gl.clear( bits );

			};

			this.clearColor = function () {

				this.clear( true, false, false );

			};

			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			//

			this.dispose = function () {

				canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
				canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
				canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

				renderLists.dispose();
				renderStates.dispose();
				properties.dispose();
				cubemaps.dispose();
				cubeuvmaps.dispose();
				objects.dispose();
				bindingStates.dispose();
				uniformsGroups.dispose();
				programCache.dispose();

				xr.dispose();

				xr.removeEventListener( 'sessionstart', onXRSessionStart );
				xr.removeEventListener( 'sessionend', onXRSessionEnd );

				if ( _transmissionRenderTarget ) {

					_transmissionRenderTarget.dispose();
					_transmissionRenderTarget = null;

				}

				animation.stop();

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				_isContextLost = true;

			}

			function onContextRestore( /* event */ ) {

				_isContextLost = false;

				const infoAutoReset = info.autoReset;
				const shadowMapEnabled = shadowMap.enabled;
				const shadowMapAutoUpdate = shadowMap.autoUpdate;
				const shadowMapNeedsUpdate = shadowMap.needsUpdate;
				const shadowMapType = shadowMap.type;

				initGLContext();

				info.autoReset = infoAutoReset;
				shadowMap.enabled = shadowMapEnabled;
				shadowMap.autoUpdate = shadowMapAutoUpdate;
				shadowMap.needsUpdate = shadowMapNeedsUpdate;
				shadowMap.type = shadowMapType;

			}

			function onContextCreationError( event ) {

			}

			function onMaterialDispose( event ) {

				const material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReferences( material );

				properties.remove( material );

			}


			function releaseMaterialProgramReferences( material ) {

				const programs = properties.get( material ).programs;

				if ( programs !== undefined ) {

					programs.forEach( function ( program ) {

						programCache.releaseProgram( program );

					} );

					if ( material.isShaderMaterial ) {

						programCache.releaseShaderCache( material );

					}

				}

			}

			// Buffer rendering

			this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

				if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

				const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				const program = setProgram( camera, scene, geometry, material, object );

				state.setMaterial( material, frontFaceCW );

				//

				let index = geometry.index;
				let rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = geometries.getWireframeAttribute( geometry );

					if ( index === undefined ) return;

					rangeFactor = 2;

				}

				//

				const drawRange = geometry.drawRange;
				const position = geometry.attributes.position;

				let drawStart = drawRange.start * rangeFactor;
				let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

				if ( group !== null ) {

					drawStart = Math.max( drawStart, group.start * rangeFactor );
					drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

				}

				if ( index !== null ) {

					drawStart = Math.max( drawStart, 0 );
					drawEnd = Math.min( drawEnd, index.count );

				} else if ( position !== undefined && position !== null ) {

					drawStart = Math.max( drawStart, 0 );
					drawEnd = Math.min( drawEnd, position.count );

				}

				const drawCount = drawEnd - drawStart;

				if ( drawCount < 0 || drawCount === Infinity ) return;

				//

				bindingStates.setup( object, material, program, geometry, index );

				let attribute;
				let renderer = bufferRenderer;

				if ( index !== null ) {

					attribute = attributes.get( index );

					renderer = indexedBufferRenderer;
					renderer.setIndex( attribute );

				}

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );

					} else {

						renderer.setMode( _gl.TRIANGLES );

					}

				} else if ( object.isLine ) {

					let lineWidth = material.linewidth;

					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( _gl.LINES );

					} else if ( object.isLineLoop ) {

						renderer.setMode( _gl.LINE_LOOP );

					} else {

						renderer.setMode( _gl.LINE_STRIP );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( _gl.POINTS );

				} else if ( object.isSprite ) {

					renderer.setMode( _gl.TRIANGLES );

				}

				if ( object.isInstancedMesh ) {

					renderer.renderInstances( drawStart, drawCount, object.count );

				} else if ( geometry.isInstancedBufferGeometry ) {

					const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
					const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

					renderer.renderInstances( drawStart, drawCount, instanceCount );

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			// Compile

			this.compile = function ( scene, camera ) {

				function prepare( material, scene, object ) {

					if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

						material.side = BackSide;
						material.needsUpdate = true;
						getProgram( material, scene, object );

						material.side = FrontSide;
						material.needsUpdate = true;
						getProgram( material, scene, object );

						material.side = DoubleSide;

					} else {

						getProgram( material, scene, object );

					}

				}

				currentRenderState = renderStates.get( scene );
				currentRenderState.init();

				renderStateStack.push( currentRenderState );

				scene.traverseVisible( function ( object ) {

					if ( object.isLight && object.layers.test( camera.layers ) ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

				currentRenderState.setupLights( _this._useLegacyLights );

				scene.traverse( function ( object ) {

					const material = object.material;

					if ( material ) {

						if ( Array.isArray( material ) ) {

							for ( let i = 0; i < material.length; i ++ ) {

								const material2 = material[ i ];

								prepare( material2, scene, object );

							}

						} else {

							prepare( material, scene, object );

						}

					}

				} );

				renderStateStack.pop();
				currentRenderState = null;

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time ) {

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

			}

			function onXRSessionStart() {

				animation.stop();

			}

			function onXRSessionEnd() {

				animation.start();

			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop( onAnimationFrame );

			if ( typeof self !== 'undefined' ) animation.setContext( self );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;
				xr.setAnimationLoop( callback );

				( callback === null ) ? animation.stop() : animation.start();

			};

			xr.addEventListener( 'sessionstart', onXRSessionStart );
			xr.addEventListener( 'sessionend', onXRSessionEnd );

			// Rendering

			this.render = function ( scene, camera ) {

				if ( camera !== undefined && camera.isCamera !== true ) {
					return;

				}

				if ( _isContextLost === true ) return;

				// update scene graph

				if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

				// update camera matrices and frustum

				if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

				if ( xr.enabled === true && xr.isPresenting === true ) {

					if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

					camera = xr.getCamera(); // use XR camera for rendering

				}

				//
				if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

				currentRenderState = renderStates.get( scene, renderStateStack.length );
				currentRenderState.init();

				renderStateStack.push( currentRenderState );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromProjectionMatrix( _projScreenMatrix );

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

				currentRenderList = renderLists.get( scene, renderListStack.length );
				currentRenderList.init();

				renderListStack.push( currentRenderList );

				projectObject( scene, camera, 0, _this.sortObjects );

				currentRenderList.finish();

				if ( _this.sortObjects === true ) {

					currentRenderList.sort( _opaqueSort, _transparentSort );

				}

				//

				this.info.render.frame ++;

				if ( _clippingEnabled === true ) clipping.beginShadows();

				const shadowsArray = currentRenderState.state.shadowsArray;

				shadowMap.render( shadowsArray, scene, camera );

				if ( _clippingEnabled === true ) clipping.endShadows();

				//

				if ( this.info.autoReset === true ) this.info.reset();


				//

				background.render( currentRenderList, scene );

				// render scene

				currentRenderState.setupLights( _this._useLegacyLights );

				if ( camera.isArrayCamera ) {

					const cameras = camera.cameras;

					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

						const camera2 = cameras[ i ];

						renderScene( currentRenderList, scene, camera2, camera2.viewport );

					}

				} else {

					renderScene( currentRenderList, scene, camera );

				}

				//

				if ( _currentRenderTarget !== null ) {

					// resolve multisample renderbuffers to a single-sample texture if necessary

					textures.updateMultisampleRenderTarget( _currentRenderTarget );

					// Generate mipmap if we're using any kind of mipmap filtering

					textures.updateRenderTargetMipmap( _currentRenderTarget );

				}

				//

				if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

				// _gl.finish();

				bindingStates.resetDefaultState();
				_currentMaterialId = - 1;
				_currentCamera = null;

				renderStateStack.pop();

				if ( renderStateStack.length > 0 ) {

					currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

				} else {

					currentRenderState = null;

				}

				renderListStack.pop();

				if ( renderListStack.length > 0 ) {

					currentRenderList = renderListStack[ renderListStack.length - 1 ];

				} else {

					currentRenderList = null;

				}

			};

			function projectObject( object, camera, groupOrder, sortObjects ) {

				if ( object.visible === false ) return;

				const visible = object.layers.test( camera.layers );

				if ( visible ) {

					if ( object.isGroup ) {

						groupOrder = object.renderOrder;

					} else if ( object.isLOD ) {

						if ( object.autoUpdate === true ) object.update( camera );

					} else if ( object.isLight ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					} else if ( object.isSprite ) {

						if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

							if ( sortObjects ) {

								_vector3.setFromMatrixPosition( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							const geometry = objects.update( object );
							const material = object.material;

							if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

							}

						}

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

							const geometry = objects.update( object );
							const material = object.material;

							if ( sortObjects ) {

								if ( object.boundingSphere !== undefined ) {

									if ( object.boundingSphere === null ) object.computeBoundingSphere();
									_vector3.copy( object.boundingSphere.center );

								} else {

									if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
									_vector3.copy( geometry.boundingSphere.center );

								}

								_vector3
									.applyMatrix4( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							if ( Array.isArray( material ) ) {

								const groups = geometry.groups;

								for ( let i = 0, l = groups.length; i < l; i ++ ) {

									const group = groups[ i ];
									const groupMaterial = material[ group.materialIndex ];

									if ( groupMaterial && groupMaterial.visible ) {

										currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

									}

								}

							} else if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

							}

						}

					}

				}

				const children = object.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, groupOrder, sortObjects );

				}

			}

			function renderScene( currentRenderList, scene, camera, viewport ) {

				const opaqueObjects = currentRenderList.opaque;
				const transmissiveObjects = currentRenderList.transmissive;
				const transparentObjects = currentRenderList.transparent;

				currentRenderState.setupLightsView( camera );

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

				if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

				if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
				if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
				if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.buffers.depth.setTest( true );
				state.buffers.depth.setMask( true );
				state.buffers.color.setMask( true );

				state.setPolygonOffset( false );

			}

			function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

				const isWebGL2 = capabilities.isWebGL2;

				if ( _transmissionRenderTarget === null ) {

					_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
						generateMipmaps: true,
						type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
						minFilter: LinearMipmapLinearFilter,
						samples: ( isWebGL2 ) ? 4 : 0
					} );

					// debug

					/*
					const geometry = new PlaneGeometry();
					const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

					const mesh = new Mesh( geometry, material );
					scene.add( mesh );
					*/

				}

				_this.getDrawingBufferSize( _vector2 );

				if ( isWebGL2 ) {

					_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

				} else {

					_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

				}

				//

				const currentRenderTarget = _this.getRenderTarget();
				_this.setRenderTarget( _transmissionRenderTarget );

				_this.getClearColor( _currentClearColor );
				_currentClearAlpha = _this.getClearAlpha();
				if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

				_this.clear();

				// Turn off the features which can affect the frag color for opaque objects pass.
				// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
				const currentToneMapping = _this.toneMapping;
				_this.toneMapping = NoToneMapping;

				renderObjects( opaqueObjects, scene, camera );

				textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
				textures.updateRenderTargetMipmap( _transmissionRenderTarget );

				let renderTargetNeedsUpdate = false;

				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

					const renderItem = transmissiveObjects[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = renderItem.material;
					const group = renderItem.group;

					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

						const currentSide = material.side;

						material.side = BackSide;
						material.needsUpdate = true;

						renderObject( object, scene, camera, geometry, material, group );

						material.side = currentSide;
						material.needsUpdate = true;

						renderTargetNeedsUpdate = true;

					}

				}

				if ( renderTargetNeedsUpdate === true ) {

					textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
					textures.updateRenderTargetMipmap( _transmissionRenderTarget );

				}

				_this.setRenderTarget( currentRenderTarget );

				_this.setClearColor( _currentClearColor, _currentClearAlpha );

				_this.toneMapping = currentToneMapping;

			}

			function renderObjects( renderList, scene, camera ) {

				const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

				for ( let i = 0, l = renderList.length; i < l; i ++ ) {

					const renderItem = renderList[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
					const group = renderItem.group;

					if ( object.layers.test( camera.layers ) ) {

						renderObject( object, scene, camera, geometry, material, group );

					}

				}

			}

			function renderObject( object, scene, camera, geometry, material, group ) {

				object.onBeforeRender( _this, scene, camera, geometry, material, group );

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				material.onBeforeRender( _this, scene, camera, geometry, object, group );

				if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

					material.side = BackSide;
					material.needsUpdate = true;
					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

					material.side = FrontSide;
					material.needsUpdate = true;
					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

					material.side = DoubleSide;

				} else {

					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				}

				object.onAfterRender( _this, scene, camera, geometry, material, group );

			}

			function getProgram( material, scene, object ) {

				if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

				const materialProperties = properties.get( material );

				const lights = currentRenderState.state.lights;
				const shadowsArray = currentRenderState.state.shadowsArray;

				const lightsStateVersion = lights.state.version;

				const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
				const programCacheKey = programCache.getProgramCacheKey( parameters );

				let programs = materialProperties.programs;

				// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

				materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
				materialProperties.fog = scene.fog;
				materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

				if ( programs === undefined ) {

					// new material

					material.addEventListener( 'dispose', onMaterialDispose );

					programs = new Map();
					materialProperties.programs = programs;

				}

				let program = programs.get( programCacheKey );

				if ( program !== undefined ) {

					// early out if program and light state is identical

					if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

						updateCommonMaterialProperties( material, parameters );

						return program;

					}

				} else {

					parameters.uniforms = programCache.getUniforms( material );

					material.onBuild( object, parameters, _this );

					material.onBeforeCompile( parameters, _this );

					program = programCache.acquireProgram( parameters, programCacheKey );
					programs.set( programCacheKey, program );

					materialProperties.uniforms = parameters.uniforms;

				}

				const uniforms = materialProperties.uniforms;

				if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

					uniforms.clippingPlanes = clipping.uniform;

				}

				updateCommonMaterialProperties( material, parameters );

				// store the light setup it was created for

				materialProperties.needsLights = materialNeedsLights( material );
				materialProperties.lightsStateVersion = lightsStateVersion;

				if ( materialProperties.needsLights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = lights.state.ambient;
					uniforms.lightProbe.value = lights.state.probe;
					uniforms.directionalLights.value = lights.state.directional;
					uniforms.directionalLightShadows.value = lights.state.directionalShadow;
					uniforms.spotLights.value = lights.state.spot;
					uniforms.spotLightShadows.value = lights.state.spotShadow;
					uniforms.rectAreaLights.value = lights.state.rectArea;
					uniforms.ltc_1.value = lights.state.rectAreaLTC1;
					uniforms.ltc_2.value = lights.state.rectAreaLTC2;
					uniforms.pointLights.value = lights.state.point;
					uniforms.pointLightShadows.value = lights.state.pointShadow;
					uniforms.hemisphereLights.value = lights.state.hemi;

					uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
					uniforms.spotShadowMap.value = lights.state.spotShadowMap;
					uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
					uniforms.spotLightMap.value = lights.state.spotLightMap;
					uniforms.pointShadowMap.value = lights.state.pointShadowMap;
					uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms

				}

				const progUniforms = program.getUniforms();
				const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

				materialProperties.currentProgram = program;
				materialProperties.uniformsList = uniformsList;

				return program;

			}

			function updateCommonMaterialProperties( material, parameters ) {

				const materialProperties = properties.get( material );

				materialProperties.outputColorSpace = parameters.outputColorSpace;
				materialProperties.instancing = parameters.instancing;
				materialProperties.instancingColor = parameters.instancingColor;
				materialProperties.skinning = parameters.skinning;
				materialProperties.morphTargets = parameters.morphTargets;
				materialProperties.morphNormals = parameters.morphNormals;
				materialProperties.morphColors = parameters.morphColors;
				materialProperties.morphTargetsCount = parameters.morphTargetsCount;
				materialProperties.numClippingPlanes = parameters.numClippingPlanes;
				materialProperties.numIntersection = parameters.numClipIntersection;
				materialProperties.vertexAlphas = parameters.vertexAlphas;
				materialProperties.vertexTangents = parameters.vertexTangents;
				materialProperties.toneMapping = parameters.toneMapping;

			}

			function setProgram( camera, scene, geometry, material, object ) {

				if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

				textures.resetTextureUnits();

				const fog = scene.fog;
				const environment = material.isMeshStandardMaterial ? scene.environment : null;
				const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
				const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
				const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
				const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
				const morphTargets = !! geometry.morphAttributes.position;
				const morphNormals = !! geometry.morphAttributes.normal;
				const morphColors = !! geometry.morphAttributes.color;

				let toneMapping = NoToneMapping;

				if ( material.toneMapped ) {

					if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

						toneMapping = _this.toneMapping;

					}

				}

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				const materialProperties = properties.get( material );
				const lights = currentRenderState.state.lights;

				if ( _clippingEnabled === true ) {

					if ( _localClippingEnabled === true || camera !== _currentCamera ) {

						const useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						clipping.setState( material, camera, useCache );

					}

				}

				//

				let needsProgramChange = false;

				if ( material.version === materialProperties.__version ) {

					if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

						needsProgramChange = true;

					} else if ( materialProperties.outputColorSpace !== colorSpace ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

						needsProgramChange = true;

					} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

						needsProgramChange = true;

					} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

						needsProgramChange = true;

					} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

						needsProgramChange = true;

					} else if ( materialProperties.envMap !== envMap ) {

						needsProgramChange = true;

					} else if ( material.fog === true && materialProperties.fog !== fog ) {

						needsProgramChange = true;

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== clipping.numPlanes ||
						materialProperties.numIntersection !== clipping.numIntersection ) ) {

						needsProgramChange = true;

					} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

						needsProgramChange = true;

					} else if ( materialProperties.vertexTangents !== vertexTangents ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphTargets !== morphTargets ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphNormals !== morphNormals ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphColors !== morphColors ) {

						needsProgramChange = true;

					} else if ( materialProperties.toneMapping !== toneMapping ) {

						needsProgramChange = true;

					} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

						needsProgramChange = true;

					}

				} else {

					needsProgramChange = true;
					materialProperties.__version = material.version;

				}

				//

				let program = materialProperties.currentProgram;

				if ( needsProgramChange === true ) {

					program = getProgram( material, scene, object );

				}

				let refreshProgram = false;
				let refreshMaterial = false;
				let refreshLights = false;

				const p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.uniforms;

				if ( state.useProgram( program.program ) ) {

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || _currentCamera !== camera ) {

					// common camera uniforms

					p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					const uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}

					// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

					if ( material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ) {

						p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

					}

					if ( _currentCamera !== camera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

				}

				// skinning and morph target uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone and morph texture must go before other textures
				// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

				if ( object.isSkinnedMesh ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					const skeleton = object.skeleton;

					if ( skeleton ) {

						if ( capabilities.floatVertexTextures ) {

							if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

							p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
							p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

						}

					}

				}

				const morphAttributes = geometry.morphAttributes;

				if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

					morphtargets.update( object, geometry, program );

				}

				if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

					materialProperties.receiveShadow = object.receiveShadow;
					p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

				}

				// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

				if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

					m_uniforms.envMap.value = envMap;

					m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

				}

				if ( refreshMaterial ) {

					p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

					if ( materialProperties.needsLights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog === true ) {

						materials.refreshFogUniforms( m_uniforms, fog );

					}

					materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

					WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

				}

				if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

					WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
					material.uniformsNeedUpdate = false;

				}

				if ( material.isSpriteMaterial ) {

					p_uniforms.setValue( _gl, 'center', object.center );

				}

				// common matrices

				p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
				p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				// UBOs

				if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

					const groups = material.uniformsGroups;

					for ( let i = 0, l = groups.length; i < l; i ++ ) {

						if ( capabilities.isWebGL2 ) {

							const group = groups[ i ];

							uniformsGroups.update( group, program );
							uniformsGroups.bind( group, program );

						}

					}

				}

				return program;

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;
				uniforms.lightProbe.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.directionalLightShadows.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.pointLightShadows.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.spotLightShadows.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			function materialNeedsLights( material ) {

				return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial || material.isShadowMaterial ||
					( material.isShaderMaterial && material.lights === true );

			}

			this.getActiveCubeFace = function () {

				return _currentActiveCubeFace;

			};

			this.getActiveMipmapLevel = function () {

				return _currentActiveMipmapLevel;

			};

			this.getRenderTarget = function () {

				return _currentRenderTarget;

			};

			this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

				properties.get( renderTarget.texture ).__webglTexture = colorTexture;
				properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

				const renderTargetProperties = properties.get( renderTarget );
				renderTargetProperties.__hasExternalTextures = true;

				if ( renderTargetProperties.__hasExternalTextures ) {

					renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

					if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

						// The multisample_render_to_texture extension doesn't work properly if there
						// are midframe flushes and an external depth buffer. Disable use of the extension.
						if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {
							renderTargetProperties.__useRenderToTexture = false;

						}

					}

				}

			};

			this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

				const renderTargetProperties = properties.get( renderTarget );
				renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
				renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

			};

			this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

				_currentRenderTarget = renderTarget;
				_currentActiveCubeFace = activeCubeFace;
				_currentActiveMipmapLevel = activeMipmapLevel;

				let useDefaultFramebuffer = true;
				let framebuffer = null;
				let isCube = false;
				let isRenderTarget3D = false;

				if ( renderTarget ) {

					const renderTargetProperties = properties.get( renderTarget );

					if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

						// We need to make sure to rebind the framebuffer.
						state.bindFramebuffer( _gl.FRAMEBUFFER, null );
						useDefaultFramebuffer = false;

					} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

						textures.setupRenderTarget( renderTarget );

					} else if ( renderTargetProperties.__hasExternalTextures ) {

						// Color and depth texture must be rebound in order for the swapchain to update.
						textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

					}

					const texture = renderTarget.texture;

					if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

						isRenderTarget3D = true;

					}

					const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

					if ( renderTarget.isWebGLCubeRenderTarget ) {

						if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

							framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

						} else {

							framebuffer = __webglFramebuffer[ activeCubeFace ];

						}

						isCube = true;

					} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

						framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

					} else {

						if ( Array.isArray( __webglFramebuffer ) ) {

							framebuffer = __webglFramebuffer[ activeMipmapLevel ];

						} else {

							framebuffer = __webglFramebuffer;

						}

					}

					_currentViewport.copy( renderTarget.viewport );
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

				} else {

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
					_currentScissorTest = _scissorTest;

				}

				const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

					state.drawBuffers( renderTarget, framebuffer );

				}

				state.viewport( _currentViewport );
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				if ( isCube ) {

					const textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

				} else if ( isRenderTarget3D ) {

					const textureProperties = properties.get( renderTarget.texture );
					const layer = activeCubeFace || 0;
					_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

				}

				_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

			};

			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

				if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {
					return;

				}

				let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

					framebuffer = framebuffer[ activeCubeFaceIndex ];

				}

				if ( framebuffer ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					try {

						const texture = renderTarget.texture;
						const textureFormat = texture.format;
						const textureType = texture.type;

						if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
							return;

						}

						const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

						if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! halfFloatSupportedByExt ) {
							return;

						}

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} finally {

						// restore framebuffer of current render target if necessary

						const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
						state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					}

				}

			};

			this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

				const levelScale = Math.pow( 2, - level );
				const width = Math.floor( texture.image.width * levelScale );
				const height = Math.floor( texture.image.height * levelScale );

				textures.setTexture2D( texture, 0 );

				_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );

				state.unbindTexture();

			};

			this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

				const width = srcTexture.image.width;
				const height = srcTexture.image.height;
				const glFormat = utils.convert( dstTexture.format );
				const glType = utils.convert( dstTexture.type );

				textures.setTexture2D( dstTexture, 0 );

				// As another texture upload may have changed pixelStorei
				// parameters, make sure they are correct for the dstTexture
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

				if ( srcTexture.isDataTexture ) {

					_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

				} else {

					if ( srcTexture.isCompressedTexture ) {

						_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

					} else {

						_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

					}

				}

				// Generate mipmaps only when copying level 0
				if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

				state.unbindTexture();

			};

			this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

				if ( _this.isWebGL1Renderer ) {
					return;

				}

				const width = sourceBox.max.x - sourceBox.min.x + 1;
				const height = sourceBox.max.y - sourceBox.min.y + 1;
				const depth = sourceBox.max.z - sourceBox.min.z + 1;
				const glFormat = utils.convert( dstTexture.format );
				const glType = utils.convert( dstTexture.type );
				let glTarget;

				if ( dstTexture.isData3DTexture ) {

					textures.setTexture3D( dstTexture, 0 );
					glTarget = _gl.TEXTURE_3D;

				} else if ( dstTexture.isDataArrayTexture ) {

					textures.setTexture2DArray( dstTexture, 0 );
					glTarget = _gl.TEXTURE_2D_ARRAY;

				} else {
					return;

				}

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

				const unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
				const unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
				const unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
				const unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
				const unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

				const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
				_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );
				_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );

				if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

					_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

				} else {

					if ( srcTexture.isCompressedArrayTexture ) {
						_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

					} else {

						_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

					}

				}

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );
				_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );
				_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );

				// Generate mipmaps only when copying level 0
				if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

				state.unbindTexture();

			};

			this.initTexture = function ( texture ) {

				if ( texture.isCubeTexture ) {

					textures.setTextureCube( texture, 0 );

				} else if ( texture.isData3DTexture ) {

					textures.setTexture3D( texture, 0 );

				} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

					textures.setTexture2DArray( texture, 0 );

				} else {

					textures.setTexture2D( texture, 0 );

				}

				state.unbindTexture();

			};

			this.resetState = function () {

				_currentActiveCubeFace = 0;
				_currentActiveMipmapLevel = 0;
				_currentRenderTarget = null;

				state.reset();
				bindingStates.reset();

			};

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		get coordinateSystem() {

			return WebGLCoordinateSystem;

		}

		get physicallyCorrectLights() { // @deprecated, r150
			return ! this.useLegacyLights;

		}

		set physicallyCorrectLights( value ) { // @deprecated, r150
			this.useLegacyLights = ! value;

		}

		get outputEncoding() { // @deprecated, r152
			return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;

		}

		set outputEncoding( encoding ) { // @deprecated, r152
			this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;

		}

		get useLegacyLights() { // @deprecated, r155
			return this._useLegacyLights;

		}

		set useLegacyLights( value ) { // @deprecated, r155
			this._useLegacyLights = value;

		}

	}

	class Scene extends Object3D {

		constructor() {

			super();

			this.isScene = true;

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.backgroundBlurriness = 0;
			this.backgroundIntensity = 1;

			this.overrideMaterial = null;

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			this.backgroundBlurriness = source.backgroundBlurriness;
			this.backgroundIntensity = source.backgroundIntensity;

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
			if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
			if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;

			return data;

		}

	}

	class VideoTexture extends Texture {

		constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isVideoTexture = true;

			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

			this.generateMipmaps = false;

			const scope = this;

			function updateVideo() {

				scope.needsUpdate = true;
				video.requestVideoFrameCallback( updateVideo );

			}

			if ( 'requestVideoFrameCallback' in video ) {

				video.requestVideoFrameCallback( updateVideo );

			}

		}

		clone() {

			return new this.constructor( this.image ).copy( this );

		}

		update() {

			const video = this.image;
			const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

			if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	}

	class FramebufferTexture extends Texture {

		constructor( width, height ) {

			super( { width, height } );

			this.isFramebufferTexture = true;

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.generateMipmaps = false;

			this.needsUpdate = true;

		}

	}

	class SpriteMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isSpriteMaterial = true;

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.rotation = 0;

			this.sizeAttenuation = true;

			this.transparent = true;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.rotation = source.rotation;

			this.sizeAttenuation = source.sizeAttenuation;

			this.fog = source.fog;

			return this;

		}

	}

	class PointsMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isPointsMaterial = true;

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshStandardMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshStandardMaterial = true;

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 1.0;
			this.metalness = 0.0;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.roughnessMap = null;

			this.metalnessMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshPhysicalMaterial extends MeshStandardMaterial {

		constructor( parameters ) {

			super();

			this.isMeshPhysicalMaterial = true;

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.type = 'MeshPhysicalMaterial';

			this.anisotropyRotation = 0;
			this.anisotropyMap = null;

			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2( 1, 1 );
			this.clearcoatNormalMap = null;

			this.ior = 1.5;

			Object.defineProperty( this, 'reflectivity', {
				get: function () {

					return ( clamp$1( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

				},
				set: function ( reflectivity ) {

					this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

				}
			} );

			this.iridescenceMap = null;
			this.iridescenceIOR = 1.3;
			this.iridescenceThicknessRange = [ 100, 400 ];
			this.iridescenceThicknessMap = null;

			this.sheenColor = new Color( 0x000000 );
			this.sheenColorMap = null;
			this.sheenRoughness = 1.0;
			this.sheenRoughnessMap = null;

			this.transmissionMap = null;

			this.thickness = 0;
			this.thicknessMap = null;
			this.attenuationDistance = Infinity;
			this.attenuationColor = new Color( 1, 1, 1 );

			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularColor = new Color( 1, 1, 1 );
			this.specularColorMap = null;

			this._anisotropy = 0;
			this._clearcoat = 0;
			this._iridescence = 0;
			this._sheen = 0.0;
			this._transmission = 0;

			this.setValues( parameters );

		}

		get anisotropy() {

			return this._anisotropy;

		}

		set anisotropy( value ) {

			if ( this._anisotropy > 0 !== value > 0 ) {

				this.version ++;

			}

			this._anisotropy = value;

		}

		get clearcoat() {

			return this._clearcoat;

		}

		set clearcoat( value ) {

			if ( this._clearcoat > 0 !== value > 0 ) {

				this.version ++;

			}

			this._clearcoat = value;

		}

		get iridescence() {

			return this._iridescence;

		}

		set iridescence( value ) {

			if ( this._iridescence > 0 !== value > 0 ) {

				this.version ++;

			}

			this._iridescence = value;

		}

		get sheen() {

			return this._sheen;

		}

		set sheen( value ) {

			if ( this._sheen > 0 !== value > 0 ) {

				this.version ++;

			}

			this._sheen = value;

		}

		get transmission() {

			return this._transmission;

		}

		set transmission( value ) {

			if ( this._transmission > 0 !== value > 0 ) {

				this.version ++;

			}

			this._transmission = value;

		}

		copy( source ) {

			super.copy( source );

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.anisotropy = source.anisotropy;
			this.anisotropyRotation = source.anisotropyRotation;
			this.anisotropyMap = source.anisotropyMap;

			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

			this.ior = source.ior;

			this.iridescence = source.iridescence;
			this.iridescenceMap = source.iridescenceMap;
			this.iridescenceIOR = source.iridescenceIOR;
			this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
			this.iridescenceThicknessMap = source.iridescenceThicknessMap;

			this.sheen = source.sheen;
			this.sheenColor.copy( source.sheenColor );
			this.sheenColorMap = source.sheenColorMap;
			this.sheenRoughness = source.sheenRoughness;
			this.sheenRoughnessMap = source.sheenRoughnessMap;

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;

			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationColor.copy( source.attenuationColor );

			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularColor.copy( source.specularColor );
			this.specularColorMap = source.specularColorMap;

			return this;

		}

	}

	class MeshPhongMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshPhongMaterial = true;

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshToonMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshToonMaterial = true;

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;
			this.gradientMap = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshNormalMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshNormalMaterial = true;

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	class MeshLambertMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshLambertMaterial = true;

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshMatcapMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshMatcapMaterial = true;

			this.defines = { 'MATCAP': '' };

			this.type = 'MeshMatcapMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.matcap = null;

			this.map = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.defines = { 'MATCAP': '' };

			this.color.copy( source.color );

			this.matcap = source.matcap;

			this.map = source.map;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class LineBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isLineBasicMaterial = true;

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			this.fog = source.fog;

			return this;

		}

	}

	const Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	class LoadingManager {

		constructor( onLoad, onProgress, onError ) {

			const scope = this;

			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = [];

			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

			this.resolveURL = function ( url ) {

				if ( urlModifier ) {

					return urlModifier( url );

				}

				return url;

			};

			this.setURLModifier = function ( transform ) {

				urlModifier = transform;

				return this;

			};

			this.addHandler = function ( regex, loader ) {

				handlers.push( regex, loader );

				return this;

			};

			this.removeHandler = function ( regex ) {

				const index = handlers.indexOf( regex );

				if ( index !== - 1 ) {

					handlers.splice( index, 2 );

				}

				return this;

			};

			this.getHandler = function ( file ) {

				for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

					const regex = handlers[ i ];
					const loader = handlers[ i + 1 ];

					if ( regex.global ) regex.lastIndex = 0; // see #17920

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			};

		}

	}

	const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

	class Loader {

		constructor( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};

		}

		load( /* url, onLoad, onProgress, onError */ ) {}

		loadAsync( url, onProgress ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		}

		parse( /* data */ ) {}

		setCrossOrigin( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		}

		setWithCredentials( value ) {

			this.withCredentials = value;
			return this;

		}

		setPath( path ) {

			this.path = path;
			return this;

		}

		setResourcePath( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		}

		setRequestHeader( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	}

	Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

	class ImageLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const image = createElementNS( 'img' );

			function onImageLoad() {

				removeEventListeners();

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				removeEventListeners();

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			function removeEventListeners() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.slice( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	}

	class TextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const texture = new Texture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	}

	class CylinderGeometry extends BufferGeometry {

		constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			const scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				const normal = new Vector3();
				const vertex = new Vector3();

				let groupCount = 0;

				// this will be used to calculate the normal
				const slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( let y = 0; y <= heightSegments; y ++ ) {

					const indexRow = [];

					const v = y / heightSegments;

					// calculate the radius of the current row

					const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( let x = 0; x <= radialSegments; x ++ ) {

						const u = x / radialSegments;

						const theta = u * thetaLength + thetaStart;

						const sinTheta = Math.sin( theta );
						const cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					for ( let y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						const a = indexArray[ y ][ x ];
						const b = indexArray[ y + 1 ][ x ];
						const c = indexArray[ y + 1 ][ x + 1 ];
						const d = indexArray[ y ][ x + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				const centerIndexStart = index;

				const uv = new Vector2();
				const vertex = new Vector3();

				let groupCount = 0;

				const radius = ( top === true ) ? radiusTop : radiusBottom;
				const sign = ( top === true ) ? 1 : - 1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( let x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				const centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;

					const cosTheta = Math.cos( theta );
					const sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

		}

	}

	class InstancedBufferGeometry extends BufferGeometry {

		constructor() {

			super();

			this.isInstancedBufferGeometry = true;

			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;

		}

		copy( source ) {

			super.copy( source );

			this.instanceCount = source.instanceCount;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	}

	class SphereGeometry extends BufferGeometry {

		constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

			super();

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			let index = 0;
			const grid = [];

			const vertex = new Vector3();
			const normal = new Vector3();

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// generate vertices, normals and uvs

			for ( let iy = 0; iy <= heightSegments; iy ++ ) {

				const verticesRow = [];

				const v = iy / heightSegments;

				// special case for the poles

				let uOffset = 0;

				if ( iy === 0 && thetaStart === 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( let ix = 0; ix <= widthSegments; ix ++ ) {

					const u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( let iy = 0; iy < heightSegments; iy ++ ) {

				for ( let ix = 0; ix < widthSegments; ix ++ ) {

					const a = grid[ iy ][ ix + 1 ];
					const b = grid[ iy ][ ix ];
					const c = grid[ iy + 1 ][ ix ];
					const d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

		}

	}

	class CircleGeometry extends BufferGeometry {

		constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			segments = Math.max( 3, segments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const vertex = new Vector3();
			const uv = new Vector2();

			// center point

			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );

			for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

				const segment = thetaStart + s / segments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uvs

				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// indices

			for ( let i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

		}

	}

	const _start$1 = /*@__PURE__*/ new Vector3();
	const _end$1 = /*@__PURE__*/ new Vector3();
	const _inverseMatrix = /*@__PURE__*/ new Matrix4();
	const _ray = /*@__PURE__*/ new Ray();
	const _sphere = /*@__PURE__*/ new Sphere();

	class Line extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

			super();

			this.isLine = true;

			this.type = 'Line';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		computeLineDistances() {

			const geometry = this.geometry;

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start$1.fromBufferAttribute( positionAttribute, i - 1 );
					_end$1.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			}

			return this;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );
			_sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

	}

	const _v1 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();
	const _v3 = /*@__PURE__*/ new Vector3();

	class DirectionalLightHelper extends Object3D {

		constructor( light, size, color ) {

			super();

			this.light = light;

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			this.type = 'DirectionalLightHelper';

			if ( size === undefined ) size = 1;

			let geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [
				- size, size, 0,
				size, size, 0,
				size, - size, 0,
				- size, - size, 0,
				- size, size, 0
			], 3 ) );

			const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.lightPlane = new Line( geometry, material );
			this.add( this.lightPlane );

			geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.targetLine = new Line( geometry, material );
			this.add( this.targetLine );

			this.update();

		}

		dispose() {

			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();

		}

		update() {

			this.light.updateWorldMatrix( true, false );
			this.light.target.updateWorldMatrix( true, false );

			_v1.setFromMatrixPosition( this.light.matrixWorld );
			_v2.setFromMatrixPosition( this.light.target.matrixWorld );
			_v3.subVectors( _v2, _v1 );

			this.lightPlane.lookAt( _v2 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( _v2 );
			this.targetLine.scale.z = _v3.length();

		}

	}

	const _start = /*@__PURE__*/ new Vector3();
	const _end = /*@__PURE__*/ new Vector3();

	class LineSegments extends Line {

		constructor( geometry, material ) {

			super( geometry, material );

			this.isLineSegments = true;

			this.type = 'LineSegments';

		}

		computeLineDistances() {

			const geometry = this.geometry;

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start.fromBufferAttribute( positionAttribute, i );
					_end.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			}

			return this;

		}

	}

	const _vector$3 = /*@__PURE__*/ new Vector3();

	class SpotLightHelper extends Object3D {

		constructor( light, color ) {

			super();

			this.light = light;

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			this.type = 'SpotLightHelper';

			const geometry = new BufferGeometry();

			const positions = [
				0, 0, 0, 	0, 0, 1,
				0, 0, 0, 	1, 0, 1,
				0, 0, 0,	- 1, 0, 1,
				0, 0, 0, 	0, 1, 1,
				0, 0, 0, 	0, - 1, 1
			];

			for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				const p1 = ( i / l ) * Math.PI * 2;
				const p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		dispose() {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		}

		update() {

			this.light.updateWorldMatrix( true, false );
			this.light.target.updateWorldMatrix( true, false );

			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( _vector$3 );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		}

	}

	class PointLightHelper extends Mesh {

		constructor( light, sphereSize, color ) {

			const geometry = new SphereGeometry( sphereSize, 4, 2 );
			const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

			super( geometry, material );

			this.light = light;

			this.color = color;

			this.type = 'PointLightHelper';

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();


			/*
		// TODO: delete this comment?
		const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		const d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

		update() {

			this.light.updateWorldMatrix( true, false );

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				this.material.color.copy( this.light.color );

			}

			/*
			const d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		}

	}

	class PolyhedronGeometry extends BufferGeometry {

		constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

			super();

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			// default buffer data

			const vertexBuffer = [];
			const uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			applyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

			if ( detail === 0 ) {

				this.computeVertexNormals(); // flat normals

			} else {

				this.normalizeNormals(); // smooth normals

			}

			// helper functions

			function subdivide( detail ) {

				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();

				// iterate over all faces and apply a subdivision with the given detail value

				for ( let i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				const cols = detail + 1;

				// we use this multidimensional array as a data structure for creating the subdivision

				const v = [];

				// construct all of the vertices for this subdivision

				for ( let i = 0; i <= cols; i ++ ) {

					v[ i ] = [];

					const aj = a.clone().lerp( c, i / cols );
					const bj = b.clone().lerp( c, i / cols );

					const rows = cols - i;

					for ( let j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( let i = 0; i < cols; i ++ ) {

					for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						const k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function applyRadius( radius ) {

				const vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				const vertex = new Vector3();

				for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					const v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( let i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					const x0 = uvBuffer[ i + 0 ];
					const x1 = uvBuffer[ i + 2 ];
					const x2 = uvBuffer[ i + 4 ];

					const max = Math.max( x0, x1, x2 );
					const min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				const stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();

				const centroid = new Vector3();

				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					const azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] = uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const vertices = [
				1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
				0, - 1, 0, 	0, 0, 1,	0, 0, - 1
			];

			const indices = [
				0, 2, 4,	0, 4, 3,	0, 3, 5,
				0, 5, 2,	1, 2, 5,	1, 5, 3,
				1, 3, 4,	1, 4, 2
			];

			super( vertices, indices, radius, detail );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		static fromJSON( data ) {

			return new OctahedronGeometry( data.radius, data.detail );

		}

	}

	const _vector$2 = /*@__PURE__*/ new Vector3();
	const _color1 = /*@__PURE__*/ new Color();
	const _color2 = /*@__PURE__*/ new Color();

	class HemisphereLightHelper extends Object3D {

		constructor( light, size, color ) {

			super();

			this.light = light;

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			this.type = 'HemisphereLightHelper';

			const geometry = new OctahedronGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );

			this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
			if ( this.color === undefined ) this.material.vertexColors = true;

			const position = geometry.getAttribute( 'position' );
			const colors = new Float32Array( position.count * 3 );

			geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

			this.add( new Mesh( geometry, this.material ) );

			this.update();

		}

		dispose() {

			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();

		}

		update() {

			const mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				const colors = mesh.geometry.getAttribute( 'color' );

				_color1.copy( this.light.color );
				_color2.copy( this.light.groundColor );

				for ( let i = 0, l = colors.count; i < l; i ++ ) {

					const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			this.light.updateWorldMatrix( true, false );

			mesh.lookAt( _vector$2.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		}

	}

	class InstancedBufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

			super( array, itemSize, normalized );

			this.isInstancedBufferAttribute = true;

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	}

	const _vector$1 = /*@__PURE__*/ new Vector3();

	class InterleavedBufferAttribute {

		constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

			this.isInterleavedBufferAttribute = true;

			this.name = '';

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized;

		}

		get count() {

			return this.data.count;

		}

		get array() {

			return this.data.array;

		}

		set needsUpdate( value ) {

			this.data.needsUpdate = value;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$1.fromBufferAttribute( this, i );

				_vector$1.applyMatrix4( m );

				this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$1.fromBufferAttribute( this, i );

				_vector$1.applyNormalMatrix( m );

				this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$1.fromBufferAttribute( this, i );

				_vector$1.transformDirection( m );

				this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

			return this;

		}

		setX( index, x ) {

			if ( this.normalized ) x = normalize$1( x, this.array );

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		}

		setY( index, y ) {

			if ( this.normalized ) y = normalize$1( y, this.array );

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		}

		setZ( index, z ) {

			if ( this.normalized ) z = normalize$1( z, this.array );

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		}

		setW( index, w ) {

			if ( this.normalized ) w = normalize$1( w, this.array );

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		}

		getX( index ) {

			let x = this.data.array[ index * this.data.stride + this.offset ];

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		getY( index ) {

			let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		getZ( index ) {

			let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		getW( index ) {

			let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		setXY( index, x, y ) {

			index = index * this.data.stride + this.offset;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );

			}

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );
				z = normalize$1( z, this.array );

			}

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			if ( this.normalized ) {

				x = normalize$1( x, this.array );
				y = normalize$1( y, this.array );
				z = normalize$1( z, this.array );
				w = normalize$1( w, this.array );

			}

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

		clone( data ) {

			if ( data === undefined ) {

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		}

		toJSON( data ) {

			if ( data === undefined ) {

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// de-interleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interleaved attribute

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	}

	class InterleavedBuffer {

		constructor( array, stride ) {

			this.isInterleavedBuffer = true;

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

			this.uuid = generateUUID$1();

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( let i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		set( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		}

		clone( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID$1();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			const ib = new this.constructor( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		toJSON( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID$1();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {

		constructor( array, stride, meshPerAttribute = 1 ) {

			super( array, stride );

			this.isInstancedInterleavedBuffer = true;

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		clone( data ) {

			const ib = super.clone( data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		}

		toJSON( data ) {

			const json = super.toJSON( data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	}

	class Raycaster {

		constructor( origin, direction, near = 0, far = Infinity ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();

			this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

		}

		set( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		}

		setFromCamera( coords, camera ) {

			if ( camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else ;

		}

		intersectObject( object, recursive = true, intersects = [] ) {

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		}

		intersectObjects( objects, recursive = true, intersects = [] ) {

			for ( let i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	class FogExp2 {

		constructor( color, density = 0.00025 ) {

			this.isFogExp2 = true;

			this.name = '';

			this.color = new Color( color );
			this.density = density;

		}

		clone() {

			return new FogExp2( this.color, this.density );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	}

	class Fog {

		constructor( color, near = 1, far = 1000 ) {

			this.isFog = true;

			this.name = '';

			this.color = new Color( color );

			this.near = near;
			this.far = far;

		}

		clone() {

			return new Fog( this.color, this.near, this.far );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		}

	}

	class Light extends Object3D {

		constructor( color, intensity = 1 ) {

			super();

			this.isLight = true;

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity;

		}

		dispose() {

			// Empty here in base class; some subclasses override.

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	}

	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	const _lookTarget$1 = /*@__PURE__*/ new Vector3();

	class LightShadow {

		constructor( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();

			this.autoUpdate = true;
			this.needsUpdate = false;

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		getViewportCount() {

			return this._viewportCount;

		}

		getFrustum() {

			return this._frustum;

		}

		updateMatrices( light ) {

			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld$1 );

			_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _lookTarget$1 );
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( _projScreenMatrix$1 );

		}

		getViewport( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		}

		getFrameExtents() {

			return this._frameExtents;

		}

		dispose() {

			if ( this.map ) {

				this.map.dispose();

			}

			if ( this.mapPass ) {

				this.mapPass.dispose();

			}

		}

		copy( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	}

	const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();

	class PointLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			this.isPointLightShadow = true;

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

		}

		updateMatrices( light, viewportIndex = 0 ) {

			const camera = this.camera;
			const shadowMatrix = this.matrix;

			const far = light.distance || camera.far;

			if ( far !== camera.far ) {

				camera.far = far;
				camera.updateProjectionMatrix();

			}

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld );

			_lookTarget.copy( camera.position );
			_lookTarget.add( this._cubeDirections[ viewportIndex ] );
			camera.up.copy( this._cubeUps[ viewportIndex ] );
			camera.lookAt( _lookTarget );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			_projScreenMatrix$2.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix$2 );

		}

	}

	class PointLight extends Light {

		constructor( color, intensity, distance = 0, decay = 2 ) {

			super( color, intensity );

			this.isPointLight = true;

			this.type = 'PointLight';

			this.distance = distance;
			this.decay = decay;

			this.shadow = new PointLightShadow();

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
			return this.intensity * 4 * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / ( 4 * Math.PI );

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	class DirectionalLightShadow extends LightShadow {

		constructor() {

			super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

			this.isDirectionalLightShadow = true;

		}

	}

	class DirectionalLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.isDirectionalLight = true;

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DEFAULT_UP );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source ) {

			super.copy( source );

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();

			return this;

		}

	}

	class SpotLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

			this.isSpotLightShadow = true;

			this.focus = 1;

		}

		updateMatrices( light ) {

			const camera = this.camera;

			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

			super.updateMatrices( light );

		}

		copy( source ) {

			super.copy( source );

			this.focus = source.focus;

			return this;

		}

	}

	class SpotLight extends Light {

		constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

			super( color, intensity );

			this.isSpotLight = true;

			this.type = 'SpotLight';

			this.position.copy( Object3D.DEFAULT_UP );
			this.updateMatrix();

			this.target = new Object3D();

			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay;

			this.map = null;

			this.shadow = new SpotLightShadow();

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
			return this.intensity * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / Math.PI;

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	class AmbientLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.isAmbientLight = true;

			this.type = 'AmbientLight';

		}

	}

	class HemisphereLight extends Light {

		constructor( skyColor, groundColor, intensity ) {

			super( skyColor, intensity );

			this.isHemisphereLight = true;

			this.type = 'HemisphereLight';

			this.position.copy( Object3D.DEFAULT_UP );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	}

	class RectAreaLight extends Light {

		constructor( color, intensity, width = 10, height = 10 ) {

			super( color, intensity );

			this.isRectAreaLight = true;

			this.type = 'RectAreaLight';

			this.width = width;
			this.height = height;

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in nits)
			return this.intensity * this.width * this.height * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in nits) from the desired luminous power (in lumens)
			this.intensity = power / ( this.width * this.height * Math.PI );

		}

		copy( source ) {

			super.copy( source );

			this.width = source.width;
			this.height = source.height;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	}

	/**
	 * @license
	 * Copyright 2010-2023 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */

	class WebGPU {

		static async isAvailable() {
			if (navigator.gpu !== undefined) {

				try {
					const adapter = await navigator.gpu.requestAdapter();

					if (adapter !== null) {
						if (window.GPUShaderStage === undefined) {

							window.GPUShaderStage = { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };

						}

						return true;
					}
				} catch (e) {
					return false;
				}

			}

			return false;
		}
	}

	class Animation {

		constructor() {

			this.nodes = null;

			this.animationLoop = null;
			this.requestId = null;

			this.isAnimating = false;

			this.context = self;

		}

		start() {

			if ( this.isAnimating === true || this.animationLoop === null || this.nodes === null ) return;

			this.isAnimating = true;

			const update = ( time, frame ) => {

				this.requestId = self.requestAnimationFrame( update );

				this.nodes.nodeFrame.update();

				this.animationLoop( time, frame );

			};

			this.requestId = self.requestAnimationFrame( update );

		}

		stop() {

			self.cancelAnimationFrame( this.requestId );

			this.isAnimating = false;

		}

		setAnimationLoop( callback ) {

			this.animationLoop = callback;

		}

		setNodes( nodes ) {

			this.nodes = nodes;

		}

	}

	class DataMap {

		constructor() {

			this.data = new WeakMap();

		}

		get( object ) {

			let map = this.data.get( object );

			if ( map === undefined ) {

				map = {};
				this.data.set( object, map );

			}

			return map;

		}

		delete( object ) {

			let map;

			if ( this.data.has( object ) ) {

				map = this.data.get( object );

				this.data.delete( object );

			}

			return map;

		}

		has( object ) {

			return this.data.has( object );

		}

		dispose() {

			this.data.clear();

		}

	}

	class ChainMap {

		constructor() {

			this.weakMap = new WeakMap();

		}

		get( keys ) {

			if ( Array.isArray( keys ) ) {

				let map = this.weakMap;

				for ( let i = 0; i < keys.length - 1; i ++ ) {

					map = map.get( keys[ i ] );

					if ( map === undefined ) return undefined;

				}

				return map.get( keys[ keys.length - 1 ] );

			} else {

				return super.get( keys );

			}

		}

		set( keys, value ) {

			if ( Array.isArray( keys ) ) {

				let map = this.weakMap;

				for ( let i = 0; i < keys.length - 1; i ++ ) {

					const key = keys[ i ];

					if ( map.has( key ) === false ) map.set( key, new WeakMap() );

					map = map.get( key );

				}

				return map.set( keys[ keys.length - 1 ], value );

			} else {

				return super.set( keys, value );

			}

		}

		delete( keys ) {

			if ( Array.isArray( keys ) ) {

				let map = this.weakMap;

				for ( let i = 0; i < keys.length - 1; i ++ ) {

					map = map.get( keys[ i ] );

					if ( map === undefined ) return false;

				}

				return map.delete( keys[ keys.length - 1 ] );

			} else {

				return super.delete( keys );

			}

		}

		dispose() {

			this.weakMap.clear();

		}

	}

	let id$3 = 0;

	class RenderObject {

		constructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext ) {

			this._nodes = nodes;
			this._geometries = geometries;

			this.id = id$3 ++;

			this.renderer = renderer;
			this.object = object;
			this.material = material;
			this.scene = scene;
			this.camera = camera;
			this.lightsNode = lightsNode;
			this.context = renderContext;

			this.geometry = object.geometry;

			this.attributes = null;
			this.pipeline = null;
			this.vertexBuffers = null;

			this._materialVersion = - 1;
			this._materialCacheKey = '';

			this.onDispose = null;

			this.onMaterialDispose = () => {

				this.dispose();

			};

			this.material.addEventListener( 'dispose', this.onMaterialDispose );

		}

		getNodeBuilder() {

			return this._nodes.getForRender( this );

		}

		getBindings() {

			return this.getNodeBuilder().getBindings();

		}

		getIndex() {

			return this._geometries.getIndex( this );

		}

		getChainArray() {

			return [ this.object, this.material, this.context, this.lightsNode ];

		}

		getAttributes() {

			if ( this.attributes !== null ) return this.attributes;

			const nodeAttributes = this.getNodeBuilder().getAttributesArray();
			const geometry = this.geometry;

			const attributes = [];
			const vertexBuffers = new Set();

			for ( const nodeAttribute of nodeAttributes ) {

				const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );

				attributes.push( attribute );

				const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
				vertexBuffers.add( bufferAttribute );

			}

			this.attributes = attributes;
			this.vertexBuffers = Array.from( vertexBuffers.values() );

			return attributes;

		}

		getVertexBuffers() {

			if ( this.vertexBuffers === null ) this.getAttributes();

			return this.vertexBuffers;

		}

		getCacheKey() {

			const { material, scene, lightsNode } = this;

			if ( material.version !== this._materialVersion ) {

				this._materialVersion = material.version;
				this._materialCacheKey = material.customProgramCacheKey();

			}

			const cacheKey = [];

			cacheKey.push( 'material:' + this._materialCacheKey );
			cacheKey.push( 'nodes:' + this._nodes.getCacheKey( scene, lightsNode ) );

			return '{' + cacheKey.join( ',' ) + '}';

		}

		dispose() {

			this.material.removeEventListener( 'dispose', this.onMaterialDispose );

			this.onDispose();

		}

	}

	class RenderObjects {

		constructor( renderer, nodes, geometries, pipelines, bindings, info ) {

			this.renderer = renderer;
			this.nodes = nodes;
			this.geometries = geometries;
			this.pipelines = pipelines;
			this.bindings = bindings;
			this.info = info;

			this.chainMaps = {};
			this.dataMap = new DataMap();

		}

		get( object, material, scene, camera, lightsNode, renderContext, passId ) {

			const chainMap = this.getChainMap( passId );
			const chainArray = [ object, material, renderContext, lightsNode ];

			let renderObject = chainMap.get( chainArray );

			if ( renderObject === undefined ) {

				renderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, passId );

				chainMap.set( chainArray, renderObject );

			} else {

				const data = this.dataMap.get( renderObject );
				const cacheKey = renderObject.getCacheKey();

				if ( data.cacheKey !== cacheKey ) {

					renderObject.dispose();

					renderObject = this.get( object, material, scene, camera, lightsNode, renderContext, passId );

				}

			}

			return renderObject;

		}

		getChainMap( passId = 'default' ) {

			return this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );

		}

		dispose() {

			this.chainMaps = {};
			this.dataMap = new DataMap();

		}

		createRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, passId ) {

			const chainMap = this.getChainMap( passId );
			const dataMap = this.dataMap;

			const renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext );

			const data = dataMap.get( renderObject );
			data.cacheKey = renderObject.getCacheKey();

			renderObject.onDispose = () => {

				dataMap.delete( renderObject );

				this.pipelines.delete( renderObject );
				this.bindings.delete( renderObject );
				this.nodes.delete( renderObject );

				chainMap.delete( renderObject.getChainArray() );

			};

			return renderObject;

		}


	}

	const AttributeType = {
		VERTEX: 1,
		INDEX: 2,
		STORAGE: 4
	};

	// size of a chunk in bytes (STD140 layout)

	const GPU_CHUNK_BYTES = 16;

	// @TODO: Move to src/constants.js

	const BlendColorFactor = 211;
	const OneMinusBlendColorFactor = 212;

	class Attributes extends DataMap {

		constructor( backend ) {

			super();

			this.backend = backend;

		}

		delete( attribute ) {

			const attributeData = super.delete( attribute );

			if ( attributeData !== undefined ) {

				this.backend.destroyAttribute( attribute );

			}

		}

		update( attribute, type ) {

			const data = this.get( attribute );

			if ( data.version === undefined ) {

				if ( type === AttributeType.VERTEX ) {

					this.backend.createAttribute( attribute );

				} else if ( type === AttributeType.INDEX ) {

					this.backend.createIndexAttribute( attribute );

				} else if ( type === AttributeType.STORAGE ) {

					this.backend.createStorageAttribute( attribute );

				}

				data.version = this._getBufferAttribute( attribute ).version;

			} else {

				const bufferAttribute = this._getBufferAttribute( attribute );

				if ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {

					this.backend.updateAttribute( attribute );

					data.version = bufferAttribute.version;

				}

			}

		}

		_getBufferAttribute( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return attribute;

		}

	}

	function arrayNeedsUint32( array ) {

		// assumes larger values usually on last

		for ( let i = array.length - 1; i >= 0; -- i ) {

			if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

		}

		return false;

	}

	function getWireframeVersion( geometry ) {

		return ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;

	}

	function getWireframeIndex( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = getWireframeVersion( geometry );

		return attribute;

	}

	class Geometries extends DataMap {

		constructor( attributes, info ) {

			super();

			this.attributes = attributes;
			this.info = info;

			this.wireframes = new WeakMap();
			this.attributeFrame = new WeakMap();

		}

		has( renderObject ) {

			const geometry = renderObject.geometry;

			return super.has( geometry ) && this.get( geometry ).initialized === true;

		}

		updateForRender( renderObject ) {

			if ( this.has( renderObject ) === false ) this.initGeometry( renderObject );

			this.updateAttributes( renderObject );

		}

		initGeometry( renderObject ) {

			const geometry = renderObject.geometry;
			const geometryData = this.get( geometry );

			geometryData.initialized = true;

			this.info.memory.geometries ++;

			const onDispose = () => {

				this.info.memory.geometries --;

				const index = geometry.index;
				const geometryAttributes = renderObject.getAttributes();

				if ( index !== null ) {

					this.attributes.delete( index );

				}

				for ( const geometryAttribute of geometryAttributes ) {

					this.attributes.delete( geometryAttribute );

				}

				const wireframeAttribute = this.wireframes.get( geometry );

				if ( wireframeAttribute !== undefined ) {

					this.attributes.delete( wireframeAttribute );

				}

				geometry.removeEventListener( 'dispose', onDispose );

			};

			geometry.addEventListener( 'dispose', onDispose );

		}

		updateAttributes( renderObject ) {

			const attributes = renderObject.getAttributes();

			for ( const attribute of attributes ) {

				this.updateAttribute( attribute, AttributeType.VERTEX );

			}

			const index = this.getIndex( renderObject );

			if ( index !== null ) {

				this.updateAttribute( index, AttributeType.INDEX );

			}

		}

		updateAttribute( attribute, type ) {

			const frame = this.info.render.frame;

			if ( this.attributeFrame.get( attribute ) !== frame ) {

				this.attributes.update( attribute, type );

				this.attributeFrame.set( attribute, frame );

			}

		}

		getIndex( renderObject ) {

			const { geometry, material } = renderObject;

			let index = geometry.index;

			if ( material.wireframe === true ) {

				const wireframes = this.wireframes;

				let wireframeAttribute = wireframes.get( geometry );

				if ( wireframeAttribute === undefined ) {

					wireframeAttribute = getWireframeIndex( geometry );

					wireframes.set( geometry, wireframeAttribute );

				} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {

					this.attributes.delete( wireframeAttribute );

					wireframeAttribute = getWireframeIndex( geometry );

					wireframes.set( geometry, wireframeAttribute );

				}

				index = wireframeAttribute;

			}

			return index;

		}

	}

	class Info {

		constructor() {

			this.autoReset = true;

			this.render = {
				frame: 0,
				drawCalls: 0,
				triangles: 0,
				points: 0,
				lines: 0
			};

			this.memory = {
				geometries: 0,
				textures: 0
			};

		}

		update( object, count, instanceCount ) {

			this.render.drawCalls ++;

			if ( object.isMesh || object.isSprite ) {

				this.render.triangles += instanceCount * ( count / 3 );

			} else if ( object.isPoints ) {

				this.render.points += instanceCount * count;

			} else if ( object.isLineSegments ) {

				this.render.lines += instanceCount * ( count / 2 );

			} else if ( object.isLine ) {

				this.render.lines += instanceCount * ( count - 1 );

			} else ;

		}

		reset() {

			this.render.drawCalls = 0;
			this.render.triangles = 0;
			this.render.points = 0;
			this.render.lines = 0;

		}

		dispose() {

			this.reset();

			this.render.frame = 0;

			this.memory.geometries = 0;
			this.memory.textures = 0;

		}

	}

	class Pipeline {

		constructor( cacheKey ) {

			this.cacheKey = cacheKey;

			this.usedTimes = 0;

		}

	}

	class RenderPipeline extends Pipeline {

		constructor( cacheKey, vertexProgram, fragmentProgram ) {

			super( cacheKey );

			this.vertexProgram = vertexProgram;
			this.fragmentProgram = fragmentProgram;

		}

	}

	class ComputePipeline extends Pipeline {

		constructor( cacheKey, computeProgram ) {

			super( cacheKey );

			this.computeProgram = computeProgram;

			this.isComputePipeline = true;

		}

	}

	let _id = 0;

	class ProgrammableStage {

		constructor( code, type ) {

			this.id = _id ++;

			this.code = code;
			this.stage = type;

			this.usedTimes = 0;

		}

	}

	class Pipelines extends DataMap {

		constructor( backend, nodes ) {

			super();

			this.backend = backend;
			this.nodes = nodes;

			this.bindings = null; // set by the bindings

			this.caches = new Map();
			this.programs = {
				vertex: new Map(),
				fragment: new Map(),
				compute: new Map()
			};

		}

		getForCompute( computeNode, bindings ) {

			const { backend } = this;

			const data = this.get( computeNode );

			if ( this._needsComputeUpdate( computeNode ) ) {

				const previousPipeline = data.pipeline;

				if ( previousPipeline ) {

					previousPipeline.usedTimes --;
					previousPipeline.computeProgram.usedTimes --;

				}

				// get shader

				const nodeBuilder = this.nodes.getForCompute( computeNode );

				// programmable stage

				let stageCompute = this.programs.compute.get( nodeBuilder.computeShader );

				if ( stageCompute === undefined ) {

					if ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );

					stageCompute = new ProgrammableStage( nodeBuilder.computeShader, 'compute' );
					this.programs.compute.set( nodeBuilder.computeShader, stageCompute );

					backend.createProgram( stageCompute );

				}

				// determine compute pipeline

				const cacheKey = this._getComputeCacheKey( computeNode, stageCompute );

				let pipeline = this.caches.get( cacheKey );

				if ( pipeline === undefined ) {

					if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( computeNode );

					pipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );

				}

				// keep track of all used times

				pipeline.usedTimes ++;
				stageCompute.usedTimes ++;

				//

				data.version = computeNode.version;
				data.pipeline = pipeline;

			}

			return data.pipeline;

		}

		getForRender( renderObject ) {

			const { backend } = this;

			const data = this.get( renderObject );

			if ( this._needsRenderUpdate( renderObject ) ) {

				const previousPipeline = data.pipeline;

				if ( previousPipeline ) {

					previousPipeline.usedTimes --;
					previousPipeline.vertexProgram.usedTimes --;
					previousPipeline.fragmentProgram.usedTimes --;

				}

				// get shader

				const nodeBuilder = this.nodes.getForRender( renderObject );

				// programmable stages

				let stageVertex = this.programs.vertex.get( nodeBuilder.vertexShader );

				if ( stageVertex === undefined ) {

					if ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );

					stageVertex = new ProgrammableStage( nodeBuilder.vertexShader, 'vertex' );
					this.programs.vertex.set( nodeBuilder.vertexShader, stageVertex );

					backend.createProgram( stageVertex );

				}

				let stageFragment = this.programs.fragment.get( nodeBuilder.fragmentShader );

				if ( stageFragment === undefined ) {

					if ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );

					stageFragment = new ProgrammableStage( nodeBuilder.fragmentShader, 'fragment' );
					this.programs.fragment.set( nodeBuilder.fragmentShader, stageFragment );

					backend.createProgram( stageFragment );

				}

				// determine render pipeline

				const cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

				let pipeline = this.caches.get( cacheKey );

				if ( pipeline === undefined ) {

					if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

					pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey );

				} else {

					renderObject.pipeline = pipeline;

				}

				// keep track of all used times

				pipeline.usedTimes ++;
				stageVertex.usedTimes ++;
				stageFragment.usedTimes ++;

				//

				data.pipeline = pipeline;

			}

			return data.pipeline;

		}

		delete( object ) {

			const pipeline = this.get( object ).pipeline;

			if ( pipeline ) {

				// pipeline

				pipeline.usedTimes --;

				if ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );

				// programs

				if ( pipeline.isComputePipeline ) {

					pipeline.computeProgram.usedTimes --;

					if ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );

				} else {

					pipeline.fragmentProgram.usedTimes --;
					pipeline.vertexProgram.usedTimes --;

					if ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );
					if ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );

				}

			}

			super.delete( object );

		}

		dispose() {

			super.dispose();

			this.caches = new Map();
			this.programs = {
				vertex: new Map(),
				fragment: new Map(),
				compute: new Map()
			};

		}

		updateForRender( renderObject ) {

			this.getForRender( renderObject );

		}

		_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {

			// check for existing pipeline

			cacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				pipeline = new ComputePipeline( cacheKey, stageCompute );

				this.caches.set( cacheKey, pipeline );

				this.backend.createComputePipeline( pipeline, bindings );

			}

			return pipeline;

		}

		_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey ) {

			// check for existing pipeline

			cacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				pipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );

				this.caches.set( cacheKey, pipeline );

				renderObject.pipeline = pipeline;

				this.backend.createRenderPipeline( renderObject );

			}

			return pipeline;

		}

		_getComputeCacheKey( computeNode, stageCompute ) {

			return 'compute' + computeNode.id + stageCompute.id;

		}

		_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {

			const { material } = renderObject;

			const parameters = [
				stageVertex.id, stageFragment.id,
				material.transparent, material.blending, material.premultipliedAlpha,
				material.blendSrc, material.blendDst, material.blendEquation,
				material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
				material.colorWrite,
				material.depthWrite, material.depthTest, material.depthFunc,
				material.stencilWrite, material.stencilFunc,
				material.stencilFail, material.stencilZFail, material.stencilZPass,
				material.stencilFuncMask, material.stencilWriteMask,
				material.side,
				this.backend.getCacheKey( renderObject )
			];

			return parameters.join();

		}

		_releasePipeline( pipeline ) {

			this.caches.delete( pipeline.cacheKey );

		}

		_releaseProgram( program ) {

			const code = program.code;
			const stage = program.stage;

			this.programs[ stage ].delete( code );

		}

		_needsComputeUpdate( computeNode ) {

			const data = this.get( computeNode );

			return data.pipeline === undefined || data.version !== computeNode.version;

		}

		_needsRenderUpdate( renderObject ) {

			const data = this.get( renderObject );
			const material = renderObject.material;

			let needsUpdate = this.backend.needsUpdate( renderObject );

			// check material state

			if ( data.material !== material || data.materialVersion !== material.version ||
				data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
				data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
				data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
				data.colorWrite !== material.colorWrite ||
				data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
				data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
				data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
				data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
				data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage
			) {

				data.material = material; data.materialVersion = material.version;
				data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
				data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
				data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
				data.colorWrite = material.colorWrite;
				data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
				data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
				data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
				data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
				data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;

				needsUpdate = true;

			}

			return needsUpdate || data.pipeline === undefined;

		}

	}

	class Bindings extends DataMap {

		constructor( backend, nodes, textures, attributes, pipelines, info ) {

			super();

			this.backend = backend;
			this.textures = textures;
			this.pipelines = pipelines;
			this.attributes = attributes;
			this.nodes = nodes;
			this.info = info;

			this.pipelines.bindings = this; // assign bindings to pipelines

			this.updateMap = new WeakMap();

		}

		getForRender( renderObject ) {

			const bindings = renderObject.getBindings();

			const data = this.get( renderObject );

			if ( data.bindings !== bindings ) {

				// each object defines an array of bindings (ubos, textures, samplers etc.)

				data.bindings = bindings;

				this._init( bindings );

				this.backend.createBindings( bindings );

			}

			return data.bindings;

		}

		getForCompute( computeNode ) {

			const data = this.get( computeNode );

			if ( data.bindings === undefined ) {

				const nodeBuilder = this.nodes.getForCompute( computeNode );

				const bindings = nodeBuilder.getBindings();

				data.bindings = bindings;

				this._init( bindings );

				this.backend.createBindings( bindings );

			}

			return data.bindings;

		}

		updateForCompute( computeNode ) {

			this._update( computeNode, this.getForCompute( computeNode ) );

		}

		updateForRender( renderObject ) {

			this._update( renderObject, this.getForRender( renderObject ) );

		}

		_init( bindings ) {

			for ( const binding of bindings ) {

				if ( binding.isSampler || binding.isSampledTexture ) {

					this.textures.updateTexture( binding.texture );

				} else if ( binding.isStorageBuffer ) {

					const attribute = binding.attribute;

					this.attributes.update( attribute, AttributeType.STORAGE );

				}

			}

		}

		_update( object, bindings ) {

			const { backend } = this;

			const updateMap = this.updateMap;
			const frame = this.info.render.frame;

			let needsBindingsUpdate = false;

			// iterate over all bindings and check if buffer updates or a new binding group is required

			for ( const binding of bindings ) {

				const isShared = binding.isShared;
				const isUpdated = updateMap.get( binding ) === frame;

				if ( isShared && isUpdated ) continue;

				if ( binding.isUniformBuffer ) {

					const needsUpdate = binding.update();

					if ( needsUpdate ) {

						backend.updateBinding( binding );

					}

				} else if ( binding.isSampledTexture ) {

					if ( binding.needsBindingsUpdate ) needsBindingsUpdate = true;

					const needsUpdate = binding.update();

					if ( needsUpdate ) {

						this.textures.updateTexture( binding.texture );

					}

				}

				updateMap.set( binding, frame );

			}

			if ( needsBindingsUpdate === true ) {

				const pipeline = this.pipelines.getForRender( object );

				this.backend.updateBindings( bindings, pipeline );

			}

		}

		dispose() {

			super.dispose();

			this.updateMap = new WeakMap();

		}

	}

	const NodeShaderStage = {
		VERTEX: 'vertex',
		FRAGMENT: 'fragment'
	};

	const NodeUpdateType = {
		NONE: 'none',
		FRAME: 'frame',
		RENDER: 'render',
		OBJECT: 'object'
	};

	const defaultShaderStages = [ 'fragment', 'vertex' ];
	const defaultBuildStages = [ 'construct', 'analyze', 'generate' ];
	const shaderStages = [ ...defaultShaderStages, 'compute' ];
	const vectorComponents = [ 'x', 'y', 'z', 'w' ];

	function getCacheKey( object ) {

		let cacheKey = '{';

		if ( object.isNode === true ) {

			cacheKey += `uuid:"${ object.uuid }"`;

		}

		for ( const { property, index, childNode } of getNodeChildren( object ) ) {

			// @TODO: Think about implement NodeArray and NodeObject.

			let childCacheKey = getCacheKey( childNode );
			if ( ! childCacheKey.includes( ',' ) ) childCacheKey = childCacheKey.slice( childCacheKey.indexOf( '"' ), childCacheKey.indexOf( '}' ) );
			cacheKey += `,${ property }${ index !== undefined ? '/' + index : '' }:${ childCacheKey }`;

		}

		cacheKey += '}';

		return cacheKey;

	}

	function* getNodeChildren( node, toJSON = false ) {

		for ( const property in node ) {

			// Ignore private properties.
			if ( property.startsWith( '_' ) === true ) continue;

			const object = node[ property ];

			if ( Array.isArray( object ) === true ) {

				for ( let i = 0; i < object.length; i ++ ) {

					const child = object[ i ];

					if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

						yield { property, index: i, childNode: child };

					}

				}

			} else if ( object && object.isNode === true ) {

				yield { property, childNode: object };

			} else if ( typeof object === 'object' ) {

				for ( const subProperty in object ) {

					const child = object[ subProperty ];

					if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

						yield { property, index: subProperty, childNode: child };

					}

				}

			}

		}

	}

	function getValueType( value ) {

		if ( value === undefined || value === null ) return null;

		const typeOf = typeof value;

		if ( value.isNode === true ) {

			return 'node';

		} else if ( typeOf === 'number' ) {

			return 'float';

		} else if ( typeOf === 'boolean' ) {

			return 'bool';

		} else if ( typeOf === 'string' ) {

			return 'string';

		} else if ( typeOf === 'function' ) {

			return 'shader';

		} else if ( value.isVector2 === true ) {

			return 'vec2';

		} else if ( value.isVector3 === true ) {

			return 'vec3';

		} else if ( value.isVector4 === true ) {

			return 'vec4';

		} else if ( value.isMatrix3 === true ) {

			return 'mat3';

		} else if ( value.isMatrix4 === true ) {

			return 'mat4';

		} else if ( value.isColor === true ) {

			return 'color';

		} else if ( value instanceof ArrayBuffer ) {

			return 'ArrayBuffer';

		}

		return null;

	}

	function getValueFromType( type, ...params ) {

		const last4 = type ? type.slice( - 4 ) : undefined;

		if ( ( last4 === 'vec2' || last4 === 'vec3' || last4 === 'vec4' ) && params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()

			params = last4 === 'vec2' ? [ params[ 0 ], params[ 0 ] ] : [ params[ 0 ], params[ 0 ], params[ 0 ] ];

		}

		if ( type === 'color' ) {

			return new Color( ...params );

		} else if ( last4 === 'vec2' ) {

			return new Vector2( ...params );

		} else if ( last4 === 'vec3' ) {

			return new Vector3( ...params );

		} else if ( last4 === 'vec4' ) {

			return new Vector4( ...params );

		} else if ( last4 === 'mat3' ) {

			return new Matrix3( ...params );

		} else if ( last4 === 'mat4' ) {

			return new Matrix4( ...params );

		} else if ( type === 'bool' ) {

			return params[ 0 ] || false;

		} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {

			return params[ 0 ] || 0;

		} else if ( type === 'string' ) {

			return params[ 0 ] || '';

		} else if ( type === 'ArrayBuffer' ) {

			return base64ToArrayBuffer( params[ 0 ] );

		}

		return null;

	}

	function arrayBufferToBase64( arrayBuffer ) {

		let chars = '';

		const array = new Uint8Array( arrayBuffer );

		for ( let i = 0; i < array.length; i ++ ) {

			chars += String.fromCharCode( array[ i ] );

		}

		return btoa( chars );

	}

	function base64ToArrayBuffer( base64 ) {

		return Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;

	}

	const NodeClasses = new Map();

	let _nodeId = 0;

	class Node extends EventDispatcher {

		constructor( nodeType = null ) {

			super();

			this.nodeType = nodeType;

			this.updateType = NodeUpdateType.NONE;
			this.updateBeforeType = NodeUpdateType.NONE;

			this.uuid = MathUtils$1.generateUUID();

			this.isNode = true;

			Object.defineProperty( this, 'id', { value: _nodeId ++ } );

		}

		get type() {

			return this.constructor.name;

		}

		isGlobal( /*builder*/ ) {

			return false;

		}

		* getChildren() {

			const self = this;

			for ( const { property, index, childNode } of getNodeChildren( this ) ) {

				yield { childNode, replaceNode( node ) {

					if ( index === undefined ) self[ property ] = node;
					else self[ property ][ index ] = node;

				} };

			}

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		traverse( callback, replaceNode = null ) {

			callback( this, replaceNode );

			for ( const { childNode, replaceNode } of this.getChildren() ) {

				childNode.traverse( callback, replaceNode );

			}

		}

		getCacheKey() {

			return getCacheKey( this );

		}

		getHash( /*builder*/ ) {

			return this.uuid;

		}

		getUpdateType() {

			return this.updateType;

		}

		getUpdateBeforeType() {

			return this.updateBeforeType;

		}

		getNodeType( /*builder*/ ) {

			return this.nodeType;

		}

		getReference( builder ) {

			const hash = this.getHash( builder );
			const nodeFromHash = builder.getNodeFromHash( hash );

			return nodeFromHash || this;

		}

		construct( builder ) {

			const nodeProperties = builder.getNodeProperties( this );

			for ( const { childNode } of this.getChildren() ) {

				nodeProperties[ '_node' + childNode.id ] = childNode;

			}

			// return a outputNode if exists
			return null;

		}

		analyze( builder ) {

			const nodeData = builder.getDataFromNode( this );
			nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;

			if ( nodeData.dependenciesCount === 1 ) {

				// node flow children

				const nodeProperties = builder.getNodeProperties( this );

				for ( const childNode of Object.values( nodeProperties ) ) {

					if ( childNode && childNode.isNode === true ) {

						childNode.build( builder );

					}

				}

			}

		}

		generate( builder, output ) {

			const { outputNode } = builder.getNodeProperties( this );

			if ( outputNode && outputNode.isNode === true ) {

				return outputNode.build( builder, output );

			}

		}

		updateBefore( /*frame*/ ) {

		}

		update( /*frame*/ ) {

		}

		build( builder, output = null ) {

			const refNode = this.getReference( builder );

			if ( this !== refNode ) {

				return refNode.build( builder, output );

			}

			builder.addNode( this );
			builder.addChain( this );

			/* Build stages expected results:
				- "construct"	-> Node
				- "analyze"		-> null
				- "generate"	-> String
			*/
			let result = null;

			const buildStage = builder.getBuildStage();

			if ( buildStage === 'construct' ) {

				const properties = builder.getNodeProperties( this );

				if ( properties.initialized !== true || builder.context.tempRead === false ) {

					const stackNodesBeforeConstruct = builder.stack.nodes.length;

					properties.initialized = true;
					properties.outputNode = this.construct( builder );

					if ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeConstruct ) {

						properties.outputNode = builder.stack;

					}

					for ( const childNode of Object.values( properties ) ) {

						if ( childNode && childNode.isNode === true ) {

							childNode.build( builder );

						}

					}

				}

			} else if ( buildStage === 'analyze' ) {

				this.analyze( builder );

			} else if ( buildStage === 'generate' ) {

				const isGenerateOnce = this.generate.length === 1;

				if ( isGenerateOnce ) {

					const type = this.getNodeType( builder );
					const nodeData = builder.getDataFromNode( this );

					result = nodeData.snippet;

					if ( result === undefined /*|| builder.context.tempRead === false*/ ) {

						result = this.generate( builder ) || '';

						nodeData.snippet = result;

					}

					result = builder.format( result, type, output );

				} else {

					result = this.generate( builder, output ) || '';

				}

			}

			builder.removeChain( this );

			return result;

		}

		getSerializeChildren() {

			return getNodeChildren( this );

		}

		serialize( json ) {

			const nodeChildren = this.getSerializeChildren();

			const inputNodes = {};

			for ( const { property, index, childNode } of nodeChildren ) {

				if ( index !== undefined ) {

					if ( inputNodes[ property ] === undefined ) {

						inputNodes[ property ] = Number.isInteger( index ) ? [] : {};

					}

					inputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;

				} else {

					inputNodes[ property ] = childNode.toJSON( json.meta ).uuid;

				}

			}

			if ( Object.keys( inputNodes ).length > 0 ) {

				json.inputNodes = inputNodes;

			}

		}

		deserialize( json ) {

			if ( json.inputNodes !== undefined ) {

				const nodes = json.meta.nodes;

				for ( const property in json.inputNodes ) {

					if ( Array.isArray( json.inputNodes[ property ] ) ) {

						const inputArray = [];

						for ( const uuid of json.inputNodes[ property ] ) {

							inputArray.push( nodes[ uuid ] );

						}

						this[ property ] = inputArray;

					} else if ( typeof json.inputNodes[ property ] === 'object' ) {

						const inputObject = {};

						for ( const subProperty in json.inputNodes[ property ] ) {

							const uuid = json.inputNodes[ property ][ subProperty ];

							inputObject[ subProperty ] = nodes[ uuid ];

						}

						this[ property ] = inputObject;

					} else {

						const uuid = json.inputNodes[ property ];

						this[ property ] = nodes[ uuid ];

					}

				}

			}

		}

		toJSON( meta ) {

			const { uuid, type } = this;
			const isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {},
					nodes: {}
				};

			}

			// serialize

			let data = meta.nodes[ uuid ];

			if ( data === undefined ) {

				data = {
					uuid,
					type,
					meta,
					metadata: {
						version: 4.6,
						type: 'Node',
						generator: 'Node.toJSON'
					}
				};

				if ( isRoot !== true ) meta.nodes[ data.uuid ] = data;

				this.serialize( data );

				delete data.meta;

			}

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const nodes = extractFromCache( meta.nodes );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;
				if ( nodes.length > 0 ) data.nodes = nodes;

			}

			return data;

		}

	}

	function addNodeClass( nodeClass ) {

		if ( typeof nodeClass !== 'function' || ! nodeClass.name ) throw new Error( `Node class ${ nodeClass.name } is not a class` );
		if ( NodeClasses.has( nodeClass.name ) ) throw new Error( `Redefinition of node class ${ nodeClass.name }` );

		NodeClasses.set( nodeClass.name, nodeClass );

	}

	class InputNode extends Node {

		constructor( value, nodeType = null ) {

			super( nodeType );

			this.isInputNode = true;

			this.value = value;
			this.precision = null;

		}

		getNodeType( /*builder*/ ) {

			if ( this.nodeType === null ) {

				return getValueType( this.value );

			}

			return this.nodeType;

		}

		getInputType( builder ) {

			return this.getNodeType( builder );

		}

		setPrecision( precision ) {

			this.precision = precision;

			return this;

		}

		serialize( data ) {

			super.serialize( data );

			data.value = this.value;

			if ( this.value && this.value.toArray ) data.value = this.value.toArray();

			data.valueType = getValueType( this.value );
			data.nodeType = this.nodeType;

			if ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );

			data.precision = this.precision;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.nodeType = data.nodeType;
			this.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;

			this.precision = data.precision || null;

			if ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );

		}

		generate( /*builder, output*/ ) {

		}

	}

	addNodeClass( InputNode );

	class ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute

		constructor( node, indexNode ) {

			super();

			this.node = node;
			this.indexNode = indexNode;

		}

		getNodeType( builder ) {

			return this.node.getNodeType( builder );

		}

		generate( builder ) {

			const nodeSnippet = this.node.build( builder );
			const indexSnippet = this.indexNode.build( builder, 'uint' );

			return `${nodeSnippet}[ ${indexSnippet} ]`;

		}

	}

	addNodeClass( ArrayElementNode );

	class ConvertNode extends Node {

		constructor( node, convertTo ) {

			super();

			this.node = node;
			this.convertTo = convertTo;

		}

		getNodeType( builder ) {

			const requestType = this.node.getNodeType( builder );

			let convertTo = null;

			for ( const overloadingType of this.convertTo.split( '|' ) ) {

				if ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {

					convertTo = overloadingType;

				}

			}

			return convertTo;

		}

		serialize( data ) {

			super.serialize( data );

			data.convertTo = this.convertTo;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.convertTo = data.convertTo;

		}

		generate( builder, output ) {

			const node = this.node;
			const type = this.getNodeType( builder );

			const snippet = node.build( builder, type );

			return builder.format( snippet, type, output );

		}

	}

	addNodeClass( ConvertNode );

	class TempNode extends Node {

		constructor( type ) {

			super( type );

			this.isTempNode = true;

		}

		hasDependencies( builder ) {

			return builder.getDataFromNode( this ).dependenciesCount > 1;

		}

		build( builder, output ) {

			const buildStage = builder.getBuildStage();

			if ( buildStage === 'generate' ) {

				const type = builder.getVectorType( this.getNodeType( builder, output ) );
				const nodeData = builder.getDataFromNode( this );

				if ( builder.context.tempRead !== false && nodeData.propertyName !== undefined ) {

					return builder.format( nodeData.propertyName, type, output );

				} else if ( builder.context.tempWrite !== false && type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {

					const snippet = super.build( builder, type );

					const nodeVar = builder.getVarFromNode( this, type );
					const propertyName = builder.getPropertyName( nodeVar );

					builder.addLineFlowCode( `${propertyName} = ${snippet}` );

					nodeData.snippet = snippet;
					nodeData.propertyName = propertyName;

					return builder.format( nodeData.propertyName, type, output );

				}

			}

			return super.build( builder, output );

		}

	}

	addNodeClass( TempNode );

	class JoinNode extends TempNode {

		constructor( nodes = [], nodeType = null ) {

			super( nodeType );

			this.nodes = nodes;

		}

		getNodeType( builder ) {

			if ( this.nodeType !== null ) {

				return builder.getVectorType( this.nodeType );

			}

			return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

		}

		generate( builder, output ) {

			const type = this.getNodeType( builder );
			const nodes = this.nodes;

			const snippetValues = [];

			for ( const input of nodes ) {

				const inputSnippet = input.build( builder );

				snippetValues.push( inputSnippet );

			}

			const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

			return builder.format( snippet, type, output );

		}

	}

	addNodeClass( JoinNode );

	const stringVectorComponents = vectorComponents.join( '' );

	class SplitNode extends Node {

		constructor( node, components = 'x' ) {

			super();

			this.node = node;
			this.components = components;

		}

		getVectorLength() {

			let vectorLength = this.components.length;

			for ( const c of this.components ) {

				vectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );

			}

			return vectorLength;

		}

		getNodeType( builder ) {

			return builder.getTypeFromLength( this.components.length );

		}

		generate( builder, output ) {

			const node = this.node;
			const nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );

			let snippet = null;

			if ( nodeTypeLength > 1 ) {

				let type = null;

				const componentsLength = this.getVectorLength();

				if ( componentsLength >= nodeTypeLength ) {

					// needed expand the input node

					type = builder.getTypeFromLength( this.getVectorLength() );

				}

				const nodeSnippet = node.build( builder, type );

				if ( this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice( 0, this.components.length ) ) {

					// unecessary swizzle

					snippet = builder.format( nodeSnippet, type, output );

				} else {

					snippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );

				}

			} else {

				// ignore .components if .node returns float/integer

				snippet = node.build( builder, output );

			}

			return snippet;

		}

		serialize( data ) {

			super.serialize( data );

			data.components = this.components;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.components = data.components;

		}

	}

	addNodeClass( SplitNode );

	class ConstNode extends InputNode {

		constructor( value, nodeType = null ) {

			super( value, nodeType );

			this.isConstNode = true;

		}

		generateConst( builder ) {

			return builder.getConst( this.getNodeType( builder ), this.value );

		}

		generate( builder, output ) {

			const type = this.getNodeType( builder );

			return builder.format( this.generateConst( builder ), type, output );

		}

	}

	addNodeClass( ConstNode );

	const NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others

	function addNodeElement( name, nodeElement ) {

		if ( NodeElements.has( name ) ) throw new Error( `Redefinition of node element ${ name }` );
		if ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );

		NodeElements.set( name, nodeElement );

	}

	const shaderNodeHandler = {

		construct( NodeClosure, params ) {

			const inputs = params.shift();

			return NodeClosure( nodeObjects( inputs ), ...params );

		},

		get: function ( node, prop, nodeObj ) {

			if ( typeof prop === 'string' && node[ prop ] === undefined ) {

				if ( NodeElements.has( prop ) ) {

					const nodeElement = NodeElements.get( prop );

					return ( ...params ) => nodeElement( nodeObj, ...params );

				} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {

					const nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );

					return ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );

				} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {

					// accessing properties ( swizzle )

					prop = prop
						.replace( /r|s/g, 'x' )
						.replace( /g|t/g, 'y' )
						.replace( /b|p/g, 'z' )
						.replace( /a|q/g, 'w' );

					return nodeObject( new SplitNode( node, prop ) );

				} else if ( prop === 'width' || prop === 'height' ) {

					// accessing property

					return nodeObject( new SplitNode( node, prop === 'width' ? 'x' : 'y' ) );

				} else if ( /^\d+$/.test( prop ) === true ) {

					// accessing array

					return nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );

				}

			}

			return node[ prop ];

		}

	};

	const nodeObjectsCacheMap = new WeakMap();

	const ShaderNodeObject = function ( obj, altType = null ) {

		const type = getValueType( obj );

		if ( type === 'node' ) {

			let nodeObject = nodeObjectsCacheMap.get( obj );

			if ( nodeObject === undefined ) {

				nodeObject = new Proxy( obj, shaderNodeHandler );
				nodeObjectsCacheMap.set( obj, nodeObject );
				nodeObjectsCacheMap.set( nodeObject, nodeObject );

			}

			return nodeObject;

		} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {

			return nodeObject( getConstNode( obj, altType ) );

		} else if ( type === 'shader' ) {

			return tslFn( obj );

		}

		return obj;

	};

	const ShaderNodeObjects = function ( objects, altType = null ) {

		for ( const name in objects ) {

			objects[ name ] = nodeObject( objects[ name ], altType );

		}

		return objects;

	};

	const ShaderNodeArray = function ( array, altType = null ) {

		const len = array.length;

		for ( let i = 0; i < len; i ++ ) {

			array[ i ] = nodeObject( array[ i ], altType );

		}

		return array;

	};

	const ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {

		const assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );

		if ( scope === null ) {

			return ( ...params ) => {

				return assignNode( new NodeClass( ...nodeArray( params ) ) );

			};

		} else if ( factor !== null ) {

			factor = nodeObject( factor );

			return ( ...params ) => {

				return assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );

			};

		} else {

			return ( ...params ) => {

				return assignNode( new NodeClass( scope, ...nodeArray( params ) ) );

			};

		}

	};

	const ShaderNodeImmutable = function ( NodeClass, ...params ) {

		return nodeObject( new NodeClass( ...nodeArray( params ) ) );

	};

	class ShaderNodeInternal extends Node {

		constructor( jsFunc ) {

			super();

			this._jsFunc = jsFunc;

		}

		call( inputs, stack, builder ) {

			inputs = nodeObjects( inputs );

			return nodeObject( this._jsFunc( inputs, stack, builder ) );

		}

		getNodeType( builder ) {

			const { outputNode } = builder.getNodeProperties( this );

			return outputNode ? outputNode.getNodeType( builder ) : super.getNodeType( builder );

		}

		construct( builder ) {

			builder.addStack();

			builder.stack.outputNode = nodeObject( this._jsFunc( builder.stack, builder ) );

			return builder.removeStack();

		}

	}

	const bools = [ false, true ];
	const uints = [ 0, 1, 2, 3 ];
	const ints = [ - 1, - 2 ];
	const floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];

	const boolsCacheMap = new Map();
	for ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );

	const uintsCacheMap = new Map();
	for ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );

	const intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );
	for ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );

	const floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );
	for ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );
	for ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );

	const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };

	const constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );

	const getConstNode = ( value, type ) => {

		if ( constNodesCacheMap.has( value ) ) {

			return constNodesCacheMap.get( value );

		} else if ( value.isNode === true ) {

			return value;

		} else {

			return new ConstNode( value, type );

		}

	};

	const safeGetNodeType = ( node ) => {

		try {

			return node.getNodeType();

		} catch ( _ ) {

			return undefined;

		}

	};

	const ConvertType = function ( type, cacheMap = null ) {

		return ( ...params ) => {

			if ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {

				params = [ getValueFromType( type, ...params ) ];

			}

			if ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {

				return nodeObject( cacheMap.get( params[ 0 ] ) );

			}

			if ( params.length === 1 ) {

				const node = getConstNode( params[ 0 ], type );
				if ( safeGetNodeType( node ) === type ) return nodeObject( node );
				return nodeObject( new ConvertNode( node, type ) );

			}

			const nodes = params.map( param => getConstNode( param ) );
			return nodeObject( new JoinNode( nodes, type ) );

		};

	};

	// exports

	// utils

	const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;

	// shader node base

	function ShaderNode( jsFunc ) {

		return new Proxy( new ShaderNodeInternal( jsFunc ), shaderNodeHandler );

	}

	const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );
	const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );
	const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );
	const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );
	const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );

	const shader = ( jsFunc ) => { // @deprecated, r154

		return new ShaderNode( jsFunc );

	};

	const tslFn = ( jsFunc ) => {

		let shaderNode = null;

		return ( ...params ) => {

			if ( shaderNode === null ) shaderNode = new ShaderNode( jsFunc );

			return shaderNode.call( ...params );

		};

	};

	addNodeClass( ShaderNode );

	// types
	// @TODO: Maybe export from ConstNode.js?

	const color$1 = new ConvertType( 'color' );

	const float = new ConvertType( 'float', cacheMaps.float );
	const int = new ConvertType( 'int', cacheMaps.int );
	const uint = new ConvertType( 'uint', cacheMaps.uint );
	const bool = new ConvertType( 'bool', cacheMaps.bool );

	const vec2 = new ConvertType( 'vec2' );
	const ivec2 = new ConvertType( 'ivec2' );
	const uvec2 = new ConvertType( 'uvec2' );
	const bvec2 = new ConvertType( 'bvec2' );

	const vec3 = new ConvertType( 'vec3' );
	const ivec3 = new ConvertType( 'ivec3' );
	const uvec3 = new ConvertType( 'uvec3' );
	const bvec3 = new ConvertType( 'bvec3' );

	const vec4 = new ConvertType( 'vec4' );
	const ivec4 = new ConvertType( 'ivec4' );
	const uvec4 = new ConvertType( 'uvec4' );
	const bvec4 = new ConvertType( 'bvec4' );

	const mat3 = new ConvertType( 'mat3' );
	const imat3 = new ConvertType( 'imat3' );
	const umat3 = new ConvertType( 'umat3' );
	const bmat3 = new ConvertType( 'bmat3' );

	const mat4 = new ConvertType( 'mat4' );
	const imat4 = new ConvertType( 'imat4' );
	const umat4 = new ConvertType( 'umat4' );
	const bmat4 = new ConvertType( 'bmat4' );

	const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );
	const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );

	addNodeElement( 'color', color$1 );
	addNodeElement( 'float', float );
	addNodeElement( 'int', int );
	addNodeElement( 'uint', uint );
	addNodeElement( 'bool', bool );
	addNodeElement( 'vec2', vec2 );
	addNodeElement( 'ivec2', ivec2 );
	addNodeElement( 'uvec2', uvec2 );
	addNodeElement( 'bvec2', bvec2 );
	addNodeElement( 'vec3', vec3 );
	addNodeElement( 'ivec3', ivec3 );
	addNodeElement( 'uvec3', uvec3 );
	addNodeElement( 'bvec3', bvec3 );
	addNodeElement( 'vec4', vec4 );
	addNodeElement( 'ivec4', ivec4 );
	addNodeElement( 'uvec4', uvec4 );
	addNodeElement( 'bvec4', bvec4 );
	addNodeElement( 'mat3', mat3 );
	addNodeElement( 'imat3', imat3 );
	addNodeElement( 'umat3', umat3 );
	addNodeElement( 'bmat3', bmat3 );
	addNodeElement( 'mat4', mat4 );
	addNodeElement( 'imat4', imat4 );
	addNodeElement( 'umat4', umat4 );
	addNodeElement( 'bmat4', bmat4 );
	addNodeElement( 'string', string );
	addNodeElement( 'arrayBuffer', arrayBuffer );

	// basic nodes
	// HACK - we cannot export them from the corresponding files because of the cyclic dependency
	const element = nodeProxy( ArrayElementNode );
	const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );

	addNodeElement( 'element', element );
	addNodeElement( 'convert', convert );

	class UniformNode extends InputNode {

		constructor( value, nodeType = null ) {

			super( value, nodeType );

			this.isUniformNode = true;

		}

		getUniformHash( builder ) {

			return this.getHash( builder );

		}

		generate( builder, output ) {

			const type = this.getNodeType( builder );

			const hash = this.getUniformHash( builder );

			let sharedNode = builder.getNodeFromHash( hash );

			if ( sharedNode === undefined ) {

				builder.setHashNode( this, hash );

				sharedNode = this;

			}

			const sharedNodeType = sharedNode.getInputType( builder );

			const nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, builder.context.label );
			const propertyName = builder.getPropertyName( nodeUniform );

			return builder.format( propertyName, type, output );

		}

	}

	const uniform = ( arg1, arg2 ) => {

		const nodeType = getConstNodeType( arg2 || arg1 );

		// @TODO: get ConstNode from .traverse() in the future
		const value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;

		return nodeObject( new UniformNode( value, nodeType ) );

	};

	addNodeClass( UniformNode );

	class ArrayUniformNode extends UniformNode {

		constructor( nodes = [] ) {

			super();

			this.isArrayUniformNode = true;

			this.nodes = nodes;

		}

		getNodeType( builder ) {

			return this.nodes[ 0 ].getNodeType( builder );

		}

	}

	addNodeClass( ArrayUniformNode );

	class VaryingNode extends Node {

		constructor( node, name = null ) {

			super();

			this.node = node;
			this.name = name;

		}

		isGlobal() {

			return true;

		}

		getHash( builder ) {

			return this.name || super.getHash( builder );

		}

		getNodeType( builder ) {

			// VaryingNode is auto type

			return this.node.getNodeType( builder );

		}

		generate( builder ) {

			const { name, node } = this;
			const type = this.getNodeType( builder );

			const nodeVarying = builder.getVaryingFromNode( this, type );

			// this property can be used to check if the varying can be optimized for a var
			nodeVarying.needsInterpolation || ( nodeVarying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );

			if ( name !== null ) {

				nodeVarying.name = name;

			}

			const propertyName = builder.getPropertyName( nodeVarying, NodeShaderStage.VERTEX );

			// force node run in vertex stage
			builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, node, type, propertyName );

			return builder.getPropertyName( nodeVarying );

		}

	}

	const varying = nodeProxy( VaryingNode );

	addNodeElement( 'varying', varying );

	addNodeClass( VaryingNode );

	class AttributeNode extends Node {

		constructor( attributeName, nodeType = null ) {

			super( nodeType );

			this._attributeName = attributeName;

		}

		getHash( builder ) {

			return this.getAttributeName( builder );

		}

		getNodeType( builder ) {

			const attributeName = this.getAttributeName( builder );

			let nodeType = super.getNodeType( builder );

			if ( nodeType === null ) {

				if ( builder.hasGeometryAttribute( attributeName ) ) {

					const attribute = builder.geometry.getAttribute( attributeName );

					nodeType = builder.getTypeFromAttribute( attribute );

				} else {

					nodeType = 'float';

				}

			}

			return nodeType;

		}

		setAttributeName( attributeName ) {

			this._attributeName = attributeName;

			return this;

		}

		getAttributeName( /*builder*/ ) {

			return this._attributeName;

		}

		generate( builder ) {

			const attributeName = this.getAttributeName( builder );
			const nodeType = this.getNodeType( builder );
			const geometryAttribute = builder.hasGeometryAttribute( attributeName );

			if ( geometryAttribute === true ) {

				const attribute = builder.geometry.getAttribute( attributeName );
				const attributeType = builder.getTypeFromAttribute( attribute );

				const nodeAttribute = builder.getAttribute( attributeName, attributeType );

				if ( builder.shaderStage === 'vertex' ) {

					return builder.format( nodeAttribute.name, attributeType, nodeType );

				} else {

					const nodeVarying = varying( this );

					return nodeVarying.build( builder, nodeType );

				}

			} else {

				return builder.getConst( nodeType );

			}

		}

	}

	const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );

	addNodeClass( AttributeNode );

	class BypassNode extends Node {

		constructor( returnNode, callNode ) {

			super();

			this.isBypassNode = true;

			this.outputNode = returnNode;
			this.callNode = callNode;

		}

		getNodeType( builder ) {

			return this.outputNode.getNodeType( builder );

		}

		generate( builder ) {

			const snippet = this.callNode.build( builder, 'void' );

			if ( snippet !== '' ) {

				builder.addLineFlowCode( snippet );

			}

			return this.outputNode.build( builder );

		}

	}

	const bypass = nodeProxy( BypassNode );

	addNodeElement( 'bypass', bypass );

	addNodeClass( BypassNode );

	let id$2 = 0;

	class NodeCache {

		constructor() {

			this.id = id$2 ++;
			this.nodesData = new WeakMap();

		}

		getNodeData( node ) {

			return this.nodesData.get( node );

		}

		setNodeData( node, data ) {

			this.nodesData.set( node, data );

		}

	}

	class CacheNode extends Node {

		constructor( node, cache = new NodeCache() ) {

			super();

			this.isCacheNode = true;

			this.node = node;
			this.cache = cache;

		}

		getNodeType( builder ) {

			return this.node.getNodeType( builder );

		}

		build( builder, ...params ) {

			const previousCache = builder.getCache();

			builder.setCache( this.cache );

			const data = this.node.build( builder, ...params );

			builder.setCache( previousCache );

			return data;

		}

	}

	const cache = nodeProxy( CacheNode );

	addNodeElement( 'cache', cache );

	addNodeClass( CacheNode );

	class ContextNode extends Node {

		constructor( node, context = {} ) {

			super();

			this.isContextNode = true;

			this.node = node;
			this.context = context;

		}

		getNodeType( builder ) {

			return this.node.getNodeType( builder );

		}

		construct( builder ) {

			const previousContext = builder.getContext();

			builder.setContext( { ...builder.context, ...this.context } );

			const node = this.node.build( builder );

			builder.setContext( previousContext );

			return node;

		}

		generate( builder, output ) {

			const previousContext = builder.getContext();

			builder.setContext( { ...builder.context, ...this.context } );

			const snippet = this.node.build( builder, output );

			builder.setContext( previousContext );

			return snippet;

		}

	}

	const context = nodeProxy( ContextNode );
	const label = ( node, name ) => context( node, { label: name } );

	addNodeElement( 'context', context );
	addNodeElement( 'label', label );

	addNodeClass( ContextNode );

	class IndexNode extends Node {

		constructor( scope ) {

			super( 'uint' );

			this.scope = scope;

			this.isInstanceIndexNode = true;

		}

		generate( builder ) {

			const nodeType = this.getNodeType( builder );
			const scope = this.scope;

			let propertyName;

			if ( scope === IndexNode.VERTEX ) {

				propertyName = builder.getVertexIndex();

			} else if ( scope === IndexNode.INSTANCE ) {

				propertyName = builder.getInstanceIndex();

			} else {

				throw new Error( 'THREE.IndexNode: Unknown scope: ' + scope );

			}

			let output;

			if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

				output = propertyName;

			} else {

				const nodeVarying = varying( this );

				output = nodeVarying.build( builder, nodeType );

			}

			return output;

		}

	}

	IndexNode.VERTEX = 'vertex';
	IndexNode.INSTANCE = 'instance';

	nodeImmutable( IndexNode, IndexNode.VERTEX );
	const instanceIndex = nodeImmutable( IndexNode, IndexNode.INSTANCE );

	addNodeClass( IndexNode );

	class LightingModel {

		init( /*input, stack, builder*/ ) { }

		direct( /*input, stack, builder*/ ) { }

		indirectDiffuse( /*input, stack, builder*/ ) { }

		indirectSpecular( /*input, stack, builder*/ ) { }

		ambientOcclusion( /*input, stack, builder*/ ) { }

	}

	class NodeAttribute {

		constructor( name, type, node = null ) {

			this.isNodeAttribute = true;

			this.name = name;
			this.type = type;
			this.node = node;

		}

	}

	class NodeUniform {

		constructor( name, type, node, needsUpdate = undefined ) {

			this.isNodeUniform = true;

			this.name = name;
			this.type = type;
			this.node = node;
			this.needsUpdate = needsUpdate;

		}

		get value() {

			return this.node.value;

		}

		set value( val ) {

			this.node.value = val;

		}

	}

	class NodeVar {

		constructor( name, type ) {

			this.isNodeVar = true;

			this.name = name;
			this.type = type;

		}

	}

	class NodeVarying extends NodeVar {

		constructor( name, type ) {

			super( name, type );

			this.needsInterpolation = false;

			this.isNodeVarying = true;

		}

	}

	class NodeCode {

		constructor( name, type, code = '' ) {

			this.name = name;
			this.type = type;
			this.code = code;

			Object.defineProperty( this, 'isNodeCode', { value: true } );

		}

	}

	class NodeKeywords {

		constructor() {

			this.keywords = [];
			this.nodes = [];
			this.keywordsCallback = {};

		}

		getNode( name ) {

			let node = this.nodes[ name ];

			if ( node === undefined && this.keywordsCallback[ name ] !== undefined ) {

				node = this.keywordsCallback[ name ]( name );

				this.nodes[ name ] = node;

			}

			return node;

		}

		addKeyword( name, callback ) {

			this.keywords.push( name );
			this.keywordsCallback[ name ] = callback;

			return this;

		}

		parse( code ) {

			const keywordNames = this.keywords;

			const regExp = new RegExp( `\\b${keywordNames.join( '\\b|\\b' )}\\b`, 'g' );

			const codeKeywords = code.match( regExp );

			const keywordNodes = [];

			if ( codeKeywords !== null ) {

				for ( const keyword of codeKeywords ) {

					const node = this.getNode( keyword );

					if ( node !== undefined && keywordNodes.indexOf( node ) === - 1 ) {

						keywordNodes.push( node );

					}

				}

			}

			return keywordNodes;

		}

		include( builder, code ) {

			const keywordNodes = this.parse( code );

			for ( const keywordNode of keywordNodes ) {

				keywordNode.build( builder );

			}

		}

	}

	class PropertyNode extends Node {

		constructor( nodeType, name = null ) {

			super( nodeType );

			this.name = name;

		}

		getHash( builder ) {

			return this.name || super.getHash( builder );

		}

		isGlobal( /*builder*/ ) {

			return true;

		}

		generate( builder ) {

			const nodeVary = builder.getVarFromNode( this, this.getNodeType( builder ) );
			const name = this.name;

			if ( name !== null ) {

				nodeVary.name = name;

			}

			return builder.getPropertyName( nodeVary );

		}

	}

	const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );

	const diffuseColor = nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );
	const roughness = nodeImmutable( PropertyNode, 'float', 'Roughness' );
	const metalness = nodeImmutable( PropertyNode, 'float', 'Metalness' );
	const clearcoat = nodeImmutable( PropertyNode, 'float', 'Clearcoat' );
	const clearcoatRoughness = nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );
	const sheen = nodeImmutable( PropertyNode, 'vec3', 'Sheen' );
	const sheenRoughness = nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );
	const iridescence = nodeImmutable( PropertyNode, 'float', 'Iridescence' );
	const iridescenceIOR = nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );
	const iridescenceThickness = nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );
	const specularColor = nodeImmutable( PropertyNode, 'color', 'SpecularColor' );
	const shininess = nodeImmutable( PropertyNode, 'float', 'Shininess' );
	const output = nodeImmutable( PropertyNode, 'vec4', 'Output' );

	addNodeClass( PropertyNode );

	class UVNode extends AttributeNode {

		constructor( index = 0 ) {

			super( null, 'vec2' );

			this.isUVNode = true;

			this.index = index;

		}

		getAttributeName( /*builder*/ ) {

			const index = this.index;

			return 'uv' + ( index > 0 ? index : '' );

		}

		serialize( data ) {

			super.serialize( data );

			data.index = this.index;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.index = data.index;

		}

	}

	const uv = ( ...params ) => nodeObject( new UVNode( ...params ) );

	addNodeClass( UVNode );

	class TextureSizeNode extends Node {

		constructor( textureNode, levelNode = null ) {

			super( 'uvec2' );

			this.isTextureSizeNode = true;

			this.textureNode = textureNode;
			this.levelNode = levelNode;

		}

		generate( builder, output ) {

			const textureProperty = this.textureNode.build( builder, 'property' );
			const levelNode = this.levelNode.build( builder, 'int' );

			return builder.format( `textureDimensions( ${textureProperty}, ${levelNode} )`, this.getNodeType( builder ), output );

		}

	}

	const textureSize = nodeProxy( TextureSizeNode );

	addNodeElement( 'textureSize', textureSize );

	addNodeClass( TextureSizeNode );

	class OperatorNode extends TempNode {

		constructor( op, aNode, bNode, ...params ) {

			super();

			this.op = op;

			if ( params.length > 0 ) {

				let finalBNode = bNode;

				for ( let i = 0; i < params.length; i ++ ) {

					finalBNode = new OperatorNode( op, finalBNode, params[ i ] );

				}

				bNode = finalBNode;

			}

			this.aNode = aNode;
			this.bNode = bNode;

		}

		hasDependencies( builder ) {

			return this.op !== '=' ? super.hasDependencies( builder ) : false;

		}

		getNodeType( builder, output ) {

			const op = this.op;

			const aNode = this.aNode;
			const bNode = this.bNode;

			const typeA = aNode.getNodeType( builder );
			const typeB = bNode.getNodeType( builder );

			if ( typeA === 'void' || typeB === 'void' ) {

				return 'void';

			} else if ( op === '=' || op === '%' ) {

				return typeA;

			} else if ( op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {

				return builder.getIntegerType( typeA );

			} else if ( op === '==' || op === '&&' || op === '||' || op === '^^' ) {

				return 'bool';

			} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {

				const typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );

				return typeLength > 1 ? `bvec${ typeLength }` : 'bool';

			} else {

				if ( typeA === 'float' && builder.isMatrix( typeB ) ) {

					return typeB;

				} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

					// matrix x vector

					return builder.getVectorFromMatrix( typeA );

				} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

					// vector x matrix

					return builder.getVectorFromMatrix( typeB );

				} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {

					// anytype x anytype: use the greater length vector

					return typeB;

				}

				return typeA;

			}

		}

		generate( builder, output ) {

			const op = this.op;

			const aNode = this.aNode;
			const bNode = this.bNode;

			const type = this.getNodeType( builder, output );

			let typeA = null;
			let typeB = null;

			if ( type !== 'void' ) {

				typeA = aNode.getNodeType( builder );
				typeB = bNode.getNodeType( builder );

				if ( op === '=' ) {

					typeB = typeA;

				} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {

					if ( builder.isVector( typeA ) ) {

						typeB = typeA;

					} else {

						typeA = typeB = 'float';

					}

				} else if ( op === '>>' || op === '<<' ) {

					typeA = type;
					typeB = builder.changeComponentType( typeB, 'uint' );

				} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

					// matrix x vector

					typeB = builder.getVectorFromMatrix( typeA );

				} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

					// vector x matrix

					typeA = builder.getVectorFromMatrix( typeB );

				} else {

					// anytype x anytype

					typeA = typeB = type;

				}

			} else {

				typeA = typeB = type;

			}

			const a = aNode.build( builder, typeA );
			const b = bNode.build( builder, typeB );

			const outputLength = builder.getTypeLength( output );

			if ( output !== 'void' ) {

				if ( op === '=' ) {

					builder.addLineFlowCode( `${a} ${this.op} ${b}` );

					return a;

				} else if ( op === '<' && outputLength > 1 ) {

					return builder.format( `${ builder.getMethod( 'lessThan' ) }( ${a}, ${b} )`, type, output );

				} else if ( op === '<=' && outputLength > 1 ) {

					return builder.format( `${ builder.getMethod( 'lessThanEqual' ) }( ${a}, ${b} )`, type, output );

				} else if ( op === '>' && outputLength > 1 ) {

					return builder.format( `${ builder.getMethod( 'greaterThan' ) }( ${a}, ${b} )`, type, output );

				} else if ( op === '>=' && outputLength > 1 ) {

					return builder.format( `${ builder.getMethod( 'greaterThanEqual' ) }( ${a}, ${b} )`, type, output );

				} else {

					return builder.format( `( ${a} ${this.op} ${b} )`, type, output );

				}

			} else if ( typeA !== 'void' ) {

				return builder.format( `${a} ${this.op} ${b}`, type, output );

			}

		}

		serialize( data ) {

			super.serialize( data );

			data.op = this.op;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.op = data.op;

		}

	}

	const add = nodeProxy( OperatorNode, '+' );
	const sub = nodeProxy( OperatorNode, '-' );
	const mul = nodeProxy( OperatorNode, '*' );
	const div = nodeProxy( OperatorNode, '/' );
	const remainder = nodeProxy( OperatorNode, '%' );
	const equal = nodeProxy( OperatorNode, '==' );
	const assign$7 = nodeProxy( OperatorNode, '=' );
	const lessThan = nodeProxy( OperatorNode, '<' );
	const greaterThan = nodeProxy( OperatorNode, '>' );
	const lessThanEqual = nodeProxy( OperatorNode, '<=' );
	const greaterThanEqual = nodeProxy( OperatorNode, '>=' );
	const and = nodeProxy( OperatorNode, '&&' );
	const or = nodeProxy( OperatorNode, '||' );
	const xor = nodeProxy( OperatorNode, '^^' );
	const bitAnd = nodeProxy( OperatorNode, '&' );
	const bitOr = nodeProxy( OperatorNode, '|' );
	const bitXor = nodeProxy( OperatorNode, '^' );
	const shiftLeft = nodeProxy( OperatorNode, '<<' );
	const shiftRight = nodeProxy( OperatorNode, '>>' );

	addNodeElement( 'add', add );
	addNodeElement( 'sub', sub );
	addNodeElement( 'mul', mul );
	addNodeElement( 'div', div );
	addNodeElement( 'remainder', remainder );
	addNodeElement( 'equal', equal );
	addNodeElement( 'assign', assign$7 );
	addNodeElement( 'lessThan', lessThan );
	addNodeElement( 'greaterThan', greaterThan );
	addNodeElement( 'lessThanEqual', lessThanEqual );
	addNodeElement( 'greaterThanEqual', greaterThanEqual );
	addNodeElement( 'and', and );
	addNodeElement( 'or', or );
	addNodeElement( 'xor', xor );
	addNodeElement( 'bitAnd', bitAnd );
	addNodeElement( 'bitOr', bitOr );
	addNodeElement( 'bitXor', bitXor );
	addNodeElement( 'shiftLeft', shiftLeft );
	addNodeElement( 'shiftRight', shiftRight );

	addNodeClass( OperatorNode );

	class MathNode extends TempNode {

		constructor( method, aNode, bNode = null, cNode = null ) {

			super();

			this.method = method;

			this.aNode = aNode;
			this.bNode = bNode;
			this.cNode = cNode;

		}

		getInputType( builder ) {

			const aType = this.aNode.getNodeType( builder );
			const bType = this.bNode ? this.bNode.getNodeType( builder ) : null;
			const cType = this.cNode ? this.cNode.getNodeType( builder ) : null;

			const aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );
			const bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );
			const cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );

			if ( aLen > bLen && aLen > cLen ) {

				return aType;

			} else if ( bLen > cLen ) {

				return bType;

			} else if ( cLen > aLen ) {

				return cType;

			}

			return aType;

		}

		getNodeType( builder ) {

			const method = this.method;

			if ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {

				return 'float';

			} else if ( method === MathNode.CROSS ) {

				return 'vec3';

			} else {

				return this.getInputType( builder );

			}

		}

		generate( builder, output ) {

			const method = this.method;

			const type = this.getNodeType( builder );
			const inputType = this.getInputType( builder );

			const a = this.aNode;
			const b = this.bNode;
			const c = this.cNode;

			const isWebGL = builder.renderer.isWebGLRenderer === true;

			if ( method === MathNode.TRANSFORM_DIRECTION ) {

				// dir can be either a direction vector or a normal vector
				// upper-left 3x3 of matrix is assumed to be orthogonal

				let tA = a;
				let tB = b;

				if ( builder.isMatrix( tA.getNodeType( builder ) ) ) {

					tB = vec4( vec3( tB ), 0.0 );

				} else {

					tA = vec4( vec3( tA ), 0.0 );

				}

				const mulNode = mul( tA, tB ).xyz;

				return normalize( mulNode ).build( builder, output );

			} else if ( method === MathNode.NEGATE ) {

				return builder.format( '-' + a.build( builder, inputType ), type, output );

			} else if ( method === MathNode.ONE_MINUS ) {

				return sub( 1.0, a ).build( builder, output );

			} else if ( method === MathNode.RECIPROCAL ) {

				return div( 1.0, a ).build( builder, output );

			} else if ( method === MathNode.DIFFERENCE ) {

				return abs( sub( a, b ) ).build( builder, output );

			} else {

				const params = [];

				if ( method === MathNode.CROSS ) {

					params.push(
						a.build( builder, type ),
						b.build( builder, type )
					);

				} else if ( method === MathNode.STEP ) {

					params.push(
						a.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),
						b.build( builder, inputType )
					);

				} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {

					params.push(
						a.build( builder, inputType ),
						b.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )
					);

				} else if ( method === MathNode.REFRACT ) {

					params.push(
						a.build( builder, inputType ),
						b.build( builder, inputType ),
						c.build( builder, 'float' )
					);

				} else if ( method === MathNode.MIX ) {

					params.push(
						a.build( builder, inputType ),
						b.build( builder, inputType ),
						c.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )
					);

				} else {

					params.push( a.build( builder, inputType ) );
					if ( b !== null ) params.push( b.build( builder, inputType ) );
					if ( c !== null ) params.push( c.build( builder, inputType ) );

				}

				return builder.format( `${ builder.getMethod( method ) }( ${params.join( ', ' )} )`, type, output );

			}

		}

		serialize( data ) {

			super.serialize( data );

			data.method = this.method;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.method = data.method;

		}

	}

	// 1 input

	MathNode.RADIANS = 'radians';
	MathNode.DEGREES = 'degrees';
	MathNode.EXP = 'exp';
	MathNode.EXP2 = 'exp2';
	MathNode.LOG = 'log';
	MathNode.LOG2 = 'log2';
	MathNode.SQRT = 'sqrt';
	MathNode.INVERSE_SQRT = 'inversesqrt';
	MathNode.FLOOR = 'floor';
	MathNode.CEIL = 'ceil';
	MathNode.NORMALIZE = 'normalize';
	MathNode.FRACT = 'fract';
	MathNode.SIN = 'sin';
	MathNode.COS = 'cos';
	MathNode.TAN = 'tan';
	MathNode.ASIN = 'asin';
	MathNode.ACOS = 'acos';
	MathNode.ATAN = 'atan';
	MathNode.ABS = 'abs';
	MathNode.SIGN = 'sign';
	MathNode.LENGTH = 'length';
	MathNode.NEGATE = 'negate';
	MathNode.ONE_MINUS = 'oneMinus';
	MathNode.DFDX = 'dFdx';
	MathNode.DFDY = 'dFdy';
	MathNode.ROUND = 'round';
	MathNode.RECIPROCAL = 'reciprocal';
	MathNode.TRUNC = 'trunc';
	MathNode.FWIDTH = 'fwidth';

	// 2 inputs

	MathNode.ATAN2 = 'atan2';
	MathNode.MIN = 'min';
	MathNode.MAX = 'max';
	MathNode.MOD = 'mod';
	MathNode.STEP = 'step';
	MathNode.REFLECT = 'reflect';
	MathNode.DISTANCE = 'distance';
	MathNode.DIFFERENCE = 'difference';
	MathNode.DOT = 'dot';
	MathNode.CROSS = 'cross';
	MathNode.POW = 'pow';
	MathNode.TRANSFORM_DIRECTION = 'transformDirection';

	// 3 inputs

	MathNode.MIX = 'mix';
	MathNode.CLAMP = 'clamp';
	MathNode.REFRACT = 'refract';
	MathNode.SMOOTHSTEP = 'smoothstep';
	MathNode.FACEFORWARD = 'faceforward';

	const EPSILON = float( 1e-6 );
	float( 1e6 );

	const radians = nodeProxy( MathNode, MathNode.RADIANS );
	const degrees = nodeProxy( MathNode, MathNode.DEGREES );
	const exp = nodeProxy( MathNode, MathNode.EXP );
	const exp2 = nodeProxy( MathNode, MathNode.EXP2 );
	const log = nodeProxy( MathNode, MathNode.LOG );
	const log2 = nodeProxy( MathNode, MathNode.LOG2 );
	const sqrt$1 = nodeProxy( MathNode, MathNode.SQRT );
	const inverseSqrt = nodeProxy( MathNode, MathNode.INVERSE_SQRT );
	const floor = nodeProxy( MathNode, MathNode.FLOOR );
	const ceil = nodeProxy( MathNode, MathNode.CEIL );
	const normalize = nodeProxy( MathNode, MathNode.NORMALIZE );
	const fract = nodeProxy( MathNode, MathNode.FRACT );
	const sin = nodeProxy( MathNode, MathNode.SIN );
	const cos = nodeProxy( MathNode, MathNode.COS );
	const tan = nodeProxy( MathNode, MathNode.TAN );
	const asin = nodeProxy( MathNode, MathNode.ASIN );
	const acos = nodeProxy( MathNode, MathNode.ACOS );
	const atan = nodeProxy( MathNode, MathNode.ATAN );
	const abs = nodeProxy( MathNode, MathNode.ABS );
	const sign = nodeProxy( MathNode, MathNode.SIGN );
	const length = nodeProxy( MathNode, MathNode.LENGTH );
	const negate = nodeProxy( MathNode, MathNode.NEGATE );
	const oneMinus = nodeProxy( MathNode, MathNode.ONE_MINUS );
	const dFdx = nodeProxy( MathNode, MathNode.DFDX );
	const dFdy = nodeProxy( MathNode, MathNode.DFDY );
	const round = nodeProxy( MathNode, MathNode.ROUND );
	const reciprocal = nodeProxy( MathNode, MathNode.RECIPROCAL );
	const trunc = nodeProxy( MathNode, MathNode.TRUNC );
	const fwidth = nodeProxy( MathNode, MathNode.FWIDTH );

	const atan2 = nodeProxy( MathNode, MathNode.ATAN2 );
	const min$1 = nodeProxy( MathNode, MathNode.MIN );
	const max$1 = nodeProxy( MathNode, MathNode.MAX );
	const mod = nodeProxy( MathNode, MathNode.MOD );
	const step = nodeProxy( MathNode, MathNode.STEP );
	const reflect = nodeProxy( MathNode, MathNode.REFLECT );
	const distance = nodeProxy( MathNode, MathNode.DISTANCE );
	const difference = nodeProxy( MathNode, MathNode.DIFFERENCE );
	const dot = nodeProxy( MathNode, MathNode.DOT );
	const cross = nodeProxy( MathNode, MathNode.CROSS );
	const pow$1 = nodeProxy( MathNode, MathNode.POW );
	const pow2 = nodeProxy( MathNode, MathNode.POW, 2 );
	const pow3 = nodeProxy( MathNode, MathNode.POW, 3 );
	const pow4 = nodeProxy( MathNode, MathNode.POW, 4 );
	const transformDirection = nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );

	const mix = nodeProxy( MathNode, MathNode.MIX );
	const clamp$2 = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );
	const saturate = ( value ) => clamp$2( value );
	const refract = nodeProxy( MathNode, MathNode.REFRACT );
	const smoothstep = nodeProxy( MathNode, MathNode.SMOOTHSTEP );
	const faceForward = nodeProxy( MathNode, MathNode.FACEFORWARD );

	const mixElement = ( t, e1, e2 ) => mix( e1, e2, t );
	const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );

	addNodeElement( 'radians', radians );
	addNodeElement( 'degrees', degrees );
	addNodeElement( 'exp', exp );
	addNodeElement( 'exp2', exp2 );
	addNodeElement( 'log', log );
	addNodeElement( 'log2', log2 );
	addNodeElement( 'sqrt', sqrt$1 );
	addNodeElement( 'inverseSqrt', inverseSqrt );
	addNodeElement( 'floor', floor );
	addNodeElement( 'ceil', ceil );
	addNodeElement( 'normalize', normalize );
	addNodeElement( 'fract', fract );
	addNodeElement( 'sin', sin );
	addNodeElement( 'cos', cos );
	addNodeElement( 'tan', tan );
	addNodeElement( 'asin', asin );
	addNodeElement( 'acos', acos );
	addNodeElement( 'atan', atan );
	addNodeElement( 'abs', abs );
	addNodeElement( 'sign', sign );
	addNodeElement( 'length', length );
	addNodeElement( 'negate', negate );
	addNodeElement( 'oneMinus', oneMinus );
	addNodeElement( 'dFdx', dFdx );
	addNodeElement( 'dFdy', dFdy );
	addNodeElement( 'round', round );
	addNodeElement( 'reciprocal', reciprocal );
	addNodeElement( 'trunc', trunc );
	addNodeElement( 'fwidth', fwidth );
	addNodeElement( 'atan2', atan2 );
	addNodeElement( 'min', min$1 );
	addNodeElement( 'max', max$1 );
	addNodeElement( 'mod', mod );
	addNodeElement( 'step', step );
	addNodeElement( 'reflect', reflect );
	addNodeElement( 'distance', distance );
	addNodeElement( 'dot', dot );
	addNodeElement( 'cross', cross );
	addNodeElement( 'pow', pow$1 );
	addNodeElement( 'pow2', pow2 );
	addNodeElement( 'pow3', pow3 );
	addNodeElement( 'pow4', pow4 );
	addNodeElement( 'transformDirection', transformDirection );
	addNodeElement( 'mix', mixElement );
	addNodeElement( 'clamp', clamp$2 );
	addNodeElement( 'refract', refract );
	addNodeElement( 'smoothstep', smoothstepElement );
	addNodeElement( 'faceForward', faceForward );
	addNodeElement( 'difference', difference );
	addNodeElement( 'saturate', saturate );

	addNodeClass( MathNode );

	const sRGBToLinearShader = tslFn( ( inputs ) => {

		const { value } = inputs;
		const { rgb } = value;

		const a = rgb.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );
		const b = rgb.mul( 0.0773993808 );
		const factor = rgb.lessThanEqual( 0.04045 );

		const rgbResult = mix( a, b, factor );

		return vec4( rgbResult, value.a );

	} );

	const LinearTosRGBShader = tslFn( ( inputs ) => {

		const { value } = inputs;
		const { rgb } = value;

		const a = rgb.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );
		const b = rgb.mul( 12.92 );
		const factor = rgb.lessThanEqual( 0.0031308 );

		const rgbResult = mix( a, b, factor );

		return vec4( rgbResult, value.a );

	} );

	const getColorSpaceMethod = ( colorSpace ) => {

		let method = null;

		if ( colorSpace === LinearSRGBColorSpace ) {

			method = 'Linear';

		} else if ( colorSpace === SRGBColorSpace ) {

			method = 'sRGB';

		}

		return method;

	};

	const getMethod = ( source, target ) => {

		return getColorSpaceMethod( source ) + 'To' + getColorSpaceMethod( target );

	};

	class ColorSpaceNode extends TempNode {

		constructor( method, node ) {

			super( 'vec4' );

			this.method = method;
			this.node = node;

		}

		construct() {

			const { method, node } = this;

			if ( method === ColorSpaceNode.LINEAR_TO_LINEAR )
				return node;

			return Methods[ method ]( { value: node } );

		}

	}

	ColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';
	ColorSpaceNode.LINEAR_TO_sRGB = 'LinearTosRGB';
	ColorSpaceNode.sRGB_TO_LINEAR = 'sRGBToLinear';

	const Methods = {
		[ ColorSpaceNode.LINEAR_TO_sRGB ]: LinearTosRGBShader,
		[ ColorSpaceNode.sRGB_TO_LINEAR ]: sRGBToLinearShader
	};

	const linearToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( getMethod( LinearSRGBColorSpace, colorSpace ), nodeObject( node ) ) );
	const colorSpaceToLinear = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( getMethod( colorSpace, LinearSRGBColorSpace ), nodeObject( node ) ) );

	const linearTosRGB = nodeProxy( ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB );
	const sRGBToLinear = nodeProxy( ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR );

	addNodeElement( 'linearTosRGB', linearTosRGB );
	addNodeElement( 'sRGBToLinear', sRGBToLinear );
	addNodeElement( 'linearToColorSpace', linearToColorSpace );
	addNodeElement( 'colorSpaceToLinear', colorSpaceToLinear );

	addNodeClass( ColorSpaceNode );

	class ExpressionNode extends Node {

		constructor( snippet = '', nodeType = 'void' ) {

			super( nodeType );

			this.snippet = snippet;

		}

		generate( builder, output ) {

			const type = this.getNodeType( builder );
			const snippet = this.snippet;

			if ( type === 'void' ) {

				builder.addLineFlowCode( snippet );

			} else {

				return builder.format( `( ${ snippet } )`, type, output );

			}

		}

	}

	const expression = nodeProxy( ExpressionNode );

	addNodeClass( ExpressionNode );

	class TextureNode extends UniformNode {

		constructor( value, uvNode = null, levelNode = null, compareNode = null ) {

			super( value );

			this.isTextureNode = true;

			this.uvNode = uvNode;
			this.levelNode = levelNode;
			this.compareNode = compareNode;

			this.updateMatrix = false;
			this.updateType = NodeUpdateType.NONE;

			this.setUpdateMatrix( uvNode === null );

		}

		getUniformHash( /*builder*/ ) {

			return this.value.uuid;

		}

		getNodeType( /*builder*/ ) {

			if ( this.value.isDepthTexture === true ) return 'float';

			return 'vec4';

		}

		getInputType( /*builder*/ ) {

			return 'texture';

		}

		getDefaultUV() {

			return uv( this.value.channel );

		}

		getTextureMatrix( uvNode ) {

			const texture = this.value;

			return uniform( texture.matrix ).mul( vec3( uvNode, 1 ) ).xy;

		}

		setUpdateMatrix( value ) {

			this.updateMatrix = value;
			this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;

			return this;

		}

		construct( builder ) {

			const properties = builder.getNodeProperties( this );

			//

			let uvNode = this.uvNode;

			if ( uvNode === null && builder.context.getUVNode ) {

				uvNode = builder.context.getUVNode( this );

			}

			if ( ! uvNode ) uvNode = this.getDefaultUV();

			if ( this.updateMatrix ) {

				uvNode = this.getTextureMatrix( uvNode );

			}

			//

			let levelNode = this.levelNode;

			if ( levelNode === null && builder.context.getSamplerLevelNode ) {

				levelNode = builder.context.getSamplerLevelNode( this );

			}

			//

			properties.uvNode = uvNode;
			properties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode( this, levelNode ) : null;

		}

		generate( builder, output ) {

			const { uvNode, levelNode } = builder.getNodeProperties( this );

			const compareNode = this.compareNode;
			const texture = this.value;

			if ( ! texture || texture.isTexture !== true ) {

				throw new Error( 'TextureNode: Need a three.js texture.' );

			}

			const textureProperty = super.generate( builder, 'property' );

			if ( output === 'sampler' ) {

				return textureProperty + '_sampler';

			} else if ( builder.isReference( output ) ) {

				return textureProperty;

			} else {

				const nodeType = this.getNodeType( builder );
				const nodeData = builder.getDataFromNode( this );

				let propertyName = nodeData.propertyName;

				if ( propertyName === undefined ) {

					const uvSnippet = uvNode.build( builder, 'vec2' );
					const nodeVar = builder.getVarFromNode( this, nodeType );

					propertyName = builder.getPropertyName( nodeVar );

					let snippet = null;

					if ( levelNode && levelNode.isNode === true ) {

						const levelSnippet = levelNode.build( builder, 'float' );

						snippet = builder.getTextureLevel( texture, textureProperty, uvSnippet, levelSnippet );

					} else if ( compareNode !== null ) {

						const compareSnippet = compareNode.build( builder, 'float' );

						snippet = builder.getTextureCompare( texture, textureProperty, uvSnippet, compareSnippet );

					} else {

						snippet = builder.getTexture( texture, textureProperty, uvSnippet );

					}

					builder.addLineFlowCode( `${propertyName} = ${snippet}` );

					nodeData.snippet = snippet;
					nodeData.propertyName = propertyName;

				}

				let snippet = propertyName;

				if ( builder.needsColorSpaceToLinear( this.value ) ) {

					snippet = colorSpaceToLinear( expression( snippet, nodeType ), this.value.colorSpace ).construct( builder ).build( builder, nodeType );

				}

				return builder.format( snippet, nodeType, output );

			}

		}

		uv( uvNode ) {

			const textureNode = this.clone();
			textureNode.uvNode = uvNode;

			return nodeObject( textureNode );

		}

		level( levelNode ) {

			const textureNode = this.clone();
			textureNode.levelNode = levelNode;

			return context( textureNode, {
				getMIPLevelAlgorithmNode: ( textureNode, levelNode ) => levelNode
			} );

		}

		size( levelNode ) {

			return textureSize( this, levelNode );

		}

		compare( compareNode ) {

			const textureNode = this.clone();
			textureNode.compareNode = nodeObject( compareNode );

			return nodeObject( textureNode );

		}

		serialize( data ) {

			super.serialize( data );

			data.value = this.value.toJSON( data.meta ).uuid;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.value = data.meta.textures[ data.value ];

		}

		update() {

			const texture = this.value;

			if ( texture.matrixAutoUpdate === true ) {

				texture.updateMatrix();

			}

		}

		clone() {

			return new this.constructor( this.value, this.uvNode, this.levelNode, this.compareNode );

		}

	}

	const texture = nodeProxy( TextureNode );

	addNodeElement( 'texture', texture );
	//addNodeElement( 'textureLevel', textureLevel );

	addNodeClass( TextureNode );

	class ReferenceNode extends Node {

		constructor( property, uniformType, object = null ) {

			super();

			this.property = property;

			this.uniformType = uniformType;

			this.object = object;

			this.node = null;

			this.updateType = NodeUpdateType.OBJECT;

			this.setNodeType( uniformType );

		}

		setNodeType( uniformType ) {

			let node = null;

			if ( uniformType === 'texture' ) {

				node = texture( null );

			} else {

				node = uniform( uniformType );

			}

			this.node = node;

		}

		getNodeType( builder ) {

			return this.node.getNodeType( builder );

		}

		update( frame ) {

			const object = this.object !== null ? this.object : frame.object;
			const property = this.property;

			this.node.value = object[ property ];

		}

		construct( /*builder*/ ) {

			return this.node;

		}

	}

	const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );

	addNodeClass( ReferenceNode );

	class MaterialReferenceNode extends ReferenceNode {

		constructor( property, inputType, material = null ) {

			super( property, inputType, material );

			this.material = material;

		}

		construct( builder ) {

			const material = this.material !== null ? this.material : builder.material;

			this.node.value = material[ this.property ];

			return super.construct( builder );

		}

		update( frame ) {

			this.object = this.material !== null ? this.material : frame.material;

			super.update( frame );

		}

	}

	const materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );

	addNodeClass( MaterialReferenceNode );

	class MaterialNode extends Node {

		constructor( scope ) {

			super();

			this.scope = scope;

		}

		getFloat( property ) {

			//@TODO: Check if it can be cached by property name.

			return materialReference( property, 'float' );

		}

		getColor( property ) {

			//@TODO: Check if it can be cached by property name.

			return materialReference( property, 'color' );

		}

		getTexture( property ) {

			//@TODO: Check if it can be cached by property name.

			const textureRefNode = materialReference( property, 'texture' );

			return textureRefNode;

		}

		construct( builder ) {

			const material = builder.context.material;
			const scope = this.scope;

			let node = null;

			if ( scope === MaterialNode.ALPHA_TEST || scope === MaterialNode.SHININESS || scope === MaterialNode.REFLECTIVITY || scope === MaterialNode.ROTATION || scope === MaterialNode.IRIDESCENCE || scope === MaterialNode.IRIDESCENCE_IOR ) {

				node = this.getFloat( scope );

			} else if ( scope === MaterialNode.SPECULAR_COLOR ) {

				node = this.getColor( 'specular' );

			} else if ( scope === MaterialNode.COLOR ) {

				const colorNode = this.getColor( 'color' );

				if ( material.map && material.map.isTexture === true ) {

					node = colorNode.mul( this.getTexture( 'map' ) );

				} else {

					node = colorNode;

				}

			} else if ( scope === MaterialNode.OPACITY ) {

				const opacityNode = this.getFloat( 'opacity' );

				if ( material.alphaMap && material.alphaMap.isTexture === true ) {

					node = opacityNode.mul( this.getTexture( 'alphaMap' ) );

				} else {

					node = opacityNode;

				}

			} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {

				if ( material.specularMap && material.specularMap.isTexture === true ) {

					node = this.getTexture( 'specularMap' ).r;

				} else {

					node = float( 1 );

				}

			} else if ( scope === MaterialNode.ROUGHNESS ) {

				const roughnessNode = this.getFloat( 'roughness' );

				if ( material.roughnessMap && material.roughnessMap.isTexture === true ) {

					node = roughnessNode.mul( this.getTexture( 'roughnessMap' ).g );

				} else {

					node = roughnessNode;

				}

			} else if ( scope === MaterialNode.METALNESS ) {

				const metalnessNode = this.getFloat( 'metalness' );

				if ( material.metalnessMap && material.metalnessMap.isTexture === true ) {

					node = metalnessNode.mul( this.getTexture( 'metalnessMap' ).b );

				} else {

					node = metalnessNode;

				}

			} else if ( scope === MaterialNode.EMISSIVE ) {

				const emissiveNode = this.getColor( 'emissive' );

				if ( material.emissiveMap && material.emissiveMap.isTexture === true ) {

					node = emissiveNode.mul( this.getTexture( 'emissiveMap' ) );

				} else {

					node = emissiveNode;

				}

			} else if ( scope === MaterialNode.CLEARCOAT ) {

				const clearcoatNode = this.getFloat( 'clearcoat' );

				if ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {

					node = clearcoatNode.mul( this.getTexture( 'clearcoatMap' ).r );

				} else {

					node = clearcoatNode;

				}

			} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {

				const clearcoatRoughnessNode = this.getFloat( 'clearcoatRoughness' );

				if ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {

					node = clearcoatRoughnessNode.mul( this.getTexture( 'clearcoatRoughnessMap' ).r );

				} else {

					node = clearcoatRoughnessNode;

				}

			} else if ( scope === MaterialNode.SHEEN ) {

				const sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU

				if ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {

					node = sheenNode.mul( this.getTexture( 'sheenColorMap' ).rgb );

				} else {

					node = sheenNode;

				}

			} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {

				const sheenRoughnessNode = this.getFloat( 'sheenRoughness' );

				if ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {

					node = sheenRoughnessNode.mul( this.getTexture( 'sheenRoughnessMap' ).a );

				} else {

					node = sheenRoughnessNode;

				}

				node = node.clamp( 0.07, 1.0 );

			} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {

				const iridescenceThicknessMaximum = reference( 1, 'float', material.iridescenceThicknessRange );

				if ( material.iridescenceThicknessMap ) {

					const iridescenceThicknessMinimum = reference( 0, 'float', material.iridescenceThicknessRange );

					node = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( 'iridescenceThicknessMap' ).g ).add( iridescenceThicknessMinimum );

				} else {

					node = iridescenceThicknessMaximum;

				}

			} else {

				const outputType = this.getNodeType( builder );

				node = materialReference( scope, outputType );

			}

			return node;

		}

	}

	MaterialNode.ALPHA_TEST = 'alphaTest';
	MaterialNode.COLOR = 'color';
	MaterialNode.OPACITY = 'opacity';
	MaterialNode.SHININESS = 'shininess';
	MaterialNode.SPECULAR = 'specular';
	MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
	MaterialNode.REFLECTIVITY = 'reflectivity';
	MaterialNode.ROUGHNESS = 'roughness';
	MaterialNode.METALNESS = 'metalness';
	MaterialNode.CLEARCOAT = 'clearcoat';
	MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
	MaterialNode.EMISSIVE = 'emissive';
	MaterialNode.ROTATION = 'rotation';
	MaterialNode.SHEEN = 'sheen';
	MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
	MaterialNode.IRIDESCENCE = 'iridescence';
	MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
	MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';

	const materialAlphaTest = nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );
	const materialColor = nodeImmutable( MaterialNode, MaterialNode.COLOR );
	const materialShininess = nodeImmutable( MaterialNode, MaterialNode.SHININESS );
	const materialEmissive = nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );
	const materialOpacity = nodeImmutable( MaterialNode, MaterialNode.OPACITY );
	const materialSpecularColor = nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );
	const materialSpecularStrength = nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );
	nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );
	const materialRoughness = nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );
	const materialMetalness = nodeImmutable( MaterialNode, MaterialNode.METALNESS );
	const materialClearcoat = nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );
	const materialClearcoatRoughness = nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );
	const materialRotation = nodeImmutable( MaterialNode, MaterialNode.ROTATION );
	const materialSheen = nodeImmutable( MaterialNode, MaterialNode.SHEEN );
	const materialSheenRoughness = nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );
	const materialIridescence = nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );
	const materialIridescenceIOR = nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );
	const materialIridescenceThickness = nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );

	addNodeClass( MaterialNode );

	class Object3DNode extends Node {

		constructor( scope = Object3DNode.VIEW_MATRIX, object3d = null ) {

			super();

			this.scope = scope;
			this.object3d = object3d;

			this.updateType = NodeUpdateType.OBJECT;

			this._uniformNode = uniform( null );

		}

		getNodeType() {

			const scope = this.scope;

			if ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {

				return 'mat4';

			} else if ( scope === Object3DNode.NORMAL_MATRIX ) {

				return 'mat3';

			} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

				return 'vec3';

			}

		}

		update( frame ) {

			const object = this.object3d;
			const uniformNode = this._uniformNode;
			const scope = this.scope;

			if ( scope === Object3DNode.VIEW_MATRIX ) {

				uniformNode.value = object.modelViewMatrix;

			} else if ( scope === Object3DNode.NORMAL_MATRIX ) {

				uniformNode.value = object.normalMatrix;

			} else if ( scope === Object3DNode.WORLD_MATRIX ) {

				uniformNode.value = object.matrixWorld;

			} else if ( scope === Object3DNode.POSITION ) {

				uniformNode.value = uniformNode.value || new Vector3();

				uniformNode.value.setFromMatrixPosition( object.matrixWorld );

			} else if ( scope === Object3DNode.SCALE ) {

				uniformNode.value = uniformNode.value || new Vector3();

				uniformNode.value.setFromMatrixScale( object.matrixWorld );

			} else if ( scope === Object3DNode.DIRECTION ) {

				uniformNode.value = uniformNode.value || new Vector3();

				object.getWorldDirection( uniformNode.value );

			} else if ( scope === Object3DNode.VIEW_POSITION ) {

				const camera = frame.camera;

				uniformNode.value = uniformNode.value || new Vector3();
				uniformNode.value.setFromMatrixPosition( object.matrixWorld );

				uniformNode.value.applyMatrix4( camera.matrixWorldInverse );

			}

		}

		generate( builder ) {

			const scope = this.scope;

			if ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {

				this._uniformNode.nodeType = 'mat4';

			} else if ( scope === Object3DNode.NORMAL_MATRIX ) {

				this._uniformNode.nodeType = 'mat3';

			} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

				this._uniformNode.nodeType = 'vec3';

			}

			return this._uniformNode.build( builder );

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;

		}

	}

	Object3DNode.VIEW_MATRIX = 'viewMatrix';
	Object3DNode.NORMAL_MATRIX = 'normalMatrix';
	Object3DNode.WORLD_MATRIX = 'worldMatrix';
	Object3DNode.POSITION = 'position';
	Object3DNode.SCALE = 'scale';
	Object3DNode.VIEW_POSITION = 'viewPosition';
	Object3DNode.DIRECTION = 'direction';

	nodeProxy( Object3DNode, Object3DNode.DIRECTION );
	nodeProxy( Object3DNode, Object3DNode.VIEW_MATRIX );
	nodeProxy( Object3DNode, Object3DNode.NORMAL_MATRIX );
	nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );
	const objectPosition = nodeProxy( Object3DNode, Object3DNode.POSITION );
	nodeProxy( Object3DNode, Object3DNode.SCALE );
	const objectViewPosition = nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );

	addNodeClass( Object3DNode );

	class CameraNode extends Object3DNode {

		constructor( scope = CameraNode.POSITION ) {

			super( scope );

		}

		getNodeType( builder ) {

			const scope = this.scope;

			if ( scope === CameraNode.PROJECTION_MATRIX ) {

				return 'mat4';

			} else if ( scope === CameraNode.NEAR || scope === CameraNode.FAR ) {

				return 'float';

			}

			return super.getNodeType( builder );

		}

		update( frame ) {

			const camera = frame.camera;
			const uniformNode = this._uniformNode;
			const scope = this.scope;

			if ( scope === CameraNode.VIEW_MATRIX ) {

				uniformNode.value = camera.matrixWorldInverse;

			} else if ( scope === CameraNode.PROJECTION_MATRIX ) {

				uniformNode.value = camera.projectionMatrix;

			} else if ( scope === CameraNode.NEAR ) {

				uniformNode.value = camera.near;

			} else if ( scope === CameraNode.FAR ) {

				uniformNode.value = camera.far;

			} else {

				this.object3d = camera;

				super.update( frame );

			}

		}

		generate( builder ) {

			const scope = this.scope;

			if ( scope === CameraNode.PROJECTION_MATRIX ) {

				this._uniformNode.nodeType = 'mat4';

			} else if ( scope === CameraNode.NEAR || scope === CameraNode.FAR ) {

				this._uniformNode.nodeType = 'float';

			}

			return super.generate( builder );

		}

	}

	CameraNode.PROJECTION_MATRIX = 'projectionMatrix';
	CameraNode.NEAR = 'near';
	CameraNode.FAR = 'far';

	const cameraProjectionMatrix = label( nodeImmutable( CameraNode, CameraNode.PROJECTION_MATRIX ), 'projectionMatrix' );
	const cameraNear = nodeImmutable( CameraNode, CameraNode.NEAR );
	const cameraFar = nodeImmutable( CameraNode, CameraNode.FAR );
	const cameraViewMatrix = nodeImmutable( CameraNode, CameraNode.VIEW_MATRIX );
	nodeImmutable( CameraNode, CameraNode.NORMAL_MATRIX );
	nodeImmutable( CameraNode, CameraNode.WORLD_MATRIX );
	nodeImmutable( CameraNode, CameraNode.POSITION );

	addNodeClass( CameraNode );

	class ModelNode extends Object3DNode {

		constructor( scope = ModelNode.VIEW_MATRIX ) {

			super( scope );

		}

		update( frame ) {

			this.object3d = frame.object;

			super.update( frame );

		}

	}

	nodeImmutable( ModelNode, ModelNode.DIRECTION );
	const modelViewMatrix = label( nodeImmutable( ModelNode, ModelNode.VIEW_MATRIX ), 'modelViewMatrix' );
	const modelNormalMatrix = nodeImmutable( ModelNode, ModelNode.NORMAL_MATRIX );
	const modelWorldMatrix = nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );
	nodeImmutable( ModelNode, ModelNode.POSITION );
	nodeImmutable( ModelNode, ModelNode.SCALE );
	nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );

	addNodeClass( ModelNode );

	class NormalNode extends Node {

		constructor( scope = NormalNode.LOCAL ) {

			super( 'vec3' );

			this.scope = scope;

		}

		isGlobal() {

			return true;

		}

		getHash( /*builder*/ ) {

			return `normal-${this.scope}`;

		}

		generate( builder ) {

			const scope = this.scope;

			let outputNode = null;

			if ( scope === NormalNode.GEOMETRY ) {

				outputNode = attribute( 'normal', 'vec3' );

			} else if ( scope === NormalNode.LOCAL ) {

				outputNode = varying( normalGeometry );

			} else if ( scope === NormalNode.VIEW ) {

				const vertexNode = modelNormalMatrix.mul( normalLocal );
				outputNode = normalize( varying( vertexNode ) );

			} else if ( scope === NormalNode.WORLD ) {

				// To use inverseTransformDirection only inverse the param order like this: cameraViewMatrix.transformDirection( normalView )
				const vertexNode = normalView.transformDirection( cameraViewMatrix );
				outputNode = normalize( varying( vertexNode ) );

			}

			return outputNode.build( builder, this.getNodeType( builder ) );

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;

		}

	}

	NormalNode.GEOMETRY = 'geometry';
	NormalNode.LOCAL = 'local';
	NormalNode.VIEW = 'view';
	NormalNode.WORLD = 'world';

	const normalGeometry = nodeImmutable( NormalNode, NormalNode.GEOMETRY );
	const normalLocal = nodeImmutable( NormalNode, NormalNode.LOCAL );
	const normalView = nodeImmutable( NormalNode, NormalNode.VIEW );
	const normalWorld = nodeImmutable( NormalNode, NormalNode.WORLD );
	const transformedNormalView = property( 'vec3', 'TransformedNormalView' );
	const transformedNormalWorld = transformedNormalView.transformDirection( cameraViewMatrix ).normalize();
	const transformedClearcoatNormalView = property( 'vec3', 'TransformedClearcoatNormalView' );

	addNodeClass( NormalNode );

	class VarNode extends Node {

		constructor( node, name = null ) {

			super();

			this.node = node;
			this.name = name;

		}

		assign( node ) {

			node.traverse( ( childNode, replaceNode ) => {

				if ( replaceNode && childNode.uuid === this.uuid ) {

					replaceNode( this.node );

				}

			} );
			this.node = node;
			return this;

		}

		isGlobal() {

			return true;

		}

		getHash( builder ) {

			return this.name || super.getHash( builder );

		}

		getNodeType( builder ) {

			return this.node.getNodeType( builder );

		}

		generate( builder ) {

			const node = this.node;
			const name = this.name;

			if ( name === null && node.isTempNode === true ) {

				return node.build( builder );

			}

			const type = builder.getVectorType( this.getNodeType( builder ) );

			const snippet = node.build( builder, type );
			const nodeVar = builder.getVarFromNode( this, type );

			if ( name !== null ) {

				nodeVar.name = name;

			}

			const propertyName = builder.getPropertyName( nodeVar );

			builder.addLineFlowCode( `${propertyName} = ${snippet}` );

			return propertyName;

		}

	}

	const temp = nodeProxy( VarNode );

	addNodeElement( 'temp', temp );

	addNodeClass( VarNode );

	class TangentNode extends Node {

		constructor( scope = TangentNode.LOCAL ) {

			super();

			this.scope = scope;

		}

		getHash( /*builder*/ ) {

			return `tangent-${this.scope}`;

		}

		getNodeType() {

			const scope = this.scope;

			if ( scope === TangentNode.GEOMETRY ) {

				return 'vec4';

			}

			return 'vec3';

		}


		generate( builder ) {

			const scope = this.scope;

			let outputNode = null;

			if ( scope === TangentNode.GEOMETRY ) {

				outputNode = attribute( 'tangent', 'vec4' );

			} else if ( scope === TangentNode.LOCAL ) {

				outputNode = varying( tangentGeometry.xyz );

			} else if ( scope === TangentNode.VIEW ) {

				const vertexNode = modelViewMatrix.mul( tangentLocal ).xyz;
				outputNode = normalize( varying( vertexNode ) );

			} else if ( scope === TangentNode.WORLD ) {

				const vertexNode = tangentView.transformDirection( cameraViewMatrix );
				outputNode = normalize( varying( vertexNode ) );

			}

			return outputNode.build( builder, this.getNodeType( builder ) );

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;

		}

	}

	TangentNode.GEOMETRY = 'geometry';
	TangentNode.LOCAL = 'local';
	TangentNode.VIEW = 'view';
	TangentNode.WORLD = 'world';

	const tangentGeometry = nodeImmutable( TangentNode, TangentNode.GEOMETRY );
	const tangentLocal = nodeImmutable( TangentNode, TangentNode.LOCAL );
	const tangentView = nodeImmutable( TangentNode, TangentNode.VIEW );
	const tangentWorld = nodeImmutable( TangentNode, TangentNode.WORLD );
	const transformedTangentView = temp( tangentView, 'TransformedTangentView' );
	normalize( transformedTangentView.transformDirection( cameraViewMatrix ) );

	addNodeClass( TangentNode );

	class BitangentNode extends Node {

		constructor( scope = BitangentNode.LOCAL ) {

			super( 'vec3' );

			this.scope = scope;

		}

		getHash( /*builder*/ ) {

			return `bitangent-${this.scope}`;

		}

		generate( builder ) {

			const scope = this.scope;

			let crossNormalTangent;

			if ( scope === BitangentNode.GEOMETRY ) {

				crossNormalTangent = normalGeometry.cross( tangentGeometry );

			} else if ( scope === BitangentNode.LOCAL ) {

				crossNormalTangent = normalLocal.cross( tangentLocal );

			} else if ( scope === BitangentNode.VIEW ) {

				crossNormalTangent = normalView.cross( tangentView );

			} else if ( scope === BitangentNode.WORLD ) {

				crossNormalTangent = normalWorld.cross( tangentWorld );

			}

			const vertexNode = crossNormalTangent.mul( tangentGeometry.w ).xyz;

			const outputNode = normalize( varying( vertexNode ) );

			return outputNode.build( builder, this.getNodeType( builder ) );

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;

		}

	}

	BitangentNode.GEOMETRY = 'geometry';
	BitangentNode.LOCAL = 'local';
	BitangentNode.VIEW = 'view';
	BitangentNode.WORLD = 'world';

	nodeImmutable( BitangentNode, BitangentNode.GEOMETRY );
	nodeImmutable( BitangentNode, BitangentNode.LOCAL );
	const bitangentView = nodeImmutable( BitangentNode, BitangentNode.VIEW );
	nodeImmutable( BitangentNode, BitangentNode.WORLD );
	const transformedBitangentView = normalize( transformedNormalView.cross( transformedTangentView ).mul( tangentGeometry.w ) );
	normalize( transformedBitangentView.transformDirection( cameraViewMatrix ) );

	addNodeClass( BitangentNode );

	class PositionNode extends Node {

		constructor( scope = PositionNode.LOCAL ) {

			super( 'vec3' );

			this.scope = scope;

		}

		isGlobal() {

			return true;

		}

		getHash( /*builder*/ ) {

			return `position-${this.scope}`;

		}

		generate( builder ) {

			const scope = this.scope;

			let outputNode = null;

			if ( scope === PositionNode.GEOMETRY ) {

				outputNode = attribute( 'position', 'vec3' );

			} else if ( scope === PositionNode.LOCAL ) {

				outputNode = varying( positionGeometry );

			} else if ( scope === PositionNode.WORLD ) {

				const vertexPositionNode = modelWorldMatrix.mul( positionLocal );
				outputNode = varying( vertexPositionNode );

			} else if ( scope === PositionNode.VIEW ) {

				const vertexPositionNode = modelViewMatrix.mul( positionLocal );
				outputNode = varying( vertexPositionNode );

			} else if ( scope === PositionNode.VIEW_DIRECTION ) {

				const vertexPositionNode = positionView.negate();
				outputNode = normalize( varying( vertexPositionNode ) );

			} else if ( scope === PositionNode.WORLD_DIRECTION ) {

				const vertexPositionNode = positionLocal.transformDirection( modelWorldMatrix );
				outputNode = normalize( varying( vertexPositionNode ) );

			}

			return outputNode.build( builder, this.getNodeType( builder ) );

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;

		}

	}

	PositionNode.GEOMETRY = 'geometry';
	PositionNode.LOCAL = 'local';
	PositionNode.WORLD = 'world';
	PositionNode.WORLD_DIRECTION = 'worldDirection';
	PositionNode.VIEW = 'view';
	PositionNode.VIEW_DIRECTION = 'viewDirection';

	const positionGeometry = nodeImmutable( PositionNode, PositionNode.GEOMETRY );
	const positionLocal = nodeImmutable( PositionNode, PositionNode.LOCAL );
	const positionWorld = nodeImmutable( PositionNode, PositionNode.WORLD );
	const positionWorldDirection = nodeImmutable( PositionNode, PositionNode.WORLD_DIRECTION );
	const positionView = nodeImmutable( PositionNode, PositionNode.VIEW );
	const positionViewDirection = nodeImmutable( PositionNode, PositionNode.VIEW_DIRECTION );

	addNodeClass( PositionNode );

	class FrontFacingNode extends Node {

		constructor() {

			super( 'bool' );

			this.isFrontFacingNode = true;

		}

		generate( builder ) {

			return builder.getFrontFacing();

		}

	}

	const frontFacing = nodeImmutable( FrontFacingNode );
	const faceDirection = float( frontFacing ).mul( 2.0 ).sub( 1.0 );

	addNodeClass( FrontFacingNode );

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	const perturbNormal2Arb = tslFn( ( inputs ) => {

		const { eye_pos, surf_norm, mapN, uv } = inputs;

		const q0 = eye_pos.dFdx();
		const q1 = eye_pos.dFdy();
		const st0 = uv.dFdx();
		const st1 = uv.dFdy();

		const N = surf_norm; // normalized

		const q1perp = q1.cross( N );
		const q0perp = N.cross( q0 );

		const T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );
		const B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );

		const det = T.dot( T ).max( B.dot( B ) );
		const scale = faceDirection.mul( det.inverseSqrt() );

		return add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();

	} );

	class NormalMapNode extends TempNode {

		constructor( node, scaleNode = null ) {

			super( 'vec3' );

			this.node = node;
			this.scaleNode = scaleNode;

			this.normalMapType = TangentSpaceNormalMap;

		}

		construct( builder ) {

			const { normalMapType, scaleNode } = this;

			let normalMap = this.node.mul( 2.0 ).sub( 1.0 );

			if ( scaleNode !== null ) {

				normalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );

			}

			let outputNode = null;

			if ( normalMapType === ObjectSpaceNormalMap ) {

				outputNode = modelNormalMatrix.mul( normalMap ).normalize();

			} else if ( normalMapType === TangentSpaceNormalMap ) {

				const tangent = builder.hasGeometryAttribute( 'tangent' );

				if ( tangent === true ) {

					outputNode = TBNViewMatrix.mul( normalMap ).normalize();

				} else {

					outputNode = perturbNormal2Arb( {
						eye_pos: positionView,
						surf_norm: normalView,
						mapN: normalMap,
						uv: uv()
					} );

				}

			}

			return outputNode;

		}

	}

	const normalMap = nodeProxy( NormalMapNode );

	const TBNViewMatrix = mat3( tangentView, bitangentView, normalView );

	addNodeClass( NormalMapNode );

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	const dHdxy_fwd = tslFn( ( { bumpTexture, bumpScale } ) => {

		const uvNode = uv();

		const Hll = texture( bumpTexture, uvNode ).x;

		return vec2(
			texture( bumpTexture, uvNode.add( uvNode.dFdx() ) ).x.sub( Hll ),
			texture( bumpTexture, uvNode.add( uvNode.dFdy() ) ).x.sub( Hll )
		).mul( bumpScale );

	} );

	const perturbNormalArb = tslFn( ( inputs ) => {

		const { surf_pos, surf_norm, dHdxy } = inputs;

		const vSigmaX = surf_pos.dFdx();
		const vSigmaY = surf_pos.dFdy();
		const vN = surf_norm; // normalized

		const R1 = vSigmaY.cross( vN );
		const R2 = vN.cross( vSigmaX );

		const fDet = vSigmaX.dot( R1 ).mul( faceDirection );

		const vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );

		return fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();

	} );

	class BumpMapNode extends TempNode {

		constructor( texture, scaleNode = null ) {

			super( 'vec3' );

			this.texture = texture;
			this.scaleNode = scaleNode;

		}

		construct() {

			const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
			const dHdxy = dHdxy_fwd( { bumpTexture: this.texture, bumpScale } );

			return perturbNormalArb( {
				surf_pos: positionView.negate(),
				surf_norm: normalView,
				dHdxy
			} );

		}

	}

	const bumpMap = nodeProxy( BumpMapNode );

	addNodeClass( BumpMapNode );

	// @TODO: Is this needed? Can it be moved in MaterialNode?

	class ExtendedMaterialNode extends MaterialNode {

		constructor( scope ) {

			super( scope );

		}

		getNodeType( builder ) {

			const scope = this.scope;
			let type = null;

			if ( scope === ExtendedMaterialNode.NORMAL || scope === ExtendedMaterialNode.CLEARCOAT_NORMAL ) {

				type = 'vec3';

			}

			return type || super.getNodeType( builder );

		}

		construct( builder ) {

			const material = builder.material;
			const scope = this.scope;

			let node = null;

			if ( scope === ExtendedMaterialNode.NORMAL ) {

				if ( material.normalMap ) {

					node = normalMap( this.getTexture( 'normalMap' ), materialReference( 'normalScale', 'vec2' ) );

				} else if ( material.bumpMap ) {

					node = bumpMap( material.bumpMap, materialReference( 'bumpScale', 'float' ) );

				} else {

					node = normalView;

				}

			} else if ( scope === ExtendedMaterialNode.CLEARCOAT_NORMAL ) {

				node = material.clearcoatNormalMap ? normalMap( this.getTexture( 'clearcoatNormalMap' ), materialReference( 'clearcoatNormalScale', 'vec2' ) ) : normalView;

			}

			return node || super.construct( builder );

		}

	}

	ExtendedMaterialNode.NORMAL = 'normal';
	ExtendedMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';

	const materialNormal = nodeImmutable( ExtendedMaterialNode, ExtendedMaterialNode.NORMAL );
	const materialClearcoatNormal = nodeImmutable( ExtendedMaterialNode, ExtendedMaterialNode.CLEARCOAT_NORMAL );

	addNodeClass( ExtendedMaterialNode );

	class ModelViewProjectionNode extends Node {

		constructor( positionNode = positionLocal ) {

			super( 'vec4' );

			this.positionNode = positionNode;

		}

		construct() {

			return cameraProjectionMatrix.mul( modelViewMatrix ).mul( this.positionNode );

		}

	}

	const modelViewProjection = nodeProxy( ModelViewProjectionNode );

	addNodeClass( ModelViewProjectionNode );

	class BufferAttributeNode extends InputNode {

		constructor( value, bufferType, bufferStride = 0, bufferOffset = 0 ) {

			super( value, bufferType );

			this.isBufferNode = true;

			this.bufferType = bufferType;
			this.bufferStride = bufferStride;
			this.bufferOffset = bufferOffset;

			this.usage = StaticDrawUsage;
			this.instanced = false;

		}

		construct( builder ) {

			const type = this.getNodeType( builder );
			const array = this.value;
			const itemSize = builder.getTypeLength( type );
			const stride = this.bufferStride || itemSize;
			const offset = this.bufferOffset;

			const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );
			const bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );

			buffer.setUsage( this.usage );

			this.attribute = bufferAttribute;
			this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute

		}

		generate( builder ) {

			const nodeType = this.getNodeType( builder );

			const nodeUniform = builder.getBufferAttributeFromNode( this, nodeType );
			const propertyName = builder.getPropertyName( nodeUniform );

			let output = null;

			if ( builder.shaderStage === 'vertex' ) {

				output = propertyName;

			} else {

				const nodeVarying = varying( this );

				output = nodeVarying.build( builder, nodeType );

			}

			return output;

		}

		getInputType( /*builder*/ ) {

			return 'bufferAttribute';

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		setInstanced( value ) {

			this.instanced = value;

			return this;

		}

	}

	const bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );
	const dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );

	const instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );
	const instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );

	addNodeClass( BufferAttributeNode );

	class InstanceNode extends Node {

		constructor( instanceMesh ) {

			super( 'void' );

			this.instanceMesh = instanceMesh;

			this.instanceMatrixNode = null;

		}

		construct( builder ) {

			let instanceMatrixNode = this.instanceMatrixNode;

			if ( instanceMatrixNode === null ) {

				const instanceMesh = this.instanceMesh;
				const instanceAttribute = instanceMesh.instanceMatrix;
				const buffer = new InstancedInterleavedBuffer( instanceAttribute.array, 16, 1 );

				const bufferFn = instanceAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

				const instanceBuffers = [
					// F.Signature -> bufferAttribute( array, type, stride, offset )
					bufferFn( buffer, 'vec4', 16, 0 ),
					bufferFn( buffer, 'vec4', 16, 4 ),
					bufferFn( buffer, 'vec4', 16, 8 ),
					bufferFn( buffer, 'vec4', 16, 12 )
				];

				instanceMatrixNode = mat4( ...instanceBuffers );

				this.instanceMatrixNode = instanceMatrixNode;

			}

			// POSITION

			const instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;

			// NORMAL

			const m = mat3( instanceMatrixNode[ 0 ].xyz, instanceMatrixNode[ 1 ].xyz, instanceMatrixNode[ 2 ].xyz );

			const transformedNormal = normalLocal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );

			const instanceNormal = m.mul( transformedNormal ).xyz;

			// ASSIGNS

			builder.stack.assign( positionLocal, instancePosition );
			builder.stack.assign( normalLocal, instanceNormal );

		}

	}

	const instance = nodeProxy( InstanceNode );

	addNodeClass( InstanceNode );

	class BufferNode extends UniformNode {

		constructor( value, bufferType, bufferCount = 0 ) {

			super( value, bufferType );

			this.isBufferNode = true;

			this.bufferType = bufferType;
			this.bufferCount = bufferCount;

		}

		getInputType( /*builder*/ ) {

			return 'buffer';

		}

	}

	const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );

	addNodeClass( BufferNode );

	class SkinningNode extends Node {

		constructor( skinnedMesh ) {

			super( 'void' );

			this.skinnedMesh = skinnedMesh;

			this.updateType = NodeUpdateType.OBJECT;

			//

			this.skinIndexNode = attribute( 'skinIndex', 'uvec4' );
			this.skinWeightNode = attribute( 'skinWeight', 'vec4' );

			this.bindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );
			this.bindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );
			this.boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );

		}

		construct( builder ) {

			const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode, boneMatricesNode } = this;

			const boneMatX = boneMatricesNode.element( skinIndexNode.x );
			const boneMatY = boneMatricesNode.element( skinIndexNode.y );
			const boneMatZ = boneMatricesNode.element( skinIndexNode.z );
			const boneMatW = boneMatricesNode.element( skinIndexNode.w );

			// POSITION

			const skinVertex = bindMatrixNode.mul( positionLocal );

			const skinned = add(
				boneMatX.mul( skinWeightNode.x ).mul( skinVertex ),
				boneMatY.mul( skinWeightNode.y ).mul( skinVertex ),
				boneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),
				boneMatW.mul( skinWeightNode.w ).mul( skinVertex )
			);

			const skinPosition = bindMatrixInverseNode.mul( skinned ).xyz;

			// NORMAL

			let skinMatrix = add(
				skinWeightNode.x.mul( boneMatX ),
				skinWeightNode.y.mul( boneMatY ),
				skinWeightNode.z.mul( boneMatZ ),
				skinWeightNode.w.mul( boneMatW )
			);

			skinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );

			const skinNormal = skinMatrix.transformDirection( normalLocal ).xyz;

			// ASSIGNS

			builder.stack.assign( positionLocal, skinPosition );
			builder.stack.assign( normalLocal, skinNormal );

			if ( builder.hasGeometryAttribute( 'tangent' ) ) {

				builder.stack.assign( tangentLocal, skinNormal );

			}

		}

		update() {

			this.skinnedMesh.skeleton.update();

		}

	}

	const skinning = nodeProxy( SkinningNode );

	addNodeClass( SkinningNode );

	class MorphNode extends Node {

		constructor( mesh ) {

			super( 'void' );

			this.mesh = mesh;
			this.morphBaseInfluence = uniform( 1 );

			this.updateType = NodeUpdateType.OBJECT;

		}

		constructAttribute( builder, name, assignNode = positionLocal ) {

			const mesh = this.mesh;
			const attributes = mesh.geometry.morphAttributes[ name ];

			builder.stack.assign( assignNode, assignNode.mul( this.morphBaseInfluence ) );

			for ( let i = 0; i < attributes.length; i ++ ) {

				const attribute = attributes[ i ];

				const bufferAttrib = bufferAttribute( attribute.array, 'vec3' );
				const influence = reference( i, 'float', mesh.morphTargetInfluences );

				builder.stack.assign( assignNode, assignNode.add( bufferAttrib.mul( influence ) ) );

			}

		}

		construct( builder ) {

			this.constructAttribute( builder, 'position' );

		}

		update() {

			const morphBaseInfluence = this.morphBaseInfluence;

			if ( this.mesh.geometry.morphTargetsRelative ) {

				morphBaseInfluence.value = 1;

			} else {

				morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );

			}

		}

	}

	const morph = nodeProxy( MorphNode );

	addNodeClass( MorphNode );

	class ReflectVectorNode extends Node {

		constructor() {

			super( 'vec3' );

		}

		getHash( /*builder*/ ) {

			return 'reflectVector';

		}

		construct() {

			const reflectView = positionViewDirection.negate().reflect( transformedNormalView );

			return reflectView.transformDirection( cameraViewMatrix );

		}

	}

	const reflectVector = nodeImmutable( ReflectVectorNode );

	addNodeClass( ReflectVectorNode );

	class CubeTextureNode extends TextureNode {

		constructor( value, uvNode = null, levelNode = null ) {

			super( value, uvNode, levelNode );

			this.isCubeTextureNode = true;

		}

		getInputType( /*builder*/ ) {

			return 'cubeTexture';

		}

		getDefaultUV() {

			return reflectVector;

		}

		setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode

		generate( builder, output ) {

			const { uvNode, levelNode } = builder.getNodeProperties( this );

			const texture = this.value;

			if ( ! texture || texture.isCubeTexture !== true ) {

				throw new Error( 'CubeTextureNode: Need a three.js cube texture.' );

			}

			const textureProperty = UniformNode.prototype.generate.call( this, builder, 'cubeTexture' );

			if ( output === 'sampler' ) {

				return textureProperty + '_sampler';

			} else if ( builder.isReference( output ) ) {

				return textureProperty;

			} else {

				const nodeData = builder.getDataFromNode( this );

				let propertyName = nodeData.propertyName;

				if ( propertyName === undefined ) {

					const cubeUV = vec3( uvNode.x.negate(), uvNode.yz );
					const uvSnippet = cubeUV.build( builder, 'vec3' );

					const nodeVar = builder.getVarFromNode( this, 'vec4' );

					propertyName = builder.getPropertyName( nodeVar );

					let snippet = null;

					if ( levelNode && levelNode.isNode === true ) {

						const levelSnippet = levelNode.build( builder, 'float' );

						snippet = builder.getTextureLevel( this, textureProperty, uvSnippet, levelSnippet );

					} else {

						snippet = builder.getTexture( this, textureProperty, uvSnippet );

					}

					builder.addLineFlowCode( `${propertyName} = ${snippet}` );

					nodeData.snippet = snippet;
					nodeData.propertyName = propertyName;

				}

				return builder.format( propertyName, 'vec4', output );

			}

		}

	}

	const cubeTexture = nodeProxy( CubeTextureNode );

	addNodeElement( 'cubeTexture', cubeTexture );

	addNodeClass( CubeTextureNode );

	class LightingNode extends Node {

		constructor() {

			super( 'vec3' );

		}

		generate( /*builder*/ ) {

		}

	}

	addNodeClass( LightingNode );

	let depthMaterial = null;

	class AnalyticLightNode extends LightingNode {

		constructor( light = null ) {

			super();

			this.updateType = NodeUpdateType.FRAME;

			this.light = light;

			this.rtt = null;
			this.shadowNode = null;

			this.color = new Color();
			this.colorNode = uniform( this.color );

		}

		getHash( /*builder*/ ) {

			return this.light.uuid;

		}

		constructShadow( builder ) {

			let shadowNode = this.shadowNode;

			if ( shadowNode === null ) {

				if ( depthMaterial === null ) depthMaterial = builder.createNodeMaterial( 'MeshBasicNodeMaterial' );

				const shadow = this.light.shadow;
				const rtt = builder.getRenderTarget( shadow.mapSize.width, shadow.mapSize.height );

				const depthTexture = new DepthTexture();
				depthTexture.minFilter = NearestFilter;
				depthTexture.magFilter = NearestFilter;
				depthTexture.image.width = shadow.mapSize.width;
				depthTexture.image.height = shadow.mapSize.height;
				depthTexture.compareFunction = LessCompare;

				rtt.depthTexture = depthTexture;

				shadow.camera.updateProjectionMatrix();

				//

				const bias = reference( 'bias', 'float', shadow );
				const normalBias = reference( 'normalBias', 'float', shadow );

				let shadowCoord = uniform( shadow.matrix ).mul( positionWorld.add( normalWorld.mul( normalBias ) ) );
				shadowCoord = shadowCoord.xyz.div( shadowCoord.w );

				const frustumTest = shadowCoord.x.greaterThanEqual( 0 )
					.and( shadowCoord.x.lessThanEqual( 1 ) )
					.and( shadowCoord.y.greaterThanEqual( 0 ) )
					.and( shadowCoord.y.lessThanEqual( 1 ) )
					.and( shadowCoord.z.lessThanEqual( 1 ) );

				shadowCoord = vec3(
					shadowCoord.x,
					shadowCoord.y.oneMinus(), // WebGPU: Flip Y
					shadowCoord.z.add( bias ).mul( 2 ).sub( 1 ) // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]
				);

				const textureCompare = ( depthTexture, shadowCoord, compare ) => texture( depthTexture, shadowCoord ).compare( compare );
				//const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );

				// BasicShadowMap

				shadowNode = textureCompare( depthTexture, shadowCoord.xy, shadowCoord.z );

				// PCFShadowMap
				/*
				const mapSize = reference( 'mapSize', 'vec2', shadow );
				const radius = reference( 'radius', 'float', shadow );

				const texelSize = vec2( 1 ).div( mapSize );
				const dx0 = texelSize.x.negate().mul( radius );
				const dy0 = texelSize.y.negate().mul( radius );
				const dx1 = texelSize.x.mul( radius );
				const dy1 = texelSize.y.mul( radius );
				const dx2 = dx0.mul( 2 );
				const dy2 = dy0.mul( 2 );
				const dx3 = dx1.mul( 2 );
				const dy3 = dy1.mul( 2 );

				shadowNode = add(
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),
					textureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )
				).mul( 1 / 17 );
				*/
				//

				this.rtt = rtt;
				this.colorNode = this.colorNode.mul( frustumTest.mix( 1, shadowNode ) );

				this.shadowNode = shadowNode;

				//

				this.updateBeforeType = NodeUpdateType.RENDER;

			}

		}

		construct( builder ) {

			if ( this.light.castShadow ) this.constructShadow( builder );

		}

		updateShadow( frame ) {

			const { rtt, light } = this;
			const { renderer, scene } = frame;

			scene.overrideMaterial = depthMaterial;

			rtt.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );

			light.shadow.updateMatrices( light );

			renderer.setRenderTarget( rtt );
			renderer.render( scene, light.shadow.camera );
			renderer.setRenderTarget( null );

			scene.overrideMaterial = null;

		}

		updateBefore( frame ) {

			const { light } = this;

			if ( light.castShadow ) this.updateShadow( frame );

		}

		update( /*frame*/ ) {

			const { light } = this;

			this.color.copy( light.color ).multiplyScalar( light.intensity );

		}

	}

	addNodeClass( AnalyticLightNode );

	const LightNodes = new WeakMap();

	const sortLights = ( lights ) => {

		return lights.sort( ( a, b ) => a.id - b.id );

	};

	class LightsNode extends Node {

		constructor( lightNodes = [] ) {

			super( 'vec3' );

			this.lightNodes = lightNodes;

			this._hash = null;

		}

		get hasLight() {

			return this.lightNodes.length > 0;

		}

		construct( builder ) {

			const lightNodes = this.lightNodes;

			for ( const lightNode of lightNodes ) {

				lightNode.build( builder );

			}

		}

		getHash( builder ) {

			if ( this._hash === null ) {

				let hash = '';

				const lightNodes = this.lightNodes;

				for ( const lightNode of lightNodes ) {

					hash += lightNode.getHash( builder ) + ' ';

				}

				this._hash = hash;

			}

			return this._hash;

		}

		getLightNodeByHash( hash ) {

			const lightNodes = this.lightNodes;

			for ( const lightNode of lightNodes ) {

				if ( lightNode.light.uuid === hash ) {

					return lightNode;

				}

			}

			return null;

		}

		fromLights( lights = [] ) {

			const lightNodes = [];

			lights = sortLights( lights );

			for ( const light of lights ) {

				let lightNode = this.getLightNodeByHash( light.uuid );

				if ( lightNode === null ) {

					const lightClass = light.constructor;
					const lightNodeClass = LightNodes.has( lightClass ) ? LightNodes.get( lightClass ) : AnalyticLightNode;

					lightNode = nodeObject( new lightNodeClass( light ) );

				}

				lightNodes.push( lightNode );

			}

			this.lightNodes = lightNodes;
			this._hash = null;

			return this;

		}

	}

	const lights = ( lights ) => nodeObject( new LightsNode().fromLights( lights ) );
	const lightsWithoutWrap = nodeProxy( LightsNode );

	function addLightNode( lightClass, lightNodeClass ) {

		if ( LightNodes.has( lightClass ) ) throw new Error( `Redefinition of light node ${ lightNodeClass.name }` );
		if ( typeof lightClass !== 'function' || ! lightClass.name ) throw new Error( `Light ${ lightClass.name } is not a class` );
		if ( typeof lightNodeClass !== 'function' || ! lightNodeClass.name ) throw new Error( `Light node ${ lightNodeClass.name } is not a class` );

		LightNodes.set( lightClass, lightNodeClass );

	}

	class AONode extends LightingNode {

		constructor( aoNode = null ) {

			super();

			this.aoNode = aoNode;

		}

		construct( builder ) {

			const aoIntensity = 1;
			const aoNode = this.aoNode.x.sub( 1.0 ).mul( aoIntensity ).add( 1.0 );

			builder.context.ambientOcclusion.mulAssign( aoNode );

		}

	}

	addNodeClass( AONode );

	class EquirectUVNode extends TempNode {

		constructor( dirNode = positionWorldDirection ) {

			super( 'vec2' );

			this.dirNode = dirNode;

		}

		construct() {

			const dir = this.dirNode;

			const u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );
			const v = dir.y.negate().clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 ); // @TODO: The use of negate() here could be an NDC issue.

			return vec2( u, v );

		}

	}

	const equirectUV = nodeProxy( EquirectUVNode );

	addNodeClass( EquirectUVNode );

	class MaxMipLevelNode extends UniformNode {

		constructor( textureNode ) {

			super( 0 );

			this.textureNode = textureNode;

			this.updateType = NodeUpdateType.FRAME;

		}

		get texture() {

			return this.textureNode.value;

		}

		update() {

			const texture = this.texture;
			const images = texture.images;
			const image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;

			if ( image && image.width !== undefined ) {

				const { width, height } = image;

				this.value = Math.log2( Math.max( width, height ) );

			}

		}

	}

	const maxMipLevel = nodeProxy( MaxMipLevelNode );

	addNodeClass( MaxMipLevelNode );

	class SpecularMIPLevelNode extends Node {

		constructor( textureNode, roughnessNode = null ) {

			super( 'float' );

			this.textureNode = textureNode;
			this.roughnessNode = roughnessNode;

		}

		construct() {

			const { textureNode, roughnessNode } = this;

			// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html

			const maxMIPLevelScalar = maxMipLevel( textureNode );

			const sigma = roughnessNode.mul( roughnessNode ).mul( Math.PI ).div( roughnessNode.add( 1.0 ) );
			const desiredMIPLevel = maxMIPLevelScalar.add( sigma.log2() );

			return desiredMIPLevel.clamp( 0.0, maxMIPLevelScalar );

		}

	}

	const specularMIPLevel = nodeProxy( SpecularMIPLevelNode );

	addNodeClass( SpecularMIPLevelNode );

	const envNodeCache = new WeakMap();

	class EnvironmentNode extends LightingNode {

		constructor( envNode = null ) {

			super();

			this.envNode = envNode;

		}

		construct( builder ) {

			let envNode = this.envNode;
			const properties = builder.getNodeProperties( this );

			if ( envNode.isTextureNode && envNode.value.isCubeTexture !== true ) {

				let cacheEnvNode = envNodeCache.get( envNode.value );

				if ( cacheEnvNode === undefined ) {

					const texture = envNode.value;
					const renderer = builder.renderer;

					// @TODO: Add dispose logic here
					const cubeRTT = builder.getCubeRenderTarget( 512 ).fromEquirectangularTexture( renderer, texture );

					cacheEnvNode = cubeTexture( cubeRTT.texture );

					envNodeCache.set( envNode.value, cacheEnvNode );

				}

				envNode	= cacheEnvNode;

			}

			//

			const intensity = reference( 'envMapIntensity', 'float', builder.material ); // @TODO: Add materialEnvIntensity in MaterialNode

			const radiance = context( envNode, createRadianceContext( roughness, transformedNormalView ) ).mul( intensity );
			const irradiance = context( envNode, createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );

			const isolateRadiance = cache( radiance );

			//

			builder.context.radiance.addAssign( isolateRadiance );

			builder.context.iblIrradiance.addAssign( irradiance );

			//

			const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;

			if ( clearcoatRadiance ) {

				const clearcoatRadianceContext = context( envNode, createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );
				const isolateClearcoatRadiance = cache( clearcoatRadianceContext );

				clearcoatRadiance.addAssign( isolateClearcoatRadiance );

			}

			//

			properties.radiance = isolateRadiance;
			properties.irradiance = irradiance;

		}

	}

	const createRadianceContext = ( roughnessNode, normalViewNode ) => {

		let reflectVec = null;
		let textureUVNode = null;

		return {
			getUVNode: ( textureNode ) => {

				let node = null;

				if ( reflectVec === null ) {

					reflectVec = positionViewDirection.negate().reflect( normalViewNode );
					reflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();
					reflectVec = reflectVec.transformDirection( cameraViewMatrix );

				}

				if ( textureNode.isCubeTextureNode ) {

					node = reflectVec;

				} else if ( textureNode.isTextureNode ) {

					if ( textureUVNode === null ) {

						// @TODO: Needed PMREM

						textureUVNode = equirectUV( reflectVec );

					}

					node = textureUVNode;

				}

				return node;

			},
			getSamplerLevelNode: () => {

				return roughnessNode;

			},
			getMIPLevelAlgorithmNode: ( textureNode, levelNode ) => {

				return specularMIPLevel( textureNode, levelNode );

			}
		};

	};

	const createIrradianceContext = ( normalWorldNode ) => {

		let textureUVNode = null;

		return {
			getUVNode: ( textureNode ) => {

				let node = null;

				if ( textureNode.isCubeTextureNode ) {

					node = normalWorldNode;

				} else if ( textureNode.isTextureNode ) {

					if ( textureUVNode === null ) {

						// @TODO: Needed PMREM

						textureUVNode = equirectUV( normalWorldNode );
						textureUVNode = vec2( textureUVNode.x, textureUVNode.y.oneMinus() );

					}

					node = textureUVNode;

				}

				return node;

			},
			getSamplerLevelNode: () => {

				return float( 1 );

			},
			getMIPLevelAlgorithmNode: ( textureNode, levelNode ) => {

				return specularMIPLevel( textureNode, levelNode );

			}
		};

	};

	addNodeClass( EnvironmentNode );

	const NodeMaterials = new Map();

	class NodeMaterial extends ShaderMaterial {

		constructor() {

			super();

			this.isNodeMaterial = true;

			this.type = this.constructor.name;

			this.forceSinglePass = false;

			this.unlit = this.constructor === NodeMaterial.prototype.constructor; // Extended materials are not unlit by default

			this.fog = true;
			this.lights = true;
			this.normals = true;
			this.colorSpace = true;

			this.lightsNode = null;
			this.envNode = null;

			this.colorNode = null;
			this.normalNode = null;
			this.opacityNode = null;
			this.backdropNode = null;
			this.backdropAlphaNode = null;
			this.alphaTestNode = null;

			this.positionNode = null;

			this.outputNode = null; // @TODO: Rename to fragmentNode
			this.vertexNode = null;

		}

		customProgramCacheKey() {

			return this.type + getCacheKey( this );

		}

		build( builder ) {

			this.construct( builder );

		}

		construct( builder ) {

			// < VERTEX STAGE >

			builder.addStack();

			builder.stack.outputNode = this.constructPosition( builder );

			builder.addFlow( 'vertex', builder.removeStack() );

			// < FRAGMENT STAGE >

			builder.addStack();

			let outputNode;

			if ( this.unlit === false ) {

				if ( this.normals === true ) this.constructNormal( builder );

				this.constructDiffuseColor( builder );
				this.constructVariants( builder );

				const outgoingLightNode = this.constructLighting( builder );

				outputNode = this.constructOutput( builder, vec4( outgoingLightNode, diffuseColor.a ) );

				// OUTPUT NODE

				builder.stack.assign( output, outputNode );

				//

				if ( this.outputNode !== null ) outputNode = this.outputNode;

			} else {

				outputNode = this.constructOutput( builder, this.outputNode || vec4( 0, 0, 0, 1 ) );

			}

			builder.stack.outputNode = outputNode;

			builder.addFlow( 'fragment', builder.removeStack() );

		}

		constructPosition( builder ) {

			const object = builder.object;
			const geometry = object.geometry;

			builder.addStack();

			if ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {

				builder.stack.add( morph( object ) );

			}

			if ( object.isSkinnedMesh === true ) {

				builder.stack.add( skinning( object ) );

			}

			if ( ( object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) && builder.isAvailable( 'instance' ) === true ) {

				builder.stack.add( instance( object ) );

			}

			if ( this.positionNode !== null ) {

				builder.stack.assign( positionLocal, this.positionNode );

			}

			builder.context.vertex = builder.removeStack();

			return this.vertexNode || modelViewProjection();

		}

		constructDiffuseColor( { stack, geometry } ) {

			let colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;

			// VERTEX COLORS

			if ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {

				colorNode = vec4( colorNode.xyz.mul( attribute( 'color' ) ), colorNode.a );

			}

			// COLOR

			stack.assign( diffuseColor, colorNode );

			// OPACITY

			const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;
			stack.assign( diffuseColor.a, diffuseColor.a.mul( opacityNode ) );

			// ALPHA TEST

			if ( this.alphaTestNode !== null || this.alphaTest > 0 ) {

				const alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;

				stack.add( diffuseColor.a.lessThanEqual( alphaTestNode ).discard() );

			}

		}

		constructVariants( /*builder*/ ) {

			// Interface function.

		}

		constructNormal( { stack } ) {

			// NORMAL VIEW

			if ( this.flatShading === true ) {

				const fdx = dFdx( positionView );
				const fdy = dFdy( positionView.negate() ); // use -positionView ?
				const normalNode = fdx.cross( fdy ).normalize();

				stack.assign( transformedNormalView, normalNode );

			} else {

				const normalNode = this.normalNode ? vec3( this.normalNode ) : materialNormal;

				stack.assign( transformedNormalView, normalNode );

			}

		}

		getEnvNode( builder ) {

			let node = null;

			if ( this.envNode ) {

				node = this.envNode;

			} else if ( this.envMap ) {

				node = this.envMap.isCubeTexture ? cubeTexture( this.envMap ) : texture( this.envMap );

			} else if ( builder.environmentNode ) {

				node = builder.environmentNode;

			}

			return node;

		}

		constructLights( builder ) {

			const envNode = this.getEnvNode( builder );

			//

			const materialLightsNode = [];

			if ( envNode ) {

				materialLightsNode.push( new EnvironmentNode( envNode ) );

			}

			if ( builder.material.aoMap ) {

				materialLightsNode.push( new AONode( texture( builder.material.aoMap ) ) );

			}

			let lightsNode = this.lightsNode || builder.lightsNode;

			if ( materialLightsNode.length > 0 ) {

				lightsNode = lightsWithoutWrap( [ ...lightsNode.lightNodes, ...materialLightsNode ] );

			}

			return lightsNode;

		}

		constructLightingModel( /*builder*/ ) {

			// Interface function.

		}

		constructLighting( builder ) {

			const { material } = builder;
			const { backdropNode, backdropAlphaNode, emissiveNode } = this;

			// OUTGOING LIGHT

			const lights = this.lights === true || this.lightsNode !== null;

			const lightsNode = lights ? this.constructLights( builder ) : null;

			let outgoingLightNode = diffuseColor.rgb;

			if ( lightsNode && lightsNode.hasLight !== false ) {

				const lightingModelNode = this.constructLightingModel( builder );

				outgoingLightNode = lightsNode.lightingContext( lightingModelNode, backdropNode, backdropAlphaNode );

			} else if ( backdropNode !== null ) {

				outgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );

			}

			// EMISSIVE

			if ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {

				outgoingLightNode = outgoingLightNode.add( emissiveNode ? vec3( emissiveNode ) : materialEmissive );

			}

			return outgoingLightNode;

		}

		constructOutput( builder, outputNode ) {

			const renderer = builder.renderer;

			// TONE MAPPING

			const toneMappingNode = builder.toneMappingNode;

			if ( toneMappingNode ) {

				outputNode = vec4( toneMappingNode.context( { color: outputNode.rgb } ), outputNode.a );

			}

			// FOG

			if ( this.fog === true ) {

				const fogNode = builder.fogNode;

				if ( fogNode ) outputNode = vec4( fogNode.mixAssign( outputNode.rgb ), outputNode.a );

			}

			// ENCODING

			if ( this.colorSpace === true ) {

				const renderTarget = renderer.getRenderTarget();

				let outputColorSpace;

				if ( renderTarget !== null ) {

					outputColorSpace = renderTarget.texture.colorSpace;

				} else {

					outputColorSpace = renderer.outputColorSpace;

				}

				if ( outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace ) {

					outputNode = outputNode.linearToColorSpace( outputColorSpace );

				}

			}

			return outputNode;

		}

		setDefaultValues( material ) {

			// This approach is to reuse the native refreshUniforms*
			// and turn available the use of features like transmission and environment in core

			for ( const property in material ) {

				const value = material[ property ];

				if ( this[ property ] === undefined ) {

					this[ property ] = value;

					if ( value && value.clone ) this[ property ] = value.clone();

				}

			}

			Object.assign( this.defines, material.defines );

			const descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );

			for ( const key in descriptors ) {

				if ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&
				     descriptors[ key ].get !== undefined ) {

					Object.defineProperty( this.constructor.prototype, key, descriptors[ key ] );

				}

			}

		}

		toJSON( meta ) {

			const isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {},
					nodes: {}
				};

			}

			const data = Material.prototype.toJSON.call( this, meta );
			const nodeChildren = getNodeChildren( this );

			data.inputNodes = {};

			for ( const { property, childNode } of nodeChildren ) {

				data.inputNodes[ property ] = childNode.toJSON( meta ).uuid;

			}

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const nodes = extractFromCache( meta.nodes );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;
				if ( nodes.length > 0 ) data.nodes = nodes;

			}

			return data;

		}

		copy( source ) {

			this.lightsNode = source.lightsNode;
			this.envNode = source.envNode;

			this.colorNode = source.colorNode;
			this.normalNode = source.normalNode;
			this.opacityNode = source.opacityNode;
			this.backdropNode = source.backdropNode;
			this.backdropAlphaNode = source.backdropAlphaNode;
			this.alphaTestNode = source.alphaTestNode;

			this.positionNode = source.positionNode;

			this.outputNode = source.outputNode;
			this.vertexNode = source.vertexNode;

			return super.copy( source );

		}

		static fromMaterial( material ) {

			if ( material.isNodeMaterial === true ) { // is already a node material

				return material;

			}

			const type = material.type.replace( 'Material', 'NodeMaterial' );

			const nodeMaterial = createNodeMaterialFromType( type );

			if ( nodeMaterial === undefined ) {

				throw new Error( `NodeMaterial: Material "${ material.type }" is not compatible.` );

			}

			for ( const key in material ) {

				nodeMaterial[ key ] = material[ key ];

			}

			return nodeMaterial;

		}

	}

	function addNodeMaterial( nodeMaterial ) {

		if ( typeof nodeMaterial !== 'function' || ! nodeMaterial.name ) throw new Error( `Node material ${ nodeMaterial.name } is not a class` );
		if ( NodeMaterials.has( nodeMaterial.name ) ) throw new Error( `Redefinition of node material ${ nodeMaterial.name }` );

		NodeMaterials.set( nodeMaterial.name, nodeMaterial );

	}

	function createNodeMaterialFromType( type ) {

		const Material = NodeMaterials.get( type );

		if ( Material !== undefined ) {

			return new Material();

		}

	}

	addNodeMaterial( NodeMaterial );

	class CondNode extends Node {

		constructor( condNode, ifNode, elseNode = null ) {

			super();

			this.condNode = condNode;

			this.ifNode = ifNode;
			this.elseNode = elseNode;

		}

		getNodeType( builder ) {

			const ifType = this.ifNode.getNodeType( builder );

			if ( this.elseNode !== null ) {

				const elseType = this.elseNode.getNodeType( builder );

				if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

					return elseType;

				}

			}

			return ifType;

		}

		generate( builder ) {

			const type = this.getNodeType( builder );
			const context$1 = { tempWrite: false };

			const { ifNode, elseNode } = this;

			const needsProperty = ifNode.getNodeType( builder ) !== 'void' || ( elseNode && elseNode.getNodeType( builder ) !== 'void' );
			const nodeProperty = needsProperty ? property( type ).build( builder ) : '';

			const nodeSnippet = context( this.condNode/*, context*/ ).build( builder, 'bool' );

			builder.addFlowCode( `\n${ builder.tab }if ( ${ nodeSnippet } ) {\n\n` ).addFlowTab();

			let ifSnippet = context( this.ifNode, context$1 ).build( builder, type );

			ifSnippet = needsProperty ? nodeProperty + ' = ' + ifSnippet + ';' : ifSnippet;

			builder.removeFlowTab().addFlowCode( builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}' );

			if ( elseNode !== null ) {

				builder.addFlowCode( ' else {\n\n' ).addFlowTab();

				let elseSnippet = context( elseNode, context$1 ).build( builder, type );
				elseSnippet = nodeProperty ? nodeProperty + ' = ' + elseSnippet + ';' : elseSnippet;

				builder.removeFlowTab().addFlowCode( builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n' );

			} else {

				builder.addFlowCode( '\n\n' );

			}

			return nodeProperty;

		}

	}

	const cond = nodeProxy( CondNode );

	addNodeElement( 'cond', cond );

	addNodeClass( CondNode );

	class LoopNode extends Node {

		constructor( params = [] ) {

			super();

			this.params = params;

		}

		getVarName( index ) {

			return String.fromCharCode( 'i'.charCodeAt() + index );

		}

		getProperties( builder ) {

			const properties = builder.getNodeProperties( this );

			if ( properties.stackNode !== undefined ) return properties;

			//

			const inputs = {};

			for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

				const prop = this.getVarName( i );

				inputs[ prop ] = expression( prop, 'int' );

			}

			properties.returnsNode = this.params[ this.params.length - 1 ]( inputs, builder.addStack(), builder );
			properties.stackNode = builder.removeStack();

			return properties;

		}

		getNodeType( builder ) {

			const { returnsNode } = this.getProperties( builder );

			return returnsNode ? returnsNode.getNodeType( builder ) : 'void';

		}

		construct( builder ) {

			// construct properties

			this.getProperties( builder );

		}

		generate( builder ) {

			const properties = this.getProperties( builder );

			const context$1 = { tempWrite: false };

			const params = this.params;
			const stackNode = properties.stackNode;

			const returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';

			for ( let i = 0, l = params.length - 1; i < l; i ++ ) {

				const param = params[ i ];
				const property = this.getVarName( i );

				let start = null, end = null, direction = null;

				if ( param.isNode ) {

					start = '0';
					end = param.generate( builder, 'int' );
					direction = 'forward';

				} else {

					start = param.start;
					end = param.end;
					direction = param.direction;

					if ( typeof start === 'number' ) start = start.toString();
					else if ( start && start.isNode ) start = start.generate( builder, 'int' );

					if ( typeof end === 'number' ) end = end.toString();
					else if ( end && end.isNode ) end = end.generate( builder, 'int' );

					if ( start !== undefined && end === undefined ) {

						start = start + ' - 1';
						end = '0';
						direction = 'backwards';

					} else if ( end !== undefined && start === undefined ) {

						start = '0';
						direction = 'forward';

					}

					if ( direction === undefined ) {

						if ( Number( start ) > Number( end ) ) {

							direction = 'backwards';

						} else {

							direction = 'forward';

						}

					}

				}

				const internalParam = { start, end, direction };

				//

				const startSnippet = internalParam.start;
				const endSnippet = internalParam.end;

				let declarationSnippet = '';
				let conditionalSnippet = '';
				let updateSnippet = '';

				declarationSnippet += builder.getVar( 'int', property ) + ' = ' + startSnippet;

				if ( internalParam.direction === 'backwards' ) {

					conditionalSnippet += property + ' >= ' + endSnippet;
					updateSnippet += property + ' --';

				} else {

					// forward

					conditionalSnippet += property + ' < ' + endSnippet;
					updateSnippet += property + ' ++';

				}

				const forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;

				builder.addFlowCode( ( i === 0 ? '\n' : '' ) + builder.tab + forSnippet + ' {\n\n' ).addFlowTab();

			}

			const stackSnippet = context( stackNode, context$1 ).build( builder, 'void' );

			builder.removeFlowTab().addFlowCode( '\n' + builder.tab + stackSnippet );

			for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

				builder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\n\n' ).removeFlowTab();

			}

			builder.addFlowTab();

			return returnsSnippet;

		}

	}

	const loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) );

	addNodeElement( 'loop', ( returns, ...params ) => bypass( returns, loop( ...params ) ) );

	addNodeClass( LoopNode );

	class StackNode extends Node {

		constructor( parent = null ) {

			super();

			this.nodes = [];
			this.outputNode = null;

			this.parent = parent;

			this._currentCond = null;

			this.isStackNode = true;

		}

		getNodeType( builder ) {

			return this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';

		}

		add( node ) {

			this.nodes.push( bypass( expression(), node ) );

			return this;

		}

		if( boolNode, method ) {

			const methodNode = shader( method );
			this._currentCond = cond( boolNode, methodNode );

			return this.add( this._currentCond );

		}

		elseif( boolNode, method ) {

			const methodNode = shader( method );
			const ifNode = cond( boolNode, methodNode );

			this._currentCond.elseNode = ifNode;
			this._currentCond = ifNode;

			return this;

		}

		else( method ) {

			this._currentCond.elseNode = shader( method );

			return this;

		}

		assign( targetNode, sourceValue ) {

			return this.add( assign$7( targetNode, sourceValue ) );

		}

		loop( ...params ) {

			return this.add( loop( ...params ) );

		}

		build( builder, ...params ) {

			for ( const node of this.nodes ) {

				node.build( builder, 'void' );

			}

			return this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );

		}

	}

	const stack = nodeProxy( StackNode );

	addNodeClass( StackNode );

	const typeFromLength = new Map( [
		[ 2, 'vec2' ],
		[ 3, 'vec3' ],
		[ 4, 'vec4' ],
		[ 9, 'mat3' ],
		[ 16, 'mat4' ]
	] );

	const typeFromArray = new Map( [
		[ Int8Array, 'int' ],
		[ Int16Array, 'int' ],
		[ Int32Array, 'int' ],
		[ Uint8Array, 'uint' ],
		[ Uint16Array, 'uint' ],
		[ Uint32Array, 'uint' ],
		[ Float32Array, 'float' ]
	] );

	const isNonPaddingElementArray = new Set( [ Int32Array, Uint32Array, Float32Array ] );

	const toFloat = ( value ) => {

		value = Number( value );

		return value + ( value % 1 ? '' : '.0' );

	};

	class NodeBuilder {

		constructor( object, renderer, parser, scene = null ) {

			this.object = object;
			this.material = ( object && object.material ) || null;
			this.geometry = ( object && object.geometry ) || null;
			this.renderer = renderer;
			this.parser = parser;
			this.scene = scene;

			this.nodes = [];
			this.updateNodes = [];
			this.updateBeforeNodes = [];
			this.hashNodes = {};

			this.lightsNode = null;
			this.environmentNode = null;
			this.fogNode = null;
			this.toneMappingNode = null;

			this.vertexShader = null;
			this.fragmentShader = null;
			this.computeShader = null;

			this.flowNodes = { vertex: [], fragment: [], compute: [] };
			this.flowCode = { vertex: '', fragment: '', compute: [] };
			this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
			this.codes = { vertex: [], fragment: [], compute: [] };
			this.bindings = { vertex: [], fragment: [], compute: [] };
			this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
			this.bindingsArray = null;
			this.attributes = [];
			this.bufferAttributes = [];
			this.varyings = [];
			this.vars = { vertex: [], fragment: [], compute: [] };
			this.flow = { code: '' };
			this.chaining = [];
			this.stack = stack();
			this.tab = '\t';

			this.context = {
				keywords: new NodeKeywords(),
				material: this.material,
				getMIPLevelAlgorithmNode: ( textureNode, levelNode ) => levelNode.mul( maxMipLevel( textureNode ) )
			};

			this.cache = new NodeCache();
			this.globalCache = this.cache;

			this.flowsData = new WeakMap();

			this.shaderStage = null;
			this.buildStage = null;

		}

		includes( node ) {

			return this.nodes.includes( node );

		}

		getBindings() {

			let bindingsArray = this.bindingsArray;

			if ( bindingsArray === null ) {

				const bindings = this.bindings;

				this.bindingsArray = bindingsArray = ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute;

			}

			return bindingsArray;

		}

		setHashNode( node, hash ) {

			this.hashNodes[ hash ] = node;

		}

		addNode( node ) {

			if ( this.nodes.indexOf( node ) === - 1 ) {

				const updateType = node.getUpdateType();
				const updateBeforeType = node.getUpdateBeforeType();

				if ( updateType !== NodeUpdateType.NONE ) {

					this.updateNodes.push( node );

				}

				if ( updateBeforeType !== NodeUpdateType.NONE ) {

					this.updateBeforeNodes.push( node );

				}

				this.nodes.push( node );

				this.setHashNode( node, node.getHash( this ) );

			}

		}

		get currentNode() {

			return this.chaining[ this.chaining.length - 1 ];

		}

		addChain( node ) {

			/*
			if ( this.chaining.indexOf( node ) !== - 1 ) {

				console.warn( 'Recursive node: ', node );

			}
			*/

			this.chaining.push( node );

		}

		removeChain( node ) {

			const lastChain = this.chaining.pop();

			if ( lastChain !== node ) {

				throw new Error( 'NodeBuilder: Invalid node chaining!' );

			}

		}

		getMethod( method ) {

			return method;

		}

		getNodeFromHash( hash ) {

			return this.hashNodes[ hash ];

		}

		addFlow( shaderStage, node ) {

			this.flowNodes[ shaderStage ].push( node );

			return node;

		}

		setContext( context ) {

			this.context = context;

		}

		getContext() {

			return this.context;

		}

		setCache( cache ) {

			this.cache = cache;

		}

		getCache() {

			return this.cache;

		}

		isAvailable( /*name*/ ) {

			return false;

		}

		getVertexIndex() {

		}

		getInstanceIndex() {

		}

		getFrontFacing() {

		}

		getFragCoord() {

		}

		isFlipY() {

			return false;

		}

		getTexture( /* texture, textureProperty, uvSnippet */ ) {

		}

		getTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {

		}

		// @TODO: rename to .generateConst()
		getConst( type, value = null ) {

			if ( value === null ) {

				if ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;
				else if ( type === 'bool' ) value = false;
				else if ( type === 'color' ) value = new Color();
				else if ( type === 'vec2' ) value = new Vector2();
				else if ( type === 'vec3' ) value = new Vector3();
				else if ( type === 'vec4' ) value = new Vector4();

			}

			if ( type === 'float' ) return toFloat( value );
			if ( type === 'int' ) return `${ Math.round( value ) }`;
			if ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';
			if ( type === 'bool' ) return value ? 'true' : 'false';
			if ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;

			const typeLength = this.getTypeLength( type );

			const componentType = this.getComponentType( type );

			const getConst = value => this.getConst( componentType, value );

			if ( typeLength === 2 ) {

				return `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;

			} else if ( typeLength === 3 ) {

				return `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;

			} else if ( typeLength === 4 ) {

				return `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;

			} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {

				return `${ this.getType( type ) }( ${ value.elements.map( getConst ).join( ', ' ) } )`;

			} else if ( typeLength > 4 ) {

				return `${ this.getType( type ) }()`;

			}

			throw new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );

		}

		getType( type ) {

			return type;

		}

		generateMethod( method ) {

			return method;

		}

		hasGeometryAttribute( name ) {

			return this.geometry && this.geometry.getAttribute( name ) !== undefined;

		}

		getAttribute( name, type ) {

			const attributes = this.attributes;

			// find attribute

			for ( const attribute of attributes ) {

				if ( attribute.name === name ) {

					return attribute;

				}

			}

			// create a new if no exist

			const attribute = new NodeAttribute( name, type );

			attributes.push( attribute );

			return attribute;

		}

		getPropertyName( node/*, shaderStage*/ ) {

			return node.name;

		}

		isVector( type ) {

			return /vec\d/.test( type );

		}

		isMatrix( type ) {

			return /mat\d/.test( type );

		}

		isReference( type ) {

			return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';

		}

		needsColorSpaceToLinear( /*texture*/ ) {

			return false;

		}

		/** @deprecated, r152 */
		getTextureEncodingFromMap( map ) {
			return this.getTextureColorSpaceFromMap( map ) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;

		}

		getTextureColorSpaceFromMap( map ) {

			let colorSpace;

			if ( map && map.isTexture ) {

				colorSpace = map.colorSpace;

			} else if ( map && map.isWebGLRenderTarget ) {

				colorSpace = map.texture.colorSpace;

			} else {

				colorSpace = NoColorSpace;

			}

			return colorSpace;

		}

		getComponentType( type ) {

			type = this.getVectorType( type );

			if ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;

			const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );

			if ( componentType === null ) return null;

			if ( componentType[ 1 ] === 'b' ) return 'bool';
			if ( componentType[ 1 ] === 'i' ) return 'int';
			if ( componentType[ 1 ] === 'u' ) return 'uint';

			return 'float';

		}

		getVectorType( type ) {

			if ( type === 'color' ) return 'vec3';
			if ( type === 'texture' ) return 'vec4';

			return type;

		}

		getTypeFromLength( length, componentType = 'float' ) {

			if ( length === 1 ) return componentType;

			const baseType = typeFromLength.get( length );
			const prefix = componentType === 'float' ? '' : componentType[ 0 ];

			return prefix + baseType;

		}

		getTypeFromArray( array ) {

			return typeFromArray.get( array.constructor );

		}

		getTypeFromAttribute( attribute ) {

			let dataAttribute = attribute;

			if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

			const array = dataAttribute.array;
			const itemSize = isNonPaddingElementArray.has( array.constructor ) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;
			const normalized = attribute.normalized;

			let arrayType;

			if ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {

				arrayType = this.getTypeFromArray( array );

			}

			return this.getTypeFromLength( itemSize, arrayType );

		}

		getTypeLength( type ) {

			const vecType = this.getVectorType( type );
			const vecNum = /vec([2-4])/.exec( vecType );

			if ( vecNum !== null ) return Number( vecNum[ 1 ] );
			if ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;
			if ( /mat3/.test( type ) === true ) return 9;
			if ( /mat4/.test( type ) === true ) return 16;

			return 0;

		}

		getVectorFromMatrix( type ) {

			return type.replace( 'mat', 'vec' );

		}

		changeComponentType( type, newComponentType ) {

			return this.getTypeFromLength( this.getTypeLength( type ), newComponentType );

		}

		getIntegerType( type ) {

			const componentType = this.getComponentType( type );

			if ( componentType === 'int' || componentType === 'uint' ) return type;

			return this.changeComponentType( type, 'int' );

		}

		addStack() {

			this.stack = stack( this.stack );

			return this.stack;

		}

		removeStack() {

			const currentStack = this.stack;

			this.stack = currentStack.parent;

			return currentStack;

		}

		getDataFromNode( node, shaderStage = this.shaderStage ) {

			const cache = node.isGlobal( this ) ? this.globalCache : this.cache;

			let nodeData = cache.getNodeData( node );

			if ( nodeData === undefined ) {

				nodeData = { vertex: {}, fragment: {}, compute: {} };

				cache.setNodeData( node, nodeData );

			}

			return shaderStage !== null ? nodeData[ shaderStage ] : nodeData;

		}

		getNodeProperties( node, shaderStage = this.shaderStage ) {

			const nodeData = this.getDataFromNode( node, shaderStage );

			return nodeData.properties || ( nodeData.properties = { outputNode: null } );

		}

		getBufferAttributeFromNode( node, type ) {

			const nodeData = this.getDataFromNode( node );

			let bufferAttribute = nodeData.bufferAttribute;

			if ( bufferAttribute === undefined ) {

				const index = this.uniforms.index ++;

				bufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );

				this.bufferAttributes.push( bufferAttribute );

				nodeData.bufferAttribute = bufferAttribute;

			}

			return bufferAttribute;

		}

		getUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {

			const nodeData = this.getDataFromNode( node, shaderStage );

			let nodeUniform = nodeData.uniform;

			if ( nodeUniform === undefined ) {

				const index = this.uniforms.index ++;

				nodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );

				this.uniforms[ shaderStage ].push( nodeUniform );

				nodeData.uniform = nodeUniform;

			}

			return nodeUniform;

		}

		getVarFromNode( node, type, shaderStage = this.shaderStage ) {

			const nodeData = this.getDataFromNode( node, shaderStage );

			let nodeVar = nodeData.variable;

			if ( nodeVar === undefined ) {

				const vars = this.vars[ shaderStage ];
				const index = vars.length;

				nodeVar = new NodeVar( 'nodeVar' + index, type );

				vars.push( nodeVar );

				nodeData.variable = nodeVar;

			}

			return nodeVar;

		}

		getVaryingFromNode( node, type ) {

			const nodeData = this.getDataFromNode( node, null );

			let nodeVarying = nodeData.varying;

			if ( nodeVarying === undefined ) {

				const varyings = this.varyings;
				const index = varyings.length;

				nodeVarying = new NodeVarying( 'nodeVarying' + index, type );

				varyings.push( nodeVarying );

				nodeData.varying = nodeVarying;

			}

			return nodeVarying;

		}

		getCodeFromNode( node, type, shaderStage = this.shaderStage ) {

			const nodeData = this.getDataFromNode( node );

			let nodeCode = nodeData.code;

			if ( nodeCode === undefined ) {

				const codes = this.codes[ shaderStage ];
				const index = codes.length;

				nodeCode = new NodeCode( 'nodeCode' + index, type );

				codes.push( nodeCode );

				nodeData.code = nodeCode;

			}

			return nodeCode;

		}

		addLineFlowCode( code ) {

			if ( code === '' ) return this;

			code = this.tab + code;

			if ( ! /;\s*$/.test( code ) ) {

				code = code + ';\n';

			}

			this.flow.code += code;

			return this;

		}

		addFlowCode( code ) {

			this.flow.code += code;

			return this;

		}

		addFlowTab() {

			this.tab += '\t';

			return this;

		}

		removeFlowTab() {

			this.tab = this.tab.slice( 0, - 1 );

			return this;

		}

		getFlowData( node/*, shaderStage*/ ) {

			return this.flowsData.get( node );

		}

		flowNode( node ) {

			const output = node.getNodeType( this );

			const flowData = this.flowChildNode( node, output );

			this.flowsData.set( node, flowData );

			return flowData;

		}

		flowChildNode( node, output = null ) {

			const previousFlow = this.flow;

			const flow = {
				code: '',
			};

			this.flow = flow;

			flow.result = node.build( this, output );

			this.flow = previousFlow;

			return flow;

		}

		flowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {

			const previousShaderStage = this.shaderStage;

			this.setShaderStage( shaderStage );

			const flowData = this.flowChildNode( node, output );

			if ( propertyName !== null ) {

				flowData.code += `${ this.tab + propertyName } = ${ flowData.result };\n`;

			}

			this.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;

			this.setShaderStage( previousShaderStage );

			return flowData;

		}

		getAttributesArray() {

			return this.attributes.concat( this.bufferAttributes );

		}

		getAttributes( /*shaderStage*/ ) {

		}

		getVaryings( /*shaderStage*/ ) {

		}

		getVar( type, name ) {

			return `${type} ${name}`;

		}

		getVars( shaderStage ) {

			let snippet = '';

			const vars = this.vars[ shaderStage ];

			for ( const variable of vars ) {

				snippet += `${ this.getVar( variable.type, variable.name ) }; `;

			}

			return snippet;

		}

		getUniforms( /*shaderStage*/ ) {

		}

		getCodes( shaderStage ) {

			const codes = this.codes[ shaderStage ];

			let code = '';

			for ( const nodeCode of codes ) {

				code += nodeCode.code + '\n';

			}

			return code;

		}

		getHash() {

			return this.vertexShader + this.fragmentShader + this.computeShader;

		}

		setShaderStage( shaderStage ) {

			this.shaderStage = shaderStage;

		}

		getShaderStage() {

			return this.shaderStage;

		}

		setBuildStage( buildStage ) {

			this.buildStage = buildStage;

		}

		getBuildStage() {

			return this.buildStage;

		}

		buildCode() {

		}

		build() {

			// construct() -> stage 1: create possible new nodes and returns an output reference node
			// analyze()   -> stage 2: analyze nodes to possible optimization and validation
			// generate()  -> stage 3: generate shader

			for ( const buildStage of defaultBuildStages ) {

				this.setBuildStage( buildStage );

				if ( this.context.vertex && this.context.vertex.isNode ) {

					this.flowNodeFromShaderStage( 'vertex', this.context.vertex );

				}

				for ( const shaderStage of shaderStages ) {

					this.setShaderStage( shaderStage );

					const flowNodes = this.flowNodes[ shaderStage ];

					for ( const node of flowNodes ) {

						if ( buildStage === 'generate' ) {

							this.flowNode( node );

						} else {

							node.build( this );

						}

					}

				}

			}

			this.setBuildStage( null );
			this.setShaderStage( null );

			// stage 4: build code for a specific output

			this.buildCode();

			return this;

		}

		createNodeMaterial( type ) {

			return createNodeMaterialFromType( type );

		}

		format( snippet, fromType, toType ) {

			fromType = this.getVectorType( fromType );
			toType = this.getVectorType( toType );

			if ( fromType === toType || toType === null || this.isReference( toType ) ) {

				return snippet;

			}

			const fromTypeLength = this.getTypeLength( fromType );
			const toTypeLength = this.getTypeLength( toType );

			if ( fromTypeLength > 4 ) { // fromType is matrix-like

				// @TODO: ignore for now

				return snippet;

			}

			if ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown

				// @TODO: ignore for now

				return snippet;

			}

			if ( fromTypeLength === toTypeLength ) {

				return `${ this.getType( toType ) }( ${ snippet } )`;

			}

			if ( fromTypeLength > toTypeLength ) {

				return this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );

			}

			if ( toTypeLength === 4 ) { // toType is vec4-like

				return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;

			}

			if ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like

				return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;

			}

			return `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like

		}

		getSignature() {

			return `// Three.js r${ REVISION } - NodeMaterial System\n`;

		}

	}

	class NodeFrame {

		constructor() {

			this.time = 0;
			this.deltaTime = 0;

			this.frameId = 0;
			this.renderId = 0;

			this.startTime = null;

			this.frameMap = new WeakMap();
			this.frameBeforeMap = new WeakMap();
			this.renderMap = new WeakMap();
			this.renderBeforeMap = new WeakMap();

			this.renderer = null;
			this.material = null;
			this.camera = null;
			this.object = null;
			this.scene = null;

		}

		updateBeforeNode( node ) {

			const updateType = node.getUpdateBeforeType();

			if ( updateType === NodeUpdateType.FRAME ) {

				if ( this.frameBeforeMap.get( node ) !== this.frameId ) {

					this.frameBeforeMap.set( node, this.frameId );

					node.updateBefore( this );

				}

			} else if ( updateType === NodeUpdateType.RENDER ) {

				if ( this.renderBeforeMap.get( node ) !== this.renderId || this.frameBeforeMap.get( node ) !== this.frameId ) {

					this.renderBeforeMap.set( node, this.renderId );
					this.frameBeforeMap.set( node, this.frameId );

					node.updateBefore( this );

				}

			} else if ( updateType === NodeUpdateType.OBJECT ) {

				node.updateBefore( this );

			}

		}

		updateNode( node ) {

			const updateType = node.getUpdateType();

			if ( updateType === NodeUpdateType.FRAME ) {

				if ( this.frameMap.get( node ) !== this.frameId ) {

					this.frameMap.set( node, this.frameId );

					node.update( this );

				}

			} else if ( updateType === NodeUpdateType.RENDER ) {

				if ( this.renderMap.get( node ) !== this.renderId || this.frameMap.get( node ) !== this.frameId ) {

					this.renderMap.set( node, this.renderId );
					this.frameMap.set( node, this.frameId );

					node.update( this );

				}

			} else if ( updateType === NodeUpdateType.OBJECT ) {

				node.update( this );

			}

		}

		update() {

			this.frameId ++;

			if ( this.lastTime === undefined ) this.lastTime = performance.now();

			this.deltaTime = ( performance.now() - this.lastTime ) / 1000;

			this.lastTime = performance.now();

			this.time += this.deltaTime;

		}

	}

	class NodeFunctionInput {

		constructor( type, name, count = null, qualifier = '', isConst = false ) {

			this.type = type;
			this.name = name;
			this.count = count;
			this.qualifier = qualifier;
			this.isConst = isConst;

		}

	}

	NodeFunctionInput.isNodeFunctionInput = true;

	let discardExpression;

	class DiscardNode extends CondNode {

		constructor( condNode ) {

			discardExpression = discardExpression || expression( 'discard' );

			super( condNode, discardExpression );

		}

	}

	const discard = nodeProxy( DiscardNode );

	addNodeElement( 'discard', discard );

	addNodeClass( DiscardNode );

	class MatcapUVNode extends TempNode {

		constructor() {

			super( 'vec2' );

		}

		construct() {

			const x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();
			const y = positionViewDirection.cross( x );

			return vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 );

		}

	}

	nodeImmutable( MatcapUVNode );

	addNodeClass( MatcapUVNode );

	class TimerNode extends UniformNode {

		constructor( scope = TimerNode.LOCAL, scale = 1, value = 0 ) {

			super( value );

			this.scope = scope;
			this.scale = scale;

			this.updateType = NodeUpdateType.FRAME;

		}
		/*
		@TODO:
		getNodeType( builder ) {

			const scope = this.scope;

			if ( scope === TimerNode.FRAME ) {

				return 'uint';

			}

			return 'float';

		}
	*/
		update( frame ) {

			const scope = this.scope;
			const scale = this.scale;

			if ( scope === TimerNode.LOCAL ) {

				this.value += frame.deltaTime * scale;

			} else if ( scope === TimerNode.DELTA ) {

				this.value = frame.deltaTime * scale;

			} else if ( scope === TimerNode.FRAME ) {

				this.value = frame.frameId;

			} else {

				// global

				this.value = frame.time * scale;

			}

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;
			data.scale = this.scale;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;
			this.scale = data.scale;

		}

	}

	TimerNode.LOCAL = 'local';
	TimerNode.GLOBAL = 'global';
	TimerNode.DELTA = 'delta';
	TimerNode.FRAME = 'frame';

	// @TODO: add support to use node in timeScale
	const timerLocal = ( timeScale, value = 0 ) => nodeObject( new TimerNode( TimerNode.LOCAL, timeScale, value ) );
	nodeImmutable( TimerNode, TimerNode.FRAME );

	addNodeClass( TimerNode );

	class OscNode extends Node {

		constructor( method = OscNode.SINE, timeNode = timerLocal() ) {

			super();

			this.method = method;
			this.timeNode = timeNode;

		}

		getNodeType( builder ) {

			return this.timeNode.getNodeType( builder );

		}

		construct() {

			const method = this.method;
			const timeNode = nodeObject( this.timeNode );

			let outputNode = null;

			if ( method === OscNode.SINE ) {

				outputNode = timeNode.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );

			} else if ( method === OscNode.SQUARE ) {

				outputNode = timeNode.fract().round();

			} else if ( method === OscNode.TRIANGLE ) {

				outputNode = timeNode.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();

			} else if ( method === OscNode.SAWTOOTH ) {

				outputNode = timeNode.fract();

			}

			return outputNode;

		}

		serialize( data ) {

			super.serialize( data );

			data.method = this.method;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.method = data.method;

		}

	}

	OscNode.SINE = 'sine';
	OscNode.SQUARE = 'square';
	OscNode.TRIANGLE = 'triangle';
	OscNode.SAWTOOTH = 'sawtooth';

	nodeProxy( OscNode, OscNode.SINE );
	nodeProxy( OscNode, OscNode.SQUARE );
	nodeProxy( OscNode, OscNode.TRIANGLE );
	nodeProxy( OscNode, OscNode.SAWTOOTH );

	addNodeClass( OscNode );

	class PackingNode extends TempNode {

		constructor( scope, node ) {

			super();

			this.scope = scope;
			this.node = node;

		}

		getNodeType( builder ) {

			return this.node.getNodeType( builder );

		}

		construct() {

			const { scope, node } = this;

			let result = null;

			if ( scope === PackingNode.DIRECTION_TO_COLOR ) {

				result = node.mul( 0.5 ).add( 0.5 );

			} else if ( scope === PackingNode.COLOR_TO_DIRECTION ) {

				result = node.mul( 2.0 ).sub( 1 );

			}

			return result;

		}

	}

	PackingNode.DIRECTION_TO_COLOR = 'directionToColor';
	PackingNode.COLOR_TO_DIRECTION = 'colorToDirection';

	const directionToColor = nodeProxy( PackingNode, PackingNode.DIRECTION_TO_COLOR );
	const colorToDirection = nodeProxy( PackingNode, PackingNode.COLOR_TO_DIRECTION );

	addNodeElement( 'directionToColor', directionToColor );
	addNodeElement( 'colorToDirection', colorToDirection );

	addNodeClass( PackingNode );

	class RemapNode extends Node {

		constructor( node, inLowNode, inHighNode, outLowNode, outHighNode ) {

			super();

			this.node = node;
			this.inLowNode = inLowNode;
			this.inHighNode = inHighNode;
			this.outLowNode = outLowNode;
			this.outHighNode = outHighNode;

			this.doClamp = true;

		}

		construct() {

			const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;

			let t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );

			if ( doClamp === true ) t = t.clamp();

			return t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );

		}

	}

	const remap = nodeProxy( RemapNode, null, null, { doClamp: false } );
	const remapClamp = nodeProxy( RemapNode );

	addNodeElement( 'remap', remap );
	addNodeElement( 'remapClamp', remapClamp );

	addNodeClass( RemapNode );

	class RotateUVNode extends TempNode {

		constructor( uvNode, rotationNode, centerNode = vec2( 0.5 ) ) {

			super( 'vec2' );

			this.uvNode = uvNode;
			this.rotationNode = rotationNode;
			this.centerNode = centerNode;

		}

		construct() {

			const { uvNode, rotationNode, centerNode } = this;

			const cosAngle = rotationNode.cos();
			const sinAngle = rotationNode.sin();

			const vector = uvNode.sub( centerNode );

			const rotatedVector = vec2( // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
				vec2( cosAngle, sinAngle ).dot( vector ),
				vec2( sinAngle.negate(), cosAngle ).dot( vector )
			);

			return rotatedVector.add( centerNode );

		}

	}

	const rotateUV = nodeProxy( RotateUVNode );

	addNodeElement( 'rotateUV', rotateUV );

	addNodeClass( RotateUVNode );

	class SpriteSheetUVNode extends Node {

		constructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {

			super( 'vec2' );

			this.countNode = countNode;
			this.uvNode = uvNode;
			this.frameNode = frameNode;

		}

		construct() {

			const { frameNode, uvNode, countNode } = this;

			const { width, height } = countNode;

			const frameNum = frameNode.mod( width.mul( height ) ).floor();

			const column = frameNum.mod( width );
			const row = height.sub( frameNum.add( 1 ).div( width ).ceil() );

			const scale = countNode.reciprocal();
			const uvFrameOffset = vec2( column, row );

			return uvNode.add( uvFrameOffset ).mul( scale );

		}

	}

	nodeProxy( SpriteSheetUVNode );

	addNodeClass( SpriteSheetUVNode );

	class TriplanarTexturesNode extends Node {

		constructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionWorld, normalNode = normalWorld ) {

			super( 'vec4' );

			this.textureXNode = textureXNode;
			this.textureYNode = textureYNode;
			this.textureZNode = textureZNode;

			this.scaleNode = scaleNode;

			this.positionNode = positionNode;
			this.normalNode = normalNode;

		}

		construct() {

			const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;

			// Ref: https://github.com/keijiro/StandardTriplanar

			// Blending factor of triplanar mapping
			let bf = normalNode.abs().normalize();
			bf = bf.div( bf.dot( vec3( 1.0 ) ) );

			// Triplanar mapping
			const tx = positionNode.yz.mul( scaleNode );
			const ty = positionNode.zx.mul( scaleNode );
			const tz = positionNode.xy.mul( scaleNode );

			// Base color
			const textureX = textureXNode.value;
			const textureY = textureYNode !== null ? textureYNode.value : textureX;
			const textureZ = textureZNode !== null ? textureZNode.value : textureX;

			const cx = texture( textureX, tx ).mul( bf.x );
			const cy = texture( textureY, ty ).mul( bf.y );
			const cz = texture( textureZ, tz ).mul( bf.z );

			return add( cx, cy, cz );

		}

	}

	const triplanarTextures = nodeProxy( TriplanarTexturesNode );
	const triplanarTexture = ( ...params ) => triplanarTextures( ...params );

	addNodeElement( 'triplanarTexture', triplanarTexture );

	addNodeClass( TriplanarTexturesNode );

	// Mipped Bicubic Texture Filtering by N8
	// https://www.shadertoy.com/view/Dl2SDW

	const bC = 1.0 / 6.0;

	const w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );

	const w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );

	const w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );

	const w3 = ( a ) => mul( bC, pow$1( a, 3 ) );

	const g0 = ( a ) => w0( a ).add( w1( a ) );

	const g1 = ( a ) => w2( a ).add( w3( a ) );

	// h0 and h1 are the two offset functions
	const h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );

	const h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );

	const bicubic = ( textureNode, texelSize, lod ) => {

		const uv = textureNode.uvNode;
		const uvScaled = mul( uv, texelSize.zw ).add( 0.5 );

		const iuv = floor( uvScaled );
		const fuv = fract( uvScaled );

		const g0x = g0( fuv.x );
		const g1x = g1( fuv.x );
		const h0x = h0( fuv.x );
		const h1x = h1( fuv.x );
		const h0y = h0( fuv.y );
		const h1y = h1( fuv.y );

		const p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
		const p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
		const p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );
		const p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );

		const a = g0( fuv.y ).mul( add( g0x.mul( textureNode.uv( p0 ).level( lod ) ), g1x.mul( textureNode.uv( p1 ).level( lod ) ) ) );
		const b = g1( fuv.y ).mul( add( g0x.mul( textureNode.uv( p2 ).level( lod ) ), g1x.mul( textureNode.uv( p3 ).level( lod ) ) ) );

		return a.add( b );

	};

	const textureBicubicMethod = ( textureNode, lodNode ) => {

		const fLodSize = vec2( textureNode.size( int( lodNode ) ) );
		const cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );
		const fLodSizeInv = div( 1.0, fLodSize );
		const cLodSizeInv = div( 1.0, cLodSize );
		const fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );
		const cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );

		return fract( lodNode ).mix( fSample, cSample );

	};

	class TextureBicubicNode extends TempNode {

		constructor( textureNode, blurNode = float( 3 ) ) {

			super( 'vec4' );

			this.textureNode = textureNode;
			this.blurNode = blurNode;

		}

		construct() {

			return textureBicubicMethod( this.textureNode, this.blurNode );

		}

	}

	const textureBicubic = nodeProxy( TextureBicubicNode );

	addNodeElement( 'bicubic', textureBicubic );

	addNodeClass( TextureBicubicNode );

	class PointUVNode extends Node {

		constructor() {

			super( 'vec2' );

			this.isPointUVNode = true;

		}

		generate( /*builder*/ ) {

			return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';

		}

	}

	nodeImmutable( PointUVNode );

	addNodeClass( PointUVNode );

	class SceneNode extends Node {

		constructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {

			super();

			this.scope = scope;
			this.scene = scene;

		}

		construct( builder ) {

			const scope = this.scope;
			const scene = this.scene !== null ? this.scene : builder.scene;

			let output;

			if ( scope === SceneNode.BACKGROUND_BLURRINESS ) {

				output = reference( 'backgroundBlurriness', 'float', scene );

			} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {

				output = reference( 'backgroundIntensity', 'float', scene );

			} else ;

			return output;

		}

	}

	SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
	SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';

	const backgroundBlurriness = nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );
	const backgroundIntensity = nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );

	addNodeClass( SceneNode );

	class StorageBufferNode extends BufferNode {

		constructor( value, bufferType, bufferCount = 0 ) {

			super( value, bufferType, bufferCount );

			this.isStorageBufferNode = true;

		}

		getInputType( /*builder*/ ) {

			return 'storageBuffer';

		}

	}

	addNodeClass( StorageBufferNode );

	class UserDataNode extends ReferenceNode {

		constructor( property, inputType, userData = null ) {

			super( property, inputType, userData );

			this.userData = userData;

		}

		update( frame ) {

			this.object = this.userData !== null ? this.userData : frame.object.userData;

			super.update( frame );

		}

	}

	addNodeClass( UserDataNode );

	const BurnNode = tslFn( ( { base, blend } ) => {

		const fn = ( c ) => blend[ c ].lessThan( EPSILON ).cond( blend[ c ], base[ c ].oneMinus().div( blend[ c ] ).oneMinus().max( 0 ) );

		return vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );

	} );

	const DodgeNode = tslFn( ( { base, blend } ) => {

		const fn = ( c ) => blend[ c ].equal( 1.0 ).cond( blend[ c ], base[ c ].div( blend[ c ].oneMinus() ).max( 0 ) );

		return vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );

	} );

	const ScreenNode = tslFn( ( { base, blend } ) => {

		const fn = ( c ) => base[ c ].oneMinus().mul( blend[ c ].oneMinus() ).oneMinus();

		return vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );

	} );

	const OverlayNode = tslFn( ( { base, blend } ) => {

		const fn = ( c ) => base[ c ].lessThan( 0.5 ).cond( base[ c ].mul( blend[ c ], 2.0 ), base[ c ].oneMinus().mul( blend[ c ].oneMinus() ).oneMinus() );

		return vec3( fn( 'x' ), fn( 'y' ), fn( 'z' ) );

	} );

	class BlendModeNode extends TempNode {

		constructor( blendMode, baseNode, blendNode ) {

			super();

			this.blendMode = blendMode;

			this.baseNode = baseNode;
			this.blendNode = blendNode;

		}

		construct() {

			const { blendMode, baseNode, blendNode } = this;
			const params = { base: baseNode, blend: blendNode };

			let outputNode = null;

			if ( blendMode === BlendModeNode.BURN ) {

				outputNode = BurnNode( params );

			} else if ( blendMode === BlendModeNode.DODGE ) {

				outputNode = DodgeNode( params );

			} else if ( blendMode === BlendModeNode.SCREEN ) {

				outputNode = ScreenNode( params );

			} else if ( blendMode === BlendModeNode.OVERLAY ) {

				outputNode = OverlayNode( params );

			}

			return outputNode;

		}

	}

	BlendModeNode.BURN = 'burn';
	BlendModeNode.DODGE = 'dodge';
	BlendModeNode.SCREEN = 'screen';
	BlendModeNode.OVERLAY = 'overlay';

	const burn = nodeProxy( BlendModeNode, BlendModeNode.BURN );
	const dodge = nodeProxy( BlendModeNode, BlendModeNode.DODGE );
	const overlay = nodeProxy( BlendModeNode, BlendModeNode.OVERLAY );
	const screen = nodeProxy( BlendModeNode, BlendModeNode.SCREEN );

	addNodeElement( 'burn', burn );
	addNodeElement( 'dodge', dodge );
	addNodeElement( 'overlay', overlay );
	addNodeElement( 'screen', screen );

	addNodeClass( BlendModeNode );

	const saturationNode = tslFn( ( { color, adjustment } ) => {

		return adjustment.mix( luminance( color ), color );

	} );

	const vibranceNode = tslFn( ( { color, adjustment } ) => {

		const average = add( color.r, color.g, color.b ).div( 3.0 );

		const mx = color.r.max( color.g.max( color.b ) );
		const amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );

		return mix( color, mx, amt );

	} );

	const hueNode = tslFn( ( { color, adjustment } ) => {

		const RGBtoYIQ = mat3( 0.299, 0.587, 0.114, 0.595716, - 0.274453, - 0.321263, 0.211456, - 0.522591, 0.311135 );
		const YIQtoRGB = mat3( 1.0, 0.9563, 0.6210, 1.0, - 0.2721, - 0.6474, 1.0, - 1.107, 1.7046 );

		const yiq = RGBtoYIQ.mul( color );

		const hue = yiq.z.atan2( yiq.y ).add( adjustment );
		const chroma = yiq.yz.length();

		return YIQtoRGB.mul( vec3( yiq.x, chroma.mul( hue.cos() ), chroma.mul( hue.sin() ) ) );

	} );

	class ColorAdjustmentNode extends TempNode {

		constructor( method, colorNode, adjustmentNode = float( 1 ) ) {

			super( 'vec3' );

			this.method = method;

			this.colorNode = colorNode;
			this.adjustmentNode = adjustmentNode;

		}

		construct() {

			const { method, colorNode, adjustmentNode } = this;

			const callParams = { color: colorNode, adjustment: adjustmentNode };

			let outputNode = null;

			if ( method === ColorAdjustmentNode.SATURATION ) {

				outputNode = saturationNode( callParams );

			} else if ( method === ColorAdjustmentNode.VIBRANCE ) {

				outputNode = vibranceNode( callParams );

			} else if ( method === ColorAdjustmentNode.HUE ) {

				outputNode = hueNode( callParams );

			} else ;

			return outputNode;

		}

	}

	ColorAdjustmentNode.SATURATION = 'saturation';
	ColorAdjustmentNode.VIBRANCE = 'vibrance';
	ColorAdjustmentNode.HUE = 'hue';

	const saturation = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.SATURATION );
	const vibrance = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE );
	const hue = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.HUE );

	const lumaCoeffs = vec3( 0.2125, 0.7154, 0.0721 );
	const luminance = ( color, luma = lumaCoeffs ) => dot( color, luma );

	addNodeElement( 'saturation', saturation );
	addNodeElement( 'vibrance', vibrance );
	addNodeElement( 'hue', hue );

	addNodeClass( ColorAdjustmentNode );

	class PosterizeNode extends TempNode {

		constructor( sourceNode, stepsNode ) {

			super();

			this.sourceNode = sourceNode;
			this.stepsNode = stepsNode;

		}

		construct() {

			const { sourceNode, stepsNode } = this;

			return sourceNode.mul( stepsNode ).floor().div( stepsNode );

		}

	}

	const posterize = nodeProxy( PosterizeNode );

	addNodeElement( 'posterize', posterize );

	addNodeClass( PosterizeNode );

	// exposure only
	const LinearToneMappingNode = tslFn( ( { color, exposure } ) => {

		return color.mul( exposure ).clamp();

	} );

	// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
	const ReinhardToneMappingNode = tslFn( ( { color, exposure } ) => {

		color = color.mul( exposure );

		return color.div( color.add( 1.0 ) ).clamp();

	} );

	// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
	const OptimizedCineonToneMappingNode = tslFn( ( { color, exposure } ) => {

		// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
		color = color.mul( exposure );
		color = color.sub( 0.004 ).max( 0.0 );

		const a = color.mul( color.mul( 6.2 ).add( 0.5 ) );
		const b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );

		return a.div( b ).pow( 2.2 );

	} );

	// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
	const RRTAndODTFit = tslFn( ( { color } ) => {

		const a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );
		const b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );

		return a.div( b );

	} );

	// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
	const ACESFilmicToneMappingNode = tslFn( ( { color, exposure } ) => {

		// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
		const ACESInputMat = mat3(
			0.59719, 0.35458, 0.04823,
			0.07600, 0.90834, 0.01566,
			0.02840, 0.13383, 0.83777
		);

		// ODT_SAT => XYZ => D60_2_D65 => sRGB
		const ACESOutputMat = mat3(
			1.60475, - 0.53108, - 0.07367,
			- 0.10208, 1.10813, - 0.00605,
			- 0.00327, - 0.07276, 1.07602
		);

		color = color.mul( exposure ).div( 0.6 );

		color = ACESInputMat.mul( color );

		// Apply RRT and ODT
		color = RRTAndODTFit( { color } );

		color = ACESOutputMat.mul( color );

		// Clamp to [0, 1]
		return color.clamp();

	} );

	const toneMappingLib = {
		[ LinearToneMapping ]: LinearToneMappingNode,
		[ ReinhardToneMapping ]: ReinhardToneMappingNode,
		[ CineonToneMapping ]: OptimizedCineonToneMappingNode,
		[ ACESFilmicToneMapping ]: ACESFilmicToneMappingNode
	};

	class ToneMappingNode extends TempNode {

		constructor( toneMapping = NoToneMapping, exposureNode = float( 1 ), colorNode = null ) {

			super( 'vec3' );

			this.toneMapping = toneMapping;

			this.exposureNode = exposureNode;
			this.colorNode = colorNode;

		}

		getCacheKey() {

			let cacheKey = super.getCacheKey();
			cacheKey = '{toneMapping:' + this.toneMapping + ',nodes:' + cacheKey + '}';

			return cacheKey;

		}

		construct( builder ) {

			const colorNode = this.colorNode || builder.context.color;
			const toneMapping = this.toneMapping;

			if ( toneMapping === NoToneMapping ) return colorNode;

			const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
			const toneMappingNode = toneMappingLib[ toneMapping ];

			let outputNode = null;

			if ( toneMappingNode ) {

				outputNode = toneMappingNode( toneMappingParams );

			} else {

				outputNode = colorNode;

			}

			return outputNode;

		}

	}

	const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );

	addNodeClass( ToneMappingNode );

	let resolution;

	class ViewportNode extends Node {

		constructor( scope ) {

			super();

			this.scope = scope;

			this.isViewportNode = true;

		}

		getNodeType() {

			return this.scope === ViewportNode.COORDINATE ? 'vec4' : 'vec2';

		}

		getUpdateType() {

			let updateType = NodeUpdateType.NONE;

			if ( this.scope === ViewportNode.RESOLUTION ) {

				updateType = NodeUpdateType.FRAME;

			}

			this.updateType = updateType;

			return updateType;

		}

		update( { renderer } ) {

			renderer.getDrawingBufferSize( resolution );

		}

		construct( builder ) {

			const scope = this.scope;

			if ( scope === ViewportNode.COORDINATE ) return;

			let output = null;

			if ( scope === ViewportNode.RESOLUTION ) {

				output = uniform( resolution || ( resolution = new Vector2() ) );

			} else {

				const coordinateNode = vec2( new ViewportNode( ViewportNode.COORDINATE ) );
				const resolutionNode = new ViewportNode( ViewportNode.RESOLUTION );

				output = coordinateNode.div( resolutionNode );

				let outX = output.x;
				let outY = output.y;

				if ( /top/i.test( scope ) && builder.isFlipY() ) outY = outY.oneMinus();
				else if ( /bottom/i.test( scope ) && builder.isFlipY() === false ) outY = outY.oneMinus();

				if ( /right/i.test( scope ) ) outX = outX.oneMinus();

				output = vec2( outX, outY );

			}

			return output;

		}

		generate( builder ) {

			if ( this.scope === ViewportNode.COORDINATE ) {

				return builder.getFragCoord();

			}

			return super.generate( builder );

		}

	}

	ViewportNode.COORDINATE = 'coordinate';
	ViewportNode.RESOLUTION = 'resolution';
	ViewportNode.TOP_LEFT = 'topLeft';
	ViewportNode.BOTTOM_LEFT = 'bottomLeft';
	ViewportNode.TOP_RIGHT = 'topRight';
	ViewportNode.BOTTOM_RIGHT = 'bottomRight';

	nodeImmutable( ViewportNode, ViewportNode.COORDINATE );
	nodeImmutable( ViewportNode, ViewportNode.RESOLUTION );
	const viewportTopLeft = nodeImmutable( ViewportNode, ViewportNode.TOP_LEFT );
	const viewportBottomLeft = nodeImmutable( ViewportNode, ViewportNode.BOTTOM_LEFT );
	nodeImmutable( ViewportNode, ViewportNode.TOP_RIGHT );
	nodeImmutable( ViewportNode, ViewportNode.BOTTOM_RIGHT );

	addNodeClass( ViewportNode );

	const _size$1 = new Vector2();

	class ViewportTextureNode extends TextureNode {

		constructor( uvNode = viewportTopLeft, levelNode = null, framebufferTexture = null ) {

			if ( framebufferTexture === null ) {

				framebufferTexture = new FramebufferTexture();
				framebufferTexture.minFilter = LinearMipmapLinearFilter;

			}

			super( framebufferTexture, uvNode, levelNode );

			this.generateMipmaps = false;

			this.isOutputTextureNode = true;

			this.updateBeforeType = NodeUpdateType.FRAME;

		}

		updateBefore( frame ) {

			const renderer = frame.renderer;
			renderer.getDrawingBufferSize( _size$1 );

			//

			const framebufferTexture = this.value;

			if ( framebufferTexture.image.width !== _size$1.width || framebufferTexture.image.height !== _size$1.height ) {

				framebufferTexture.image.width = _size$1.width;
				framebufferTexture.image.height = _size$1.height;
				framebufferTexture.needsUpdate = true;

			}

			//

			const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
			framebufferTexture.generateMipmaps = this.generateMipmaps;

			renderer.copyFramebufferToTexture( framebufferTexture );

			framebufferTexture.generateMipmaps = currentGenerateMipmaps;

		}

		clone() {

			return new this.constructor( this.uvNode, this.levelNode, this.value );

		}

	}

	const viewportTexture = nodeProxy( ViewportTextureNode );
	const viewportMipTexture = nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );

	addNodeElement( 'viewportTexture', viewportTexture );
	addNodeElement( 'viewportMipTexture', viewportMipTexture );

	addNodeClass( ViewportTextureNode );

	let sharedFramebuffer = null;

	class ViewportSharedTextureNode extends ViewportTextureNode {

		constructor( uvNode = viewportTopLeft, levelNode = null ) {

			if ( sharedFramebuffer === null ) {

				sharedFramebuffer = new FramebufferTexture();

			}

			super( uvNode, levelNode, sharedFramebuffer );

		}

	}

	const viewportSharedTexture = nodeProxy( ViewportSharedTextureNode );

	addNodeElement( 'viewportSharedTexture', viewportSharedTexture );

	addNodeClass( ViewportSharedTextureNode );

	let sharedDepthbuffer = null;

	class ViewportDepthTextureNode extends ViewportTextureNode {

		constructor( uvNode = viewportTopLeft, levelNode = null ) {

			if ( sharedDepthbuffer === null ) {

				sharedDepthbuffer = new DepthTexture();
				sharedDepthbuffer.minFilter = LinearMipmapLinearFilter;
				sharedDepthbuffer.type = UnsignedIntType;
				sharedDepthbuffer.format = DepthFormat;

			}

			super( uvNode, levelNode, sharedDepthbuffer );

		}

	}

	const viewportDepthTexture = nodeProxy( ViewportDepthTextureNode );

	addNodeElement( 'viewportDepthTexture', viewportDepthTexture );

	addNodeClass( ViewportDepthTextureNode );

	class ViewportDepthNode extends Node {

		constructor( scope, textureNode = null ) {

			super( 'float' );

			this.scope = scope;
			this.textureNode = textureNode;

			this.isViewportDepthNode = true;

		}

		construct( /*builder*/ ) {

			const { scope } = this;

			let node = null;

			if ( scope === ViewportDepthNode.DEPTH ) {

				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

			} else if ( scope === ViewportDepthNode.DEPTH_TEXTURE ) {

				const texture = this.textureNode || viewportDepthTexture();

				const viewZ = perspectiveDepthToViewZ( texture, cameraNear, cameraFar );
				node = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			}

			return node;

		}

	}

	// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

	// -near maps to 0; -far maps to 1
	const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );

	// maps perspective depth in [ 0, 1 ] to viewZ
	const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );

	ViewportDepthNode.DEPTH = 'depth';
	ViewportDepthNode.DEPTH_TEXTURE = 'depthTexture';

	nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );
	nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE );

	addNodeClass( ViewportDepthNode );

	class CodeNode extends Node {

		constructor( code = '', includes = [], language = '' ) {

			super( 'code' );

			this.isCodeNode = true;

			this.code = code;
			this.language = language;

			this._includes = includes;

		}

		setIncludes( includes ) {

			this._includes = includes;

			return this;

		}

		getIncludes( /*builder*/ ) {

			return this._includes;

		}

		generate( builder ) {

			const includes = this.getIncludes( builder );

			for ( const include of includes ) {

				include.build( builder );

			}

			const nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );
			nodeCode.code = this.code;

			return nodeCode.code;

		}

		serialize( data ) {

			super.serialize( data );

			data.code = this.code;
			data.language = this.language;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.code = data.code;
			this.language = data.language;

		}

	}

	const code = nodeProxy( CodeNode );
	const glsl = ( src, includes ) => code( src, includes, 'glsl' );

	addNodeClass( CodeNode );

	class FunctionCallNode extends TempNode {

		constructor( functionNode = null, parameters = {} ) {

			super();

			this.functionNode = functionNode;
			this.parameters = parameters;

		}

		setParameters( parameters ) {

			this.parameters = parameters;

			return this;

		}

		getParameters() {

			return this.parameters;

		}

		getNodeType( builder ) {

			return this.functionNode.getNodeType( builder );

		}

		generate( builder ) {

			const params = [];

			const functionNode = this.functionNode;

			const inputs = functionNode.getInputs( builder );
			const parameters = this.parameters;

			if ( Array.isArray( parameters ) ) {

				for ( let i = 0; i < parameters.length; i ++ ) {

					const inputNode = inputs[ i ];
					const node = parameters[ i ];

					params.push( node.build( builder, inputNode.type ) );

				}

			} else {

				for ( const inputNode of inputs ) {

					const node = parameters[ inputNode.name ];

					if ( node !== undefined ) {

						params.push( node.build( builder, inputNode.type ) );

					} else {

						throw new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );

					}

				}

			}

			const functionName = functionNode.build( builder, 'property' );

			return `${functionName}( ${params.join( ', ' )} )`;

		}

	}

	const call = ( func, ...params ) => {

		params = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );

		return nodeObject( new FunctionCallNode( nodeObject( func ), params ) );

	};

	addNodeElement( 'call', call );

	addNodeClass( FunctionCallNode );

	class FunctionNode extends CodeNode {

		constructor( code = '', includes = [], language = '' ) {

			super( code, includes, language );

			this.keywords = {};

		}

		getNodeType( builder ) {

			return this.getNodeFunction( builder ).type;

		}

		getInputs( builder ) {

			return this.getNodeFunction( builder ).inputs;

		}

		getNodeFunction( builder ) {

			const nodeData = builder.getDataFromNode( this );

			let nodeFunction = nodeData.nodeFunction;

			if ( nodeFunction === undefined ) {

				nodeFunction = builder.parser.parseFunction( this.code );

				nodeData.nodeFunction = nodeFunction;

			}

			return nodeFunction;

		}

		generate( builder, output ) {

			super.generate( builder );

			const nodeFunction = this.getNodeFunction( builder );

			const name = nodeFunction.name;
			const type = nodeFunction.type;

			const nodeCode = builder.getCodeFromNode( this, type );

			if ( name !== '' ) {

				// use a custom property name

				nodeCode.name = name;

			}

			const propertyName = builder.getPropertyName( nodeCode );

			let code = this.getNodeFunction( builder ).getCode( propertyName );

			const keywords = this.keywords;
			const keywordsProperties = Object.keys( keywords );

			if ( keywordsProperties.length > 0 ) {

				for ( const property of keywordsProperties ) {

					const propertyRegExp = new RegExp( `\\b${property}\\b`, 'g' );
					const nodeProperty = keywords[ property ].build( builder, 'property' );

					code = code.replace( propertyRegExp, nodeProperty );

				}

			}

			nodeCode.code = code;

			if ( output === 'property' ) {

				return propertyName;

			} else {

				return builder.format( `${ propertyName }()`, type, output );

			}

		}

	}

	addNodeClass( FunctionNode );

	class ScriptableValueNode extends Node {

		constructor( value = null ) {

			super();

			this._value = value;
			this._cache = null;

			this.inputType = null;
			this.outpuType = null;

			this.events = new EventDispatcher();

			this.isScriptableValueNode = true;

		}

		get isScriptableOutputNode() {

			return this.outputType !== null;

		}

		set value( val ) {

			if ( this._value === val ) return;

			if ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {

				URL.revokeObjectURL( this._cache );

				this._cache = null;

			}

			this._value = val;

			this.events.dispatchEvent( { type: 'change' } );

			this.refresh();

		}

		get value() {

			return this._value;

		}

		refresh() {

			this.events.dispatchEvent( { type: 'refresh' } );

		}

		getValue() {

			const value = this.value;

			if ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {

				this._cache = URL.createObjectURL( new Blob( [ value.value ] ) );

			} else if ( value && value.value !== null && value.value !== undefined && (
				( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||
				( this.inputType === 'Number' && typeof value.value === 'number' ) ||
				( this.inputType === 'Vector2' && value.value.isVector2 ) ||
				( this.inputType === 'Vector3' && value.value.isVector3 ) ||
				( this.inputType === 'Vector4' && value.value.isVector4 ) ||
				( this.inputType === 'Color' && value.value.isColor ) ||
				( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||
				( this.inputType === 'Matrix4' && value.value.isMatrix4 )
			) ) {

				return value.value;

			}

			return this._cache || value;

		}

		getNodeType( builder ) {

			return this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';

		}

		construct() {

			return this.value && this.value.isNode ? this.value : float();

		}

		serialize( data ) {

			super.serialize( data );

			if ( this.value !== null ) {

				if ( this.inputType === 'ArrayBuffer' ) {

					data.value = arrayBufferToBase64( this.value );

				} else {

					data.value = this.value ? this.value.toJSON( data.meta ).uuid : null;

				}

			} else {

				data.value = null;

			}

			data.inputType = this.inputType;
			data.outputType = this.outputType;

		}

		deserialize( data ) {

			super.deserialize( data );

			let value = null;

			if ( data.value !== null ) {

				if ( data.inputType === 'ArrayBuffer' ) {

					value = base64ToArrayBuffer( data.value );

				} else if ( data.inputType === 'Texture' ) {

					value = data.meta.textures[ data.value ];

				} else {

					value = data.meta.nodes[ data.value ] || null;

				}

			}

			this.value = value;

			this.inputType = data.inputType;
			this.outputType = data.outputType;

		}

	}

	const scriptableValue = nodeProxy( ScriptableValueNode );

	addNodeElement( 'scriptableValue', scriptableValue );

	addNodeClass( ScriptableValueNode );

	class Resources extends Map {

		get( key, callback = null, ...params ) {

			if ( this.has( key ) ) return super.get( key );

			if ( callback !== null ) {

				const value = callback( ...params );
				this.set( key, value );
				return value;

			}

		}

	}

	class Parameters {

		constructor( scriptableNode ) {

			this.scriptableNode = scriptableNode;

		}

		get parameters() {

			return this.scriptableNode.parameters;

		}

		get layout() {

			return this.scriptableNode.getLayout();

		}

		getInputLayout( id ) {

			return this.scriptableNode.getInputLayout( id );

		}

		get( name ) {

			const param = this.parameters[ name ];
			const value = param ? param.getValue() : null;

			return value;

		}

	}

	const global = new Resources();

	class ScriptableNode extends Node {

		constructor( codeNode = null, parameters = {} ) {

			super();

			this.codeNode = codeNode;
			this.parameters = parameters;

			this._local = new Resources();
			this._output = scriptableValue();
			this._outputs = {};
			this._source = this.source;
			this._method = null;
			this._object = null;
			this._value = null;
			this._needsOutputUpdate = true;

			this.onRefresh = this.onRefresh.bind( this );

			this.isScriptableNode = true;

		}

		get source() {

			return this.codeNode ? this.codeNode.code : '';

		}

		setLocal( name, value ) {

			return this._local.set( name, value );

		}

		getLocal( name ) {

			return this._local.get( name );

		}

		onRefresh() {

			this._refresh();

		}

		getInputLayout( id ) {

			for ( const element of this.getLayout() ) {

				if ( element.inputType && ( element.id === id || element.name === id ) ) {

					return element;

				}

			}

		}

		getOutputLayout( id ) {

			for ( const element of this.getLayout() ) {

				if ( element.outputType && ( element.id === id || element.name === id ) ) {

					return element;

				}

			}

		}

		setOutput( name, value ) {

			const outputs = this._outputs;

			if ( outputs[ name ] === undefined ) {

				outputs[ name ] = scriptableValue( value );

			} else {

				outputs[ name ].value = value;

			}

			return this;

		}

		getOutput( name ) {

			return this._outputs[ name ];

		}

		getParameter( name ) {

			return this.parameters[ name ];

		}

		setParameter( name, value ) {

			const parameters = this.parameters;

			if ( value && value.isScriptableNode ) {

				this.deleteParameter( name );

				parameters[ name ] = value;
				parameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );

			} else if ( value && value.isScriptableValueNode ) {

				this.deleteParameter( name );

				parameters[ name ] = value;
				parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

			} else if ( parameters[ name ] === undefined ) {

				parameters[ name ] = scriptableValue( value );
				parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

			} else {

				parameters[ name ].value = value;

			}

			return this;

		}

		getValue() {

			return this.getDefaultOutput().getValue();

		}

		deleteParameter( name ) {

			let valueNode = this.parameters[ name ];

			if ( valueNode ) {

				if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

				valueNode.events.removeEventListener( 'refresh', this.onRefresh );

			}

			return this;

		}

		clearParameters() {

			for ( const name of Object.keys( this.parameters ) ) {

				this.deleteParameter( name );

			}

			this.needsUpdate = true;

			return this;

		}

		call( name, ...params ) {

			const object = this.getObject();
			const method = object[ name ];

			if ( typeof method === 'function' ) {

				return method( ...params );

			}

		}

		async callAsync( name, ...params ) {

			const object = this.getObject();
			const method = object[ name ];

			if ( typeof method === 'function' ) {

				return method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );

			}

		}

		getNodeType( builder ) {

			return this.getDefaultOutputNode().getNodeType( builder );

		}

		refresh( output = null ) {

			if ( output !== null ) {

				this.getOutput( output ).refresh();

			} else {

				this._refresh();

			}

		}

		getObject() {

			if ( this.needsUpdate ) this.dispose();
			if ( this._object !== null ) return this._object;

			//

			const refresh = () => this.refresh();
			const setOutput = ( id, value ) => this.setOutput( id, value );

			const parameters = new Parameters( this );

			const THREE = global.get( 'THREE' );
			const TSL = global.get( 'TSL' );

			const method = this.getMethod( this.codeNode );
			const params = [ parameters, this._local, global, refresh, setOutput, THREE, TSL ];

			this._object = method( ...params );

			const layout = this._object.layout;

			if ( layout ) {

				if ( layout.cache === false ) {

					this._local.clear();

				}

				// default output
				this._output.outputType = layout.outputType || null;

				if ( Array.isArray( layout.elements ) ) {

					for ( const element of layout.elements ) {

						const id = element.id || element.name;

						if ( element.inputType ) {

							if ( this.getParameter( id ) === undefined ) this.setParameter( id, null );

							this.getParameter( id ).inputType = element.inputType;

						}

						if ( element.outputType ) {

							if ( this.getOutput( id ) === undefined ) this.setOutput( id, null );

							this.getOutput( id ).outputType = element.outputType;

						}

					}

				}

			}

			return this._object;

		}

		deserialize( data ) {

			super.deserialize( data );

			for ( const name in this.parameters ) {

				let valueNode = this.parameters[ name ];

				if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

				valueNode.events.addEventListener( 'refresh', this.onRefresh );

			}

		}

		getLayout() {

			return this.getObject().layout;

		}

		getDefaultOutputNode() {

			const output = this.getDefaultOutput().value;

			if ( output && output.isNode ) {

				return output;

			}

			return float();

		}

		getDefaultOutput()	{

			return this._exec()._output;

		}

		getMethod() {

			if ( this.needsUpdate ) this.dispose();
			if ( this._method !== null ) return this._method;

			//

			const parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];
			const interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];

			const properties = interfaceProps.join( ', ' );
			const declarations = 'var ' + properties + '; var output = {};\n';
			const returns = '\nreturn { ...output, ' + properties + ' };';

			const code = declarations + this.codeNode.code + returns;

			//

			this._method = new Function( ...parametersProps, code );

			return this._method;

		}

		dispose() {

			if ( this._method === null ) return;

			if ( this._object && typeof this._object.dispose === 'function' ) {

				this._object.dispose();

			}

			this._method = null;
			this._object = null;
			this._source = null;
			this._value = null;
			this._needsOutputUpdate = true;
			this._output.value = null;
			this._outputs = {};

		}

		construct() {

			return this.getDefaultOutputNode();

		}

		set needsUpdate( value ) {

			if ( value === true ) this.dispose();

		}

		get needsUpdate() {

			return this.source !== this._source;

		}

		_exec()	{

			if ( this.codeNode === null ) return this;

			if ( this._needsOutputUpdate === true ) {

				this._value = this.call( 'main' );

				this._needsOutputUpdate = false;

			}

			this._output.value = this._value;

			return this;

		}

		_refresh() {

			this.needsUpdate = true;

			this._exec();

			this._output.refresh();

		}

	}

	const scriptable = nodeProxy( ScriptableNode );

	addNodeElement( 'scriptable', scriptable );

	addNodeClass( ScriptableNode );

	class FogNode extends Node {

		constructor( colorNode, factorNode ) {

			super( 'float' );

			this.isFogNode = true;

			this.colorNode = colorNode;
			this.factorNode = factorNode;

		}

		mixAssign( outputNode ) {

			return this.mix( outputNode, this.colorNode );

		}

		construct() {

			return this.factorNode;

		}

	}

	const fog = nodeProxy( FogNode );

	addNodeElement( 'fog', fog );

	addNodeClass( FogNode );

	class FogRangeNode extends FogNode {

		constructor( colorNode, nearNode, farNode ) {

			super( colorNode );

			this.isFogRangeNode = true;

			this.nearNode = nearNode;
			this.farNode = farNode;

		}

		construct() {

			return smoothstep( this.nearNode, this.farNode, positionView.z.negate() );

		}

	}

	const rangeFog = nodeProxy( FogRangeNode );

	addNodeElement( 'rangeFog', rangeFog );

	addNodeClass( FogRangeNode );

	class FogExp2Node extends FogNode {

		constructor( colorNode, densityNode ) {

			super( colorNode );

			this.isFogExp2Node = true;

			this.densityNode = densityNode;

		}

		construct() {

			const depthNode = positionView.z.negate();
			const densityNode = this.densityNode;

			return densityNode.mul( densityNode, depthNode, depthNode ).negate().exp().oneMinus();

		}

	}

	const densityFog = nodeProxy( FogExp2Node );

	addNodeElement( 'densityFog', densityFog );

	addNodeClass( FogExp2Node );

	let min = null;
	let max = null;

	class RangeNode extends Node {

		constructor( minNode = float(), maxNode = float() ) {

			super();

			this.minNode = minNode;
			this.maxNode = maxNode;

		}

		getVectorLength( builder ) {

			const minLength = builder.getTypeLength( getValueType( this.minNode.value ) );
			const maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );

			return minLength > maxLength ? minLength : maxLength;

		}

		getNodeType( builder ) {

			return builder.object.isInstancedMesh === true ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';

		}

		construct( builder ) {

			const object = builder.object;

			let output = null;

			if ( object.isInstancedMesh === true ) {

				const minValue = this.minNode.value;
				const maxValue = this.maxNode.value;

				const minLength = builder.getTypeLength( getValueType( minValue ) );
				const maxLength = builder.getTypeLength( getValueType( maxValue ) );

				min = min || new Vector4();
				max = max || new Vector4();

				min.setScalar( 0 );
				max.setScalar( 0 );

				if ( minLength === 1 ) min.setScalar( minValue );
				else if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b );
				else min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );

				if ( maxLength === 1 ) max.setScalar( maxValue );
				else if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b );
				else max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );

				const stride = 4;

				const length = stride * object.count;
				const array = new Float32Array( length );

				for ( let i = 0; i < length; i ++ ) {

					const index = i % stride;

					const minElementValue = min.getComponent( index );
					const maxElementValue = max.getComponent( index );

					array[ i ] = MathUtils$1.lerp( minElementValue, maxElementValue, Math.random() );

				}

				const nodeType = this.getNodeType( builder );

				output = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );
				//output = bufferAttribute( array, 'vec4', 4, 0 ).convert( nodeType );

			} else {

				output = float( 0 );

			}

			return output;

		}

	}

	nodeProxy( RangeNode );

	addNodeClass( RangeNode );

	class ComputeNode extends Node {

		constructor( computeNode, count, workgroupSize = [ 64 ] ) {

			super( 'void' );

			this.isComputeNode = true;

			this.computeNode = computeNode;

			this.count = count;
			this.workgroupSize = workgroupSize;
			this.dispatchCount = 0;

			this.version = 1;
			this.updateType = NodeUpdateType.OBJECT;

			this.updateDispatchCount();

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		updateDispatchCount() {

			const { count, workgroupSize } = this;

			let size = workgroupSize[ 0 ];

			for ( let i = 1; i < workgroupSize.length; i ++ )
				size *= workgroupSize[ i ];

			this.dispatchCount = Math.ceil( count / size );

		}

		onInit() { }

		update( { renderer } ) {

			renderer.compute( this );

		}

		generate( builder ) {

			const { shaderStage } = builder;

			if ( shaderStage === 'compute' ) {

				const snippet = this.computeNode.build( builder, 'void' );

				if ( snippet !== '' ) {

					builder.addLineFlowCode( snippet );

				}

			}

		}

	}

	const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );

	addNodeElement( 'compute', compute );

	addNodeClass( ComputeNode );

	class LightNode extends Node {

		constructor( scope = LightNode.TARGET_DIRECTION, light = null ) {

			super();

			this.scope = scope;
			this.light = light;

		}

		construct() {

			const { scope, light } = this;

			let output = null;

			if ( scope === LightNode.TARGET_DIRECTION ) {

				output = cameraViewMatrix.transformDirection( objectPosition( light ).sub( objectPosition( light.target ) ) );

			}

			return output;

		}

		serialize( data ) {

			super.serialize( data );

			data.scope = this.scope;

		}

		deserialize( data ) {

			super.deserialize( data );

			this.scope = data.scope;

		}

	}

	LightNode.TARGET_DIRECTION = 'targetDirection';

	const lightTargetDirection = nodeProxy( LightNode, LightNode.TARGET_DIRECTION );

	addNodeClass( LightNode );

	const getDistanceAttenuation = tslFn( ( inputs ) => {

		const { lightDistance, cutoffDistance, decayExponent } = inputs;

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		const distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();

		return cutoffDistance.greaterThan( 0 ).cond(
			distanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),
			distanceFalloff
		);

	} ); // validated

	class PointLightNode extends AnalyticLightNode {

		constructor( light = null ) {

			super( light );

			this.cutoffDistanceNode = uniform( 0 );
			this.decayExponentNode = uniform( 0 );

		}

		update( frame ) {

			const { light } = this;

			super.update( frame );

			this.cutoffDistanceNode.value = light.distance;
			this.decayExponentNode.value = light.decay;

		}

		construct( builder ) {

			const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

			const lightingModel = builder.context.lightingModel;

			const lVector = objectViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode

			const lightDirection = lVector.normalize();
			const lightDistance = lVector.length();

			const lightAttenuation = getDistanceAttenuation( {
				lightDistance,
				cutoffDistance: cutoffDistanceNode,
				decayExponent: decayExponentNode
			} );

			const lightColor = colorNode.mul( lightAttenuation );

			const reflectedLight = builder.context.reflectedLight;

			lightingModel.direct( {
				lightDirection,
				lightColor,
				reflectedLight
			} );

		}

	}

	addLightNode( PointLight, PointLightNode );

	addNodeClass( PointLightNode );

	class DirectionalLightNode extends AnalyticLightNode {

		constructor( light = null ) {

			super( light );

		}

		construct( builder ) {

			super.construct( builder );

			const lightingModel = builder.context.lightingModel;

			const lightColor = this.colorNode;
			const lightDirection = lightTargetDirection( this.light );
			const reflectedLight = builder.context.reflectedLight;

			lightingModel.direct( {
				lightDirection,
				lightColor,
				reflectedLight
			} );

		}

	}

	addLightNode( DirectionalLight, DirectionalLightNode );

	addNodeClass( DirectionalLightNode );

	class SpotLightNode extends AnalyticLightNode {

		constructor( light = null ) {

			super( light );

			this.coneCosNode = uniform( 0 );
			this.penumbraCosNode = uniform( 0 );

			this.cutoffDistanceNode = uniform( 0 );
			this.decayExponentNode = uniform( 0 );

		}

		update( frame ) {

			super.update( frame );

			const { light } = this;

			this.coneCosNode.value = Math.cos( light.angle );
			this.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );

			this.cutoffDistanceNode.value = light.distance;
			this.decayExponentNode.value = light.decay;

		}

		getSpotAttenuation( angleCosine ) {

			const { coneCosNode, penumbraCosNode } = this;

			return smoothstep( coneCosNode, penumbraCosNode, angleCosine );

		}

		construct( builder ) {

			super.construct( builder );

			const lightingModel = builder.context.lightingModel;

			const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

			const lVector = objectViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode

			const lightDirection = lVector.normalize();
			const angleCos = lightDirection.dot( lightTargetDirection( light ) );
			const spotAttenuation = this.getSpotAttenuation( angleCos );

			const lightDistance = lVector.length();

			const lightAttenuation = getDistanceAttenuation( {
				lightDistance,
				cutoffDistance: cutoffDistanceNode,
				decayExponent: decayExponentNode
			} );

			const lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );

			const reflectedLight = builder.context.reflectedLight;

			lightingModel.direct( {
				lightDirection,
				lightColor,
				reflectedLight
			} );

		}

	}

	addLightNode( SpotLight, SpotLightNode );

	addNodeClass( SpotLightNode );

	class IESSpotLight extends SpotLight {

		constructor( color, intensity, distance, angle, penumbra, decay ) {

			super( color, intensity, distance, angle, penumbra, decay );

			this.iesMap = null;

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.iesMap = source.iesMap;

			return this;

		}

	}

	class IESSpotLightNode extends SpotLightNode {

		getSpotAttenuation( angleCosine ) {

			const iesMap = this.light.iesMap;

			let spotAttenuation = null;

			if ( iesMap && iesMap.isTexture === true ) {

				const angle = angleCosine.acos().mul( 1.0 / Math.PI );

				spotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;

			} else {

				spotAttenuation = super.getSpotAttenuation( angleCosine );

			}

			return spotAttenuation;

		}

	}

	addLightNode( IESSpotLight, IESSpotLightNode );

	addNodeClass( IESSpotLightNode );

	class AmbientLightNode extends AnalyticLightNode {

		constructor( light = null ) {

			super( light );

		}

		construct( { context } ) {

			context.irradiance.addAssign( this.colorNode );

		}

	}

	addLightNode( AmbientLight, AmbientLightNode );

	addNodeClass( AmbientLightNode );

	class LightingContextNode extends ContextNode {

		constructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {

			super( node );

			this.lightingModel = lightingModel;
			this.backdropNode = backdropNode;
			this.backdropAlphaNode = backdropAlphaNode;

		}

		getNodeType( /*builder*/ ) {

			return 'vec3';

		}

		construct( builder ) {

			const { lightingModel, backdropNode, backdropAlphaNode } = this;

			const context = this.context = {}; // reset context
			const properties = builder.getNodeProperties( this );

			const directDiffuse = vec3().temp(),
				directSpecular = vec3().temp(),
				indirectDiffuse = vec3().temp(),
				indirectSpecular = vec3().temp();

			let totalDiffuse = add( directDiffuse, indirectDiffuse );

			if ( backdropNode !== null ) {

				totalDiffuse = vec3( backdropAlphaNode !== null ? mix( totalDiffuse, backdropNode, backdropAlphaNode ) : backdropNode );

			}

			const totalSpecular = add( directSpecular, indirectSpecular );
			const total = add( totalDiffuse, totalSpecular ).temp();

			const reflectedLight = {
				directDiffuse,
				directSpecular,
				indirectDiffuse,
				indirectSpecular,
				total
			};

			const lighting = {
				radiance: vec3().temp(),
				irradiance: vec3().temp(),
				iblIrradiance: vec3().temp(),
				ambientOcclusion: float( 1 ).temp()
			};

			context.reflectedLight = reflectedLight;
			context.lightingModel = lightingModel || context.lightingModel;

			Object.assign( properties, reflectedLight, lighting );
			Object.assign( context, lighting );

			if ( lightingModel ) {

				lightingModel.init( context, builder.stack, builder );

				lightingModel.indirectDiffuse( context, builder.stack, builder );
				lightingModel.indirectSpecular( context, builder.stack, builder );
				lightingModel.ambientOcclusion( context, builder.stack, builder );

			}

			return super.construct( builder );

		}

		generate( builder ) {

			const { context } = this;
			const type = this.getNodeType( builder );

			super.generate( builder, type );

			return context.reflectedLight.total.build( builder, type );

		}

	}

	const lightingContext = nodeProxy( LightingContextNode );

	addNodeElement( 'lightingContext', lightingContext );

	addNodeClass( LightingContextNode );

	class HemisphereLightNode extends AnalyticLightNode {

		constructor( light = null ) {

			super( light );

			this.lightPositionNode = objectPosition( light );
			this.lightDirectionNode = this.lightPositionNode.normalize();

			this.groundColorNode = uniform( new Color() );

		}

		update( frame ) {

			const { light } = this;

			super.update( frame );

			this.lightPositionNode.object3d = light;

			this.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );

		}

		construct( builder ) {

			const { colorNode, groundColorNode, lightDirectionNode } = this;

			const dotNL = normalView.dot( lightDirectionNode );
			const hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );

			const irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );

			builder.context.irradiance.addAssign( irradiance );

		}

	}

	addLightNode( HemisphereLight, HemisphereLightNode );

	addNodeClass( HemisphereLightNode );

	const checkerShaderNode = tslFn( ( inputs ) => {

		const uv = inputs.uv.mul( 2.0 );

		const cx = uv.x.floor();
		const cy = uv.y.floor();
		const result = cx.add( cy ).mod( 2.0 );

		return result.sign();

	} );

	class CheckerNode extends TempNode {

		constructor( uvNode = uv() ) {

			super( 'float' );

			this.uvNode = uvNode;

		}

		generate( builder ) {

			return checkerShaderNode( { uv: this.uvNode } ).build( builder );

		}

	}

	const checker = nodeProxy( CheckerNode );

	addNodeElement( 'checker', checker );

	addNodeClass( CheckerNode );

	const defaultValues$8 = new LineBasicMaterial();

	class LineBasicNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isLineBasicNodeMaterial = true;

			this.lights = false;
			this.normals = false;

			this.setDefaultValues( defaultValues$8 );

			this.setValues( parameters );

		}

	}

	addNodeMaterial( LineBasicNodeMaterial );

	const defaultValues$7 = new MeshNormalMaterial();

	class MeshNormalNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isMeshNormalNodeMaterial = true;

			this.colorSpace = false;

			this.setDefaultValues( defaultValues$7 );

			this.setValues( parameters );

		}

		constructDiffuseColor( { stack } ) {

			const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

			stack.assign( diffuseColor, vec4( directionToColor( transformedNormalView ), opacityNode ) );

		}

	}

	addNodeMaterial( MeshNormalNodeMaterial );

	const defaultValues$6 = new MeshBasicMaterial();

	class MeshBasicNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isMeshBasicNodeMaterial = true;

			this.lights = false;

			this.setDefaultValues( defaultValues$6 );

			this.setValues( parameters );

		}

	}

	addNodeMaterial( MeshBasicNodeMaterial );

	const F_Schlick = tslFn( ( { f0, f90, dotVH } ) => {

		// Original approximation by Christophe Schlick '94
		// float fresnel = pow( 1.0 - dotVH, 5.0 );

		// Optimized variant (presented by Epic at SIGGRAPH '13)
		// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
		const fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();

		return f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );

	} ); // validated

	const BRDF_Lambert = tslFn( ( inputs ) => {

		return inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light

	} ); // validated

	const G_BlinnPhong_Implicit = () => float( 0.25 );

	const D_BlinnPhong = tslFn( ( { dotNH } ) => {

		return shininess.mul( 0.5 / Math.PI ).add( 1.0 ).mul( dotNH.pow( shininess ) );

	} );

	const BRDF_BlinnPhong = tslFn( ( { lightDirection } ) => {

		const halfDir = lightDirection.add( positionViewDirection ).normalize();

		const dotNH = transformedNormalView.dot( halfDir ).clamp();
		const dotVH = positionViewDirection.dot( halfDir ).clamp();

		const F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );
		const G = G_BlinnPhong_Implicit();
		const D = D_BlinnPhong( { dotNH } );

		return F.mul( G ).mul( D );

	} );

	class PhongLightingModel extends LightingModel {

		constructor( specular = true ) {

			super();

			this.specular = specular;

		}

		direct( { lightDirection, lightColor, reflectedLight } ) {

			const dotNL = transformedNormalView.dot( lightDirection ).clamp();
			const irradiance = dotNL.mul( lightColor );

			reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

			if ( this.specular === true ) {

				reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );

			}

		}

		indirectDiffuse( { irradiance, reflectedLight } ) {

			reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		}

	}

	const defaultValues$5 = new MeshLambertMaterial();

	class MeshLambertNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isMeshLambertNodeMaterial = true;

			this.lights = true;

			this.setDefaultValues( defaultValues$5 );

			this.setValues( parameters );

		}

		constructLightingModel( /*builder*/ ) {

			return new PhongLightingModel( false ); // ( specular ) -> force lambert

		}

	}

	addNodeMaterial( MeshLambertNodeMaterial );

	const defaultValues$4 = new MeshPhongMaterial();

	class MeshPhongNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isMeshPhongNodeMaterial = true;

			this.lights = true;

			this.shininessNode = null;
			this.specularNode = null;

			this.setDefaultValues( defaultValues$4 );

			this.setValues( parameters );

		}

		constructLightingModel( /*builder*/ ) {

			return new PhongLightingModel();

		}

		constructVariants( { stack } ) {

			// SHININESS

			const shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )

			stack.assign( shininess, shininessNode );

			// SPECULAR COLOR

			const specularNode = this.specularNode || materialSpecularColor;

			stack.assign( specularColor, specularNode );

		}

		copy( source ) {

			this.shininessNode = source.shininessNode;
			this.specularNode = source.specularNode;

			return super.copy( source );

		}

	}

	addNodeMaterial( MeshPhongNodeMaterial );

	const getGeometryRoughness = tslFn( () => {

		const dxy = normalGeometry.dFdx().abs().max( normalGeometry.dFdy().abs() );
		const geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );

		return geometryRoughness;

	} );

	const getRoughness = tslFn( ( inputs ) => {

		const { roughness } = inputs;

		const geometryRoughness = getGeometryRoughness();

		let roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.
		roughnessFactor = roughnessFactor.add( geometryRoughness );
		roughnessFactor = roughnessFactor.min( 1.0 );

		return roughnessFactor;

	} );

	// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	const V_GGX_SmithCorrelated = tslFn( ( inputs ) => {

		const { alpha, dotNL, dotNV } = inputs;

		const a2 = alpha.pow2();

		const gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );
		const gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );

		return div( 0.5, gv.add( gl ).max( EPSILON ) );

	} ); // validated

	// Microfacet Models for Refraction through Rough Surfaces - equation (33)
	// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
	// alpha is "roughness squared" in Disney’s reparameterization
	const D_GGX = tslFn( ( inputs ) => {

		const { alpha, dotNH } = inputs;

		const a2 = alpha.pow2();

		const denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1

		return a2.div( denom.pow2() ).mul( 1 / Math.PI );

	} ); // validated

	// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
	const BRDF_GGX = tslFn( ( inputs ) => {

		const { lightDirection, f0, f90, roughness, iridescenceFresnel } = inputs;

		const normalView = inputs.normalView || transformedNormalView;

		const alpha = roughness.pow2(); // UE4's roughness

		const halfDir = lightDirection.add( positionViewDirection ).normalize();

		const dotNL = normalView.dot( lightDirection ).clamp();
		const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV
		const dotNH = normalView.dot( halfDir ).clamp();
		const dotVH = positionViewDirection.dot( halfDir ).clamp();

		let F = F_Schlick( { f0, f90, dotVH } );

		if ( iridescenceFresnel ) {

			F = iridescence.mix( F, iridescenceFresnel );

		}

		const V = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );
		const D = D_GGX( { alpha, dotNH } );

		return F.mul( V ).mul( D );

	} ); // validated

	// Analytical approximation of the DFG LUT, one half of the
	// split-sum approximation used in indirect specular lighting.
	// via 'environmentBRDF' from "Physically Based Shading on Mobile"
	// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
	const DFGApprox = tslFn( ( inputs ) => {

		const { roughness } = inputs;

		const dotNV = inputs.dotNV || transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

		const c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

		const r = roughness.mul( c0 ).add( c1 );

		const a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );

		const fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );

		return fab;

	} );

	const EnvironmentBRDF = tslFn( ( inputs ) => {

		const { dotNV, specularColor, specularF90, roughness } = inputs;

		const fab = DFGApprox( { dotNV, roughness } );
		return specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );

	} );

	const Schlick_to_F0 = tslFn( ( { f, f90, dotVH } ) => {

		const x = dotVH.oneMinus().saturate();
		const x2 = x.mul( x );
		const x5 = x.mul( x2, x2 ).clamp( 0, .9999 );

		return f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );

	} );

	// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
	const D_Charlie = ( roughness, dotNH ) => {

		const alpha = roughness.pow2();

		// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
		const invAlpha = float( 1.0 ).div( alpha );
		const cos2h = dotNH.pow2();
		const sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

		return float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );

	};

	// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
	const V_Neubelt = ( dotNV, dotNL ) => {

		// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
		return float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );

	};

	const BRDF_Sheen = tslFn( ( { lightDirection } ) => {

		const halfDir = lightDirection.add( positionViewDirection ).normalize();

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp();
		const dotNH = transformedNormalView.dot( halfDir ).clamp();

		const D = D_Charlie( sheenRoughness, dotNH );
		const V = V_Neubelt( dotNV, dotNL );

		return sheen.mul( D ).mul( V );

	} );

	//
	// Iridescence
	//

	// XYZ to linear-sRGB color space
	const XYZ_TO_REC709 = mat3(
		3.2404542, - 0.9692660, 0.0556434,
		- 1.5371385, 1.8760108, - 0.2040259,
		- 0.4985314, 0.0415560, 1.0572252
	);

	// Assume air interface for top
	// Note: We don't handle the case fresnel0 == 1
	const Fresnel0ToIor = ( fresnel0 ) => {

		const sqrtF0 = fresnel0.sqrt();
		return vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );

	};

	// ior is a value between 1.0 and 3.0. 1.0 is air interface
	const IorToFresnel0 = ( transmittedIor, incidentIor ) => {

		return transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();

	};

	// Fresnel equations for dielectric/dielectric interfaces.
	// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
	// Evaluation XYZ sensitivity curves in Fourier space
	const evalSensitivity = ( OPD, shift ) => {

		const phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );
		const val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		const pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		const VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

		const x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );

		let xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );
		xyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );

		const rgb = XYZ_TO_REC709.mul( xyz );
		return rgb;

	};

	const evalIridescence = ( outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 ) => {

		// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
		const iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		// Evaluate the cosTheta on the base layer (Snell law)
		const sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( float( 1 ).sub( cosTheta1.pow2() ) );

		// Handle TIR:
		const cosTheta2Sq = float( 1 ).sub( sinTheta2Sq );
		/*if ( cosTheta2Sq < 0.0 ) {

				return vec3( 1.0 );

		}*/

		const cosTheta2 = cosTheta2Sq.sqrt();

		// First interface
		const R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		const R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );
		//const R21 = R12;
		const T121 = R12.oneMinus();
		const phi12 = iridescenceIOR.lessThan( outsideIOR ).cond( Math.PI, 0.0 );
		const phi21 = float( Math.PI ).sub( phi12 );

		// Second interface
		const baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0
		const R1 = IorToFresnel0( baseIOR, iridescenceIOR.vec3() );
		const R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );
		const phi23 = vec3(
			baseIOR.x.lessThan( iridescenceIOR ).cond( Math.PI, 0.0 ),
			baseIOR.y.lessThan( iridescenceIOR ).cond( Math.PI, 0.0 ),
			baseIOR.z.lessThan( iridescenceIOR ).cond( Math.PI, 0.0 )
		);

		// Phase shift
		const OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );
		const phi = vec3( phi21 ).add( phi23 );

		// Compound terms
		const R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );
		const r123 = R123.sqrt();
		const Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );

		// Reflectance term for m = 0 (DC term amplitude)
		const C0 = R12.add( Rs );
		let I = C0;

		// Reflectance term for m > 0 (pairs of diracs)
		let Cm = Rs.sub( T121 );
		for ( let m = 1; m <= 2; ++ m ) {

			Cm = Cm.mul( r123 );
			const Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );
			I = I.add( Cm.mul( Sm ) );

		}

		// Since out of gamut colors might be produced, negative color values are clamped to 0.
		return I.max( vec3( 0.0 ) );

	};

	//
	//	Sheen
	//

	// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
	// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
	const IBLSheenBRDF = ( normal, viewDir, roughness ) => {

		const dotNV = normal.dot( viewDir ).saturate();

		const r2 = roughness.pow2();

		const a = cond(
			roughness.lessThan( 0.25 ),
			float( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),
			float( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )
		);

		const b = cond(
			roughness.lessThan( 0.25 ),
			float( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),
			float( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )
		);

		const DG = cond( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );

		return DG.mul( 1.0 / Math.PI ).saturate();

	};

	const clearcoatF0 = vec3( 0.04 );
	const clearcoatF90 = vec3( 1 );

	//

	class PhysicalLightingModel extends LightingModel {

		constructor( clearcoat = true, sheen = true, iridescence = true ) {

			super();

			this.clearcoat = clearcoat;
			this.sheen = sheen;
			this.iridescence = iridescence;

			this.clearcoatRadiance = null;
			this.clearcoatSpecular = null;
			this.sheenSpecular = null;
			this.iridescenceFresnel = null;
			this.iridescenceF0 = null;

		}

		init( { reflectedLight } ) {

			if ( this.clearcoat === true ) {

				this.clearcoatRadiance = vec3().temp();
				this.clearcoatSpecular = vec3().temp();

				const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

				const Fcc = F_Schlick( {
					dotVH: dotNVcc,
					f0: clearcoatF0,
					f90: clearcoatF90
				} );

				const outgoingLight = reflectedLight.total;
				const clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecular.mul( clearcoat ) );

				outgoingLight.assign( clearcoatLight );

			}

			if ( this.sheen === true ) {

				this.sheenSpecular = vec3().temp();

				const outgoingLight = reflectedLight.total;

				const sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();
				const sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecular );

				outgoingLight.assign( sheenLight );

			}

			if ( this.iridescence === true ) {

				const dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();

				this.iridescenceFresnel = evalIridescence( float( 1.0 ), iridescenceIOR, dotNVi, iridescenceThickness, specularColor );
				this.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );

			}

		}

		// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
		// Approximates multiscattering in order to preserve energy.
		// http://www.jcgt.org/published/0008/01/03/

		computeMultiscattering( singleScatter, multiScatter, specularF90 = float( 1 ) ) {

			const fab = DFGApprox( { roughness } );

			const Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;

			const FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );

			const Ess = fab.x.add( fab.y );
			const Ems = Ess.oneMinus();

			const Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21
			const Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );

			singleScatter.addAssign( FssEss );
			multiScatter.addAssign( Fms.mul( Ems ) );

		}

		direct( { lightDirection, lightColor, reflectedLight } ) {

			const dotNL = transformedNormalView.dot( lightDirection ).clamp();
			const irradiance = dotNL.mul( lightColor );

			if ( this.sheen === true ) {

				this.sheenSpecular.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );

			}

			if ( this.clearcoat === true ) {

				const dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();
				const ccIrradiance = dotNLcc.mul( lightColor );

				this.clearcoatSpecular.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );

			}

			reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

			reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel } ) ) );

		}

		indirectDiffuse( { irradiance, reflectedLight } ) {

			reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		}

		indirectSpecular( { radiance, iblIrradiance, reflectedLight, } ) {

			if ( this.sheen === true ) {

				this.sheenSpecular.addAssign( iblIrradiance.mul(
					sheen,
					IBLSheenBRDF( transformedNormalView, positionViewDirection, sheenRoughness )
				) );

			}

			if ( this.clearcoat === true ) {

				const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

				const clearcoatEnv = EnvironmentBRDF( {
					dotNV: dotNVcc,
					specularColor: clearcoatF0,
					specularF90: clearcoatF90,
					roughness: clearcoatRoughness
				} );

				this.clearcoatSpecular.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );

			}

			// Both indirect specular and indirect diffuse light accumulate here

			const singleScattering = vec3().temp();
			const multiScattering = vec3().temp();
			const cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );

			this.computeMultiscattering( singleScattering, multiScattering );

			const totalScattering = singleScattering.add( multiScattering );

			const diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );

			reflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );
			reflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );

			reflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );

		}

		ambientOcclusion( { ambientOcclusion, reflectedLight } ) {

			const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

			const aoNV = dotNV.add( ambientOcclusion );
			const aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();

			const aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();

			reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

			reflectedLight.indirectSpecular.mulAssign( aoNode );

		}

	}

	const defaultValues$3 = new MeshStandardMaterial();

	class MeshStandardNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isMeshStandardNodeMaterial = true;

			this.emissiveNode = null;

			this.metalnessNode = null;
			this.roughnessNode = null;

			this.setDefaultValues( defaultValues$3 );

			this.setValues( parameters );

		}

		constructLightingModel( /*builder*/ ) {

			return new PhysicalLightingModel( false, false ); // ( clearcoat, sheen ) -> standard

		}

		constructVariants( { stack } ) {

			// METALNESS

			const metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;

			stack.assign( metalness, metalnessNode );

			// ROUGHNESS

			let roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;
			roughnessNode = getRoughness( { roughness: roughnessNode } );

			stack.assign( roughness, roughnessNode );

			// SPECULAR COLOR

			const specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessNode );

			stack.assign( specularColor, specularColorNode );

			// DIFFUSE COLOR

			stack.assign( diffuseColor, vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );

		}

		copy( source ) {

			this.emissiveNode = source.emissiveNode;

			this.metalnessNode = source.metalnessNode;
			this.roughnessNode = source.roughnessNode;

			return super.copy( source );

		}

	}

	addNodeMaterial( MeshStandardNodeMaterial );

	const defaultValues$2 = new MeshPhysicalMaterial();

	class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {

		constructor( parameters ) {

			super();

			this.isMeshPhysicalNodeMaterial = true;

			this.clearcoatNode = null;
			this.clearcoatRoughnessNode = null;
			this.clearcoatNormalNode = null;

			this.sheenNode = null;
			this.sheenRoughnessNode = null;

			this.iridescenceNode = null;
			this.iridescenceIORNode = null;
			this.iridescenceThicknessNode = null;

			this.specularIntensityNode = null;
			this.specularColorNode = null;

			this.transmissionNode = null;
			this.thicknessNode = null;
			this.attenuationDistanceNode = null;
			this.attenuationColorNode = null;

			this.setDefaultValues( defaultValues$2 );

			this.setValues( parameters );

		}

		constructLightingModel( /*builder*/ ) {

			return new PhysicalLightingModel(); // @TODO: Optimize shader using parameters.

		}

		constructVariants( builder ) {

			super.constructVariants( builder );

			const { stack } = builder;

			// CLEARCOAT

			const clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;
			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;

			stack.assign( clearcoat, clearcoatNode );
			stack.assign( clearcoatRoughness, clearcoatRoughnessNode );

			// SHEEN

			const sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;
			const sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;

			stack.assign( sheen, sheenNode );
			stack.assign( sheenRoughness, sheenRoughnessNode );

			// IRIDESCENCE

			const iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;
			const iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;
			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;

			stack.assign( iridescence, iridescenceNode );
			stack.assign( iridescenceIOR, iridescenceIORNode );
			stack.assign( iridescenceThickness, iridescenceThicknessNode );

		}

		constructNormal( builder ) {

			super.constructNormal( builder );

			// CLEARCOAT NORMAL

			const clearcoatNormalNode = this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;

			builder.stack.assign( transformedClearcoatNormalView, clearcoatNormalNode );

		}

		copy( source ) {

			this.clearcoatNode = source.clearcoatNode;
			this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
			this.clearcoatNormalNode = source.clearcoatNormalNode;

			this.sheenNode = source.sheenNode;
			this.sheenRoughnessNode = source.sheenRoughnessNode;

			this.iridescenceNode = source.iridescenceNode;
			this.iridescenceIORNode = source.iridescenceIORNode;
			this.iridescenceThicknessNode = source.iridescenceThicknessNode;

			this.specularIntensityNode = source.specularIntensityNode;
			this.specularColorNode = source.specularColorNode;

			this.transmissionNode = source.transmissionNode;
			this.thicknessNode = source.thicknessNode;
			this.attenuationDistanceNode = source.attenuationDistanceNode;
			this.attenuationColorNode = source.attenuationColorNode;

			return super.copy( source );

		}

	}

	addNodeMaterial( MeshPhysicalNodeMaterial );

	const defaultValues$1 = new PointsMaterial();

	class PointsNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isPointsNodeMaterial = true;

			this.lights = false;
			this.normals = false;

			this.transparent = true;

			this.colorNode = null;
			this.opacityNode = null;

			this.alphaTestNode = null;

			this.lightNode = null;

			this.sizeNode = null;

			this.positionNode = null;

			this.setDefaultValues( defaultValues$1 );

			this.setValues( parameters );

		}

		copy( source ) {

			this.sizeNode = source.sizeNode;

			return super.copy( source );

		}

	}

	addNodeMaterial( PointsNodeMaterial );

	const defaultValues = new SpriteMaterial();

	class SpriteNodeMaterial extends NodeMaterial {

		constructor( parameters ) {

			super();

			this.isSpriteNodeMaterial = true;

			this.lights = false;
			this.normals = false;

			this.colorNode = null;
			this.opacityNode = null;

			this.alphaTestNode = null;

			this.lightNode = null;

			this.positionNode = null;
			this.rotationNode = null;
			this.scaleNode = null;

			this.setDefaultValues( defaultValues );

			this.setValues( parameters );

		}

		constructPosition( { object, context } ) {

			// < VERTEX STAGE >

			const { positionNode, rotationNode, scaleNode } = this;

			const vertex = positionLocal;

			let mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );

			let scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );

			if ( scaleNode !== null ) {

				scale = scale.mul( scaleNode );

			}

			let alignedPosition = vertex.xy;

			if ( object.center && object.center.isVector2 === true ) {

				alignedPosition = alignedPosition.sub( uniform( object.center ).sub( 0.5 ) );

			}

			alignedPosition = alignedPosition.mul( scale );

			const rotation = float( rotationNode || materialRotation );

			const cosAngle = rotation.cos();
			const sinAngle = rotation.sin();

			const rotatedPosition = vec2( // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
				vec2( cosAngle, sinAngle.negate() ).dot( alignedPosition ),
				vec2( sinAngle, cosAngle ).dot( alignedPosition )
			);

			mvPosition = vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );

			const modelViewProjection = cameraProjectionMatrix.mul( mvPosition );

			context.vertex = vertex;

			return modelViewProjection;

		}

		copy( source ) {

			this.positionNode = source.positionNode;
			this.rotationNode = source.rotationNode;
			this.scaleNode = source.scaleNode;

			return super.copy( source );

		}

	}

	addNodeMaterial( SpriteNodeMaterial );

	class NodeParser {

		parseFunction( /*source*/ ) {

		}

	}

	class NodeFunction {

		constructor( type, inputs, name = '', presicion = '' ) {

			this.type = type;
			this.inputs = inputs;
			this.name = name;
			this.presicion = presicion;

		}

		getCode( /*name = this.name*/ ) {

		}

	}

	NodeFunction.isNodeFunction = true;

	// Original shader code from:
	// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_noise.glsl

	glsl( `float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}` );

	// Original shader code from:
	// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl

	glsl( `#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}` );

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	class RenderList {

		constructor() {

			this.renderItems = [];
			this.renderItemsIndex = 0;

			this.opaque = [];
			this.transparent = [];

			this.lightsNode = lights( [] );
			this.lightsArray = [];

		}

		init() {

			this.renderItemsIndex = 0;

			this.opaque.length = 0;
			this.transparent.length = 0;
			this.lightsArray.length = 0;

			return this;

		}

		getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = this.renderItems[ this.renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				this.renderItems[ this.renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			this.renderItemsIndex ++;

			return renderItem;

		}

		push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? this.transparent : this.opaque ).push( renderItem );

		}

		unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? this.transparent : this.opaque ).unshift( renderItem );

		}

		pushLight( light ) {

			this.lightsArray.push( light );

		}

		getLightsNode() {

			return this.lightsNode.fromLights( this.lightsArray );

		}

		sort( customOpaqueSort, customTransparentSort ) {

			if ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );
			if ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		finish() {

			// update lights

			this.lightsNode.fromLights( this.lightsArray );

			// Clear references from inactive renderItems in the list

			for ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {

				const renderItem = this.renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;

			}

		}

	}

	class RenderLists {

		constructor() {

			this.lists = new ChainMap();

		}

		get( scene, camera ) {

			const lists = this.lists;
			const keys = [ scene, camera ];

			let list = lists.get( keys );

			if ( list === undefined ) {

				list = new RenderList();
				lists.set( keys, list );

			}

			return list;

		}

		dispose() {

			this.lists = new ChainMap();

		}

	}

	let id$1 = 0;

	class RenderContext {

		constructor() {

			this.id = id$1 ++;

			this.color = true;
			this.clearColor = true;
			this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };

			this.depth = true;
			this.clearDepth = true;
			this.clearDepthValue = 1;

			this.stencil = true;
			this.clearStencil = true;
			this.clearStencilValue = 1;

			this.viewport = false;
			this.viewportValue = new Vector4();

			this.scissor = false;
			this.scissorValue = new Vector4();

			this.texture = null;
			this.depthTexture = null;
			this.activeCubeFace = 0;
			this.sampleCount = 1;

		}

	}

	class RenderContexts {

		constructor() {

			this.chainMaps = {};

		}

		get( scene, camera, renderTarget = null ) {

			const chainKey = [ scene, camera ];
			const attachmentState = renderTarget === null ? 'default' : `${renderTarget.texture.format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;

			const chainMap = this.getChainMap( attachmentState );

			let renderState = chainMap.get( chainKey );

			if ( renderState === undefined ) {

				renderState = new RenderContext();

				chainMap.set( chainKey, renderState );

			}

			if ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

			return renderState;

		}

		getChainMap( attachmentState ) {

			return this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );

		}

		dispose() {

			this.chainMaps = {};

		}

	}

	const _size = new Vector2();

	class Textures extends DataMap {

		constructor( backend, info ) {

			super();

			this.backend = backend;
			this.info = info;

		}

		updateRenderTarget( renderTarget ) {

			const renderTargetData = this.get( renderTarget );
			const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

			const texture = renderTarget.texture;
			const size = this.getSize( texture );

			let depthTexture = renderTarget.depthTexture || renderTargetData.depthTexture;

			if ( depthTexture === undefined ) {

				depthTexture = new DepthTexture();
				depthTexture.format = DepthStencilFormat;
				depthTexture.type = UnsignedInt248Type;
				depthTexture.image.width = size.width;
				depthTexture.image.height = size.height;

			}

			if ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {

				texture.needsUpdate = true;
				depthTexture.needsUpdate = true;

				depthTexture.image.width = size.width;
				depthTexture.image.height = size.height;

			}

			renderTargetData.width = size.width;
			renderTargetData.height = size.height;
			renderTargetData.texture = texture;
			renderTargetData.depthTexture = depthTexture;

			if ( renderTargetData.sampleCount !== sampleCount ) {

				texture.needsUpdate = true;
				depthTexture.needsUpdate = true;

				renderTargetData.sampleCount = sampleCount;

			}

			const options = { sampleCount };

			this.updateTexture( texture, options );
			this.updateTexture( depthTexture, options );

			// dispose handler

			if ( renderTargetData.initialized !== true ) {

				renderTargetData.initialized = true;

				// dispose

				const onDispose = () => {

					renderTarget.removeEventListener( 'dispose', onDispose );

					this._destroyTexture( texture );
					this._destroyTexture( depthTexture );

				};

				renderTarget.addEventListener( 'dispose', onDispose );

			}

		}

		updateTexture( texture, options = {} ) {

			const textureData = this.get( texture );
			if ( textureData.initialized === true && textureData.version === texture.version ) return;

			const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
			const backend = this.backend;

			if ( isRenderTarget && textureData.initialized === true ) {

				// it's an update

				backend.destroySampler( texture );
				backend.destroyTexture( texture );

			}

			//

			if ( isRenderTarget ) {

				backend.createSampler( texture );
				backend.createTexture( texture, options );

			} else {

				const needsCreate = textureData.initialized !== true;

				if ( needsCreate ) backend.createSampler( texture );

				if ( texture.version > 0 ) {

					const image = texture.image;

					if ( image === undefined ) ; else if ( image.complete === false ) ; else {

						if ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {

							backend.createTexture( texture, options );

							textureData.isDefaultTexture = false;

						}

						backend.updateTexture( texture );

					}

				} else {

					// async update

					backend.createDefaultTexture( texture );

					textureData.isDefaultTexture = true;

				}

			}

			// dispose handler

			if ( textureData.initialized !== true ) {

				textureData.initialized = true;

				//

				this.info.memory.textures ++;

				// dispose

				const onDispose = () => {

					texture.removeEventListener( 'dispose', onDispose );

					this._destroyTexture( texture );

					this.info.memory.textures --;

				};

				texture.addEventListener( 'dispose', onDispose );

			}

			//

			textureData.version = texture.version;

		}

		getSize( texture, target = _size ) {

			if ( texture.isCubeTexture ) {

				target.width = texture.image[ 0 ].width;
				target.height = texture.image[ 0 ].height;

			} else {

				target.width = texture.image.width;
				target.height = texture.image.height;

			}

			return target;

		}

		_destroyTexture( texture ) {

			this.backend.destroySampler( texture );
			this.backend.destroyTexture( texture );

			this.delete( texture );

		}

	}

	let _clearAlpha;
	const _clearColor = new Color();

	class Background extends DataMap {

		constructor( renderer, nodes ) {

			super();

			this.renderer = renderer;
			this.nodes = nodes;

			this.backgroundMesh = null;
			this.backgroundMeshNode = null;

		}

		update( scene, renderList, renderContext ) {

			const renderer = this.renderer;
			const background = this.nodes.getBackgroundNode( scene ) || scene.background;

			let forceClear = false;

			if ( background === null ) {

				// no background settings, use clear color configuration from the renderer

				_clearColor.copyLinearToSRGB( renderer._clearColor );
				_clearAlpha = renderer._clearAlpha;

			} else if ( background.isColor === true ) {

				// background is an opaque color

				_clearColor.copyLinearToSRGB( background );
				_clearAlpha = 1;
				forceClear = true;

			} else if ( background.isNode === true ) {

				const sceneData = this.get( scene );
				const backgroundNode = background;

				_clearColor.copy( renderer._clearColor );
				_clearAlpha = renderer._clearAlpha;

				let backgroundMesh = this.backgroundMesh;

				if ( backgroundMesh === null ) {

					this.backgroundMeshNode = context( backgroundNode, {
						// @TODO: Add Texture2D support using node context
						getUVNode: () => normalWorld,
						getSamplerLevelNode: () => backgroundBlurriness
					} ).mul( backgroundIntensity );

					let viewProj = modelViewProjection();
					viewProj = vec4( viewProj.x, viewProj.y, viewProj.w, viewProj.w );

					const nodeMaterial = new NodeMaterial();
					nodeMaterial.outputNode = this.backgroundMeshNode;
					nodeMaterial.side = BackSide;
					nodeMaterial.depthTest = false;
					nodeMaterial.depthWrite = false;
					nodeMaterial.fog = false;
					nodeMaterial.vertexNode = viewProj;

					this.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );
					backgroundMesh.frustumCulled = false;

					backgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

				}

				const backgroundCacheKey = backgroundNode.getCacheKey();

				if ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {

					this.backgroundMeshNode.node = backgroundNode;

					backgroundMesh.material.needsUpdate = true;

					sceneData.backgroundCacheKey = backgroundCacheKey;

				}

				renderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null );

			} else ;

			//

			if ( renderer.autoClear === true || forceClear === true ) {

				_clearColor.multiplyScalar( _clearAlpha );

				const clearColorValue = renderContext.clearColorValue;

				clearColorValue.r = _clearColor.r;
				clearColorValue.g = _clearColor.g;
				clearColorValue.b = _clearColor.b;
				clearColorValue.a = _clearAlpha;

				renderContext.depthClearValue = renderer._clearDepth;
				renderContext.stencilClearValue = renderer._clearStencil;

				renderContext.clearColor = renderer.autoClearColor === true;
				renderContext.clearDepth = renderer.autoClearDepth === true;
				renderContext.clearStencil = renderer.autoClearStencil === true;

			} else {

				renderContext.clearColor = false;
				renderContext.clearDepth = false;
				renderContext.clearStencil = false;

			}

		}

	}

	class Nodes extends DataMap {

		constructor( renderer, backend ) {

			super();

			this.renderer = renderer;
			this.backend = backend;
			this.nodeFrame = new NodeFrame();

		}

		getForRender( renderObject ) {

			const renderObjectData = this.get( renderObject );

			let nodeBuilder = renderObjectData.nodeBuilder;

			if ( nodeBuilder === undefined ) {

				nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer, renderObject.scene );
				nodeBuilder.material = renderObject.material;
				nodeBuilder.lightsNode = renderObject.lightsNode;
				nodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );
				nodeBuilder.fogNode = this.getFogNode( renderObject.scene );
				nodeBuilder.toneMappingNode = this.getToneMappingNode();
				nodeBuilder.build();

				renderObjectData.nodeBuilder = nodeBuilder;

			}

			return nodeBuilder;

		}

		getForCompute( computeNode ) {

			const computeData = this.get( computeNode );

			let nodeBuilder = computeData.nodeBuilder;

			if ( nodeBuilder === undefined ) {

				nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );
				nodeBuilder.build();

				computeData.nodeBuilder = nodeBuilder;

			}

			return nodeBuilder;

		}

		getEnvironmentNode( scene ) {

			return scene.environmentNode || this.get( scene ).environmentNode || null;

		}

		getBackgroundNode( scene ) {

			return scene.backgroundNode || this.get( scene ).backgroundNode || null;

		}

		getFogNode( scene ) {

			return scene.fogNode || this.get( scene ).fogNode || null;

		}

		getToneMappingNode() {

			if ( this.isToneMappingState === false ) return null;

			return this.renderer.toneMappingNode || this.get( this.renderer ).toneMappingNode || null;

		}

		getCacheKey( scene, lightsNode ) {

			const environmentNode = this.getEnvironmentNode( scene );
			const fogNode = this.getFogNode( scene );
			const toneMappingNode = this.getToneMappingNode();

			const cacheKey = [];

			if ( lightsNode ) cacheKey.push( 'lightsNode:' + lightsNode.getCacheKey() );
			if ( environmentNode ) cacheKey.push( 'environmentNode:' + environmentNode.getCacheKey() );
			if ( fogNode ) cacheKey.push( 'fogNode:' + fogNode.getCacheKey() );
			if ( toneMappingNode ) cacheKey.push( 'toneMappingNode:' + toneMappingNode.getCacheKey() );

			return '{' + cacheKey.join( ',' ) + '}';

		}

		updateScene( scene ) {

			this.updateEnvironment( scene );
			this.updateFog( scene );
			this.updateBackground( scene );
			this.updateToneMapping();

		}

		get isToneMappingState() {

			const renderer = this.renderer;
			const renderTarget = renderer.getRenderTarget();

			return renderTarget && renderTarget.isCubeRenderTarget ? false : true;

		}

		updateToneMapping() {

			const renderer = this.renderer;
			const rendererData = this.get( renderer );
			const rendererToneMapping = renderer.toneMapping;

			if ( this.isToneMappingState && rendererToneMapping !== NoToneMapping ) {

				if ( rendererData.toneMapping !== rendererToneMapping ) {

					const rendererToneMappingNode = rendererData.rendererToneMappingNode || toneMapping( rendererToneMapping, reference( 'toneMappingExposure', 'float', renderer ) );
					rendererToneMappingNode.toneMapping = rendererToneMapping;

					rendererData.rendererToneMappingNode = rendererToneMappingNode;
					rendererData.toneMappingNode = rendererToneMappingNode;
					rendererData.toneMapping = rendererToneMapping;

				}

			} else {

				// Don't delete rendererData.rendererToneMappingNode
				delete rendererData.toneMappingNode;
				delete rendererData.toneMapping;

			}

		}

		updateBackground( scene ) {

			const sceneData = this.get( scene );
			const background = scene.background;

			if ( background ) {

				if ( sceneData.background !== background ) {

					let backgroundNode = null;

					if ( background.isCubeTexture === true ) {

						backgroundNode = cubeTexture( background, normalWorld );

					} else if ( background.isTexture === true ) {

						let nodeUV = null;

						if ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping ) {

							nodeUV = equirectUV();

						} else {

							nodeUV = viewportBottomLeft;

						}

						backgroundNode = texture( background, nodeUV ).setUpdateMatrix( true );

					} else if ( background.isColor !== true ) ;

					sceneData.backgroundNode = backgroundNode;
					sceneData.background = background;

				}

			} else if ( sceneData.backgroundNode ) {

				delete sceneData.backgroundNode;
				delete sceneData.background;

			}

		}

		updateFog( scene ) {

			const sceneData = this.get( scene );
			const fog = scene.fog;

			if ( fog ) {

				if ( sceneData.fog !== fog ) {

					let fogNode = null;

					if ( fog.isFogExp2 ) {

						fogNode = densityFog( reference( 'color', 'color', fog ), reference( 'density', 'float', fog ) );

					} else if ( fog.isFog ) {

						fogNode = rangeFog( reference( 'color', 'color', fog ), reference( 'near', 'float', fog ), reference( 'far', 'float', fog ) );

					} else ;

					sceneData.fogNode = fogNode;
					sceneData.fog = fog;

				}

			} else {

				delete sceneData.fogNode;
				delete sceneData.fog;

			}

		}

		updateEnvironment( scene ) {

			const sceneData = this.get( scene );
			const environment = scene.environment;

			if ( environment ) {

				if ( sceneData.environment !== environment ) {

					let environmentNode = null;

					if ( environment.isCubeTexture === true ) {

						environmentNode = cubeTexture( environment );

					} else if ( environment.isTexture === true ) {

						environmentNode = texture( environment );

					} else ;

					sceneData.environmentNode = environmentNode;
					sceneData.environment = environment;

				}

			} else if ( sceneData.environmentNode ) {

				delete sceneData.environmentNode;
				delete sceneData.environment;

			}

		}

		getNodeFrame( renderObject ) {

			const nodeFrame = this.nodeFrame;
			nodeFrame.scene = renderObject.scene;
			nodeFrame.object = renderObject.object;
			nodeFrame.camera = renderObject.camera;
			nodeFrame.renderer = renderObject.renderer;
			nodeFrame.material = renderObject.material;

			return nodeFrame;

		}

		updateBefore( renderObject ) {

			const nodeFrame = this.getNodeFrame( renderObject );
			const nodeBuilder = this.getForRender( renderObject );

			for ( const node of nodeBuilder.updateBeforeNodes ) {

				nodeFrame.updateBeforeNode( node );

			}

		}

		updateForCompute( /*computeNode*/ ) { }

		updateForRender( renderObject ) {

			const nodeFrame = this.getNodeFrame( renderObject );
			const nodeBuilder = this.getForRender( renderObject );

			for ( const node of nodeBuilder.updateNodes ) {

				nodeFrame.updateNode( node );

			}

		}

		dispose() {

			super.dispose();

			this.nodeFrame = new NodeFrame();

		}

	}

	const _scene = new Scene();
	const _drawingBufferSize = new Vector2();
	const _screen = new Vector4();
	const _frustum = new Frustum();
	const _projScreenMatrix = new Matrix4();
	const _vector3 = new Vector3();

	class Renderer {

		constructor( backend ) {

			this.isRenderer = true;

			// public

			this.domElement = backend.getDomElement();

			this.backend = backend;

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			this.outputColorSpace = SRGBColorSpace;

			this.toneMapping = NoToneMapping;
			this.toneMappingExposure = 1.0;

			this.sortObjects = true;

			this.depth = true;
			this.stencil = true;

			// internals

			this._pixelRatio = 1;
			this._width = this.domElement.width;
			this._height = this.domElement.height;

			this._viewport = new Vector4( 0, 0, this._width, this._height );
			this._scissor = new Vector4( 0, 0, this._width, this._height );
			this._scissorTest = false;

			this._info = null;
			this._properties = null;
			this._attributes = null;
			this._geometries = null;
			this._nodes = null;
			this._bindings = null;
			this._objects = null;
			this._pipelines = null;
			this._renderLists = null;
			this._renderContexts = null;
			this._textures = null;
			this._background = null;

			this._animation = new Animation();

			this._currentRenderContext = null;
			this._lastRenderContext = null;

			this._opaqueSort = null;
			this._transparentSort = null;

			this._clearAlpha = 1;
			this._clearColor = new Color( 0x000000 );
			this._clearDepth = 1;
			this._clearStencil = 0;

			this._renderTarget = null;
			this._currentActiveCubeFace = 0;

			this._initialized = false;
			this._initPromise = null;

			// backwards compatibility

			this.shadowMap = {
				enabled: false,
				type: null
			};

			this.xr = {
				enabled: false
			};

		}

		async init() {

			if ( this._initialized ) {

				throw new Error( 'Renderer: Backend has already been initialized.' );

			}

			if ( this._initPromise !== null ) {

				return this._initPromise;

			}

			this._initPromise = new Promise( async ( resolve, reject ) => {

				const backend = this.backend;

				try {

					await backend.init( this );

				} catch ( error ) {

					reject( error );
					return;

				}

				this._info = new Info();
				this._nodes = new Nodes( this, backend );
				this._attributes = new Attributes( backend );
				this._background = new Background( this, this._nodes );
				this._geometries = new Geometries( this._attributes, this._info );
				this._textures = new Textures( backend, this._info );
				this._pipelines = new Pipelines( backend, this._nodes );
				this._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this._info );
				this._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this._info );
				this._renderLists = new RenderLists();
				this._renderContexts = new RenderContexts();

				//

				this._animation.setNodes( this._nodes );
				this._animation.start();

				this._initialized = true;

				resolve();

			} );

			return this._initPromise;

		}

		get coordinateSystem() {

			return this.backend.coordinateSystem;

		}

		async compile( /*scene, camera*/ ) {

		}

		async render( scene, camera ) {

			if ( this._initialized === false ) await this.init();

			// preserve render tree

			const nodeFrame = this._nodes.nodeFrame;

			const previousRenderId = nodeFrame.renderId;
			const previousRenderState = this._currentRenderContext;

			//

			const sceneRef = ( scene.isScene === true ) ? scene : _scene;

			const renderTarget = this._renderTarget;
			const renderContext = this._renderContexts.get( scene, camera, renderTarget );
			const activeCubeFace = this._activeCubeFace;

			this._currentRenderContext = renderContext;

			nodeFrame.renderId ++;

			//

			const coordinateSystem = this.coordinateSystem;

			if ( camera.coordinateSystem !== coordinateSystem ) {

				camera.coordinateSystem = coordinateSystem;

				camera.updateProjectionMatrix();

			}

			//

			if ( this._animation.isAnimating === false ) nodeFrame.update();

			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

			if ( this._info.autoReset === true ) this._info.reset();

			this._info.render.frame ++;

			//

			let viewport = this._viewport;
			let scissor = this._scissor;
			let pixelRatio = this._pixelRatio;

			if ( renderTarget !== null ) {

				viewport = renderTarget.viewport;
				scissor = renderTarget.scissor;
				pixelRatio = 1;

			}

			this.getDrawingBufferSize( _drawingBufferSize );

			_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );

			const minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;
			const maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;

			renderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();
			renderContext.viewportValue.minDepth = minDepth;
			renderContext.viewportValue.maxDepth = maxDepth;
			renderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;

			renderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();
			renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;

			renderContext.depth = this.depth;
			renderContext.stencil = this.stencil;

			//

			sceneRef.onBeforeRender( this, scene, camera, renderTarget );

			//

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );

			const renderList = this._renderLists.get( scene, camera );
			renderList.init();

			this._projectObject( scene, camera, 0, renderList );

			renderList.finish();

			if ( this.sortObjects === true ) {

				renderList.sort( this._opaqueSort, this._transparentSort );

			}

			//

			if ( renderTarget !== null ) {

				this._textures.updateRenderTarget( renderTarget );

				const renderTargetData = this._textures.get( renderTarget );

				renderContext.texture = renderTargetData.texture;
				renderContext.depthTexture = renderTargetData.depthTexture;

			} else {

				renderContext.texture = null;
				renderContext.depthTexture = null;

			}

			renderContext.activeCubeFace = activeCubeFace;

			//

			this._nodes.updateScene( sceneRef );

			//

			this._background.update( sceneRef, renderList, renderContext );

			//

			this.backend.beginRender( renderContext );

			// process render lists

			const opaqueObjects = renderList.opaque;
			const transparentObjects = renderList.transparent;
			const lightsNode = renderList.lightsNode;

			if ( opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
			if ( transparentObjects.length > 0 ) this._renderObjects( transparentObjects, camera, sceneRef, lightsNode );

			// finish render pass

			this.backend.finishRender( renderContext );

			// restore render tree

			nodeFrame.renderId = previousRenderId;
			this._currentRenderContext = previousRenderState;

			this._lastRenderContext = renderContext;

			//

			sceneRef.onAfterRender( this, scene, camera, renderTarget );

		}

		setAnimationLoop( callback ) {

			if ( this._initialized === false ) this.init();

			const animation = this._animation;

			animation.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		}

		getArrayBuffer( attribute ) { // @deprecated, r155

			return this.getArrayBufferAsync( attribute );

		}

		async getArrayBufferAsync( attribute ) {

			return await this.backend.getArrayBufferAsync( attribute );

		}

		getContext() {

			return this._context;

		}

		getPixelRatio() {

			return this._pixelRatio;

		}

		getDrawingBufferSize( target ) {

			return target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();

		}

		getSize( target ) {

			return target.set( this._width, this._height );

		}

		setPixelRatio( value = 1 ) {

			this._pixelRatio = value;

			this.setSize( this._width, this._height, false );

		}

		setDrawingBufferSize( width, height, pixelRatio ) {

			this._width = width;
			this._height = height;

			this._pixelRatio = pixelRatio;

			this.domElement.width = Math.floor( width * pixelRatio );
			this.domElement.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

			if ( this._initialized ) this.backend.updateSize();

		}

		setSize( width, height, updateStyle = true ) {

			this._width = width;
			this._height = height;

			this.domElement.width = Math.floor( width * this._pixelRatio );
			this.domElement.height = Math.floor( height * this._pixelRatio );

			if ( updateStyle === true ) {

				this.domElement.style.width = width + 'px';
				this.domElement.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

			if ( this._initialized ) this.backend.updateSize();

		}

		setOpaqueSort( method ) {

			this._opaqueSort = method;

		}

		setTransparentSort( method ) {

			this._transparentSort = method;

		}

		getScissor( target ) {

			const scissor = this._scissor;

			target.x = scissor.x;
			target.y = scissor.y;
			target.width = scissor.width;
			target.height = scissor.height;

			return target;

		}

		setScissor( x, y, width, height ) {

			const scissor = this._scissor;

			if ( x.isVector4 ) {

				scissor.copy( x );

			} else {

				scissor.set( x, y, width, height );

			}

		}

		getScissorTest() {

			return this._scissorTest;

		}

		setScissorTest( boolean ) {

			this._scissorTest = boolean;

		}

		getViewport( target ) {

			return target.copy( this._viewport );

		}

		setViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {

			const viewport = this._viewport;

			if ( x.isVector4 ) {

				viewport.copy( x );

			} else {

				viewport.set( x, y, width, height );

			}

			viewport.minDepth = minDepth;
			viewport.maxDepth = maxDepth;

		}

		getClearColor( target ) {

			return target.copy( this._clearColor );

		}

		setClearColor( color, alpha = 1 ) {

			this._clearColor.set( color );
			this._clearAlpha = alpha;

		}

		getClearAlpha() {

			return this._clearAlpha;

		}

		setClearAlpha( alpha ) {

			this._clearAlpha = alpha;

		}

		getClearDepth() {

			return this._clearDepth;

		}

		setClearDepth( depth ) {

			this._clearDepth = depth;

		}

		getClearStencil() {

			return this._clearStencil;

		}

		setClearStencil( stencil ) {

			this._clearStencil = stencil;

		}

		clear( color = true, depth = true, stencil = true ) {

			const renderContext = this._currentRenderContext || this._lastRenderContext;

			if ( renderContext ) this.backend.clear( renderContext, color, depth, stencil );

		}

		clearColor() {

			this.clear( true, false, false );

		}

		clearDepth() {

			this.clear( false, true, false );

		}

		clearStencil() {

			this.clear( false, false, true );

		}

		dispose() {

			this._objects.dispose();
			this._properties.dispose();
			this._pipelines.dispose();
			this._nodes.dispose();
			this._bindings.dispose();
			this._info.dispose();
			this._renderLists.dispose();
			this._renderContexts.dispose();
			this._textures.dispose();

			this.setRenderTarget( null );
			this.setAnimationLoop( null );

		}

		setRenderTarget( renderTarget, activeCubeFace = 0 ) {

			this._renderTarget = renderTarget;
			this._activeCubeFace = activeCubeFace;

		}

		getRenderTarget() {

			return this._renderTarget;

		}

		async compute( computeNodes ) {

			if ( this._initialized === false ) await this.init();

			const backend = this.backend;
			const pipelines = this._pipelines;
			const bindings = this._bindings;
			const nodes = this._nodes;
			const computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];

			backend.beginCompute( computeNodes );

			for ( const computeNode of computeList ) {

				// onInit

				if ( pipelines.has( computeNode ) === false ) {

					const dispose = () => {

						computeNode.removeEventListener( 'dispose', dispose );

						pipelines.delete( computeNode );
						bindings.delete( computeNode );
						nodes.delete( computeNode );

					};

					computeNode.addEventListener( 'dispose', dispose );

					//

					computeNode.onInit( { renderer: this } );

				}

				nodes.updateForCompute( computeNode );
				bindings.updateForCompute( computeNode );

				const computeBindings = bindings.getForCompute( computeNode );
				const computePipeline = pipelines.getForCompute( computeNode, computeBindings );

				backend.compute( computeNodes, computeNode, computeBindings, computePipeline );

			}

			backend.finishCompute( computeNodes );

		}

		hasFeature( name ) {

			return this.backend.hasFeature( name );

		}

		copyFramebufferToTexture( framebufferTexture ) {

			const renderContext = this._currentRenderContext || this._lastRenderContext;

			this._textures.updateTexture( framebufferTexture );

			this.backend.copyFramebufferToTexture( framebufferTexture, renderContext );

		}

		readRenderTargetPixelsAsync( renderTarget, x, y, width, height ) {

			return this.backend.copyTextureToBuffer( renderTarget.texture, x, y, width, height );

		}

		_projectObject( object, camera, groupOrder, renderList ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					renderList.pushLight( object );

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );

						}

						const geometry = object.geometry;
						const material = object.material;

						if ( material.visible ) {

							renderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isLineLoop ) ; else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						const geometry = object.geometry;
						const material = object.material;

						if ( this.sortObjects === true ) {

							if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

							_vector3
								.copy( geometry.boundingSphere.center )
								.applyMatrix4( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									renderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							renderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this._projectObject( children[ i ], camera, groupOrder, renderList );

			}

		}

		_renderObjects( renderList, camera, scene, lightsNode ) {

			// process renderable objects

			for ( let i = 0, il = renderList.length; i < il; i ++ ) {

				const renderItem = renderList[ i ];

				// @TODO: Add support for multiple materials per object. This will require to extract
				// the material from the renderItem object and pass it with its group data to _renderObject().

				const { object, geometry, material, group } = renderItem;

				if ( camera.isArrayCamera ) {

					const cameras = camera.cameras;

					for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

						const camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							const vp = camera2.viewport;
							const minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;
							const maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;

							const viewportValue = this._currentRenderContext.viewportValue;
							viewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();
							viewportValue.minDepth = minDepth;
							viewportValue.maxDepth = maxDepth;

							this.backend.updateViewport( this._currentRenderContext );

							this._renderObject( object, scene, camera2, geometry, material, group, lightsNode );

						}

					}

				} else {

					this._renderObject( object, scene, camera, geometry, material, group, lightsNode );

				}

			}

		}

		_renderObject( object, scene, camera, geometry, material, group, lightsNode ) {

			material = scene.overrideMaterial !== null ? scene.overrideMaterial : material;

			//

			object.onBeforeRender( this, scene, camera, geometry, material, group );

			material.onBeforeRender( this, scene, camera, geometry, material, group );

			//

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				this._renderObjectDirect( object, material, scene, camera, lightsNode, 'backSide' ); // create backSide pass id

				material.side = FrontSide;
				this._renderObjectDirect( object, material, scene, camera, lightsNode ); // use default pass id

				material.side = DoubleSide;

			} else {

				this._renderObjectDirect( object, material, scene, camera, lightsNode );

			}

			//

			object.onAfterRender( this, scene, camera, geometry, material, group );

		}

		_renderObjectDirect( object, material, scene, camera, lightsNode, passId ) {

			const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, passId );

			//

			this._nodes.updateBefore( renderObject );

			//

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			//

			this._nodes.updateForRender( renderObject );
			this._geometries.updateForRender( renderObject );
			this._bindings.updateForRender( renderObject );
			this._pipelines.updateForRender( renderObject );

			//

			this.backend.draw( renderObject, this._info );

		}

	}

	const GPUPrimitiveTopology = {
		PointList: 'point-list',
		LineList: 'line-list',
		LineStrip: 'line-strip',
		TriangleList: 'triangle-list',
		TriangleStrip: 'triangle-strip',
	};

	const GPUCompareFunction = {
		Never: 'never',
		Less: 'less',
		Equal: 'equal',
		LessEqual: 'less-equal',
		Greater: 'greater',
		NotEqual: 'not-equal',
		GreaterEqual: 'greater-equal',
		Always: 'always'
	};

	const GPUStoreOp = {
		Store: 'store',
		Discard: 'discard'
	};

	const GPULoadOp = {
		Load: 'load',
		Clear: 'clear'
	};

	const GPUFrontFace = {
		CCW: 'ccw',
		CW: 'cw'
	};

	const GPUCullMode = {
		None: 'none',
		Front: 'front',
		Back: 'back'
	};

	const GPUIndexFormat = {
		Uint16: 'uint16',
		Uint32: 'uint32'
	};

	const GPUTextureFormat = {

		// 8-bit formats

		R8Unorm: 'r8unorm',
		R8Snorm: 'r8snorm',
		R8Uint: 'r8uint',
		R8Sint: 'r8sint',

		// 16-bit formats

		R16Uint: 'r16uint',
		R16Sint: 'r16sint',
		R16Float: 'r16float',
		RG8Unorm: 'rg8unorm',
		RG8Snorm: 'rg8snorm',
		RG8Uint: 'rg8uint',
		RG8Sint: 'rg8sint',

		// 32-bit formats

		R32Uint: 'r32uint',
		R32Sint: 'r32sint',
		R32Float: 'r32float',
		RG16Uint: 'rg16uint',
		RG16Sint: 'rg16sint',
		RG16Float: 'rg16float',
		RGBA8Unorm: 'rgba8unorm',
		RGBA8UnormSRGB: 'rgba8unorm-srgb',
		RGBA8Snorm: 'rgba8snorm',
		RGBA8Uint: 'rgba8uint',
		RGBA8Sint: 'rgba8sint',
		BGRA8Unorm: 'bgra8unorm',
		BGRA8UnormSRGB: 'bgra8unorm-srgb',
		// Packed 32-bit formats
		RGB9E5UFloat: 'rgb9e5ufloat',
		RGB10A2Unorm: 'rgb10a2unorm',
		RG11B10uFloat: 'rgb10a2unorm',

		// 64-bit formats

		RG32Uint: 'rg32uint',
		RG32Sint: 'rg32sint',
		RG32Float: 'rg32float',
		RGBA16Uint: 'rgba16uint',
		RGBA16Sint: 'rgba16sint',
		RGBA16Float: 'rgba16float',

		// 128-bit formats

		RGBA32Uint: 'rgba32uint',
		RGBA32Sint: 'rgba32sint',
		RGBA32Float: 'rgba32float',

		// Depth and stencil formats

		Stencil8: 'stencil8',
		Depth16Unorm: 'depth16unorm',
		Depth24Plus: 'depth24plus',
		Depth24PlusStencil8: 'depth24plus-stencil8',
		Depth32Float: 'depth32float',

		// 'depth32float-stencil8' extension

		Depth32FloatStencil8: 'depth32float-stencil8',

		// BC compressed formats usable if 'texture-compression-bc' is both
		// supported by the device/user agent and enabled in requestDevice.

		BC1RGBAUnorm: 'bc1-rgba-unorm',
		BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
		BC2RGBAUnorm: 'bc2-rgba-unorm',
		BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
		BC3RGBAUnorm: 'bc3-rgba-unorm',
		BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
		BC4RUnorm: 'bc4-r-unorm',
		BC4RSnorm: 'bc4-r-snorm',
		BC5RGUnorm: 'bc5-rg-unorm',
		BC5RGSnorm: 'bc5-rg-snorm',
		BC6HRGBUFloat: 'bc6h-rgb-ufloat',
		BC6HRGBFloat: 'bc6h-rgb-float',
		BC7RGBAUnorm: 'bc7-rgba-unorm',
		BC7RGBAUnormSRGB: 'bc7-rgba-srgb',

		// ETC2 compressed formats usable if 'texture-compression-etc2' is both
		// supported by the device/user agent and enabled in requestDevice.

		ETC2RGB8Unorm: 'etc2-rgb8unorm',
		ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
		ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
		ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
		ETC2RGBA8Unorm: 'etc2-rgba8unorm',
		ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
		EACR11Unorm: 'eac-r11unorm',
		EACR11Snorm: 'eac-r11snorm',
		EACRG11Unorm: 'eac-rg11unorm',
		EACRG11Snorm: 'eac-rg11snorm',

		// ASTC compressed formats usable if 'texture-compression-astc' is both
		// supported by the device/user agent and enabled in requestDevice.

		ASTC4x4Unorm: 'astc-4x4-unorm',
		ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
		ASTC5x4Unorm: 'astc-5x4-unorm',
		ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
		ASTC5x5Unorm: 'astc-5x5-unorm',
		ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
		ASTC6x5Unorm: 'astc-6x5-unorm',
		ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
		ASTC6x6Unorm: 'astc-6x6-unorm',
		ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
		ASTC8x5Unorm: 'astc-8x5-unorm',
		ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
		ASTC8x6Unorm: 'astc-8x6-unorm',
		ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
		ASTC8x8Unorm: 'astc-8x8-unorm',
		ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
		ASTC10x5Unorm: 'astc-10x5-unorm',
		ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
		ASTC10x6Unorm: 'astc-10x6-unorm',
		ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
		ASTC10x8Unorm: 'astc-10x8-unorm',
		ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
		ASTC10x10Unorm: 'astc-10x10-unorm',
		ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
		ASTC12x10Unorm: 'astc-12x10-unorm',
		ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
		ASTC12x12Unorm: 'astc-12x12-unorm',
		ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',

	};

	const GPUAddressMode = {
		ClampToEdge: 'clamp-to-edge',
		Repeat: 'repeat',
		MirrorRepeat: 'mirror-repeat'
	};

	const GPUFilterMode = {
		Linear: 'linear',
		Nearest: 'nearest'
	};

	const GPUBlendFactor = {
		Zero: 'zero',
		One: 'one',
		Src: 'src',
		OneMinusSrc: 'one-minus-src',
		SrcAlpha: 'src-alpha',
		OneMinusSrcAlpha: 'one-minus-src-alpha',
		Dst: 'dst',
		OneMinusDstColor: 'one-minus-dst',
		DstAlpha: 'dst-alpha',
		OneMinusDstAlpha: 'one-minus-dst-alpha',
		SrcAlphaSaturated: 'src-alpha-saturated',
		Constant: 'constant',
		OneMinusConstant: 'one-minus-constant'
	};

	const GPUBlendOperation = {
		Add: 'add',
		Subtract: 'subtract',
		ReverseSubtract: 'reverse-subtract',
		Min: 'min',
		Max: 'max'
	};

	const GPUColorWriteFlags = {
		None: 0,
		Red: 0x1,
		Green: 0x2,
		Blue: 0x4,
		Alpha: 0x8,
		All: 0xF
	};

	const GPUStencilOperation = {
		Keep: 'keep',
		Zero: 'zero',
		Replace: 'replace',
		Invert: 'invert',
		IncrementClamp: 'increment-clamp',
		DecrementClamp: 'decrement-clamp',
		IncrementWrap: 'increment-wrap',
		DecrementWrap: 'decrement-wrap'
	};

	const GPUBufferBindingType = {
		Uniform: 'uniform',
		Storage: 'storage',
		ReadOnlyStorage: 'read-only-storage'
	};

	const GPUTextureDimension = {
		OneD: '1d',
		TwoD: '2d',
		ThreeD: '3d'
	};

	const GPUTextureViewDimension = {
		OneD: '1d',
		TwoD: '2d',
		TwoDArray: '2d-array',
		Cube: 'cube',
		CubeArray: 'cube-array',
		ThreeD: '3d'
	};

	const GPUTextureAspect = {
		All: 'all',
		StencilOnly: 'stencil-only',
		DepthOnly: 'depth-only'
	};

	const GPUInputStepMode = {
		Vertex: 'vertex',
		Instance: 'instance'
	};

	const GPUFeatureName = {
		DepthClipControl: 'depth-clip-control',
		Depth32FloatStencil8: 'depth32float-stencil8',
		TextureCompressionBC: 'texture-compression-bc',
		TextureCompressionETC2: 'texture-compression-etc2',
		TextureCompressionASTC: 'texture-compression-astc',
		TimestampQuery: 'timestamp-query',
		IndirectFirstInstance: 'indirect-first-instance',
		ShaderF16: 'shader-f16',
		RG11B10UFloat: 'rg11b10ufloat-renderable',
		BGRA8UNormStorage: 'bgra8unorm-storage',
		Float32Filterable: 'float32-filterable'
	};

	class Binding {

		constructor( name = '' ) {

			this.name = name;

			this.visibility = 0;

		}

		setVisibility( visibility ) {

			this.visibility |= visibility;

		}

	}

	function getFloatLength( floatLength ) {

		// ensure chunk size alignment (STD140 layout)

		return floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );

	}

	function getVectorLength( count, vectorLength = 4 ) {

		const strideLength = getStrideLength( vectorLength );

		const floatLength = strideLength * count;

		return getFloatLength( floatLength );

	}

	function getStrideLength( vectorLength ) {

		const strideLength = 4;

		return vectorLength + ( ( strideLength - ( vectorLength % strideLength ) ) % strideLength );

	}

	class Buffer extends Binding {

		constructor( name, buffer = null ) {

			super( name );

			this.isBuffer = true;

			this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

			this._buffer = buffer;

		}

		get byteLength() {

			return getFloatLength( this._buffer.byteLength );

		}

		get buffer() {

			return this._buffer;

		}

		update() {

			return true;

		}

	}

	class UniformBuffer extends Buffer {

		constructor( name, buffer = null ) {

			super( name, buffer );

			this.isUniformBuffer = true;

		}

	}

	class UniformsGroup extends UniformBuffer {

		constructor( name ) {

			super( name );

			this.isUniformsGroup = true;

			// the order of uniforms in this array must match the order of uniforms in the shader

			this.uniforms = [];

		}

		addUniform( uniform ) {

			this.uniforms.push( uniform );

			return this;

		}

		removeUniform( uniform ) {

			const index = this.uniforms.indexOf( uniform );

			if ( index !== - 1 ) {

				this.uniforms.splice( index, 1 );

			}

			return this;

		}

		get buffer() {

			let buffer = this._buffer;

			if ( buffer === null ) {

				const byteLength = this.byteLength;

				buffer = new Float32Array( new ArrayBuffer( byteLength ) );

				this._buffer = buffer;

			}

			return buffer;

		}

		get byteLength() {

			let offset = 0; // global buffer offset in bytes

			for ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {

				const uniform = this.uniforms[ i ];

				// offset within a single chunk in bytes

				const chunkOffset = offset % GPU_CHUNK_BYTES;
				const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;

				// conformance tests

				if ( chunkOffset !== 0 && ( remainingSizeInChunk - uniform.boundary ) < 0 ) {

					// check for chunk overflow

					offset += ( GPU_CHUNK_BYTES - chunkOffset );

				} else if ( chunkOffset % uniform.boundary !== 0 ) {

					// check for correct alignment

					offset += ( chunkOffset % uniform.boundary );

				}

				uniform.offset = ( offset / this.bytesPerElement );

				offset += ( uniform.itemSize * this.bytesPerElement );

			}

			return Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;

		}

		update() {

			let updated = false;

			for ( const uniform of this.uniforms ) {

				if ( this.updateByType( uniform ) === true ) {

					updated = true;

				}

			}

			return updated;

		}

		updateByType( uniform ) {

			if ( uniform.isFloatUniform ) return this.updateNumber( uniform );
			if ( uniform.isVector2Uniform ) return this.updateVector2( uniform );
			if ( uniform.isVector3Uniform ) return this.updateVector3( uniform );
			if ( uniform.isVector4Uniform ) return this.updateVector4( uniform );
			if ( uniform.isColorUniform ) return this.updateColor( uniform );
			if ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );
			if ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );

		}

		updateNumber( uniform ) {

			let updated = false;

			const a = this.buffer;
			const v = uniform.getValue();
			const offset = uniform.offset;

			if ( a[ offset ] !== v ) {

				a[ offset ] = v;
				updated = true;

			}

			return updated;

		}

		updateVector2( uniform ) {

			let updated = false;

			const a = this.buffer;
			const v = uniform.getValue();
			const offset = uniform.offset;

			if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {

				a[ offset + 0 ] = v.x;
				a[ offset + 1 ] = v.y;

				updated = true;

			}

			return updated;

		}

		updateVector3( uniform ) {

			let updated = false;

			const a = this.buffer;
			const v = uniform.getValue();
			const offset = uniform.offset;

			if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {

				a[ offset + 0 ] = v.x;
				a[ offset + 1 ] = v.y;
				a[ offset + 2 ] = v.z;

				updated = true;

			}

			return updated;

		}

		updateVector4( uniform ) {

			let updated = false;

			const a = this.buffer;
			const v = uniform.getValue();
			const offset = uniform.offset;

			if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {

				a[ offset + 0 ] = v.x;
				a[ offset + 1 ] = v.y;
				a[ offset + 2 ] = v.z;
				a[ offset + 3 ] = v.w;

				updated = true;

			}

			return updated;

		}

		updateColor( uniform ) {

			let updated = false;

			const a = this.buffer;
			const c = uniform.getValue();
			const offset = uniform.offset;

			if ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {

				a[ offset + 0 ] = c.r;
				a[ offset + 1 ] = c.g;
				a[ offset + 2 ] = c.b;

				updated = true;

			}

			return updated;

		}

		updateMatrix3( uniform ) {

			let updated = false;

			const a = this.buffer;
			const e = uniform.getValue().elements;
			const offset = uniform.offset;

			if ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||
				a[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||
				a[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {

				a[ offset + 0 ] = e[ 0 ];
				a[ offset + 1 ] = e[ 1 ];
				a[ offset + 2 ] = e[ 2 ];
				a[ offset + 4 ] = e[ 3 ];
				a[ offset + 5 ] = e[ 4 ];
				a[ offset + 6 ] = e[ 5 ];
				a[ offset + 8 ] = e[ 6 ];
				a[ offset + 9 ] = e[ 7 ];
				a[ offset + 10 ] = e[ 8 ];

				updated = true;

			}

			return updated;

		}

		updateMatrix4( uniform ) {

			let updated = false;

			const a = this.buffer;
			const e = uniform.getValue().elements;
			const offset = uniform.offset;

			if ( arraysEqual( a, e, offset ) === false ) {

				a.set( e, offset );
				updated = true;

			}

			return updated;

		}

	}

	function arraysEqual( a, b, offset ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			if ( a[ offset + i ] !== b[ i ] ) return false;

		}

		return true;

	}

	class Uniform {

		constructor( name, value = null ) {

			this.name = name;
			this.value = value;

			this.boundary = 0; // used to build the uniform buffer according to the STD140 layout
			this.itemSize = 0;

			this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer

		}

		setValue( value ) {

			this.value = value;

		}

		getValue() {

			return this.value;

		}

	}

	class FloatUniform extends Uniform {

		constructor( name, value = 0 ) {

			super( name, value );

			this.isFloatUniform = true;

			this.boundary = 4;
			this.itemSize = 1;

		}

	}

	class Vector2Uniform extends Uniform {

		constructor( name, value = new Vector2() ) {

			super( name, value );

			this.isVector2Uniform = true;

			this.boundary = 8;
			this.itemSize = 2;

		}

	}

	class Vector3Uniform extends Uniform {

		constructor( name, value = new Vector3() ) {

			super( name, value );

			this.isVector3Uniform = true;

			this.boundary = 16;
			this.itemSize = 3;

		}

	}

	class Vector4Uniform extends Uniform {

		constructor( name, value = new Vector4() ) {

			super( name, value );

			this.isVector4Uniform = true;

			this.boundary = 16;
			this.itemSize = 4;

		}

	}

	class ColorUniform extends Uniform {

		constructor( name, value = new Color() ) {

			super( name, value );

			this.isColorUniform = true;

			this.boundary = 16;
			this.itemSize = 3;

		}

	}

	class Matrix3Uniform extends Uniform {

		constructor( name, value = new Matrix3() ) {

			super( name, value );

			this.isMatrix3Uniform = true;

			this.boundary = 48;
			this.itemSize = 12;

		}

	}

	class Matrix4Uniform extends Uniform {

		constructor( name, value = new Matrix4() ) {

			super( name, value );

			this.isMatrix4Uniform = true;

			this.boundary = 64;
			this.itemSize = 16;

		}

	}

	class FloatNodeUniform extends FloatUniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class Vector2NodeUniform extends Vector2Uniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class Vector3NodeUniform extends Vector3Uniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class Vector4NodeUniform extends Vector4Uniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class ColorNodeUniform extends ColorUniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class Matrix3NodeUniform extends Matrix3Uniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class Matrix4NodeUniform extends Matrix4Uniform {

		constructor( nodeUniform ) {

			super( nodeUniform.name, nodeUniform.value );

			this.nodeUniform = nodeUniform;

		}

		getValue() {

			return this.nodeUniform.value;

		}

	}

	class Sampler extends Binding {

		constructor( name, texture ) {

			super( name );

			this.texture = texture;
			this.version = texture.version;

			this.isSampler = true;

		}

	}

	class NodeSampler extends Sampler {

		constructor( name, textureNode ) {

			super( name, textureNode.value );

			this.textureNode = textureNode;

		}

		getTexture() {

			return this.textureNode.value;

		}

	}

	let id = 0;

	class SampledTexture extends Binding {

		constructor( name, texture ) {

			super( name );

			this.id = id ++;

			this.texture = texture;
			this.version = texture.version;

			this.isSampledTexture = true;

		}

		get needsBindingsUpdate() {

			const { texture, version } = this;

			return texture.isVideoTexture ? true : version !== texture.version; // @TODO: version === 0 && texture.version > 0 ( add it just to External Textures like PNG,JPG )

		}

		update() {

			if ( this.version !== this.texture.version ) {

				this.version = this.texture.version;

				return true;

			}

			return false;

		}

	}

	class SampledCubeTexture extends SampledTexture {

		constructor( name, texture ) {

			super( name, texture );

			this.isSampledCubeTexture = true;

		}

	}

	class NodeSampledTexture extends SampledTexture {

		constructor( name, textureNode ) {

			super( name, textureNode.value );

			this.textureNode = textureNode;

		}

		getTexture() {

			return this.textureNode.value;

		}

	}

	class NodeSampledCubeTexture extends SampledCubeTexture {

		constructor( name, textureNode ) {

			super( name, textureNode.value );

			this.textureNode = textureNode;

		}

		getTexture() {

			return this.textureNode.value;

		}

	}

	class StorageBuffer extends Buffer {

		constructor( name, attribute ) {

			super( name, attribute.array );

			this.attribute = attribute;

			this.isStorageBuffer = true;

		}

	}

	// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

	class CubeRenderTarget extends WebGLCubeRenderTarget {

		constructor( size = 1, options = {} ) {

			super( size, options );

			this.isCubeRenderTarget = true;

		}

		fromEquirectangularTexture( renderer, texture$1 ) {

			const currentMinFilter = texture$1.minFilter;
			const currentGenerateMipmaps = texture$1.generateMipmaps;

			texture$1.generateMipmaps = true;

			this.texture.type = texture$1.type;
			this.texture.colorSpace = texture$1.colorSpace;

			this.texture.generateMipmaps = texture$1.generateMipmaps;
			this.texture.minFilter = texture$1.minFilter;
			this.texture.magFilter = texture$1.magFilter;

			const geometry = new BoxGeometry( 5, 5, 5 );

			const uvNode = equirectUV( positionWorldDirection );

			const material = createNodeMaterialFromType( 'MeshBasicNodeMaterial' );
			material.colorNode = texture( texture$1, uvNode, 0 );
			material.side = BackSide;
			material.blending = NoBlending;

			const mesh = new Mesh( geometry, material );

			const scene = new Scene();
			scene.add( mesh );

			// Avoid blurred poles
			if ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, scene );

			texture$1.minFilter = currentMinFilter;
			texture$1.currentGenerateMipmaps = currentGenerateMipmaps;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

	}

	const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i;
	const propertiesRegexp = /[a-z_0-9]+/ig;

	const wgslTypeLib$1 = {
		f32: 'float'
	};

	const parse = ( source ) => {

		source = source.trim();

		const declaration = source.match( declarationRegexp );

		if ( declaration !== null && declaration.length === 4 ) {

			// tokenizer

			const inputsCode = declaration[ 2 ];
			const propsMatches = [];

			let nameMatch = null;

			while ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {

				propsMatches.push( nameMatch );

			}

			// parser

			const inputs = [];

			let i = 0;

			while ( i < propsMatches.length ) {

				// default

				const name = propsMatches[ i ++ ][ 0 ];
				let type = propsMatches[ i ++ ][ 0 ];

				type = wgslTypeLib$1[ type ] || type;

				// precision

				if ( i < propsMatches.length && /^[fui]\d{2}$/.test( propsMatches[ i ][ 0 ] ) === true )
					i ++;

				// add input

				inputs.push( new NodeFunctionInput( type, name ) );

			}

			//

			const blockCode = source.substring( declaration[ 0 ].length );

			const name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';
			const type = declaration[ 3 ] || 'void';

			return {
				type,
				inputs,
				name,
				inputsCode,
				blockCode
			};

		} else {

			throw new Error( 'FunctionNode: Function is not a WGSL code.' );

		}

	};

	class WGSLNodeFunction extends NodeFunction {

		constructor( source ) {

			const { type, inputs, name, inputsCode, blockCode } = parse( source );

			super( type, inputs, name );

			this.inputsCode = inputsCode;
			this.blockCode = blockCode;

		}

		getCode( name = this.name ) {

			const type = this.type !== 'void' ? '-> ' + this.type : '';

			return `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ type }` + this.blockCode;

		}

	}

	class WGSLNodeParser extends NodeParser {

		parseFunction( source ) {

			return new WGSLNodeFunction( source );

		}

	}

	const gpuShaderStageLib = {
		'vertex': GPUShaderStage.VERTEX,
		'fragment': GPUShaderStage.FRAGMENT,
		'compute': GPUShaderStage.COMPUTE
	};

	const supports = {
		instance: true
	};

	const wgslTypeLib = {
		float: 'f32',
		int: 'i32',
		uint: 'u32',
		bool: 'bool',
		color: 'vec3<f32>',

		vec2: 'vec2<f32>',
		ivec2: 'vec2<i32>',
		uvec2: 'vec2<u32>',
		bvec2: 'vec2<bool>',

		vec3: 'vec3<f32>',
		ivec3: 'vec3<i32>',
		uvec3: 'vec3<u32>',
		bvec3: 'vec3<bool>',

		vec4: 'vec4<f32>',
		ivec4: 'vec4<i32>',
		uvec4: 'vec4<u32>',
		bvec4: 'vec4<bool>',

		mat3: 'mat3x3<f32>',
		imat3: 'mat3x3<i32>',
		umat3: 'mat3x3<u32>',
		bmat3: 'mat3x3<bool>',

		mat4: 'mat4x4<f32>',
		imat4: 'mat4x4<i32>',
		umat4: 'mat4x4<u32>',
		bmat4: 'mat4x4<bool>'
	};

	const wgslMethods = {
		dFdx: 'dpdx',
		dFdy: 'dpdy',
		mod: 'threejs_mod',
		lessThanEqual: 'threejs_lessThanEqual',
		inversesqrt: 'inverseSqrt'
	};

	const wgslPolyfill = {
		lessThanEqual: new CodeNode( `
fn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );

}
` ),
		mod: new CodeNode( `
fn threejs_mod( x : f32, y : f32 ) -> f32 {

	return x - y * floor( x / y );

}
` ),
		repeatWrapping: new CodeNode( `
fn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
` )
	};

	class WGSLNodeBuilder extends NodeBuilder {

		constructor( object, renderer, scene = null ) {

			super( object, renderer, new WGSLNodeParser(), scene );

			this.uniformsGroup = {};

			this.builtins = {
				vertex: new Map(),
				fragment: new Map(),
				compute: new Map(),
				attribute: new Map()
			};

		}

		build() {

			const { object, material } = this;

			if ( material !== null ) {

				NodeMaterial.fromMaterial( material ).build( this );

			} else {

				this.addFlow( 'compute', object );

			}

			return super.build();

		}

		needsColorSpaceToLinear( texture ) {

			return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

		}

		getSampler( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

			if ( shaderStage === 'fragment' ) {

				return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;

			} else {

				this._include( 'repeatWrapping' );

				const dimension = `textureDimensions( ${textureProperty}, 0 )`;

				return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), 0 )`;

			}

		}

		getVideoSampler( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

			if ( shaderStage === 'fragment' ) {

				return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;

			}

		}

		getSamplerLevel( textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage ) {

			if ( shaderStage === 'fragment' ) {

				return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;

			} else {

				this._include( 'repeatWrapping' );

				const dimension = `textureDimensions( ${textureProperty}, 0 )`;

				return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${biasSnippet} ) )`;

			}

		}

		getTexture( texture, textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

			let snippet = null;

			if ( texture.isVideoTexture === true ) {

				snippet = this.getVideoSampler( textureProperty, uvSnippet, shaderStage );

			} else {

				snippet = this.getSampler( textureProperty, uvSnippet, shaderStage );

			}

			return snippet;

		}

		getTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, shaderStage = this.shaderStage ) {

			if ( shaderStage === 'fragment' ) {

				return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;

			}

		}

		getTextureLevel( texture, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage ) {

			let snippet = null;

			if ( texture.isVideoTexture === true ) {

				snippet = this.getVideoSampler( textureProperty, uvSnippet, shaderStage );

			} else {

				snippet = this.getSamplerLevel( textureProperty, uvSnippet, biasSnippet, shaderStage );

			}

			return snippet;

		}

		getPropertyName( node, shaderStage = this.shaderStage ) {

			if ( node.isNodeVarying === true && node.needsInterpolation === true ) {

				if ( shaderStage === 'vertex' ) {

					return `NodeVaryings.${ node.name }`;

				}

			} else if ( node.isNodeUniform === true ) {

				const name = node.name;
				const type = node.type;

				if ( type === 'texture' || type === 'cubeTexture' ) {

					return name;

				} else if ( type === 'buffer' || type === 'storageBuffer' ) {

					return `NodeBuffer_${node.node.id}.${name}`;

				} else {

					return `NodeUniforms.${name}`;

				}

			}

			return super.getPropertyName( node );

		}

		getUniformFromNode( node, type, shaderStage, name = null ) {

			const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
			const nodeData = this.getDataFromNode( node, shaderStage );

			if ( nodeData.uniformGPU === undefined ) {

				let uniformGPU;

				const bindings = this.bindings[ shaderStage ];

				if ( type === 'texture' || type === 'cubeTexture' ) {

					let texture = null;

					if ( type === 'texture' ) {

						texture = new NodeSampledTexture( uniformNode.name, uniformNode.node );

					} else if ( type === 'cubeTexture' ) {

						texture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node );

					}

					texture.setVisibility( gpuShaderStageLib[ shaderStage ] );

					// add first textures in sequence and group for last
					const lastBinding = bindings[ bindings.length - 1 ];
					const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;

					if ( shaderStage === 'fragment' ) {

						const sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node );
						sampler.setVisibility( gpuShaderStageLib[ shaderStage ] );

						bindings.splice( index, 0, sampler, texture );

						uniformGPU = [ sampler, texture ];

					} else {

						bindings.splice( index, 0, texture );

						uniformGPU = [ texture ];

					}

				} else if ( type === 'buffer' || type === 'storageBuffer' ) {

					const bufferClass = type === 'storageBuffer' ? StorageBuffer : UniformBuffer;
					const buffer = new bufferClass( 'NodeBuffer_' + node.id, node.value );
					buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );

					// add first textures in sequence and group for last
					const lastBinding = bindings[ bindings.length - 1 ];
					const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;

					bindings.splice( index, 0, buffer );

					uniformGPU = buffer;

				} else {

					let uniformsGroup = this.uniformsGroup[ shaderStage ];

					if ( uniformsGroup === undefined ) {

						uniformsGroup = new UniformsGroup( 'nodeUniforms' );
						uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

						this.uniformsGroup[ shaderStage ] = uniformsGroup;

						bindings.push( uniformsGroup );

					}

					if ( node.isArrayUniformNode === true ) {

						uniformGPU = [];

						for ( const uniformNode of node.nodes ) {

							const uniformNodeGPU = this._getNodeUniform( uniformNode, type );

							// fit bounds to buffer
							uniformNodeGPU.boundary = getVectorLength( uniformNodeGPU.itemSize );
							uniformNodeGPU.itemSize = getStrideLength( uniformNodeGPU.itemSize );

							uniformsGroup.addUniform( uniformNodeGPU );

							uniformGPU.push( uniformNodeGPU );

						}

					} else {

						uniformGPU = this._getNodeUniform( uniformNode, type );

						uniformsGroup.addUniform( uniformGPU );

					}

				}

				nodeData.uniformGPU = uniformGPU;

				if ( shaderStage === 'vertex' ) {

					this.bindingsOffset[ 'fragment' ] = bindings.length;

				}

			}

			return uniformNode;

		}

		isReference( type ) {

			return super.isReference( type ) || type === 'texture_2d' || type === 'texture_cube';

		}

		getBuiltin( name, property, type, shaderStage = this.shaderStage ) {

			const map = this.builtins[ shaderStage ];

			if ( map.has( name ) === false ) {

				map.set( name, {
					name,
					property,
					type
				} );

			}

			return property;

		}

		getVertexIndex() {

			if ( this.shaderStage === 'vertex' ) {

				return this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );

			}

			return 'vertexIndex';

		}

		getInstanceIndex() {

			if ( this.shaderStage === 'vertex' ) {

				return this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );

			}

			return 'instanceIndex';

		}

		getFrontFacing() {

			return this.getBuiltin( 'front_facing', 'isFront', 'bool' );

		}

		getFragCoord() {

			return this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>', 'fragment' );

		}

		isFlipY() {

			return false;

		}

		getAttributes( shaderStage ) {

			const snippets = [];

			if ( shaderStage === 'compute' ) {

				this.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );

			}

			if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

				for ( const { name, property, type } of this.builtins.attribute.values() ) {

					snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

				}

				const attributes = this.getAttributesArray();

				for ( let index = 0, length = attributes.length; index < length; index ++ ) {

					const attribute = attributes[ index ];
					const name = attribute.name;
					const type = this.getType( attribute.type );

					snippets.push( `@location( ${index} ) ${ name } : ${ type }` );

				}

			}

			return snippets.join( ',\n\t' );

		}

		getVar( type, name ) {

			return `var ${ name } : ${ this.getType( type ) }`;

		}

		getVars( shaderStage ) {

			const snippets = [];
			const vars = this.vars[ shaderStage ];

			for ( const variable of vars ) {

				snippets.push( `\t${ this.getVar( variable.type, variable.name ) };` );

			}

			return `\n${ snippets.join( '\n' ) }\n`;

		}

		getVaryings( shaderStage ) {

			const snippets = [];

			if ( shaderStage === 'vertex' ) {

				this.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );

			}

			if ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {

				const varyings = this.varyings;
				const vars = this.vars[ shaderStage ];

				for ( let index = 0; index < varyings.length; index ++ ) {

					const varying = varyings[ index ];

					if ( varying.needsInterpolation ) {

						let attributesSnippet = `@location( ${index} )`;

						if ( varying.type === 'int' || varying.type === 'uint' ) {

							attributesSnippet += ' @interpolate( flat )';

						}

						snippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );

					} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {

						vars.push( varying );

					}

				}

			}

			for ( const { name, property, type } of this.builtins[ shaderStage ].values() ) {

				snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

			}

			const code = snippets.join( ',\n\t' );

			return shaderStage === 'vertex' ? this._getWGSLStruct( 'NodeVaryingsStruct', '\t' + code ) : code;

		}

		getUniforms( shaderStage ) {

			const uniforms = this.uniforms[ shaderStage ];

			const bindingSnippets = [];
			const bufferSnippets = [];
			const groupSnippets = [];

			let index = this.bindingsOffset[ shaderStage ];

			for ( const uniform of uniforms ) {

				if ( uniform.type === 'texture' || uniform.type === 'cubeTexture' ) {

					if ( shaderStage === 'fragment' ) {

						const texture = uniform.node.value;

						if ( texture.isDepthTexture === true && texture.compareFunction !== null ) {

							bindingSnippets.push( `@binding( ${index ++} ) @group( 0 ) var ${uniform.name}_sampler : sampler_comparison;` );

						} else {

							bindingSnippets.push( `@binding( ${index ++} ) @group( 0 ) var ${uniform.name}_sampler : sampler;` );

						}

					}

					const texture = uniform.node.value;

					let textureType;

					if ( texture.isCubeTexture === true ) {

						textureType = 'texture_cube<f32>';

					} else if ( texture.isDepthTexture === true ) {

						textureType = 'texture_depth_2d';

					} else if ( texture.isVideoTexture === true ) {

						textureType = 'texture_external';

					} else {

						textureType = 'texture_2d<f32>';

					}

					bindingSnippets.push( `@binding( ${index ++} ) @group( 0 ) var ${uniform.name} : ${textureType};` );

				} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' ) {

					const bufferNode = uniform.node;
					const bufferType = this.getType( bufferNode.bufferType );
					const bufferCount = bufferNode.bufferCount;

					const bufferCountSnippet = bufferCount > 0 ? ', ' + bufferCount : '';
					const bufferSnippet = `\t${uniform.name} : array< ${bufferType}${bufferCountSnippet} >\n`;
					const bufferAccessMode = bufferNode.isStorageBufferNode ? 'storage,read_write' : 'uniform';

					bufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, index ++ ) );

				} else {

					const vectorType = this.getType( this.getVectorType( uniform.type ) );

					if ( Array.isArray( uniform.value ) === true ) {

						const length = uniform.value.length;

						groupSnippets.push( `uniform ${vectorType}[ ${length} ] ${uniform.name}` );

					} else {

						groupSnippets.push( `\t${uniform.name} : ${ vectorType}` );

					}

				}

			}

			let code = bindingSnippets.join( '\n' );
			code += bufferSnippets.join( '\n' );

			if ( groupSnippets.length > 0 ) {

				code += this._getWGSLStructBinding( 'NodeUniforms', groupSnippets.join( ',\n' ), 'uniform', index ++ );

			}

			return code;

		}

		buildCode() {

			const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

			for ( const shaderStage in shadersData ) {

				let flow = '// code\n\n';
				flow += this.flowCode[ shaderStage ];

				const flowNodes = this.flowNodes[ shaderStage ];
				const mainNode = flowNodes[ flowNodes.length - 1 ];

				for ( const node of flowNodes ) {

					const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
					const slotName = node.name;

					if ( slotName ) {

						if ( flow.length > 0 ) flow += '\n';

						flow += `\t// flow -> ${ slotName }\n\t`;

					}

					flow += `${ flowSlotData.code }\n\t`;

					if ( node === mainNode && shaderStage !== 'compute' ) {

						flow += '// result\n\t';

						if ( shaderStage === 'vertex' ) {

							flow += 'NodeVaryings.Vertex = ';

						} else if ( shaderStage === 'fragment' ) {

							flow += 'return ';

						}

						flow += `${ flowSlotData.result };`;

					}

				}

				const stageData = shadersData[ shaderStage ];

				stageData.uniforms = this.getUniforms( shaderStage );
				stageData.attributes = this.getAttributes( shaderStage );
				stageData.varyings = this.getVaryings( shaderStage );
				stageData.vars = this.getVars( shaderStage );
				stageData.codes = this.getCodes( shaderStage );
				stageData.flow = flow;

			}

			if ( this.material !== null ) {

				this.vertexShader = this._getWGSLVertexCode( shadersData.vertex );
				this.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );

			} else {

				this.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );

			}

		}

		getRenderTarget( width, height, options ) {

			return new RenderTarget( width, height, options );

		}

		getCubeRenderTarget( size, options ) {

			return new CubeRenderTarget( size, options );

		}

		getMethod( method ) {

			if ( wgslPolyfill[ method ] !== undefined ) {

				this._include( method );

			}

			return wgslMethods[ method ] || method;

		}

		getType( type ) {

			return wgslTypeLib[ type ] || type;

		}

		isAvailable( name ) {

			return supports[ name ] === true;

		}

		_include( name ) {

			wgslPolyfill[ name ].build( this );

		}

		_getNodeUniform( uniformNode, type ) {

			if ( type === 'float' ) return new FloatNodeUniform( uniformNode );
			if ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );
			if ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );
			if ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );
			if ( type === 'color' ) return new ColorNodeUniform( uniformNode );
			if ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );
			if ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );

			throw new Error( `Uniform "${type}" not declared.` );

		}

		_getWGSLVertexCode( shaderData ) {

			return `${ this.getSignature() }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> NodeVaryingsStruct {

	// system
	var NodeVaryings: NodeVaryingsStruct;

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return NodeVaryings;

}
`;

		}

		_getWGSLFragmentCode( shaderData ) {

			return `${ this.getSignature() }

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> @location( 0 ) vec4<f32> {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

		}

		_getWGSLComputeCode( shaderData, workgroupSize ) {

			return `${ this.getSignature() }
// system
var<private> instanceIndex : u32;

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x;

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

		}

		_getWGSLStruct( name, vars ) {

			return `
struct ${name} {
${vars}
};`;

		}

		_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {

			const structName = name + 'Struct';
			const structSnippet = this._getWGSLStruct( structName, vars );

			return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;

		}

	}

	let vector2 = null;
	let vector4 = null;

	class Backend {

		constructor( parameters = {} ) {

			this.parameters = Object.assign( {}, parameters );
			this.data = new WeakMap();
			this.renderer = null;
			this.domElement = null;

		}

		async init( renderer ) {

			this.renderer = renderer;

		}

		// render context

		begin( renderContext ) { }

		finish( renderContext ) { }

		// render object

		draw( renderObject, info ) { }

		// program

		createProgram( program ) { }

		destroyProgram( program ) { }

		// bindings

		createBindings( renderObject ) { }

		updateBindings( renderObject ) { }

		// pipeline

		createRenderPipeline( renderObject ) { }

		createComputePipeline( computeNode, pipeline ) { }

		destroyPipeline( pipeline ) { }

		// cache key

		needsUpdate( renderObject ) { } // return Boolean ( fast test )

		getCacheKey( renderObject ) { } // return String

		// node builder

		createNodeBuilder( renderObject ) { } // return NodeBuilder (ADD IT)

		// textures

		createSampler( texture ) { }

		createDefaultTexture( texture ) { }

		createTexture( texture ) { }

		copyTextureToBuffer( texture, x, y, width, height ) {}

		// attributes

		createAttribute( attribute ) { }

		createIndexAttribute( attribute ) { }

		updateAttribute( attribute ) { }

		destroyAttribute( attribute ) { }

		// canvas

		updateSize() { }

		// utils

		hasFeature( name ) { } // return Boolean

		getInstanceCount( renderObject ) {

			const { object, geometry } = renderObject;

			return geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.isInstancedMesh ? object.count : 1 );

		}

		getDrawingBufferSize() {

			vector2 = vector2 || new Vector2();

			return this.renderer.getDrawingBufferSize( vector2 );

		}

		getScissor() {

			vector4 = vector4 || new Vector4();

			return this.renderer.getScissor( vector4 );

		}

		getDomElement() {

			let domElement = this.domElement;

			if ( domElement === null ) {

				this.domElement = domElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : this.createCanvasElement();

			}

			return domElement;

		}

		createCanvasElement() {

			const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.style.display = 'block';
			return canvas;

		}

		// resource properties

		get( object ) {

			let map = this.data.get( object );

			if ( map === undefined ) {

				map = {};
				this.data.set( object, map );

			}

			return map;

		}

		delete( object ) {

			this.data.delete( object );

		}

	}

	class WebGPUUtils {

		constructor( backend ) {

			this.backend = backend;

		}

		getCurrentDepthStencilFormat( renderContext ) {

			let format;

			if ( renderContext.depthTexture !== null ) {

				format = this.getTextureFormatGPU( renderContext.depthTexture );

			} else if ( renderContext.depth && renderContext.stencil ) {

				format = GPUTextureFormat.Depth24PlusStencil8;

			} else if ( renderContext.depth ) {

				format = GPUTextureFormat.Depth24Plus;

			}

			return format;

		}

		getTextureFormatGPU( texture ) {

			return this.backend.get( texture ).texture.format;

		}

		getCurrentColorFormat( renderContext ) {

			let format;

			if ( renderContext.texture !== null ) {

				format = this.getTextureFormatGPU( renderContext.texture );

			} else {

				format = GPUTextureFormat.BGRA8Unorm; // default context format

			}

			return format;

		}

		getCurrentColorSpace( renderContext ) {

			if ( renderContext.texture !== null ) {

				return renderContext.texture.colorSpace;

			}

			return this.backend.renderer.outputColorSpace;

		}

		getPrimitiveTopology( object, material ) {

			if ( object.isPoints ) return GPUPrimitiveTopology.PointList;
			else if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;
			else if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;
			else if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;

		}

		getSampleCount( renderContext ) {

			if ( renderContext.texture !== null ) {

				return renderContext.sampleCount;

			}

			return this.backend.parameters.sampleCount;

		}

	}

	const typedArraysToVertexFormatPrefix = new Map( [
		[ Int8Array, [ 'sint8', 'snorm8' ]],
		[ Uint8Array, [ 'uint8', 'unorm8' ]],
		[ Int16Array, [ 'sint16', 'snorm16' ]],
		[ Uint16Array, [ 'uint16', 'unorm16' ]],
		[ Int32Array, [ 'sint32', 'snorm32' ]],
		[ Uint32Array, [ 'uint32', 'unorm32' ]],
		[ Float32Array, [ 'float32', ]],
	] );

	const typedAttributeToVertexFormatPrefix = new Map( [
		[ Float16BufferAttribute, [ 'float16', ]],
	] );

	const typeArraysToVertexFormatPrefixForItemSize1 = new Map( [
		[ Int32Array, 'sint32' ],
		[ Uint32Array, 'uint32' ],
		[ Float32Array, 'float32' ]
	] );

	class WebGPUAttributeUtils {

		constructor( backend ) {

			this.backend = backend;

		}

		createAttribute( attribute, usage ) {

			const bufferAttribute = this._getBufferAttribute( attribute );

			const backend = this.backend;
			const bufferData = backend.get( bufferAttribute );

			let buffer = bufferData.buffer;

			if ( buffer === undefined ) {

				const device = backend.device;

				const array = bufferAttribute.array;
				const size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441

				buffer = device.createBuffer( {
					label: bufferAttribute.name,
					size: size,
					usage: usage,
					mappedAtCreation: true
				} );

				new array.constructor( buffer.getMappedRange() ).set( array );

				buffer.unmap();

				bufferData.buffer = buffer;

			}

		}

		updateAttribute( attribute ) {

			const bufferAttribute = this._getBufferAttribute( attribute );

			const backend = this.backend;
			const device = backend.device;

			const buffer = backend.get( bufferAttribute ).buffer;

			const array = bufferAttribute.array;
			const updateRange = bufferAttribute.updateRange;

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				device.queue.writeBuffer(
					buffer,
					0,
					array,
					0
				);

			} else {

				device.queue.writeBuffer(
					buffer,
					0,
					array,
					updateRange.offset * array.BYTES_PER_ELEMENT,
					updateRange.count * array.BYTES_PER_ELEMENT
				);

				updateRange.count = - 1; // reset range

			}

		}

		createShaderVertexBuffers( renderObject ) {

			const attributes = renderObject.getAttributes();
			const vertexBuffers = new Map();

			for ( let slot = 0; slot < attributes.length; slot ++ ) {

				const geometryAttribute = attributes[ slot ];
				const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
				const bufferAttribute = this._getBufferAttribute( geometryAttribute );

				let vertexBufferLayout = vertexBuffers.get( bufferAttribute );

				if ( vertexBufferLayout === undefined ) {

					let arrayStride, stepMode;

					if ( geometryAttribute.isInterleavedBufferAttribute === true ) {

						arrayStride = geometryAttribute.data.stride * bytesPerElement;
						stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

					} else {

						arrayStride = geometryAttribute.itemSize * bytesPerElement;
						stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

					}

					vertexBufferLayout = {
						arrayStride,
						attributes: [],
						stepMode
					};

					vertexBuffers.set( bufferAttribute, vertexBufferLayout );

				}

				const format = this._getVertexFormat( geometryAttribute );
				const offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;

				vertexBufferLayout.attributes.push( {
					shaderLocation: slot,
					offset,
					format
				} );

			}

			return Array.from( vertexBuffers.values() );

		}

		destroyAttribute( attribute ) {

			const backend = this.backend;
			const data = backend.get( this._getBufferAttribute( attribute ) );

			data.buffer.destroy();

			backend.delete( attribute );

		}

		async getArrayBufferAsync( attribute ) {

			const backend = this.backend;
			const device = backend.device;

			const data = backend.get( this._getBufferAttribute( attribute ) );

			const bufferGPU = data.buffer;
			const size = bufferGPU.size;

			let readBufferGPU = data.readBuffer;
			let needsUnmap = true;

			if ( readBufferGPU === undefined ) {

				readBufferGPU = device.createBuffer( {
					label: attribute.name,
					size,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				} );

				needsUnmap = false;

				data.readBuffer = readBufferGPU;

			}

			const cmdEncoder = device.createCommandEncoder( {} );

			cmdEncoder.copyBufferToBuffer(
				bufferGPU,
				0,
				readBufferGPU,
				0,
				size
			);

			if ( needsUnmap ) readBufferGPU.unmap();

			const gpuCommands = cmdEncoder.finish();
			device.queue.submit( [ gpuCommands ] );

			await readBufferGPU.mapAsync( GPUMapMode.READ );

			const arrayBuffer = readBufferGPU.getMappedRange();

			return arrayBuffer;

		}

		_getVertexFormat( geometryAttribute ) {

			const { itemSize, normalized } = geometryAttribute;
			const ArrayType = geometryAttribute.array.constructor;
			const AttributeType = geometryAttribute.constructor;

			let format;

			if ( itemSize == 1 ) {

				format = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );

			} else {

				const prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );
				const prefix = prefixOptions[ normalized ? 1 : 0 ];

				if ( prefix ) {

					const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
					const paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;
					const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;

					if ( paddedItemSize % 1 ) {

						throw new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );

					}

					format = `${prefix}x${paddedItemSize}`;

				}

			}

			return format;

		}

		_getBufferAttribute( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return attribute;

		}

	}

	class WebGPUBindingUtils {

		constructor( backend ) {

			this.backend = backend;

		}

		createBindingsLayout( bindings ) {

			const backend = this.backend;
			const device = backend.device;

			const entries = [];

			let index = 0;

			for ( const binding of bindings ) {

				const bindingGPU = {
					binding: index ++,
					visibility: binding.visibility
				};

				if ( binding.isUniformBuffer || binding.isStorageBuffer ) {

					const buffer = {}; // GPUBufferBindingLayout

					if ( binding.isStorageBuffer ) {

						buffer.type = GPUBufferBindingType.Storage;

					}

					bindingGPU.buffer = buffer;

				} else if ( binding.isSampler ) {

					const sampler = {}; // GPUSamplerBindingLayout

					if ( binding.texture.isDepthTexture ) {

						if ( binding.texture.compareFunction !== null ) {

							sampler.type = 'comparison';

						}

					}

					bindingGPU.sampler = sampler;

				} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {

					bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout

				} else if ( binding.isSampledTexture ) {

					const texture = {}; // GPUTextureBindingLayout

					if ( binding.texture.isDepthTexture ) {

						texture.sampleType = 'depth';

					}

					if ( binding.isSampledCubeTexture ) {

						texture.viewDimension = GPUTextureViewDimension.Cube;

					}

					bindingGPU.texture = texture;

				} else ;

				entries.push( bindingGPU );

			}

			return device.createBindGroupLayout( { entries } );

		}

		createBindings( bindings ) {

			const backend = this.backend;
			const bindingsData = backend.get( bindings );

			// setup (static) binding layout and (dynamic) binding group

			const bindLayoutGPU = this.createBindingsLayout( bindings );
			const bindGroupGPU = this.createBindGroup( bindings, bindLayoutGPU );

			bindingsData.layout = bindLayoutGPU;
			bindingsData.group = bindGroupGPU;
			bindingsData.bindings = bindings;

		}

		updateBinding( binding ) {

			const backend = this.backend;
			const device = backend.device;

			const buffer = binding.buffer;
			const bufferGPU = backend.get( binding ).buffer;

			device.queue.writeBuffer( bufferGPU, 0, buffer, 0 );

		}

		createBindGroup( bindings, layoutGPU ) {

			const backend = this.backend;
			const device = backend.device;

			let bindingPoint = 0;
			const entriesGPU = [];

			for ( const binding of bindings ) {

				if ( binding.isUniformBuffer ) {

					const bindingData = backend.get( binding );

					if ( bindingData.buffer === undefined ) {

						const byteLength = binding.byteLength;

						const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;

						const bufferGPU = device.createBuffer( {
							label: 'bindingBuffer',
							size: byteLength,
							usage: usage
						} );

						bindingData.buffer = bufferGPU;

					}

					entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

				} else if ( binding.isStorageBuffer ) {

					const bindingData = backend.get( binding );

					if ( bindingData.buffer === undefined ) {

						const attribute = binding.attribute;
						//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

						//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

						bindingData.buffer = backend.get( attribute ).buffer;

					}

					entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

				} else if ( binding.isSampler ) {

					const textureGPU = backend.get( binding.texture );

					entriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );

				} else if ( binding.isSampledTexture ) {

					const textureData = backend.get( binding.texture );

					let dimensionViewGPU;

					if ( binding.isSampledCubeTexture ) {

						dimensionViewGPU = GPUTextureViewDimension.Cube;

					} else {

						dimensionViewGPU = GPUTextureViewDimension.TwoD;

					}

					let resourceGPU;

					if ( textureData.externalTexture !== undefined ) {

						resourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );

					} else {

						const aspectGPU = GPUTextureAspect.All;

						resourceGPU = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU } );

					}

					entriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );

				}

				bindingPoint ++;

			}

			return device.createBindGroup( {
				layout: layoutGPU,
				entries: entriesGPU
			} );

		}

	}

	class WebGPUPipelineUtils {

		constructor( backend ) {

			this.backend = backend;

		}

		createRenderPipeline( renderObject ) {

			const { object, material, geometry, pipeline } = renderObject;
			const { vertexProgram, fragmentProgram } = pipeline;

			const backend = this.backend;
			const device = backend.device;
			const utils = backend.utils;

			const pipelineData = backend.get( pipeline );
			const bindingsData = backend.get( renderObject.getBindings() );

			// vertex buffers

			const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );

			// blending

			let blending;

			if ( material.transparent === true && material.blending !== NoBlending ) {

				blending = this._getBlending( material );

			}

			// stencil

			let stencilFront = {};

			if ( material.stencilWrite === true ) {

				stencilFront = {
					compare: this._getStencilCompare( material ),
					failOp: this._getStencilOperation( material.stencilFail ),
					depthFailOp: this._getStencilOperation( material.stencilZFail ),
					passOp: this._getStencilOperation( material.stencilZPass )
				};

			}

			//

			const vertexModule = backend.get( vertexProgram ).module;
			const fragmentModule = backend.get( fragmentProgram ).module;

			const primitiveState = this._getPrimitiveState( object, geometry, material );
			const colorWriteMask = this._getColorWriteMask( material );
			const depthCompare = this._getDepthCompare( material );
			const colorFormat = utils.getCurrentColorFormat( renderObject.context );
			const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
			const sampleCount = utils.getSampleCount( renderObject.context );

			pipelineData.pipeline = device.createRenderPipeline( {
				vertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),
				fragment: Object.assign( {}, fragmentModule, { targets: [ {
					format: colorFormat,
					blend: blending,
					writeMask: colorWriteMask
				} ] } ),
				primitive: primitiveState,
				depthStencil: {
					format: depthStencilFormat,
					depthWriteEnabled: material.depthWrite,
					depthCompare: depthCompare,
					stencilFront: stencilFront,
					stencilBack: {}, // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
					stencilReadMask: material.stencilFuncMask,
					stencilWriteMask: material.stencilWriteMask
				},
				multisample: {
					count: sampleCount,
					alphaToCoverageEnabled: material.alphaToCoverage
				},
				layout: device.createPipelineLayout( {
					bindGroupLayouts: [ bindingsData.layout ]
				} )
			} );

		}

		createComputePipeline( pipeline, bindings ) {

			const backend = this.backend;
			const device = backend.device;

			const computeProgram = backend.get( pipeline.computeProgram ).module;

			const pipelineGPU = backend.get( pipeline );
			const bindingsData = backend.get( bindings );

			pipelineGPU.pipeline = device.createComputePipeline( {
				compute: computeProgram,
				layout: device.createPipelineLayout( {
					bindGroupLayouts: [ bindingsData.layout ]
				} )
			} );

		}

		_getBlending( material ) {

			let color, alpha;

			const blending = material.blending;

			if ( blending === CustomBlending ) {

				const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : GPUBlendFactor.One;
				const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : GPUBlendFactor.Zero;
				const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : GPUBlendFactor.Add;

				color = {
					srcFactor: this._getBlendFactor( material.blendSrc ),
					dstFactor: this._getBlendFactor( material.blendDst ),
					operation: this._getBlendOperation( material.blendEquation )
				};

				alpha = {
					srcFactor: this._getBlendFactor( blendSrcAlpha ),
					dstFactor: this._getBlendFactor( blendDstAlpha ),
					operation: this._getBlendOperation( blendEquationAlpha )
				};

			} else {

				const premultipliedAlpha = material.premultipliedAlpha;

				const setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {

					color = {
						srcFactor: srcRGB,
						dstFactor: dstRGB,
						operation: GPUBlendOperation.Add
					};

					alpha = {
						srcFactor: srcAlpha,
						dstFactor: dstAlpha,
						operation: GPUBlendOperation.Add
					};

				};

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
							break;

						case AdditiveBlending:
							setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
							break;

						case SubtractiveBlending:
							setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
							break;

						case MultiplyBlending:
							setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
							break;

						case AdditiveBlending:
							setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );
							break;

						case SubtractiveBlending:
							setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
							break;

						case MultiplyBlending:
							setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );
							break;

					}

				}

			}

			if ( color !== undefined && alpha !== undefined ) {

				return { color, alpha };

			}

		}

		_getBlendFactor( blend ) {

			let blendFactor;

			switch ( blend ) {

				case ZeroFactor:
					blendFactor = GPUBlendFactor.Zero;
					break;

				case OneFactor:
					blendFactor = GPUBlendFactor.One;
					break;

				case SrcColorFactor:
					blendFactor = GPUBlendFactor.Src;
					break;

				case OneMinusSrcColorFactor:
					blendFactor = GPUBlendFactor.OneMinusSrc;
					break;

				case SrcAlphaFactor:
					blendFactor = GPUBlendFactor.SrcAlpha;
					break;

				case OneMinusSrcAlphaFactor:
					blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
					break;

				case DstColorFactor:
					blendFactor = GPUBlendFactor.Dst;
					break;

				case OneMinusDstColorFactor:
					blendFactor = GPUBlendFactor.OneMinusDstColor;
					break;

				case DstAlphaFactor:
					blendFactor = GPUBlendFactor.DstAlpha;
					break;

				case OneMinusDstAlphaFactor:
					blendFactor = GPUBlendFactor.OneMinusDstAlpha;
					break;

				case SrcAlphaSaturateFactor:
					blendFactor = GPUBlendFactor.SrcAlphaSaturated;
					break;

				case BlendColorFactor:
					blendFactor = GPUBlendFactor.Constant;
					break;

				case OneMinusBlendColorFactor:
					blendFactor = GPUBlendFactor.OneMinusConstant;
					break;

			}

			return blendFactor;

		}

		_getStencilCompare( material ) {

			let stencilCompare;

			const stencilFunc = material.stencilFunc;

			switch ( stencilFunc ) {

				case NeverStencilFunc:
					stencilCompare = GPUCompareFunction.Never;
					break;

				case AlwaysStencilFunc:
					stencilCompare = GPUCompareFunction.Always;
					break;

				case LessStencilFunc:
					stencilCompare = GPUCompareFunction.Less;
					break;

				case LessEqualStencilFunc:
					stencilCompare = GPUCompareFunction.LessEqual;
					break;

				case EqualStencilFunc:
					stencilCompare = GPUCompareFunction.Equal;
					break;

				case GreaterEqualStencilFunc:
					stencilCompare = GPUCompareFunction.GreaterEqual;
					break;

				case GreaterStencilFunc:
					stencilCompare = GPUCompareFunction.Greater;
					break;

				case NotEqualStencilFunc:
					stencilCompare = GPUCompareFunction.NotEqual;
					break;

			}

			return stencilCompare;

		}

		_getStencilOperation( op ) {

			let stencilOperation;

			switch ( op ) {

				case KeepStencilOp:
					stencilOperation = GPUStencilOperation.Keep;
					break;

				case ZeroStencilOp:
					stencilOperation = GPUStencilOperation.Zero;
					break;

				case ReplaceStencilOp:
					stencilOperation = GPUStencilOperation.Replace;
					break;

				case InvertStencilOp:
					stencilOperation = GPUStencilOperation.Invert;
					break;

				case IncrementStencilOp:
					stencilOperation = GPUStencilOperation.IncrementClamp;
					break;

				case DecrementStencilOp:
					stencilOperation = GPUStencilOperation.DecrementClamp;
					break;

				case IncrementWrapStencilOp:
					stencilOperation = GPUStencilOperation.IncrementWrap;
					break;

				case DecrementWrapStencilOp:
					stencilOperation = GPUStencilOperation.DecrementWrap;
					break;

			}

			return stencilOperation;

		}

		_getBlendOperation( blendEquation ) {

			let blendOperation;

			switch ( blendEquation ) {

				case AddEquation:
					blendOperation = GPUBlendOperation.Add;
					break;

				case SubtractEquation:
					blendOperation = GPUBlendOperation.Subtract;
					break;

				case ReverseSubtractEquation:
					blendOperation = GPUBlendOperation.ReverseSubtract;
					break;

				case MinEquation:
					blendOperation = GPUBlendOperation.Min;
					break;

				case MaxEquation:
					blendOperation = GPUBlendOperation.Max;
					break;

			}

			return blendOperation;

		}

		_getPrimitiveState( object, geometry, material ) {

			const descriptor = {};
			const utils = this.backend.utils;

			descriptor.topology = utils.getPrimitiveTopology( object, material );

			if ( object.isLine === true && object.isLineSegments !== true ) {

				const count = ( geometry.index ) ? geometry.index.count : geometry.attributes.position.count;
				descriptor.stripIndexFormat = ( count > 65535 ) ? GPUIndexFormat.Uint32 : GPUIndexFormat.Uint16; // define data type for primitive restart value

			}

			switch ( material.side ) {

				case FrontSide:
					descriptor.frontFace = GPUFrontFace.CW;
					descriptor.cullMode = GPUCullMode.Front;
					break;

				case BackSide:
					descriptor.frontFace = GPUFrontFace.CW;
					descriptor.cullMode = GPUCullMode.Back;
					break;

				case DoubleSide:
					descriptor.frontFace = GPUFrontFace.CW;
					descriptor.cullMode = GPUCullMode.None;
					break;

			}

			return descriptor;

		}

		_getColorWriteMask( material ) {

			return ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;

		}

		_getDepthCompare( material ) {

			let depthCompare;

			if ( material.depthTest === false ) {

				depthCompare = GPUCompareFunction.Always;

			} else {

				const depthFunc = material.depthFunc;

				switch ( depthFunc ) {

					case NeverDepth:
						depthCompare = GPUCompareFunction.Never;
						break;

					case AlwaysDepth:
						depthCompare = GPUCompareFunction.Always;
						break;

					case LessDepth:
						depthCompare = GPUCompareFunction.Less;
						break;

					case LessEqualDepth:
						depthCompare = GPUCompareFunction.LessEqual;
						break;

					case EqualDepth:
						depthCompare = GPUCompareFunction.Equal;
						break;

					case GreaterEqualDepth:
						depthCompare = GPUCompareFunction.GreaterEqual;
						break;

					case GreaterDepth:
						depthCompare = GPUCompareFunction.Greater;
						break;

					case NotEqualDepth:
						depthCompare = GPUCompareFunction.NotEqual;
						break;

				}

			}

			return depthCompare;

		}

	}

	class WebGPUTextureMipmapUtils {

		constructor( device ) {

			this.device = device;

			const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;

			const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;

			this.sampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );

			// We'll need a new pipeline for every texture format used.
			this.pipelines = {};

			this.mipmapVertexShaderModule = device.createShaderModule( {
				label: 'mipmapVertex',
				code: mipmapVertexSource
			} );

			this.mipmapFragmentShaderModule = device.createShaderModule( {
				label: 'mipmapFragment',
				code: mipmapFragmentSource
			} );

		}

		getMipmapPipeline( format ) {

			let pipeline = this.pipelines[ format ];

			if ( pipeline === undefined ) {

				pipeline = this.device.createRenderPipeline( {
					vertex: {
						module: this.mipmapVertexShaderModule,
						entryPoint: 'main'
					},
					fragment: {
						module: this.mipmapFragmentShaderModule,
						entryPoint: 'main',
						targets: [ { format } ]
					},
					primitive: {
						topology: GPUPrimitiveTopology.TriangleStrip,
						stripIndexFormat: GPUIndexFormat.Uint32
					},
					layout: 'auto'
				} );

				this.pipelines[ format ] = pipeline;

			}

			return pipeline;

		}

		generateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

			const pipeline = this.getMipmapPipeline( textureGPUDescriptor.format );

			const commandEncoder = this.device.createCommandEncoder( {} );
			const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

			let srcView = textureGPU.createView( {
				baseMipLevel: 0,
				mipLevelCount: 1,
				dimension: GPUTextureViewDimension.TwoD,
				baseArrayLayer
			} );

			for ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {

				const dstView = textureGPU.createView( {
					baseMipLevel: i,
					mipLevelCount: 1,
					dimension: GPUTextureViewDimension.TwoD,
					baseArrayLayer
				} );

				const passEncoder = commandEncoder.beginRenderPass( {
					colorAttachments: [ {
						view: dstView,
						loadOp: GPULoadOp.Clear,
						storeOp: GPUStoreOp.Store,
						clearValue: [ 0, 0, 0, 0 ]
					} ]
				} );

				const bindGroup = this.device.createBindGroup( {
					layout: bindGroupLayout,
					entries: [ {
						binding: 0,
						resource: this.sampler
					}, {
						binding: 1,
						resource: srcView
					} ]
				} );

				passEncoder.setPipeline( pipeline );
				passEncoder.setBindGroup( 0, bindGroup );
				passEncoder.draw( 4, 1, 0, 0 );
				passEncoder.end();

				srcView = dstView;

			}

			this.device.queue.submit( [ commandEncoder.finish() ] );

		}

	}

	const _compareToWebGPU = {
		[ NeverCompare ]: 'never',
		[ LessCompare ]: 'less',
		[ EqualCompare ]: 'equal',
		[ LessEqualCompare ]: 'less-equal',
		[ GreaterCompare ]: 'greater',
		[ GreaterEqualCompare ]: 'greater-equal',
		[ AlwaysCompare ]: 'always',
		[ NotEqualCompare ]: 'not-equal'
	};

	class WebGPUTextureUtils {

		constructor( backend ) {

			this.backend = backend;

			this.mipmapUtils = null;

			this.defaultTexture = null;
			this.defaultCubeTexture = null;

		}

		createSampler( texture ) {

			const backend = this.backend;
			const device = backend.device;

			const textureGPU = backend.get( texture );

			const samplerDescriptorGPU = {
				addressModeU: this._convertAddressMode( texture.wrapS ),
				addressModeV: this._convertAddressMode( texture.wrapT ),
				addressModeW: this._convertAddressMode( texture.wrapR ),
				magFilter: this._convertFilterMode( texture.magFilter ),
				minFilter: this._convertFilterMode( texture.minFilter ),
				mipmapFilter: this._convertFilterMode( texture.minFilter ),
				maxAnisotropy: texture.anisotropy
			};

			if ( texture.isDepthTexture && texture.compareFunction !== null ) {

				samplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];

			}

			textureGPU.sampler = device.createSampler( samplerDescriptorGPU );

		}

		createDefaultTexture( texture ) {

			let textureGPU;

			if ( texture.isCubeTexture ) {

				textureGPU = this._getDefaultCubeTextureGPU();

			} else {

				textureGPU = this._getDefaultTextureGPU();

			}

			this.backend.get( texture ).texture = textureGPU;

		}

		createTexture( texture, options = {} ) {

			const backend = this.backend;
			const textureData = backend.get( texture );

			if ( textureData.initialized ) {

				throw new Error( 'WebGPUTextureUtils: Texture already initialized.' );

			}

			const { width, height, depth } = this._getSize( texture );

			const needsMipmaps = this._needsMipmaps( texture );
			const dimension = this._getDimension( texture );
			const mipLevelCount = this._getMipLevelCount( texture, width, height, needsMipmaps );
			const format = texture.internalFormat || this._getFormat( texture );

			const sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;
			const primarySampleCount = texture.isRenderTargetTexture ? 1 : sampleCount;

			let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;

			if ( texture.isCompressedTexture !== true ) {

				usage |= GPUTextureUsage.RENDER_ATTACHMENT;

			}

			const textureDescriptorGPU = {
				label: texture.name,
				size: {
					width: width,
					height: height,
					depthOrArrayLayers: depth,
				},
				mipLevelCount: mipLevelCount,
				sampleCount: primarySampleCount,
				dimension: dimension,
				format: format,
				usage: usage
			};

			// texture creation

			if ( texture.isVideoTexture ) {

				const video = texture.source.data;
				const videoFrame = new VideoFrame( video );

				textureDescriptorGPU.size.width = videoFrame.displayWidth;
				textureDescriptorGPU.size.height = videoFrame.displayHeight;

				videoFrame.close();

				textureData.externalTexture = video;

			} else {

				if ( format === undefined ) {

					return this.createDefaultTexture( texture );

				}

				textureData.texture = backend.device.createTexture( textureDescriptorGPU );

			}

			if ( texture.isRenderTargetTexture && sampleCount > 1 ) {

				const msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );

				msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
				msaaTextureDescriptorGPU.sampleCount = sampleCount;

				textureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );

			}

			textureData.initialized = true;

			textureData.needsMipmaps = needsMipmaps;
			textureData.textureDescriptorGPU = textureDescriptorGPU;

		}

		destroyTexture( texture ) {

			const backend = this.backend;
			const textureData = backend.get( texture );

			textureData.texture.destroy();

			if ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();

			backend.delete( texture );

		}

		destroySampler( texture ) {

			const backend = this.backend;
			const textureData = backend.get( texture );

			delete textureData.sampler;

		}

		generateMipmaps( texture ) {

			const textureData = this.backend.get( texture );

			if ( texture.isCubeTexture ) {

				for ( let i = 0; i < 6; i ++ ) {

					this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

				}

			} else {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU );

			}

		}

		updateTexture( texture ) {

			const textureData = this.backend.get( texture );

			const { needsMipmaps, textureDescriptorGPU } = textureData;

			if ( textureDescriptorGPU === undefined ) // unsupported texture format
				return;

			// transfer texture data

			if ( texture.isDataTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {

				this._copyBufferToTexture( texture.image, textureData.texture, textureDescriptorGPU, needsMipmaps );

			} else if ( texture.isCompressedTexture ) {

				this._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );

			} else if ( texture.isCubeTexture ) {

				if ( texture.image.length === 6 ) {

					this._copyCubeMapToTexture( texture.image, texture, textureData.texture, textureDescriptorGPU, needsMipmaps );

				}

			} else if ( texture.isRenderTargetTexture ) {

				if ( needsMipmaps === true ) this._generateMipmaps( textureData.texture, textureDescriptorGPU );

			} else if ( texture.isVideoTexture ) {

				const video = texture.source.data;

				textureData.externalTexture = video;

			} else if ( texture.image !== null ) {

				this._copyImageToTexture( texture.image, texture, textureData.texture, textureDescriptorGPU, needsMipmaps );

			} else ;

			//

			textureData.version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		async copyTextureToBuffer( texture, x, y, width, height ) {

			const device = this.backend.device;

			const textureData = this.backend.get( texture );
			const textureGPU = textureData.texture;
			const format = textureData.textureDescriptorGPU.format;
			const bytesPerTexel = this._getBytesPerTexel( format );

			const readBuffer = device.createBuffer(
				{
					size: width * height * bytesPerTexel,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				}
			);

			const encoder = device.createCommandEncoder();

			encoder.copyTextureToBuffer(
				{
					texture: textureGPU,
					origin: { x, y },
				},
				{
					buffer: readBuffer,
					bytesPerRow: width * bytesPerTexel
				},
				{
					width: width,
					height: height
				}

			);

			const typedArrayType = this._getTypedArrayType( format );

			device.queue.submit( [ encoder.finish() ] );

			await readBuffer.mapAsync( GPUMapMode.READ );

			const buffer = readBuffer.getMappedRange();

			return new typedArrayType( buffer );

		}

		_isEnvironmentTexture( texture ) {

			const mapping = texture.mapping;

			return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

		}

		_getDefaultTextureGPU() {

			let defaultTexture = this.defaultTexture;

			if ( defaultTexture === null ) {

				const texture = new Texture();
				texture.minFilter = NearestFilter;
				texture.magFilter = NearestFilter;

				this.createTexture( texture );

				this.defaultTexture = defaultTexture = texture;

			}

			return this.backend.get( defaultTexture ).texture;

		}

		_getDefaultCubeTextureGPU() {

			let defaultCubeTexture = this.defaultTexture;

			if ( defaultCubeTexture === null ) {

				const texture = new CubeTexture();
				texture.minFilter = NearestFilter;
				texture.magFilter = NearestFilter;

				this.createTexture( texture );

				this.defaultCubeTexture = defaultCubeTexture = texture;

			}

			return this.backend.get( defaultCubeTexture ).texture;

		}

		_copyImageToTexture( image, texture, textureGPU, textureDescriptorGPU, needsMipmaps, originDepth ) {

			if ( this._isHTMLImage( image ) ) {

				this._getImageBitmapFromHTML( image, texture ).then( imageBitmap => {

					this._copyExternalImageToTexture( imageBitmap, textureGPU, textureDescriptorGPU, needsMipmaps, originDepth );

				} );

			} else {

				// assume ImageBitmap

				this._copyExternalImageToTexture( image, textureGPU, textureDescriptorGPU, needsMipmaps, originDepth );

			}

		}

		_isHTMLImage( image ) {

			return ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) || ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement );

		}

		_copyCubeMapToTexture( images, texture, textureGPU, textureDescriptorGPU, needsMipmaps ) {

			for ( let i = 0; i < 6; i ++ ) {

				const image = images[ i ];

				if ( image.isDataTexture ) {

					this._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, needsMipmaps, i );

				} else {

					this._copyImageToTexture( image, texture, textureGPU, textureDescriptorGPU, needsMipmaps, i );

				}

			}

		}

		_copyExternalImageToTexture( image, textureGPU, textureDescriptorGPU, needsMipmaps, originDepth = 0 ) {

			const device = this.backend.device;

			device.queue.copyExternalImageToTexture(
				{
					source: image
				}, {
					texture: textureGPU,
					mipLevel: 0,
					origin: { x: 0, y: 0, z: originDepth }
				}, {
					width: image.width,
					height: image.height,
					depthOrArrayLayers: 1
				}
			);

			if ( needsMipmaps ) this._generateMipmaps( textureGPU, textureDescriptorGPU, originDepth );

		}

		_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {

			if ( this.mipmapUtils === null ) {

				this.mipmapUtils = new WebGPUTextureMipmapUtils( this.backend.device );

			}

			this.mipmapUtils.generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );

		}

		_getImageBitmapFromHTML( image, texture ) {

			const width = image.width;
			const height = image.height;

			const options = {};

			options.imageOrientation = ( texture.flipY === true ) ? 'flipY' : 'none';
			options.premultiplyAlpha = ( texture.premultiplyAlpha === true ) ? 'premultiply' : 'default';

			return createImageBitmap( image, 0, 0, width, height, options );

		}

		_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, needsMipmaps, originDepth = 0 ) {

			// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
			// @TODO: Consider to support valid buffer layouts with other formats like RGB

			const device = this.backend.device;

			const data = image.data;

			const bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );
			const bytesPerRow = image.width * bytesPerTexel;

			device.queue.writeTexture(
				{
					texture: textureGPU,
					mipLevel: 0,
					origin: { x: 0, y: 0, z: originDepth }
				},
				data,
				{
					offset: 0,
					bytesPerRow
				},
				{
					width: image.width,
					height: image.height,
					depthOrArrayLayers: ( image.depth !== undefined ) ? image.depth : 1
				} );

			if ( needsMipmaps === true ) this._generateMipmaps( textureGPU, textureDescriptorGPU, originDepth );

		}

		_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {

			// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

			const device = this.backend.device;

			const blockData = this._getBlockData( textureDescriptorGPU.format );

			for ( let i = 0; i < mipmaps.length; i ++ ) {

				const mipmap = mipmaps[ i ];

				const width = mipmap.width;
				const height = mipmap.height;

				const bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;

				device.queue.writeTexture(
					{
						texture: textureGPU,
						mipLevel: i
					},
					mipmap.data,
					{
						offset: 0,
						bytesPerRow
					},
					{
						width: Math.ceil( width / blockData.width ) * blockData.width,
						height: Math.ceil( height / blockData.width ) * blockData.width,
						depthOrArrayLayers: 1
					}
				);

			}

		}

		_getBlockData( format ) {

			// this method is only relevant for compressed texture formats

			if ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1
			if ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3
			if ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5
			if ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
			if ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
			if ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
			if ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)

			if ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
			if ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
			if ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
			if ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };
			if ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };
			if ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };
			if ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };

			if ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
			if ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };
			if ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };
			if ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };
			if ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };
			if ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };
			if ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };
			if ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };
			if ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };
			if ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };
			if ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };
			if ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };
			if ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };
			if ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };

		}

		_convertAddressMode( value ) {

			let addressMode = GPUAddressMode.ClampToEdge;

			if ( value === RepeatWrapping ) {

				addressMode = GPUAddressMode.Repeat;

			} else if ( value === MirroredRepeatWrapping ) {

				addressMode = GPUAddressMode.MirrorRepeat;

			}

			return addressMode;

		}

		_convertFilterMode( value ) {

			let filterMode = GPUFilterMode.Linear;

			if ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {

				filterMode = GPUFilterMode.Nearest;

			}

			return filterMode;

		}

		_getSize( texture ) {

			const image = texture.image;

			let width, height, depth;

			if ( texture.isCubeTexture ) {

				const faceImage = image.length > 0 ? image[ 0 ].image || image[ 0 ] : null;

				width = faceImage ? faceImage.width : 1;
				height = faceImage ? faceImage.height : 1;
				depth = 6; // one image for each side of the cube map

			} else if ( image !== null ) {

				width = image.width;
				height = image.height;
				depth = ( image.depth !== undefined ) ? image.depth : 1;

			} else {

				width = height = depth = 1;

			}

			return { width, height, depth };

		}

		_needsMipmaps( texture ) {

			if ( this._isEnvironmentTexture( texture ) ) return true;

			return ( texture.isCompressedTexture !== true ) /*&& ( texture.generateMipmaps === true )*/ && ( texture.minFilter !== NearestFilter ) && ( texture.minFilter !== LinearFilter );

		}

		_getBytesPerTexel( format ) {

			if ( format === GPUTextureFormat.R8Unorm ) return 1;
			if ( format === GPUTextureFormat.R16Float ) return 2;
			if ( format === GPUTextureFormat.RG8Unorm ) return 2;
			if ( format === GPUTextureFormat.RG16Float ) return 4;
			if ( format === GPUTextureFormat.R32Float ) return 4;
			if ( format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB ) return 4;
			if ( format === GPUTextureFormat.RG32Float ) return 8;
			if ( format === GPUTextureFormat.RGBA16Float ) return 8;
			if ( format === GPUTextureFormat.RGBA32Float ) return 16;

		}

		_getTypedArrayType( format ) {

			if ( format === GPUTextureFormat.R8Uint ) return Uint8Array;
			if ( format === GPUTextureFormat.R8Sint ) return Int8Array;
			if ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;
			if ( format === GPUTextureFormat.R8Snorm ) return Int8Array;
			if ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;
			if ( format === GPUTextureFormat.RG8Sint ) return Int8Array;
			if ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;
			if ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;
			if ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;
			if ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;
			if ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;
			if ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;


			if ( format === GPUTextureFormat.R16Uint ) return Uint16Array;
			if ( format === GPUTextureFormat.R16Sint ) return Int16Array;
			if ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;
			if ( format === GPUTextureFormat.RG16Sint ) return Int16Array;
			if ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;
			if ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;


			if ( format === GPUTextureFormat.R32Uint ) return Uint32Array;
			if ( format === GPUTextureFormat.R32Sint ) return Int32Array;
			if ( format === GPUTextureFormat.R32Float ) return Float32Array;
			if ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;
			if ( format === GPUTextureFormat.RG32Sint ) return Int32Array;
			if ( format === GPUTextureFormat.RG32Float ) return Float32Array;
			if ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;
			if ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;
			if ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;

		}

		_getDimension( texture ) {

			let dimension;

			if ( texture.isData3DTexture ) {

				dimension = GPUTextureDimension.ThreeD;

			} else {

				dimension = GPUTextureDimension.TwoD;

			}

			return dimension;

		}

		_getMipLevelCount( texture, width, height, needsMipmaps ) {

			let mipLevelCount;

			if ( texture.isCompressedTexture ) {

				mipLevelCount = texture.mipmaps.length;

			} else if ( needsMipmaps ) {

				mipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;

			} else {

				mipLevelCount = 1; // a texture without mipmaps has a base mip (mipLevel 0)

			}

			return mipLevelCount;

		}

		_getFormat( texture ) {

			const format = texture.format;
			const type = texture.type;
			const colorSpace = texture.colorSpace;

			let formatGPU;

			if ( /*texture.isRenderTargetTexture === true ||*/ texture.isFramebufferTexture === true ) {

				formatGPU = GPUTextureFormat.BGRA8Unorm;

			} else if ( texture.isCompressedTexture === true ) {

				switch ( format ) {

					case RGBA_S3TC_DXT1_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
						break;

					case RGBA_S3TC_DXT3_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
						break;

					case RGBA_S3TC_DXT5_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
						break;

					case RGB_ETC2_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
						break;

					case RGBA_ETC2_EAC_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
						break;

					case RGBA_ASTC_4x4_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
						break;

					case RGBA_ASTC_5x4_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
						break;

					case RGBA_ASTC_5x5_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
						break;

					case RGBA_ASTC_6x5_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
						break;

					case RGBA_ASTC_6x6_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
						break;

					case RGBA_ASTC_8x5_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
						break;

					case RGBA_ASTC_8x6_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
						break;

					case RGBA_ASTC_8x8_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
						break;

					case RGBA_ASTC_10x5_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
						break;

					case RGBA_ASTC_10x6_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
						break;

					case RGBA_ASTC_10x8_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
						break;

					case RGBA_ASTC_10x10_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
						break;

					case RGBA_ASTC_12x10_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
						break;

					case RGBA_ASTC_12x12_Format:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
						break;

				}

			} else {

				switch ( format ) {

					case RGBAFormat:

						switch ( type ) {

							case UnsignedByteType:
								formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
								break;

							case HalfFloatType:
								formatGPU = GPUTextureFormat.RGBA16Float;
								break;

							case FloatType:
								formatGPU = GPUTextureFormat.RGBA32Float;
								break;

						}

						break;

					case RedFormat:

						switch ( type ) {

							case UnsignedByteType:
								formatGPU = GPUTextureFormat.R8Unorm;
								break;

							case HalfFloatType:
								formatGPU = GPUTextureFormat.R16Float;
								break;

							case FloatType:
								formatGPU = GPUTextureFormat.R32Float;
								break;

						}

						break;

					case RGFormat:

						switch ( type ) {

							case UnsignedByteType:
								formatGPU = GPUTextureFormat.RG8Unorm;
								break;

							case HalfFloatType:
								formatGPU = GPUTextureFormat.RG16Float;
								break;

							case FloatType:
								formatGPU = GPUTextureFormat.RG32Float;
								break;

						}

						break;

					case DepthFormat:

						switch ( type ) {

							case UnsignedShortType:
								formatGPU = GPUTextureFormat.Depth16Unorm;
								break;

							case UnsignedIntType:
								formatGPU = GPUTextureFormat.Depth24Plus;
								break;

							case FloatType:
								formatGPU = GPUTextureFormat.Depth32Float;
								break;

						}

						break;

					case DepthStencilFormat:

						switch ( type ) {

							case UnsignedInt248Type:
								formatGPU = GPUTextureFormat.Depth24PlusStencil8;
								break;

							case FloatType:

								if ( this.device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) ;

								formatGPU = GPUTextureFormat.Depth32FloatStencil8;

								break;

						}

						break;

				}

			}

			return formatGPU;

		}

	}

	/*// debugger tools
	import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
	//*/

	// statics
	/*
	let _staticAdapter = null;

	if ( navigator.gpu !== undefined ) {

		_staticAdapter = await navigator.gpu.requestAdapter();

	}*/

	let _deferFeatures = [];


	//

	class WebGPUBackend extends Backend {

		constructor( parameters = {} ) {

			super( parameters );

			// some parameters require default values other than "undefined"

			this.parameters.antialias = ( parameters.antialias === true );

			if ( this.parameters.antialias === true ) {

				this.parameters.sampleCount = ( parameters.sampleCount === undefined ) ? 4 : parameters.sampleCount;

			} else {

				this.parameters.sampleCount = 1;

			}

			this.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;

			this.adapter = null;
			this.device = null;
			this.context = null;
			this.colorBuffer = null;

			this.defaultDepthTexture = new DepthTexture();
			this.defaultDepthTexture.name = 'depthBuffer';

			this.utils = new WebGPUUtils( this );
			this.attributeUtils = new WebGPUAttributeUtils( this );
			this.bindingUtils = new WebGPUBindingUtils( this );
			this.pipelineUtils = new WebGPUPipelineUtils( this );
			this.textureUtils = new WebGPUTextureUtils( this );

		}

		async init( renderer ) {

			await super.init( renderer );

			//

			const parameters = this.parameters;

			const adapterOptions = {
				powerPreference: parameters.powerPreference
			};

			const adapter = await navigator.gpu.requestAdapter( adapterOptions );

			if ( adapter === null ) {

				throw new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );

			}

			// feature support

			const features = Object.values( GPUFeatureName );

			const supportedFeatures = [];

			for ( const name of features ) {

				if ( adapter.features.has( name ) ) {

					supportedFeatures.push( name );

				}

			}

			const deviceDescriptor = {
				requiredFeatures: supportedFeatures,
				requiredLimits: parameters.requiredLimits
			};

			const device = await adapter.requestDevice( deviceDescriptor );

			const context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );

			this.adapter = adapter;
			this.device = device;
			this.context = context;

			//resolve deferred adapter features
			//https://github.com/mrdoob/three.js/pull/26242
			if (_deferFeatures.length) {	
				_deferFeatures.forEach(resolve => resolve());
				_deferFeatures = [];
			}


			this.updateSize();

		}

		get coordinateSystem() {

			return WebGPUCoordinateSystem;

		}

		async getArrayBufferAsync( attribute ) {

			return await this.attributeUtils.getArrayBufferAsync( attribute );

		}

		beginRender( renderContext ) {

			const renderContextData = this.get( renderContext );

			const device = this.device;

			const descriptor = {
				colorAttachments: [ {
					view: null
				} ],
				depthStencilAttachment: {
					view: null
				}
			};

			const colorAttachment = descriptor.colorAttachments[ 0 ];
			const depthStencilAttachment = descriptor.depthStencilAttachment;

			const antialias = this.parameters.antialias;

			if ( renderContext.texture !== null ) {

				const textureData = this.get( renderContext.texture );
				const depthTextureData = this.get( renderContext.depthTexture );

				const view = textureData.texture.createView( {
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: renderContext.activeCubeFace,
					dimension: GPUTextureViewDimension.TwoD
				} );

				if ( textureData.msaaTexture !== undefined ) {

					colorAttachment.view = textureData.msaaTexture.createView();
					colorAttachment.resolveTarget = view;

				} else {

					colorAttachment.view = view;
					colorAttachment.resolveTarget = undefined;

				}

				depthStencilAttachment.view = depthTextureData.texture.createView();

				if ( renderContext.stencil && renderContext.depthTexture.format === DepthFormat ) {

					renderContext.stencil = false;

				}

			} else {

				if ( antialias === true ) {

					colorAttachment.view = this.colorBuffer.createView();
					colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

				} else {

					colorAttachment.view = this.context.getCurrentTexture().createView();
					colorAttachment.resolveTarget = undefined;

				}

				depthStencilAttachment.view = this._getDepthBufferGPU( renderContext ).createView();

			}

			if ( renderContext.clearColor ) {

				colorAttachment.clearValue = renderContext.clearColorValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			} else {

				colorAttachment.loadOp = GPULoadOp.Load;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

			//

			if ( renderContext.depth ) {

				if ( renderContext.clearDepth ) {

					depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
					depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
					depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

				} else {

					depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
					depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

				}

			}

			if ( renderContext.stencil ) {

				if ( renderContext.clearStencil ) {

					depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
					depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
					depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

				} else {

					depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
					depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

				}

			}

			//

			const encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );
			const currentPass = encoder.beginRenderPass( descriptor );

			//

			renderContextData.descriptor = descriptor;
			renderContextData.encoder = encoder;
			renderContextData.currentPass = currentPass;
			renderContextData.currentAttributesSet = {};

			//

			if ( renderContext.viewport ) {

				this.updateViewport( renderContext );

			}

			if ( renderContext.scissor ) {

				const { x, y, width, height } = renderContext.scissorValue;

				currentPass.setScissorRect( x, y, width, height );

			}

		}

		finishRender( renderContext ) {

			const renderContextData = this.get( renderContext );

			renderContextData.currentPass.end();

			this.device.queue.submit( [ renderContextData.encoder.finish() ] );

			//

			if ( renderContext.texture !== null && renderContext.texture.generateMipmaps === true ) {

				this.textureUtils.generateMipmaps( renderContext.texture );

			}

		}

		updateViewport( renderContext ) {

			const { currentPass } = this.get( renderContext );
			const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;

			currentPass.setViewport( x, y, width, height, minDepth, maxDepth );

		}

		clear( renderContext, color, depth, stencil ) {

			const device = this.device;
			const renderContextData = this.get( renderContext );

			const { descriptor } = renderContextData;

			depth = depth && renderContext.depth;
			stencil = stencil && renderContext.stencil;

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			const antialias = this.parameters.antialias;

			// @TODO: Include render target in clear operation.
			if ( antialias === true ) {

				colorAttachment.view = this.colorBuffer.createView();
				colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

			} else {

				colorAttachment.view = this.context.getCurrentTexture().createView();
				colorAttachment.resolveTarget = undefined;

			}

			descriptor.depthStencilAttachment.view = this._getDepthBufferGPU( renderContext ).createView();

			if ( color ) {

				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.clearValue = renderContext.clearColorValue;

			}

			if ( depth ) {

				descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				descriptor.depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;

			}

			if ( stencil ) {

				descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				descriptor.depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;

			}

			renderContextData.encoder = device.createCommandEncoder( {} );
			renderContextData.currentPass = renderContextData.encoder.beginRenderPass( descriptor );

			renderContextData.currentPass.end();

			device.queue.submit( [ renderContextData.encoder.finish() ] );

		}

		// compute

		beginCompute( computeGroup ) {

			const groupGPU = this.get( computeGroup );

			groupGPU.cmdEncoderGPU = this.device.createCommandEncoder( {} );
			groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass();

		}

		compute( computeGroup, computeNode, bindings, pipeline ) {

			const { passEncoderGPU } = this.get( computeGroup );

			// pipeline

			const pipelineGPU = this.get( pipeline ).pipeline;
			passEncoderGPU.setPipeline( pipelineGPU );

			// bind group

			const bindGroupGPU = this.get( bindings ).group;
			passEncoderGPU.setBindGroup( 0, bindGroupGPU );

			passEncoderGPU.dispatchWorkgroups( computeNode.dispatchCount );

		}

		finishCompute( computeGroup ) {

			const groupData = this.get( computeGroup );

			groupData.passEncoderGPU.end();
			this.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );

		}

		// render object

		draw( renderObject, info ) {

			const { object, geometry, context, pipeline } = renderObject;

			const bindingsData = this.get( renderObject.getBindings() );
			const contextData = this.get( context );
			const pipelineGPU = this.get( pipeline ).pipeline;
			const attributesSet = contextData.currentAttributesSet;

			// pipeline

			const passEncoderGPU = contextData.currentPass;
			passEncoderGPU.setPipeline( pipelineGPU );

			// bind group

			const bindGroupGPU = bindingsData.group;
			passEncoderGPU.setBindGroup( 0, bindGroupGPU );

			// attributes

			const index = renderObject.getIndex();

			const hasIndex = ( index !== null );

			// index

			if ( hasIndex === true ) {

				if ( attributesSet.index !== index ) {
				
					const buffer = this.get( index ).buffer;
					const indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

					passEncoderGPU.setIndexBuffer( buffer, indexFormat );

					attributesSet.index = index;

				}

			}

			// vertex buffers

			const vertexBuffers = renderObject.getVertexBuffers();

			for ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {

				const vertexBuffer = vertexBuffers[ i ];

				if ( attributesSet[ i ] !== vertexBuffer ) {

					const buffer = this.get( vertexBuffer ).buffer;
					passEncoderGPU.setVertexBuffer( i, buffer );

					attributesSet[ i ] = vertexBuffer;

				}

			}

			// draw

			const drawRange = geometry.drawRange;
			const firstVertex = drawRange.start;

			const instanceCount = this.getInstanceCount( renderObject );

			if ( hasIndex === true ) {

				const indexCount = ( drawRange.count !== Infinity ) ? drawRange.count : index.count;

				passEncoderGPU.drawIndexed( indexCount, instanceCount, firstVertex, 0, 0 );

				info.update( object, indexCount, instanceCount );

			} else {

				const positionAttribute = geometry.attributes.position;
				const vertexCount = ( drawRange.count !== Infinity ) ? drawRange.count : positionAttribute.count;

				passEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );

				info.update( object, vertexCount, instanceCount );

			}

		}

		// cache key

		needsUpdate( renderObject ) {

			const renderObjectGPU = this.get( renderObject );

			const { object, material } = renderObject;

			const utils = this.utils;

			const sampleCount = utils.getSampleCount( renderObject.context );
			const colorSpace = utils.getCurrentColorSpace( renderObject.context );
			const colorFormat = utils.getCurrentColorFormat( renderObject.context );
			const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
			const primitiveTopology = utils.getPrimitiveTopology( object, material );

			let needsUpdate = false;

			if ( renderObjectGPU.sampleCount !== sampleCount || renderObjectGPU.colorSpace !== colorSpace ||
				renderObjectGPU.colorFormat !== colorFormat || renderObjectGPU.depthStencilFormat !== depthStencilFormat ||
	            renderObjectGPU.primitiveTopology !== primitiveTopology ) {

				renderObjectGPU.sampleCount = sampleCount;
				renderObjectGPU.colorSpace = colorSpace;
				renderObjectGPU.colorFormat = colorFormat;
				renderObjectGPU.depthStencilFormat = depthStencilFormat;
				renderObjectGPU.primitiveTopology = primitiveTopology;

				needsUpdate = true;

			}

			return needsUpdate;

		}

		getCacheKey( renderObject ) {

			const { object, material } = renderObject;

			const utils = this.utils;
			const renderContext = renderObject.context;

			return [
				utils.getSampleCount( renderContext ),
				utils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),
				utils.getPrimitiveTopology( object, material )
			].join();

		}

		// textures

		createSampler( texture ) {

			this.textureUtils.createSampler( texture );

		}

		destroySampler( texture ) {

			this.textureUtils.destroySampler( texture );

		}

		createDefaultTexture( texture ) {

			this.textureUtils.createDefaultTexture( texture );

		}

		createTexture( texture, options ) {

			this.textureUtils.createTexture( texture, options );

		}

		updateTexture( texture ) {

			this.textureUtils.updateTexture( texture );

		}

		destroyTexture( texture ) {

			this.textureUtils.destroyTexture( texture );

		}

		copyTextureToBuffer( texture, x, y, width, height ) {

			return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height );

		}

		// node builder

		createNodeBuilder( object, renderer, scene = null ) {

			return new WGSLNodeBuilder( object, renderer, scene );

		}

		// program

		createProgram( program ) {

			const programGPU = this.get( program );

			programGPU.module = {
				module: this.device.createShaderModule( { code: program.code, label: program.stage } ),
				entryPoint: 'main'
			};

		}

		destroyProgram( program ) {

			this.delete( program );

		}

		// pipelines

		createRenderPipeline( renderObject ) {

			this.pipelineUtils.createRenderPipeline( renderObject );

		}

		createComputePipeline( computePipeline, bindings ) {

			this.pipelineUtils.createComputePipeline( computePipeline, bindings );

		}

		// bindings

		createBindings( bindings ) {

			this.bindingUtils.createBindings( bindings );

		}

		updateBindings( bindings ) {

			this.bindingUtils.createBindings( bindings );

		}

		updateBinding( binding ) {

			this.bindingUtils.updateBinding( binding );

		}

		// attributes

		createIndexAttribute( attribute ) {

			this.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

		}

		createAttribute( attribute ) {

			this.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

		}

		createStorageAttribute( attribute ) {

			this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

		}

		updateAttribute( attribute ) {

			this.attributeUtils.updateAttribute( attribute );

		}

		destroyAttribute( attribute ) {

			this.attributeUtils.destroyAttribute( attribute );

		}

		// canvas

		updateSize() {

			this._configureContext();
			this._setupColorBuffer();

		}

		// utils public

		hasFeature( name ) {
			return new Promise((resolve, reject) => {
				
				if (this.adapter) {
					
					resolve(this.adapter.features.has( name ));
				} else {
					_deferFeatures.push(() => resolve(this.hasFeature(name)));
				}
			});
		}

		copyFramebufferToTexture( texture, renderContext ) {

			const renderContextData = this.get( renderContext );

			const { encoder, descriptor } = renderContextData;

			let sourceGPU = null;

			if ( texture.isFramebufferTexture ) {

				sourceGPU = this.context.getCurrentTexture();

			} else if ( texture.isDepthTexture ) {

				sourceGPU = this._getDepthBufferGPU( renderContext );

			}

			const destinationGPU = this.get( texture ).texture;

			renderContextData.currentPass.end();

			encoder.copyTextureToTexture(
				{
					texture: sourceGPU,
					origin: { x: 0, y: 0, z: 0 }
				},
				{
					texture: destinationGPU
				},
				[
					texture.image.width,
					texture.image.height
				]
			);

			if ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );

			descriptor.colorAttachments[ 0 ].loadOp = GPULoadOp.Load;
			if ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			if ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

			renderContextData.currentPass = encoder.beginRenderPass( descriptor );
			renderContextData.currentAttributesSet = {};

		}

		// utils

		_getDepthBufferGPU( renderContext ) {

			const { width, height } = this.getDrawingBufferSize();

			const depthTexture = this.defaultDepthTexture;
			const depthTextureGPU = this.get( depthTexture ).texture;

			let format, type;

			if ( renderContext.stencil ) {

				format = DepthStencilFormat;
				type = UnsignedInt248Type;

			} else if ( renderContext.depth ) {

				format = DepthFormat;
				type = UnsignedIntType;

			}

			if ( depthTextureGPU !== undefined ) {

				if ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {

					return depthTextureGPU;

				}

				this.textureUtils.destroyTexture( depthTexture );

			}

			depthTexture.name = 'depthBuffer';
			depthTexture.format = format;
			depthTexture.type = type;
			depthTexture.image.width = width;
			depthTexture.image.height = height;

			this.textureUtils.createTexture( depthTexture, { sampleCount: this.parameters.sampleCount } );

			return this.get( depthTexture ).texture;

		}

		_configureContext() {

			this.context.configure( {
				device: this.device,
				format: GPUTextureFormat.BGRA8Unorm,
				usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
				alphaMode: 'premultiplied'
			} );

		}

		_setupColorBuffer() {

			if ( this.colorBuffer ) this.colorBuffer.destroy();

			const { width, height } = this.getDrawingBufferSize();
			//const format = navigator.gpu.getPreferredCanvasFormat(); // @TODO: Move to WebGPUUtils

			this.colorBuffer = this.device.createTexture( {
				label: 'colorBuffer',
				size: {
					width: width,
					height: height,
					depthOrArrayLayers: 1
				},
				sampleCount: this.parameters.sampleCount,
				format: GPUTextureFormat.BGRA8Unorm,
				usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
			} );

		}

	}

	/*
	const debugHandler = {

		get: function ( target, name ) {

			// Add |update
			if ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );

			return target[ name ];

		}

	};
	*/
	class WebGPURenderer extends Renderer {

		constructor( parameters = {} ) {

			const backend = new WebGPUBackend( parameters );
			//const backend = new Proxy( new WebGPUBackend( parameters ), debugHandler );

			super( backend );

			this.isWebGPURenderer = true;

		}

	}

	/**
	 * @license
	 * Copyright 2010-2023 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */

	class LinearSRGBMaterial extends MeshBasicMaterial {

	    constructor(parameters) {
	        super(parameters);

	        //set texture colorSpace to linear for SRGB performance fix
	        if (this.map) this.map.colorSpace = LinearSRGBColorSpace;
	    }

	    onBeforeCompile(shader) {
	        //fix shader for SRGB performance fix
	        shader.fragmentShader = shader.fragmentShader.replace(
	            '#include <map_fragment>',
	            `
            #ifdef USE_MAP
            
                vec4 sampledDiffuseColor = texture2D( map, vMapUv );
            
                // inline sRGB decode
                sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.a );

                diffuseColor *= sampledDiffuseColor;

            #endif

                            `
	        );

	    }
	}

	/*
	 * Built-in easing functions for use in Troika animations. Any of the easings defined here
	 * may be referred to within Tweens by their exported symbol name, or by reference.
	 * 
	 * The implementations here are roughly based on the logic from the jQuery Easing plugin
	 * (original license blocks are maintained below for completeness), but they have been
	 * significantly rewritten to use a single 0-1 time argument signature, converted to ES2015
	 * syntax, and otherwise modified for succinctness or performance.
	 */

	const {pow, PI, sqrt} = Math;
	const HALF_PI = PI / 2;
	const TWO_PI = PI * 2;


	// factories for common easing function patterns
	function makeInOut(inFn, outFn) {
	  return t => t < 0.5 ? inFn(t * 2) * 0.5 : outFn(t * 2 - 1) * 0.5 + 0.5
	}
	function makeExpIn(exp) {
	  return t => pow(t, exp)
	}
	function makeExpOut(exp) {
	  return t => 1 - pow(1 - t, exp)
	}
	function makeExpInOut(exp) {
	  return t => t < 0.5 ?
	    pow(t * 2, exp) * 0.5 :
	    (1 - pow(1 - (t * 2 - 1), exp)) * 0.5 + 0.5
	}


	const linear$1 = t => t;

	const easeInQuad = makeExpIn(2);
	const easeOutQuad = makeExpOut(2);
	const easeInOutQuad = makeExpInOut(2);

	const easeInCubic = makeExpIn(3);
	const easeOutCubic = makeExpOut(3);
	const easeInOutCubic = makeExpInOut(3);

	const easeInQuart = makeExpIn(4);
	const easeOutQuart = makeExpOut(4);
	const easeInOutQuart = makeExpInOut(4);

	const easeInQuint = makeExpIn(5);
	const easeOutQuint = makeExpOut(5);
	const easeInOutQuint = makeExpInOut(5);

	const easeInSine = t => 1 - Math.cos(t * (HALF_PI));
	const easeOutSine = t => Math.sin(t * (HALF_PI));
	const easeInOutSine = t => -0.5 * (Math.cos(PI * t) - 1);

	const easeInExpo = t =>
	  (t === 0) ? 0 : pow(2, 10 * (t - 1));

	const easeOutExpo = t =>
	  (t === 1) ? 1 : 1 - pow(2, -10 * t);

	const easeInOutExpo = t =>
	  (t === 0 || t === 1) ? t :
	  t < 0.5 ?
	    pow(2, 10 * (t * 2 - 1)) * 0.5 :
	    (1 - pow(2, -10 * (t * 2 - 1))) * 0.5 + 0.5;

	const easeInCirc = t =>
	  1 - sqrt(1 - t * t);

	const easeOutCirc = t =>
	  sqrt(1 - pow(t - 1, 2));

	const easeInOutCirc = makeInOut(easeInCirc, easeOutCirc);

	const easeInElastic = t =>
	  (t === 0 || t === 1) ? t : 1 - easeOutElastic(1 - t);

	const easeOutElastic = t =>
	  (t === 0 || t === 1) ? t :
	    Math.pow(2, -10 * t) * Math.sin((t - 0.075) * TWO_PI / 0.3) + 1;

	const easeInOutElastic = makeInOut(easeInElastic, easeOutElastic);

	const easeInBack = t =>
	  t * t * (2.70158 * t - 1.70158);

	const easeOutBack = t =>
	  (t -= 1) * t * (2.70158 * t + 1.70158) + 1;

	const easeInOutBack = t => {
	  const s = 1.70158 * 1.525;
	  return (t *= 2) < 1 ? 
	    0.5 * (t * t * ((s + 1) * t - s)) : 
	    0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2)
	};

	const easeInBounce = t => 
	  1 - easeOutBounce(1 - t);

	const easeOutBounce = t => 
	  t < (1 / 2.75) ? 
	    (7.5625 * t * t) :
	  t < (2 / 2.75) ? 
	    (7.5625 * (t -= (1.5 / 2.75)) * t + .75) :
	  t < (2.5 / 2.75) ? 
	    (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) :
	    (7.5625 * (t -= (2.625 / 2.75)) * t + .984375);

	const easeInOutBounce = makeInOut(easeInBounce, easeOutBounce);

	// Aliases...?
	// export {
	//   easeInBack as swingFrom,
	//   easeOutBack as swingTo,
	//   easeInOutBack as swingFromTo,
	//   easeOutBounce as bounce,
	//   easeFrom
	// }





	// ===== License blocks from originating works: =====

	/*
	 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
	 *
	 * Uses the built in easing capabilities added In jQuery 1.1
	 * to offer multiple easing options
	 *
	 * TERMS OF USE - jQuery Easing
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright Â© 2008 George McGinley Smith
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice, this list of
	 * conditions and the following disclaimer.
	 * Redistributions in binary form must reproduce the above copyright notice, this list
	 * of conditions and the following disclaimer in the documentation and/or other materials
	 * provided with the distribution.
	 *
	 * Neither the name of the author nor the names of contributors may be used to endorse
	 * or promote products derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
	 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	*/

	/*
	 *
	 * TERMS OF USE - EASING EQUATIONS
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright Â© 2001 Robert Penner
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice, this list of
	 * conditions and the following disclaimer.
	 * Redistributions in binary form must reproduce the above copyright notice, this list
	 * of conditions and the following disclaimer in the documentation and/or other materials
	 * provided with the distribution.
	 *
	 * Neither the name of the author nor the names of contributors may be used to endorse
	 * or promote products derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
	 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */

	var Easings = /*#__PURE__*/Object.freeze({
		__proto__: null,
		linear: linear$1,
		easeInQuad: easeInQuad,
		easeOutQuad: easeOutQuad,
		easeInOutQuad: easeInOutQuad,
		easeInCubic: easeInCubic,
		easeOutCubic: easeOutCubic,
		easeInOutCubic: easeInOutCubic,
		easeInQuart: easeInQuart,
		easeOutQuart: easeOutQuart,
		easeInOutQuart: easeInOutQuart,
		easeInQuint: easeInQuint,
		easeOutQuint: easeOutQuint,
		easeInOutQuint: easeInOutQuint,
		easeInSine: easeInSine,
		easeOutSine: easeOutSine,
		easeInOutSine: easeInOutSine,
		easeInExpo: easeInExpo,
		easeOutExpo: easeOutExpo,
		easeInOutExpo: easeInOutExpo,
		easeInCirc: easeInCirc,
		easeOutCirc: easeOutCirc,
		easeInOutCirc: easeInOutCirc,
		easeInElastic: easeInElastic,
		easeOutElastic: easeOutElastic,
		easeInOutElastic: easeInOutElastic,
		easeInBack: easeInBack,
		easeOutBack: easeOutBack,
		easeInOutBack: easeInOutBack,
		easeInBounce: easeInBounce,
		easeOutBounce: easeOutBounce,
		easeInOutBounce: easeInOutBounce
	});

	/**
	 * Simple numeric interpolator function
	 */
	function number(fromValue, toValue, progress) {
	  return fromValue + (toValue - fromValue) * progress
	}

	/**
	 * Interpolator for color values; decomposes the color into r/g/b channels and does
	 * numeric interpolation on each individually. The result is a 24-bit integer value
	 * holding the r/g/b channels in its 3 bytes.
	 */
	function color(fromValue, toValue, progress) {
	  fromValue = colorValueToNumber(fromValue);
	  toValue = colorValueToNumber(toValue);
	  return rgbToNumber(
	    number(fromValue >> 16 & 255, toValue >> 16 & 255, progress),
	    number(fromValue >> 8 & 255, toValue >> 8 & 255, progress),
	    number(fromValue & 255, toValue & 255, progress)
	  )
	}



	/**
	 * Utility for converting one of the supported color value types to a 24-bit numeric color
	 * representation.
	 * @param {*} value - The input value to translate. Supported types:
	 * - 24-bit number: simply returned as is
	 * - string value: evaluated using a canvas context, so supports color keywords, rgb(), hsl(), etc.
	 * - a three.js `Color` object
	 * @return {*}
	 */
	const colorValueToNumber = (function() {
	  let colorCanvas, colorCanvasCtx;

	  // Cache for evaluated string values
	  let stringCache = Object.create(null);
	  let stringCacheSize = 0;
	  const stringCacheMaxSize = 2048;

	  return function(value) {
	    if (typeof value === 'number') {
	      return value
	    }
	    else if (typeof value === 'string') {
	      if (value in stringCache) {
	        return stringCache[value]
	      }

	      // 2D canvas for evaluating string values
	      if (!colorCanvas) {
	        colorCanvas = document.createElement('canvas');
	        colorCanvasCtx = colorCanvas.getContext('2d');
	      }

	      colorCanvas.width = colorCanvas.height = 1;
	      colorCanvasCtx.fillStyle = value;
	      colorCanvasCtx.fillRect(0, 0, 1, 1);
	      const colorData = colorCanvasCtx.getImageData(0, 0, 1, 1).data;
	      const result = rgbToNumber(colorData[0], colorData[1], colorData[2]);

	      // Enforce max cache size - for now this invalidates the entire cache when reaching
	      // the max size; we could use a true LRU cache but hitting the max size should be rare
	      // in real world usage so this should suffice as a simple memory size protection.
	      if (stringCacheSize > stringCacheMaxSize) {
	        stringCache = Object.create(null);
	        stringCacheSize = 0;
	      }

	      // Put into cache
	      stringCache[value] = result;
	      stringCacheSize++;

	      return result
	    }
	    else if (value && value.isColor) {
	      return value.getHex()
	    }
	    else {
	      return 0 //fallback to black
	    }
	  }
	})();

	function rgbToNumber(r, g, b) {
	  return r << 16 ^ g << 8 ^ b
	}

	var Interpolators = /*#__PURE__*/Object.freeze({
		__proto__: null,
		number: number,
		color: color
	});

	/*eslint no-unused-vars: "off"*/

	/**
	 * @interface AbstractTween
	 * Defines the interface expected by `Runner` for tween-like things.
	 */
	class AbstractTween {
	  /**
	   * @abstract
	   * For a given elapsed time relative to the start of the tween, calculates the value at that time and calls the
	   * `callback` function with that value. If the given time is during the `delay` period, the callback will not be
	   * invoked.
	   * @param {number} time
	   */
	  gotoElapsedTime(time) {}

	  /**
	   * @abstract
	   * Like `gotoElapsedTime` but goes to the very end of the tween.
	   */
	  gotoEnd() {}

	  /**
	   * @abstract
	   * For a given elapsed time relative to the start of the tween, determines if the tween is in its completed end state.
	   * @param {number} time
	   * @return {boolean}
	   */
	  isDoneAtElapsedTime(time) {}
	}

	const linear = v => v;
	const maxSafeInteger = 0x1fffffffffffff;

	/**
	 * @class Tween
	 * Represents a transition between two values across a duration of time.
	 *
	 * Typically you will create a Tween between two values, with a callback function to handle the intermediate values,
	 * and then start the Tween in a {@link Runner} which will start invoking the tween on each animation frame until
	 * it reaches the end of its duration.
	 *
	 * @param callback {Function} a function that will be called with the current tween value at a given point in time.
	 * @param fromValue {*} the beginning value
	 * @param toValue {*} the ending value
	 * @param duration {Number} the duration of the tween in milliseconds
	 * @param [delay] {Number} optional time in milliseconds to wait before starting the tween
	 * @param [easing] {Function|String} optional easing to be applied to the tween values. Can either be a function
	 *        that takes a value from 0 to 1 and returns a corresponding "eased" value, or a string that matches the
	 *        name of one of the common Penner easing functions - see http://easings.net/ Defaults to linear easing.
	 * @param [iterations] {Number} optional number of times to repeat the tween animation. For endless repeating,
	 *        specify `Infinity`.
	 * @param [direction] {String} direction to run the tween; one of 'forward', 'reverse', or 'alternate'. For
	 *        'alternate', it will toggle between forward and reverse on each iteration.
	 * @param [interpolate] {String|Function} how tweened values should be calculated between the fromValue and toValue.
	 *        Can be the string name for one of the built-in interpolators in Interpolators.js, or a custom function that
	 *        will be passed 3 arguments: `fromValue`, `toValue`, and `progress` from 0 to 1.
	 */
	class Tween extends AbstractTween {
	  constructor(callback, fromValue, toValue, duration=750, delay=0, easing=linear, iterations=1, direction='forward', interpolate='number') {
	    super();
	    this.callback = callback;
	    this.fromValue = fromValue;
	    this.toValue = toValue;
	    this.duration = duration;
	    this.delay = delay;
	    this.easing = typeof easing === 'string' ? (Easings[easing] || linear) : easing;
	    this.iterations = iterations;
	    this.direction = direction;
	    this.interpolate = typeof interpolate === 'function' ? interpolate : Interpolators[interpolate] || number;

	    /**
	     * @property totalElapsed
	     * @type {number}
	     * The total duration of this tween from 0 to its completion, taking into account its `duration`, `delay`, and
	     * `iterations`. This is calculated once upon instantiation, and may be used to determine whether the tween is
	     * finished or not at a given time.
	     */
	    this.totalElapsed = this.iterations < maxSafeInteger ? this.delay + (this.duration * this.iterations) : maxSafeInteger;
	  }

	  /**
	   * For a given elapsed time relative to the start of the tween, calculates the value at that time and calls the
	   * `callback` function with that value. If the given time is during the `delay` period, the callback will not be
	   * invoked.
	   * @param {number} time
	   */
	  gotoElapsedTime(time) {
	    let duration = this.duration;
	    let delay = this.delay;
	    if (time >= delay) {
	      time = Math.min(time, this.totalElapsed) - delay; //never go past final value
	      let progress = (time % duration) / duration;
	      if (progress === 0 && time !== 0) progress = 1;
	      progress = this.easing(progress);
	      if (this.direction === 'reverse' || (this.direction === 'alternate' && Math.ceil(time / duration) % 2 === 0)) {
	        progress = 1 - progress;
	      }
	      this.callback(this.interpolate(this.fromValue, this.toValue, progress));
	    }
	  }

	  /**
	   * Like `gotoElapsedTime` but goes to the very end of the tween.
	   */
	  gotoEnd() {
	    this.gotoElapsedTime(this.totalElapsed);
	  }

	  /**
	   * For a given elapsed time relative to the start of the tween, determines if the tween is in its completed end state.
	   * @param {number} time
	   * @return {boolean}
	   */
	  isDoneAtElapsedTime(time) {
	    return time > this.totalElapsed
	  }
	}

	/**
	 * A specialized Tween that controls one or more other tweens. The controlled tweens are treated as a
	 * single unit and the easing/iterations/etc. are applied across the total duration of all tweens.
	 */
	class MultiTween extends Tween {
	  constructor(tweens, duration, delay, easing, iterations, direction) {
	    if (typeof duration !== 'number') {
	      // Calculate duration based on the longest individual total duration
	      duration = tweens.reduce((dur, tween) => Math.max(dur, tween.totalElapsed), 0);
	    }
	    if (duration === Infinity) {
	      // Make an infinite duration finite, so easing math still works
	      duration = Number.MAX_VALUE;
	    }

	    // Tween the total duration time
	    super(null, 0, duration, duration, delay, easing, iterations, direction);
	    if (tweens.length === 1) {
	      this.callback = tweens[0].gotoElapsedTime.bind(tweens[0]);
	    } else {
	      tweens.sort(endTimeComparator); //sort by end time to ensure proper iteration in syncTweens
	      this.callback = this._syncTweens;
	    }
	    this.tweens = tweens;
	  }

	  _syncTweens(time) {
	    // NOTE: forward iteration is important here so the tweens are evaluated in order
	    // of when they end; that way later tweens will take precedence over earlier ones.
	    // TODO would be nice to ignore tweens past their totalElapsed entirely, but have to
	    // figure out how to do that while ensuring they don't get stuck with a value that is
	    // slightly prior to their end state.
	    for (let i = 0, len = this.tweens.length; i < len; i++) {
	      this.tweens[i].gotoElapsedTime(time);
	    }
	  }
	}

	function endTimeComparator(a, b) {
	  return a.totalElapsed - b.totalElapsed
	}

	let runners = [];
	let nextFrameTimer = null;
	let hasStoppedRunners = false;

	function noop$2() {}

	function isRunnerRunning(runner) {return runner.runner$running}
	function isTweenNotStopped(tween) {return !tween.runner$stopped}

	function tick() {
	  let now = Date.now();
	  nextFrameTimer = null;

	  // Filter out any runners that were stopped since last tick
	  if (hasStoppedRunners) {
	    runners = runners.filter(isRunnerRunning);
	    hasStoppedRunners = false;
	  }

	  if (runners.length) {
	    // Sync each runner, filtering out empty ones as we go
	    for (let i = runners.length; i-- > 0;) {
	      runners[i]._tick(now);
	    }
	    // Queue next tick if there are still active runners
	    queueFrame();
	  }
	}

	let _scheduler = window;

	function queueFrame() {
	  if (!nextFrameTimer) {
	    nextFrameTimer = _scheduler.requestAnimationFrame(tick);
	  }
	}


	function startRunner(runner) {
	  if (!runner.runner$running) {
	    runner.runner$running = true;
	    runners.push(runner);
	    queueFrame();
	  }
	}

	function stopRunner(runner) {
	  runner.runner$running = false;
	  hasStoppedRunners = true;
	}


	/**
	 * @class Runner
	 * A container for {@link Tween} instances that handles invoking them on each animation frame.
	 */
	class Runner {
	  constructor() {
	    this.tweens = [];
	  }

	  destructor() {
	    this.tweens = null;
	    stopRunner(this);
	    this.start = this.stop = this.pause = this._tick = noop$2;
	  }

	  /**
	   * Add a tween to the runner. It will be invoked on the next frame, not immediately.
	   * @param {Tween} tween
	   */
	  start(tween) {
	    // If previously paused, update start time to account for the duration of the pause
	    if (tween.runner$paused && tween.runner$started) {
	      tween.runner$started += (Date.now() - tween.runner$paused);
	    } else {
	      this.tweens.push(tween);
	    }
	    tween.runner$paused = null;
	    tween.runner$stopped = false;

	    // add runner to running runners
	    startRunner(this);
	  }

	  /**
	   * Remove a tween from the runner.
	   * @param tween
	   */
	  stop(tween) {
	    // queue tween for removal from list on next tick
	    tween.runner$stopped = true;
	    tween.runner$paused = null;
	  }

	  /**
	   * Pause a tween; call `runner.start(tween)` to unpause it
	   * @param tween
	   */
	  pause(tween) {
	    if (!tween.runner$paused) {
	      tween.runner$paused = Date.now();
	    }
	  }

	  /**
	   * Stop all running tweens.
	   */
	  stopAll() {
	    if (this.tweens) {
	      this.tweens.forEach(this.stop, this);
	    }
	  }

	  _tick(now) {
	    let tweens = this.tweens;
	    let hasStoppedTweens = false;
	    let hasRunningTweens = false;

	    // Sync each tween, filtering out old finished ones as we go
	    for (let i = 0, len = tweens.length; i < len; i++) {
	      let tween = tweens[i];
	      if (!tween.runner$stopped && !tween.runner$paused) {
	        // Sync the tween to current time
	        let elapsed = now - (tween.runner$started || (tween.runner$started = now));
	        tween.gotoElapsedTime(elapsed);
	        hasRunningTweens = true;

	        // Queue for removal if we're past its end time
	        if (tween.isDoneAtElapsedTime(elapsed)) {
	          this.stop(tween);
	          if (tween.onDone) {
	            tween.onDone();
	          }
	        }
	      }
	      if (tween.runner$stopped) {
	        hasStoppedTweens = true;
	      }
	    }

	    if (hasRunningTweens) {
	      this.onTick();
	    }

	    // Prune list if needed
	    // TODO perhaps batch this up so it happens less often
	    if (hasStoppedTweens) {
	      this.tweens = tweens.filter(isTweenNotStopped);

	      // remove runner from running runners if it has no tweens left
	      if (!this.tweens.length) {
	        stopRunner(this);
	        if (this.onDone) {
	          this.onDone();
	        }
	      }
	    }
	  }

	  /**
	   * Override to specify a function that will be called at the end of every frame, after all
	   * tweens have been updated.
	   */
	  onTick() {
	    // abstract
	  }

	  /**
	   * Override to specify a function that will be called after all running tweens have completed.
	   */
	  onDone() {
	    // abstract
	  }
	}

	/**
	 * Preset spring physics configurations.
	 * For convenience, these match the presets defined by react-spring: https://www.react-spring.io/docs/hooks/api
	 */
	var PRESETS = {
	  default: { mass: 1, tension: 170, friction: 26 },
	  gentle: { mass: 1, tension: 120, friction: 14 },
	  wobbly: { mass: 1, tension: 180, friction: 12 },
	  stiff: { mass: 1, tension: 210, friction: 20 },
	  slow: { mass: 1, tension: 280, friction: 60 },
	  molasses: { mass: 1, tension: 280, friction: 120 }
	};

	// Factors to be applied to the tension and friction values; these match those used by
	// react-spring internally, so that users can use the same spring configs as they would
	// in react-spring.
	const tensionFactor = 0.000001;
	const frictionFactor = 0.001;

	const DEFAULTS = PRESETS.default;

	/**
	 * @class SpringTween
	 * Represents a transition between two values based on spring physics.
	 *
	 * This is very similar to `Tween`, except that it does not have a fixed duration. Instead, it advances a simple
	 * spring physics simulation on each call to `gotoElapsedTime`. Since it depends on being advanced in forward-time
	 * order, it cannot be repeated or run in a reverse direction. It is also not usable as a member of a `MultiTween`.
	 *
	 * The `toValue` property can be modified at any time while the simulation is running, and the velocity will be
	 * maintained; this makes spring tweens more useful than duration-based tweens for objects whose target values are
	 * changed rapidly over time, e.g. drag-drop.
	 *
	 * Non-numeric interpolations are not yet supported.
	 *
	 * @param callback {Function} a function that will be called with the current tween value at a given point in time.
	 * @param {number} fromValue - the beginning value
	 * @param {number} toValue - the initial ending value; this can be modified later by setting the `toValue` property
	 * @param {string|object} springConfig - the physical configuration of the spring physics simulation. Either an object
	 *        with `mass`, `tension`, and `friction` properties, or a string corresponding to one of the presets defined
	 *        in `SpringPresets.js`. Defaults to the "default" preset.
	 * @param {number} springConfig.mass - the mass of the simulated object being moved
	 * @param {number} springConfig.tension - the spring's tension constant accelerating the simulated object
	 * @param {number} springConfig.friction - the friction force decelerating the simulated object
	 * @param {number} [initialVelocity] - velocity of the object at the start of the simulation
	 * @param {number} [delay] optional time in milliseconds to wait before starting the simulation
	 */
	class SpringTween extends AbstractTween {
	  constructor (
	    callback,
	    fromValue,
	    toValue,
	    springConfig,
	    initialVelocity = 0,
	    delay = 0
	  ) {
	    super();
	    this.isSpring = true;
	    this.callback = callback;
	    this.currentValue = fromValue;
	    this.toValue = toValue;
	    this.velocity = initialVelocity;
	    this.delay = delay;

	    if (typeof springConfig === 'string') {
	      springConfig = PRESETS[springConfig];
	    }
	    if (!springConfig) springConfig = DEFAULTS;
	    const {mass, tension, friction} = springConfig;
	    this.mass = typeof mass === 'number' ? mass : DEFAULTS.mass;
	    this.tension = (typeof tension === 'number' ? tension : DEFAULTS.tension) * tensionFactor;
	    this.friction = (typeof friction === 'number' ? friction : DEFAULTS.friction) * frictionFactor;
	    this.minAcceleration = 1e-10; // in units/ms^2 - TODO make this configurable

	    this.$lastTime = delay;
	    this.$endTime = Infinity; //unknown until simulation is stepped to the end state
	  }

	  gotoElapsedTime (time) {
	    if (time >= this.delay) {
	      let { toValue, mass, tension, friction, minAcceleration } = this;
	      let velocity = this.velocity || 0;
	      let value = this.currentValue;

	      // Step simulation by 1ms
	      for (let t = this.$lastTime; t < time; t++) {
	        const acceleration = (tension * (toValue - value) - friction * velocity) / mass;
	        // Acceleration converges to zero near end state
	        if (Math.abs(acceleration) < minAcceleration) {
	          velocity = 0;
	          value = toValue;
	          this.$endTime = t;
	          break
	        } else {
	          velocity += acceleration;
	          value += velocity;
	        }
	      }
	      this.velocity = velocity;
	      this.$lastTime = time;
	      this.callback(this.currentValue = value);
	    }
	  }

	  gotoEnd () {
	    this.velocity = 0;
	    this.$lastTime = this.$endTime;
	    this.callback(this.currentValue = this.toValue);
	  }

	  isDoneAtElapsedTime (time) {
	    return time >= this.$endTime
	  }
	}

	///// Miscellaneous Utility Functions /////


	/**
	 * Pseudo-polyfilled shortcut for `Object.assign`. Copies own properties from
	 * second-and-after arguments onto the first object, overwriting any that already
	 * exist, and returns the first argument.
	 * @return {object}
	 */
	const assign$6 = Object.assign || _assign;

	// Non-native impl; exported for access by tests
	function _assign(/*target, ...sources*/) {
	  let target = arguments[0];
	  for (let i = 1, len = arguments.length; i < len; i++) {
	    let source = arguments[i];
	    if (source) {
	      for (let prop in source) {
	        if (source.hasOwnProperty(prop)) {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	  return target
	}


	/**
	 * Like {@link assign}, but will ony copy properties that do _not_ already
	 * exist on the target object.
	 * @return {object}
	 */
	function assignIf(/*target, ...sources*/) {
	  let target = arguments[0];
	  for (let i = 1, len = arguments.length; i < len; i++) {
	    let source = arguments[i];
	    if (source) {
	      for (let prop in source) {
	        if (source.hasOwnProperty(prop) && !target.hasOwnProperty(prop)) {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	  return target
	}

	/**
	 * Like {@link assign}, but for any property where the source and target are both
	 * sub-objects, does a deep recursive copy.
	 * @param {object} target
	 * @param {object} source
	 */
	function assignDeep(target, source) {
	  if (source) {
	    for (let prop in source) {
	      if (source.hasOwnProperty(prop)) {
	        if (target[prop] && typeof target[prop] === 'object' && typeof source[prop] === 'object') {
	          assignDeep(target[prop], source[prop]);
	        } else {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	}


	/**
	 * Iterate over an object's own (non-prototype-inherited) properties
	 * @param {object} object - The object to iterate over
	 * @param {function} fn - A function that will be invoked for each iterated property. It
	 *        will be passed three arguments:
	 *        - value (the property value)
	 *        - key (the property name)
	 *        - object (the object being iterated over)
	 * @param {*} [scope] - An optional object to be used as `this` when calling the `fn`
	 */
	function forOwn$2(object, fn, scope) {
	  for (let prop in object) {
	    if (object.hasOwnProperty(prop)) {
	      fn.call(scope, object[prop], prop, object);
	    }
	  }
	}


	/**
	 * Given an object instance, return a consistent unique id for it.
	 * @type function
	 * @param {Object} obj - The object instance
	 * @return {string} id
	 */
	const getIdForObject = (() => {
	  let objIds = new WeakMap();
	  let lastId = 0;
	  return function getIdForObject(obj) {
	    let id = objIds.get(obj);
	    if (!id) {
	      objIds.set(obj, (id = `$id${++lastId}`));
	    }
	    return id
	  }
	})();


	/**
	 * Create a function that memoizes the result of another function based on the most
	 * recent call's arguments and `this`. The arguments are compared using strict shallow equality.
	 * @param {function} fn
	 * @return {function}
	 */
	function memoize(fn) {
	  let prevArgs, prevThis, prevResult;
	  return function() {
	    let changed = !prevArgs || this !== prevThis || arguments.length !== prevArgs.length;
	    if (!changed) {
	      for (let i = 0, len = arguments.length; i < len; i++) {
	        if (arguments[i] !== prevArgs[i]) {
	          changed = true;
	          break
	        }
	      }
	    }
	    if (changed) {
	      prevArgs = Array.prototype.slice.call(arguments);
	      prevThis = this;
	      prevResult = fn.apply(this, arguments);
	    }
	    return prevResult
	  }
	}


	/**
	 * Utility for the "extend-as" pattern used in several places to decorate facade
	 * classes with extra capabilities.
	 * @param {string} name - unique identifier for this class extension
	 * @param {function} doExtend - the function that creates the actual class extension,
	 *        this is passed the base class and will only be called once per base class.
	 * @return {function(class): class}
	 */
	function createClassExtender$1(name, doExtend) {
	  const cache = new WeakMap();
	  return function(classToExtend) {
	    let extended = cache.get(classToExtend);
	    if (!extended) { //bidir check due to inheritance of statics
	      extended = doExtend(classToExtend);
	      cache.set(classToExtend, extended);
	    }
	    return extended
	  }
	}


	/**
	 * Determine whether a given object is a React element descriptor object, i.e. the
	 * result of a JSX transpilation to React.createElement().
	 * @param obj
	 * @return {boolean}
	 */
	function isReactElement(obj) {
	  const t = obj.$$typeof;
	  return (t && t.toString && t.toString() === 'Symbol(react.element)') || false
	}

	var utils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		assign: assign$6,
		_assign: _assign,
		assignIf: assignIf,
		assignDeep: assignDeep,
		forOwn: forOwn$2,
		getIdForObject: getIdForObject,
		memoize: memoize,
		createClassExtender: createClassExtender$1,
		isReactElement: isReactElement
	});

	/**
	 * The base class for all Facade classes.
	 *
	 * A Facade is basically just a class that receives property assignments from a scene descriptor
	 * and manages forwarding the resulting state to more complex underlying implementation
	 * objects, e.g. ThreeJS objects.
	 *
	 * The instantiated facade objects have a very simple lifecycle:
	 *   - The `constructor` in which the initial state and the underyling implementation object(s)
	 *     can be initialized. It will be passed a single argument: the `parent` facade object.
	 *   - Updates to the object's properties, usually by direct assignment from the scene descriptor.
	 *     These updates can be handled immediately by defining property setters that handle syncing
	 *     new values to the underyling implementation object(s).
	 *   - The `afterUpdate()` method which signals the end of all property updates; this can be
	 *     implemented to handle syncing the full set of updated properties to the underlying
	 *     implementation object(s). Useful if an aspect of the syncing relies on multiple properties
	 *     or needs things to be synced in a specific order.
	 *   - The `destructor` method which is always called when the object is removed from the scene.
	 *     Implement this to remove and clean up the underlying implementation object(s) and other
	 *     cleanup logic.
	 *
	 * Scene Descriptors:
	 *
	 * All facade instances are created, updated, and destroyed based on the current structure of
	 * a scene descriptor object. The properties in the descriptor are generally just copied
	 * directly to properties of the same names on the facade instance, which can handle them
	 * either by custom setters or in `afterUpdate`. There are a few special properties in the
	 * descriptor:
	 *
	 *   - `facade`: (required) a reference to the Facade class that will be instantiated.
	 *   - `key`: (recommended) an identifier that is unique amongst the descriptor's siblings, which
	 *     is used to associate the descriptor with its corresponding Facade instance. One will be
	 *     assigned automatically if omitted, but it's recommended that you set one manually to ensure
	 *     descriptors are predictably resolved to the same facade instances when siblings are being
	 *     added or removed. Not doing so can lead to unnecessary facade destruction/creation and/or
	 *     unpredictable facade states.
	 *   - `children`: (optional) for `Parent` facade subclasses, defines the child object descriptors.
	 *   - `ref`: (optional) a function that will be called with a reference to the instantiated Facade
	 *     on creation, and with `null` on destruction, allowing external code to maintain references
	 *     to individual facades.
	 *   - `transition`: (optional) defines a set of properties that should be transitioned smoothly
	 *     when their value changes. See `Animatable` for more details.
	 *   - `animation`: (optional) defines one or more keyframe animations. See `Animatable` for more
	 *     details.
	 *   - `exitAnimation`: (optional) defines a keyframe animation to run when the facade is removed
	 *     from its parent.
	 *   - `pointerStates`: (optional) defines sets of property values that should be used in place
	 *     of those defined on the main object, when the user's pointer (mouse, touch, vr controller,
	 *     etc.) is in `hover` or `active` interaction state with the facade. See `PointerStates`
	 *     for more details.
	 *
	 * It is also possible to define facade descriptors using JSX (https://reactjs.org/docs/introducing-jsx.html),
	 * if it is precompiled to `React.createElement` calls. In this case, use the facade class as the JSX
	 * element name instead of a `facade` property, and child descriptors are defined as nested JSX elements i
	 * nstead of a `children` property. *NOTE:* While this is often a nicer looking syntax than the plain JS object
	 * form, be aware that the creation of JSX elements does carry a slight performance cost from extra logic
	 * and object allocations, so you should avoid it when defining large numbers of facades or when updating
	 * descriptors on every frame.
	 */
	class Facade {
	  constructor(parent) {
	    this.$facadeId = `facade${ idCounter++ }`;
	    this.parent = parent;
	  }

	  /**
	   * Performs a manual update of this facade, invoking the afterUpdate lifecycle method and triggering a
	   * render. This can be called in event handlers, for example, to affect changes to this facade and its
	   * subtree. This process is synchronous. Never override this method as a way to react to updates, as it
	   * is not the only way a component is updated; instead override `afterUpdate` or use setters.
	   * @param {object} [props] - A set of properties to be copied to the facade
	   */
	  update(props) {
	    if (props && typeof props === 'object') {
	      // Always assign transition and animation first
	      this.transition = props.transition;
	      this.animation = props.animation;
	      for (let prop in props) {
	        if (props.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
	          this[prop] = props[prop];
	        }
	      }
	    }
	    this.afterUpdate();
	    this.requestRender();
	  }

	  /**
	   * Called at the end of an update batch, after all individual properties have been assigned.
	   */
	  afterUpdate() {
	    // Handle calling ref function
	    let ref = this.ref;
	    if (ref !== this._lastRef) {
	      if (typeof this._lastRef === 'function') {
	        this._lastRef.call(null, null);
	      }
	      if (typeof ref === 'function') {
	        ref.call(null, this);
	        this._lastRef = ref;
	      } else {
	        this._lastRef = null;
	      }
	    }
	  }

	  /**
	   * Dispatch a message with optional data up the facade parent tree.
	   */
	  notifyWorld(message, data) {
	    if (this.parent) {
	      this.parent.onNotifyWorld(this, message, data);
	    }
	  }

	  /**
	   * Default onNotifyWorld handler just bubbles it up the parent chain.
	   */
	  onNotifyWorld(source, message, data) {
	    let notifiableParent = this._notifiableParent;
	    if (notifiableParent) {
	      notifiableParent.onNotifyWorld.call(notifiableParent, source, message, data);
	    } else {
	      // Optimization: on first call, walk up the tree looking for the first ancestor with a
	      // non-default onNotifyWorld implementation, and save a pointer to that ancestor
	      // facade so we can just call it directly the next time without any tree walking.
	      notifiableParent = this.parent;
	      let defaultImpl = Facade.prototype.onNotifyWorld;
	      while (notifiableParent) {
	        if (notifiableParent.onNotifyWorld !== defaultImpl) {
	          this._notifiableParent = notifiableParent;
	          notifiableParent.onNotifyWorld(source, message, data);
	          break
	        }
	        notifiableParent = notifiableParent.parent;
	      }
	    }
	  }

	  /**
	   * Notifies the top-level world manager that this object has changed in some way that affects its
	   * visible rendering, so a rendering frame will be scheduled.
	   */
	  requestRender() {
	    this.notifyWorld('needsRender');
	  }

	  traverse(fn) {
	    fn(this);
	  }

	  forEachChild(fn) {
	  }

	  /**
	   * Add an event listener for the given event type.
	   * @param {String} type
	   * @param {Function} handler
	   */
	  addEventListener(type, handler) {
	    this.notifyWorld('addEventListener', {type, handler});
	  }

	  /**
	   * Remove an event listener for the given event type.
	   * @param {String} type
	   * @param {Function} handler
	   */
	  removeEventListener(type, handler) {
	    this.notifyWorld('removeEventListener', {type, handler});
	  }

	  /**
	   * Dispatch an Event object on this facade, with DOM events bubbling logic.
	   * @param {Event} event
	   */
	  dispatchEvent(event) {
	    this.notifyWorld('dispatchEvent', event);
	  }

	  /**
	   * Called when the instance is being removed from the scene. Override this to implement any
	   * custom cleanup logic.
	   */
	  destructor() {
	    // Unregister all event listeners from the world
	    if (this.parent) {
	      this.notifyWorld('removeAllEventListeners');
	    }

	    // Teardown refs
	    if (typeof this.ref === 'function') {
	      this.ref.call(null, null);
	    }
	    this.parent = this._notifiableParent = null;
	  }
	}

	assign$6(Facade.prototype, {
	  ref: null,
	  _lastRef: null,
	  _notifiableParent: null
	});


	let idCounter = 0;
	const DEF_SPECIAL_PROPS = {key:1, facade:1, transition:1, animation:1};

	/**
	 * @static
	 * Determine if a certain property name is one of the special descriptor properties
	 */
	Facade.isSpecialDescriptorProperty = function(name) {
	  return DEF_SPECIAL_PROPS.hasOwnProperty(name)
	};

	/**
	 * @static
	 * Define a property name as an event handler for a given Facade class, so that it
	 * automatically updates the global event registry when set.
	 * @param {class} facadeClass - the class whose prototype the property should be defined on
	 * @param {String} propName - the name of the event handler property, e.g. 'onMouseOver'
	 * @param {String} eventType - the type of the event that will trigger the handler, e.g. 'mouseover'
	 */
	Facade.defineEventProperty = function(facadeClass, propName, eventType) {
	  let privateProp = `${propName}➤handler`;
	  Object.defineProperty(facadeClass.prototype, propName, {
	    get() {
	      return this[privateProp]
	    },
	    set(handler) {
	      const oldHandler = this[privateProp];
	      if ((handler || null) !== (oldHandler || null)) {
	        // Remove old listener
	        if (typeof oldHandler === 'function') {
	          this.removeEventListener(eventType, oldHandler);
	        }
	        // Add new listener
	        if (typeof handler === 'function') {
	          this.addEventListener(eventType, handler);
	        }
	        this[privateProp] = handler;
	      }
	    }
	  });
	};

	const DEFAULT_DURATION = 750;
	const DEFAULT_EASING = 'easeOutCubic';

	const TEMP_ARRAY$1 = [null];

	function animationIdJsonReplacer(key, value) {
	  return key === 'paused' ? undefined : value === Infinity ? 'Infinity' : value
	}

	function compareByTime(a, b) {
	  return a.time - b.time
	}

	const extendAsAnimatable = createClassExtender$1('animatable', function(BaseFacadeClass) {
	  class AnimatableFacade extends BaseFacadeClass {

	    constructor(...args) {
	      super(...args);

	      // Create root runner for all this object's animation and transition tweens
	      this.animation$runner = new Runner();
	      this.animation$runner.onTick = () => {
	        this.afterUpdate();
	        this.requestRender();
	      };
	    }

	    /**
	     * Handle the special "transition" property. The descriptor should be an object with
	     * transitionable property names as keys and transition parameters as values. The
	     * transition parameters can either be objects describing the transition parameters,
	     * or `true` for a default transition.
	     *
	     *   transition: {
	     *     x: true, // uses a default duration-based transition
	     *     y: 'spring', //uses a default spring-based transition
	     *     z: {
	     *       // ...custom transition config
	     *     }
	     *   }
	     *
	     * The custom transition config object can take one of two forms for duration- vs.
	     * spring-based animations:
	     *
	     * Duration-based:
	     *
	     *   {
	     *     duration: n, //in ms, defaults to 750
	     *     easing: e, //easing function, defaults to 'easeOutCubic'
	     *     delay: n, //in ms, defaults to 0
	     *     interpolate: 'number' //one of the builtin named interpolators ('number', 'color', etc.) or a custom Function
	     *   }
	     *
	     * Spring-based:
	     *
	     *   {
	     *     spring: s, //either `true`, a named preset string e.g. "wobbly", or an object with {mass, tension, friction}
	     *     delay: n //in ms, defaults to 0
	     *   }
	     *
	     * Note that spring-based transitions do not currently support custom interpolations so they should only be used
	     * for numeric values.
	     */
	    set transition(descriptor) {
	      if (descriptor) {
	        // Ensure setter/getter has been created for all props in transition
	        for (let propName in descriptor) {
	          if (descriptor.hasOwnProperty(propName)) {
	            defineTransitionPropInterceptor(propName, this);
	          }
	        }
	      }
	      this.transition$descriptor = descriptor;
	    }
	    get transition() {
	      return this.transition$descriptor
	    }


	    /**
	     * Handle the special "animation" property. The descriptor should be an object or array
	     * of objects defining a set of keyframes and their playback parameters. Keyframes are
	     * defined by numeric keys from 0 to 100, each defining an object with the target
	     * property values for that keyframe.
	     *
	     *   animation: [{
	     *     0: {rotateZ: 0, color: 0x000000}, //can also use key "from"
	     *     100: {rotateZ: Math.PI * 2, color: 0xffffff}, //can also use key "to"
	     *     delay: 0, //starting delay in ms
	     *     duration: 2000, //total anim duration in ms, defaults to 750
	     *     easing: 'linear', //easing for the whole animation, defaults to 'linear'
	     *     iterations: 5, //number of times to loop the animation, defaults to 1. Set to Infinity for endless loop.
	     *     direction: 'forward', //either 'forward', 'backward', or 'alternate'
	     *     interpolate: {color: 'color'}, //mapping of property names to Interpolators.js names or custom functions
	     *     paused: false //if true the animation will be paused at its current position until set back to false
	     *   }, ...]
	     *
	     * Internally the animations will be built into a set of nested tweens:
	     *
	     * |--------------------------- Main MultiTween ------------------------------------|
	     *
	     * |------------- Anim 1 MultiTween w/ easing+repeat ----------------|
	     * |--- prop1 tween 1 ---|--- prop1 tween 2 ---|--- prop1 tween 3 ---|
	     * |--------- prop2 tween 1 --------|--------- prop2 tween 2 --------|
	     *
	     *                    delay -->|-------- Anim 2 MultiTween w/ easing+repeat --------|
	     *                             |----- prop3 tween 1 -----|----- prop3 tween 2 ------|
	     *                             |------------------- prop4 tween --------------------|
	     *                                            |----------- prop5 tween -------------|
	     */
	    set animation(descriptor) {
	      if (this.animation$descriptor === descriptor) return
	      this.animation$descriptor = descriptor;
	      let oldAnimTweens = this.animation$tweens || null;
	      let newAnimTweens = this.animation$tweens = descriptor ? Object.create(null) : null;
	      let runner = this.animation$runner;
	      let hasChanged = false;

	      // Handle single object not wrapped in array
	      if (descriptor && !Array.isArray(descriptor)) {
	        TEMP_ARRAY$1[0] = descriptor;
	        descriptor = TEMP_ARRAY$1;
	      }

	      if (descriptor) {
	        for (let i = 0, len = descriptor.length; i < len; i++) {
	          let animDesc = descriptor[i];
	          if (!animDesc) continue

	          // Calculate an identifier for this animation based on properties whose modification requires a new tween
	          let animId = JSON.stringify(animDesc, animationIdJsonReplacer);
	          //console.log(`${animId} - is ${oldAnimTweens && oldAnimTweens[animId] ? '' : 'not'} in old tweens`)

	          // If a matching tween already exists, update it
	          if (oldAnimTweens && (animId in oldAnimTweens)) {
	            let tween = oldAnimTweens[animId];
	            if (animDesc.paused) {
	              runner.pause(tween);
	            } else {
	              runner.start(tween);
	            }
	            newAnimTweens[animId] = tween;
	          }
	          // Otherwise create a new tween
	          else {
	            let delay = 0;
	            let duration = DEFAULT_DURATION;
	            let easing = 'linear';
	            let iterations = 1;
	            let keyframes = [];
	            let direction = 'forward';

	            for (let key in animDesc) {
	              if (animDesc.hasOwnProperty(key)) {
	                switch(key) {
	                  case 'duration':
	                    duration = animDesc[key]; break
	                  case 'delay':
	                    delay = animDesc[key]; break
	                  case 'easing':
	                    easing = animDesc[key]; break
	                  case 'iterations':
	                    iterations = animDesc[key]; break
	                  case 'direction':
	                    direction = animDesc[key]; break
	                  default: {
	                    let percent = key === 'from' ? 0 : key === 'to' ? 100 : parseFloat(key);
	                    if (!isNaN(percent) && percent >= 0 && percent <= 100) {
	                      keyframes.push({time: percent / 100, props: animDesc[key]});
	                      for (let animProp in animDesc[key]) {
	                        if (animDesc[key].hasOwnProperty(animProp)) {
	                          // Ensure setter is in place
	                          defineTransitionPropInterceptor(animProp, this);
	                          // Stop any active transition tweens for this property
	                          let tweenKey = animProp + '➤anim:tween';
	                          if (this[tweenKey]) {
	                            runner.stop(this[tweenKey]);
	                            this[tweenKey] = null;
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }

	            if (keyframes.length) {
	              // Sort the keyframes by time
	              keyframes.sort(compareByTime);
	              if (keyframes[0].time > 0) {
	                keyframes.unshift(assignIf({time: 0}, keyframes[0]));
	              }

	              // Build a MultiTween with tweens for each keyframe+property
	              let keyframePropTweens = [];
	              for (let j = 1, len = keyframes.length; j < len; j++) {
	                let keyframe = keyframes[j];
	                let props = keyframe.props;
	                for (let prop in props) {
	                  if (props.hasOwnProperty(prop)) {
	                    let prevKeyframe = null;
	                    for (let k = j; k--;) {
	                      if (prop in keyframes[k].props) {
	                        prevKeyframe = keyframes[k];
	                        break
	                      }
	                    }
	                    if (prevKeyframe) {
	                      let propTween = new Tween(
	                        this[prop + '➤anim:actuallySet'].bind(this), //callback
	                        prevKeyframe.props[prop], //fromValue
	                        props[prop], //toValue
	                        (keyframe.time - prevKeyframe.time) * duration, //duration
	                        prevKeyframe.time * duration, //delay
	                        'linear', //easing
	                        1, //iterations
	                        'forward', //direction
	                        animDesc.interpolate && animDesc.interpolate[prop] || 'number'
	                      );
	                      propTween.$$property = prop;
	                      keyframePropTweens.push(propTween);
	                    }
	                  }
	                }
	              }
	              let tween = newAnimTweens[animId] = new MultiTween(keyframePropTweens, duration, delay, easing, iterations, direction);
	              if (!animDesc.paused) {
	                runner.start(tween);
	              }

	              // The tween runner won't do anything until next tick, so immediately sync to the first frame's
	              // properties if the animation has no delay to avoid a flash of bad initial state
	              if (delay === 0) {
	                let firstKeyframeProps = keyframes[0].props;
	                for (let prop in firstKeyframeProps) {
	                  if (firstKeyframeProps.hasOwnProperty(prop)) {
	                    this[prop + '➤anim:actuallySet'](firstKeyframeProps[prop]);
	                  }
	                }
	              }
	            }

	            hasChanged = true;
	          }
	        }
	      }

	      // Stop any obsolete tweens
	      if (oldAnimTweens) {
	        for (let animId in oldAnimTweens) {
	          if (!newAnimTweens || !newAnimTweens[animId]) {
	            let tween = oldAnimTweens[animId];
	            tween.gotoEnd(); //force to end value so it doesn't stick partway through
	            runner.stop(tween);
	            hasChanged = true;
	          }
	        }
	      }

	      // If the total set of animations has changed, recalc the set of animating properties
	      if (hasChanged) {
	        if (newAnimTweens) {
	          let animatingProps = this.animation$animatingProps = Object.create(null);
	          for (let animId in newAnimTweens) {
	            let propTweens = newAnimTweens[animId].tweens;
	            for (let i = propTweens.length; i--;) {
	              animatingProps[propTweens[i].$$property] = true;
	            }
	          }
	        } else {
	          this.animation$animatingProps = null;
	        }
	      }
	    }
	    get animation() {
	      return this.animation$descriptor
	    }

	    destructor() {
	      const runner = this.animation$runner;
	      if (this.exitAnimation && !this.parent.isDestroying) {
	        runner.stopAll();
	        this.animation = this.exitAnimation;
	        this.exitAnimation = this.transition = null;
	        const onTick = runner.onTick;
	        runner.onTick = () => {
	          if (this.parent && !this.parent.isDestroying) {
	            onTick();
	          } else {
	            // An ancestor may have been destroyed during our exit animation, orphaning this object;
	            // catch this case and short-circuit the animation to prevent errors in subsequent ticks
	            runner.onDone = null;
	            this.destructor();
	          }
	        };
	        runner.onDone = () => {
	          this.requestRender();
	          this.destructor();
	        };
	      } else {
	        runner.destructor();
	        super.destructor();
	      }
	    }
	  }

	  // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it
	  // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with
	  // other custom setters anywhere else in the prototype chain.
	  function defineTransitionPropInterceptor(propName, currentInstance) {
	    if (!AnimatableFacade.prototype.hasOwnProperty(propName)) {
	      let actualValueKey = `${ propName }➤anim:actualValue`;
	      let actuallySetKey = `${ propName }➤anim:actuallySet`;
	      let hasBeenSetKey = `${ propName }➤anim:hasBeenSet`;
	      let activeTweenKey = `${ propName }➤anim:tween`;

	      // Find the nearest getter/setter up the prototype chain, if one exists. Assuming the prototype won't change after the fact.
	      let superGetter, superSetter;
	      let proto = BaseFacadeClass.prototype;
	      while (proto) {
	        let desc = Object.getOwnPropertyDescriptor(proto, propName);
	        if (desc) {
	          superSetter = desc.set;
	          superGetter = desc.get;
	          if (superSetter && !superGetter || superGetter && !superSetter) {
	            throw new Error(`Animatable: property ${propName} has a custom ${superSetter ? 'setter' : 'getter'} but no ${superSetter ? 'getter' : 'setter'}. Animatable properties must have both.`)
	          }
	          break
	        }
	        proto = Object.getPrototypeOf(proto);
	      }

	      // Function to set the value, bypassing the interceptor setter.
	      // Use the super setter if available, otherwise store in a private-ish key
	      let actuallySet = superSetter ? function actuallySet(value) {
	        superSetter.call(this, value);
	        if (!this[hasBeenSetKey]) {
	          this[hasBeenSetKey] = true;
	        }
	      } : function actuallySet(value) {
	        this[actualValueKey] = value;
	        if (!this[hasBeenSetKey]) {
	          this[hasBeenSetKey] = true;
	        }
	      };
	      Object.defineProperty(AnimatableFacade.prototype, actuallySetKey, { value: actuallySet });


	      // Add the custom getter/setter for this property
	      Object.defineProperty(AnimatableFacade.prototype, propName, {
	        get() {
	          // Always return the current actual value
	          return superGetter ? superGetter.call(this) : this[hasBeenSetKey] ? this[actualValueKey] : BaseFacadeClass.prototype[propName]
	        },

	        set(value) {
	          // Will this value be controlled by an animation? Ignore it since animations take precedence.
	          if (this.animation$animatingProps && this.animation$animatingProps[propName]) {
	            return
	          }

	          // Does this value have a transition defined, and are the old/new values transitionable?
	          let runner = this.animation$runner;
	          let transition = this.transition;
	          if (transition && transition[propName] && this[hasBeenSetKey] && transition.hasOwnProperty(propName)) {
	            transition = transition[propName];
	            let springConfig = transition === 'spring' ? 'default' : transition.spring;
	            // If there's no active transition tween, or the new value is different than the active tween's
	            // target value, initiate a new transition tween. Otherwise ignore it.
	            let tween = this[activeTweenKey];
	            let needsNewTween = false;
	            if (tween) {
	              // Active tween - start new one if new value is different than the old tween's target
	              // value, unless they're both springs in which case update the original
	              if (value !== tween.toValue) {
	                if (springConfig && tween.isSpring) {
	                  // TODO allow mid-simulation modification of spring config?
	                  tween.toValue = value;
	                } else {
	                  runner.stop(tween);
	                  needsNewTween = true;
	                }
	              }
	            } else if (value !== this[propName]) {
	              // No active tween - only start one if the value is changing
	              needsNewTween = true;
	            }
	            if (needsNewTween) {
	              tween = this[activeTweenKey] = springConfig
	                ? new SpringTween(
	                  actuallySet.bind(this), //callback
	                  this[propName], //fromValue
	                  value, //toValue
	                  springConfig, //springConfig (mass, friction, tension)
	                  0, //initialVelocity
	                  transition.delay || 0 //delay
	                )
	                : new Tween(
	                  actuallySet.bind(this), //callback
	                  this[propName], //fromValue
	                  value, //toValue
	                  transition.duration || DEFAULT_DURATION, //duration
	                  transition.delay || 0, //delay
	                  transition.easing || DEFAULT_EASING, //easing
	                  1, //iterations
	                  'forward', //direction
	                  transition.interpolate || 'number' //interpolate
	                );
	              tween.onDone = () => {
	                tween = this[activeTweenKey] = null;
	              };
	              runner.start(tween);
	            }
	            return
	          }

	          // No animation or transition will be started; set the value.
	          actuallySet.call(this, value);

	          // Clean up obsolete stuff
	          let tween = this[activeTweenKey];
	          if (tween) runner.stop(tween);
	          this[activeTweenKey] = null;
	        }
	      });
	    }


	    // If the instance had this property set before the intercepting setter was added to the
	    // prototype, that would continue to take precedence, so move its value to the private property.
	    if (currentInstance.hasOwnProperty(propName)) {
	      currentInstance[`${ propName }➤anim:actualValue`] = currentInstance[propName];
	      currentInstance[`${ propName }➤anim:hasBeenSet`] = true;
	      delete currentInstance[propName];
	    }

	  }

	  return AnimatableFacade
	});

	/**
	 * Allows a facade to be configured with an optional `pointerStates` property, which defines
	 * sets of property values that should be used in place of the object's actual values when
	 * the user interacts with the facade using their pointer device (mouse, touch, vr controller, etc.)
	 * This is not used directly, but is automatically wrapped by `ParentFacade` and `ListFacade` when
	 * setting up their children if the `pointerStates` property is present.
	 *
	 * The `pointerStates` property should point to an object with `hover` and/or `active` properties,
	 * each of which is an object holding the individual properties to be used in those states. Any
	 * properties defined in `active` will take precedence over those defined in `hover`.
	 *
	 * The properties will honor any `transition`s defined for them, but the `transition` must be
	 * defined on the facade's main configuration object, not within the pointerStates themselves.
	 */
	const extendAsPointerStatesAware = createClassExtender$1('pointerStates', function(BaseFacadeClass) {
	  const isHoveringProp = '➤pntr:isHovering';
	  const isActiveProp = '➤pntr:isActive';
	  const propsWithInterceptors = Object.create(null);

	  class PointerStatesAware extends BaseFacadeClass {
	    constructor(parent) {
	      super(parent);
	      this.addEventListener('mouseover', hoverOverHandler);
	      this.addEventListener('mouseout', hoverOutHandler);
	      this.addEventListener('mousedown', activeDownHandler);
	      this.addEventListener('mouseup', activeUpHandler);
	    }

	    afterUpdate() {
	      this._applyPointerStates();
	      super.afterUpdate();
	    }

	    _applyPointerStates() {
	      const pointerStates = this.pointerStates;
	      const hoverValuesToUse = (pointerStates && this[isHoveringProp] && pointerStates.hover) || null;
	      const activeValuesToUse = (pointerStates && this[isActiveProp] && pointerStates.active) || null;

	      const lastAppliedValues = this['➤pntr:lastAppliedValues'] || propsWithInterceptors;
	      const appliedValues = this['➤pntr:lastAppliedValues'] =
	        (hoverValuesToUse || activeValuesToUse) ? assign$6(Object.create(null), hoverValuesToUse, activeValuesToUse) : null;

	      if (appliedValues) {
	        for (let prop in appliedValues) {
	          definePropInterceptor(prop, this);
	          actuallySet(this, prop, appliedValues[prop]);
	        }
	      }

	      if (lastAppliedValues) {
	        for (let prop in lastAppliedValues) {
	          if (!appliedValues || !(prop in appliedValues)) {
	            actuallySet(this, prop, this[`${prop}➤pntr:baseValue`]);
	          }
	        }
	      }
	    }
	  }

	  // Flag for identification
	  Object.defineProperty(PointerStatesAware.prototype, 'isPointerStateAware', {value: true});

	  // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it
	  // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with
	  // other custom setters anywhere else in the prototype chain.
	  function definePropInterceptor(propName, currentInstance) {
	    // On first set for this instance, move the prop's previous value, if any, to the private property
	    const hasBeenSetProp = `${propName}➤pntr:hasBeenSet`;
	    if (!currentInstance[hasBeenSetProp]) {
	      currentInstance[`${ propName }➤pntr:baseValue`] = currentInstance[propName];
	      delete currentInstance[propName]; //remove own prop so it doesn't override the prototype getter/setter
	      currentInstance[hasBeenSetProp] = true;
	    }

	    if (!PointerStatesAware.prototype.hasOwnProperty(propName)) {
	      propsWithInterceptors[propName] = 1;
	      const baseValueProp = `${ propName }➤pntr:baseValue`;
	      const appliedValueProp = `${propName}➤pntr:appliedValue`;

	      Object.defineProperty(PointerStatesAware.prototype, propName, {
	        get() {
	          const superGetter = getSuperGetter(propName);
	          return superGetter ? superGetter.call(this) :
	            (appliedValueProp in this) ? this[appliedValueProp] :
	            this[baseValueProp]
	        },

	        set(value) {
	          this[baseValueProp] = value;
	        }
	      });
	    }
	  }

	  function actuallySet(instance, propName, value) {
	    const superSetter = getSuperSetter(propName);
	    if (superSetter) {
	      superSetter.call(instance, value);
	    } else {
	      instance[`${propName}➤pntr:appliedValue`] = value;
	    }
	  }

	  function getSuperGetter(propName) {
	    let proto = BaseFacadeClass.prototype;
	    if (propName in proto) { //prefilter across entire proto chain
	      while (proto) {
	        let desc = Object.getOwnPropertyDescriptor(proto, propName);
	        if (desc && desc.get) {
	          return desc.get
	        }
	        proto = Object.getPrototypeOf(proto);
	      }
	    }
	    return null
	  }

	  function getSuperSetter(propName) {
	    let proto = BaseFacadeClass.prototype;
	    if (propName in proto) { //prefilter across entire proto chain
	      while (proto) {
	        let desc = Object.getOwnPropertyDescriptor(proto, propName);
	        if (desc && desc.set) {
	          return desc.set
	        }
	        proto = Object.getPrototypeOf(proto);
	      }
	    }
	    return null
	  }

	  function hoverOverHandler(e) {
	    e.currentTarget[isHoveringProp] = true;
	    afterPointerStateChange(e);
	  }
	  function hoverOutHandler(e) {
	    e.currentTarget[isHoveringProp] = e.currentTarget[isActiveProp] = false;
	    afterPointerStateChange(e);
	  }
	  function activeDownHandler(e) {
	    e.currentTarget[isActiveProp] = true;
	    afterPointerStateChange(e);
	  }
	  function activeUpHandler(e) {
	    e.currentTarget[isActiveProp] = false;
	    afterPointerStateChange(e);
	  }

	  function afterPointerStateChange(e) {
	    let highestFacade = e.currentTarget;
	    let parent = highestFacade.parent;
	    while (parent && parent.shouldUpdateChildren()) {
	      if (parent.isPointerStateAware) {
	        highestFacade = parent;
	      }
	      parent = parent.parent;
	    }
	    highestFacade.afterUpdate();
	    highestFacade.requestRender();
	  }

	  return PointerStatesAware
	});

	/**
	 * ListFacade is an optimized way to define a large number of scene objects based on an array of data.
	 * Unlike mapping a data array to `children` objects in the scene descriptor, ListFacade allows you to
	 * define only a single "template" descriptor object whose properties are either constant values
	 * or accessor functions that get invoked for each data item. The resulting property values are
	 * then applied directly to the implementation objects, without creating any intermediary objects.
	 *
	 * Example:
	 *
	 *     {
	 *       key: 'balls',
	 *       facade: ListFacade,
	 *       data: itemsData,
	 *       template: {
	 *         key: (item, i, all) => `ball_${ item.id }`,
	 *         facade: Ball,
	 *         x: (item, i, all) => item.time,
	 *         y: (item, i, all) => item.count,
	 *         radius: 10,
	 *         color: (item, i, all) => item.important ? 0xff0000 : 0xcccccc
	 *       }
	 *     }
	 */
	class List extends Facade {
	  constructor(parent) {
	    super(parent);
	    this._orderedItemKeys = [];
	  }

	  afterUpdate() {
	    let {data, template} = this;
	    let hasData = data && data.length && Array.isArray(data);

	    if (this.shouldUpdateChildren()) {
	      let oldDict = this._itemsDict || null;
	      let newDict = this._itemsDict = hasData ? Object.create(null) : null;
	      let orderedItemKeys = this._orderedItemKeys;

	      if (hasData) {
	        orderedItemKeys.length = data.length;

	        for (let i = 0, len = data.length; i < len; i++) {
	          let childData = data[i];
	          let key = template.key(childData, i, data);
	          let facadeClass = template.facade;
	          while(newDict[key]) {
	            key += '|dupe';
	          }

	          // If a transition/animation is present, upgrade the class to a Animatable class on demand.
	          // NOTE: changing between animatable/non-animatable results in a full teardown/recreation
	          // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`
	          // definition if the object is expected to ever need transitions, even if it's temporarily empty.
	          let transition = typeof template.transition === 'function' ? template.transition(childData, i, data) : template.transition;
	          let animation = typeof template.animation === 'function' ? template.animation(childData, i, data) : template.animation;
	          let exitAnimation = typeof template.exitAnimation === 'function' ? template.exitAnimation(childData, i, data) : template.exitAnimation;
	          if (transition || animation || exitAnimation) {
	            facadeClass = extendAsAnimatable(facadeClass);
	          }

	          // Same for pointer states
	          let pointerStates = template.pointerStates;
	          if (pointerStates === 'function' ? pointerStates(childData, i, data) : pointerStates) {
	            facadeClass = extendAsPointerStatesAware(facadeClass);
	          }

	          // If we have an old instance with the same key and class, reuse it; otherwise instantiate a new one
	          let oldImpl = oldDict && oldDict[key];
	          let newImpl;
	          if (oldImpl && oldImpl.constructor === facadeClass) {
	            newImpl = oldImpl;
	          } else {
	            // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering
	            if (oldImpl) oldImpl.destructor();
	            newImpl = new facadeClass(this);
	          }
	          //always set transition/animation before any other props
	          newImpl.transition = transition;
	          newImpl.animation = animation;
	          for (let prop in template) {
	            if (template.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
	              newImpl[prop] = typeof template[prop] === 'function' ? template[prop](childData, i, data) : template[prop];
	            }
	          }
	          newImpl.afterUpdate();
	          newDict[key] = newImpl;
	          orderedItemKeys[i] = key;
	        }
	      }

	      // Destroy all old child instances that were not reused or replaced
	      if (oldDict) {
	        for (let key in oldDict) {
	          if (!newDict || !newDict[key]) {
	            oldDict[key].destructor();
	          }
	        }
	      }
	    }

	    super.afterUpdate();
	  }

	  /**
	   * Override to selectively prevent updating the ListFacade's items on `afterUpdate`, for
	   * potential performance gain.
	   * @returns {boolean}
	   */
	  shouldUpdateChildren() {
	    return true
	  }

	  /**
	   * Walk this facade's descendant tree, invoking a function for it and each descendant.
	   * The iteration order will match the order in which the `data` items were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  traverse(fn, thisArg) {
	    fn.call(thisArg, this);
	    let keys = this._orderedItemKeys;
	    let dict = this._itemsDict;
	    for (let i = 0, len = keys.length; i < len; i++) {
	      dict[keys[i]].traverse(fn, thisArg);
	    }
	  }

	  /**
	   * Iterate over this facade's direct child facades, invoking a function for each.
	   * The iteration order will match the order in which the `data` items were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  forEachChild(fn, thisArg) {
	    let keys = this._orderedItemKeys;
	    let dict = this._itemsDict;
	    for (let i = 0, len = keys.length; i < len; i++) {
	      fn.call(thisArg, dict[keys[i]], keys[i]);
	    }
	  }

	  destructor() {
	    this.isDestroying = true;
	    // Destroy all child instances
	    let dict = this._itemsDict;
	    if (dict) {
	      for (let key in dict) {
	        dict[key].destructor();
	      }
	    }
	    super.destructor();
	  }
	}

	const TEMP_ARRAY = [null];

	/**
	 * @typedef {object} FacadeDescriptor
	 * An object describing the type and properties of a child facade to be created and managed by
	 * its parent. See the detailed description in the docs for {@link Facade.js}.
	 * @property {class} facade
	 * @property {string|number} [key]
	 */


	/**
	 * Base facade class for objects that have `children`. Manages creating and destroying child
	 * facade instances as needed as its `children` array changes.
	 *
	 * If you need to create a large number of child objects based on an array of incoming data,
	 * consider using a `ListFacade` instead of a parent object with a large `children` array, since
	 * that requires only a single template descriptor object instead of one for every child.
	 */
	class ParentFacade extends Facade {
	  constructor(parent) {
	    super(parent);

	    /**
	     * @member {FacadeDescriptor | Array<FacadeDescriptor>} children
	     * Descriptors for one or more child facades.
	     */
	    this.children = null;

	    this._orderedChildKeys = [];
	  }

	  afterUpdate() {
	    if (this.shouldUpdateChildren()) {
	      this.updateChildren(this.describeChildren());
	    }
	    super.afterUpdate();
	  }

	  /**
	   * Return the descriptor(s) for the actual children to be created and managed. By default
	   * this simply returns the value of the `children` property set by the parent, but you can
	   * override it to customize how the child content should be structured, for instance to wrap
	   * the `children` within a deeper structure, add in anonymous child siblings, or modify the
	   * `children` configurations.
	   * @protected
	   * @return {FacadeDescriptor | Array<FacadeDescriptor>}
	   */
	  describeChildren() {
	    return this.children
	  }

	  /**
	   * Override to selectively prevent traversing to child nodes on `afterUpdate`, for
	   * potential performance gain.
	   * @returns {boolean}
	   */
	  shouldUpdateChildren() {
	    return true
	  }

	  updateChildren(children) {
	    const oldDict = this._childrenDict || null;
	    let newDict = this._childrenDict = null;
	    const orderedChildKeys = this._orderedChildKeys;
	    orderedChildKeys.length = 0;

	    if (children) {
	      // Allow single child without wrapper array
	      if (!Array.isArray(children)) {
	        TEMP_ARRAY[0] = children;
	        children = TEMP_ARRAY;
	      }

	      for (let i = 0, len = children.length; i < len; i++) {
	        let childDesc = children[i];
	        if (!childDesc) continue //child members can be null
	        if (!newDict) {
	          newDict = this._childrenDict = Object.create(null);
	        }

	        // Handle child descriptors defined via a JSX->React.createElement() transforms (ReactElement objects)
	        const isJSX = isReactElement(childDesc);
	        let propsObj = isJSX ? childDesc.props : childDesc;
	        let facadeClass = isJSX ? childDesc.type : childDesc.facade;

	        // Find this child's key; if not specified by the author, build one from the facade class name
	        let key = childDesc.key;
	        if (!key) {
	          let j = 0;
	          do {
	            key = `auto:${facadeClass.name}:${j++}`;
	          } while (newDict[key])
	        }
	        if (newDict[key]) {
	          while(newDict[key]) {
	            key += '|dupe';
	          }
	        }

	        // If a transition/animation is present, upgrade the class to a Animatable class on demand.
	        // NOTE: changing between animatable/non-animatable results in a full teardown/recreation
	        // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`
	        // definition if the object is expected to ever need transitions, even if it's temporarily empty.
	        let transition = propsObj.transition;
	        let animation = propsObj.animation;
	        if (transition || animation || propsObj.exitAnimation) {
	          facadeClass = extendAsAnimatable(facadeClass);
	        }

	        // Same for pointer states
	        if (propsObj.pointerStates) {
	          facadeClass = extendAsPointerStatesAware(facadeClass);
	        }

	        // If we have an old instance with the same key and class, update it, otherwise instantiate a new one
	        let oldImpl = oldDict && oldDict[key];
	        let newImpl;
	        if (oldImpl && oldImpl.constructor === facadeClass) {
	          newImpl = oldImpl;
	        } else {
	          // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering
	          if (oldImpl) oldImpl.destructor();
	          newImpl = new facadeClass(this);
	        }
	        //always set transition/animation before any other props
	        newImpl.transition = transition;
	        newImpl.animation = animation;
	        for (let prop in propsObj) {
	          if (propsObj.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
	            newImpl[prop] = propsObj[prop];
	          }
	        }
	        newDict[key] = newImpl;
	        orderedChildKeys.push(key);
	        newImpl.afterUpdate();
	      }
	    }

	    // Destroy all old child instances that were not reused or replaced
	    if (oldDict) {
	      for (let key in oldDict) {
	        if (!newDict || !newDict[key]) {
	          oldDict[key].destructor();
	        }
	      }
	    }
	  }

	  getChildByKey(key) {
	    let dict = this._childrenDict;
	    return dict && dict[key] || null
	  }

	  /**
	   * Walk this facade's descendant tree, invoking a function for it and each descendant.
	   * The iteration order will match the order in which the `children` were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  traverse(fn, thisArg) {
	    fn.call(thisArg, this);
	    const keys = this._orderedChildKeys;
	    const dict = this._childrenDict;
	    for (let i = 0, len = keys.length; i < len; i++) {
	      dict[keys[i]].traverse(fn, thisArg);
	    }
	  }

	  /**
	   * Iterate over this facade's direct child facades, invoking a function for each.
	   * The iteration order will match the order in which the `children` were declared. It may
	   * also include items that have been queued for removal but not yet removed, e.g. facades
	   * in the process of an `exitAnimation`.
	   * @param {Function} fn
	   * @param {Object} [thisArg]
	   */
	  forEachChild(fn, thisArg) {
	    const keys = this._orderedChildKeys;
	    const dict = this._childrenDict;
	    for (let i = 0, len = keys.length; i < len; i++) {
	      fn.call(thisArg, dict[keys[i]], keys[i]);
	    }
	  }

	  destructor() {
	    this.isDestroying = true;
	    // Destroy all child instances
	    let dict = this._childrenDict;
	    if (dict) {
	      for (let key in dict) {
	        dict[key].destructor();
	      }
	    }
	    super.destructor();
	  }
	}

	const pointerMotionEventProps = [
	  'onMouseOver',
	  'onMouseOut',
	  'onMouseMove',
	  'onDragStart',
	  'onDrag',
	  'onDragEnter',
	  'onDragOver',
	  'onDragLeave'
	];

	const pointerActionEventProps = [
	  'onMouseDown',
	  'onMouseUp',
	  'onClick',
	  'onDoubleClick',
	  'onDrop',
	  'onDragEnd',
	  'onWheel'
	];

	const pointerActionEventTypes = pointerActionEventProps.map(eventPropToType);
	const pointerMotionEventTypes = pointerMotionEventProps.map(eventPropToType);

	const pointerEventProps = pointerMotionEventProps.concat(pointerActionEventProps);
	const pointerEventTypes = pointerMotionEventTypes.concat(pointerActionEventTypes);

	function eventPropToType(prop) {
	  return prop === 'onDoubleClick' ? 'dblclick' : prop.replace(/^on/, '').toLowerCase()
	}


	class PointerEventTarget extends ParentFacade {
	  /**
	   * Determine if this PointerEventTarget should intercept pointer events:
	   * - By default only facades with a pointer event listener assigned will be counted, to prevent being blocked by unwanted objects
	   * - If an object should definitely block events from objects behind it, set `pointerEvents:true`
	   * - If an object has one of the pointer event properties but should be ignored in picking, set `pointerEvents:false`
	   */
	  interceptsPointerEvents(eventRegistry) {
	    if (this.pointerEvents === false) {
	      return false
	    }
	    if (this.pointerEvents) {
	      return true
	    }
	    for (let i = 0, len = pointerEventTypes.length; i < len; i++) {
	      if (eventRegistry.hasFacadeListenersOfType(this, pointerEventTypes[i])) {
	        return true
	      }
	    }
	  }
	}


	Object.defineProperty(PointerEventTarget.prototype, 'isPointerEventTarget', {value: true});


	// Add handlers for pointer event properties
	pointerEventProps.forEach(propName => {
	  Facade.defineEventProperty(PointerEventTarget, propName, eventPropToType(propName));
	});

	/**
	 * @class EventRegistry
	 * Utility for tracking event listeners by type and target facade
	 */
	function EventRegistry() {
	  const byEventType = Object.create(null);

	  this.addListenerForFacade = (facade, type, handler) => {
	    const listenersOfType = byEventType[type] || (byEventType[type] = {
	      count: 0,
	      byFacadeId: Object.create(null)
	    });
	    const facadeId = facade.$facadeId;
	    const oldHandlers = listenersOfType.byFacadeId[facadeId];
	    // No listeners for this facade yet; set handler function as single value to avoid
	    // unnecessary array creation in the common single-listener case.
	    if (!oldHandlers) {
	      listenersOfType.count++;
	      listenersOfType.byFacadeId[facadeId] = handler;
	    }
	    // Already multiple listeners; add to array if not already present
	    else if (Array.isArray(oldHandlers)) {
	      if (oldHandlers.indexOf(handler) === -1) {
	        listenersOfType.count++;
	        oldHandlers.push(handler);
	      }
	    }
	    // Second unique listener; promote to array
	    else if (oldHandlers !== handler) {
	      listenersOfType.count++;
	      listenersOfType.byFacadeId[facadeId] = [oldHandlers, handler];
	    }
	  };

	  this.removeListenerForFacade = (facade, type, handler) => {
	    const listenersOfType = byEventType[type];
	    const facadeId = facade.$facadeId;
	    const oldHandlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
	    // Single listener; delete from map
	    if (oldHandlers === handler) {
	      listenersOfType.count--;
	      delete listenersOfType.byFacadeId[facadeId];
	    }
	    // Multiple listeners; remove from array
	    else if (Array.isArray(oldHandlers)) {
	      const idx = oldHandlers.indexOf(handler);
	      if (idx > -1) {
	        listenersOfType.count--;
	        // Delete from map if the array will be empty; we don't demote from array to single
	        // item because it can result in unneeded churn in the likely case of a different
	        // listener being added immediately after
	        if (oldHandlers.length === 1) {
	          delete listenersOfType.byFacadeId[facadeId];
	        } else {
	          oldHandlers.splice(idx, 1);
	        }
	      }
	    }
	  };

	  this.removeAllListenersForFacade = (facade) => {
	    const facadeId = facade.$facadeId;
	    for (let type in byEventType) {
	      let facadeListeners = byEventType[type].byFacadeId[facadeId];
	      if (facadeListeners) {
	        byEventType[type].count -= (Array.isArray(facadeListeners) ? facadeListeners.length : 1);
	        delete byEventType[type].byFacadeId[facadeId];
	      }
	    }
	  };

	  this.hasFacadeListenersOfType = (facade, type) => {
	    return byEventType[type] ? !!byEventType[type].byFacadeId[facade.$facadeId] : false
	  };

	  this.hasAnyListenersOfType = (type) => {
	    return byEventType[type] ? byEventType[type].count > 0 : false
	  };

	  this.findBubblingEventTarget = (targetFacade, eventType) => {
	    while (targetFacade) {
	      if (this.hasFacadeListenersOfType(targetFacade, eventType)) {
	        return targetFacade
	      }
	      targetFacade = targetFacade.parent;
	    }
	    return null
	  };

	  function tryCall(func, scope, arg1, arg2) {
	    try {
	      func.call(scope, arg1, arg2);
	    } catch(err) {
	    }
	  }

	  this.forEachFacadeListenerOfType = (facade, type, callback, scope) => {
	    const listenersOfType = byEventType[type];
	    const facadeId = facade.$facadeId;
	    const handlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
	    if (handlers) {
	      if (Array.isArray(handlers)) {
	        for (let i = 0; i < handlers.length; i++) {
	          tryCall(callback, scope, handlers[i], facadeId);
	        }
	      } else {
	        tryCall(callback, scope, handlers, facadeId);
	      }
	    }
	  };

	  this.forEachListenerOfType = (type, callback, scope) => {
	    const listenersOfType = byEventType[type];
	    if (listenersOfType && listenersOfType.count > 0) {
	      for (let facadeId in listenersOfType.byFacadeId) {
	        const facadeListeners = listenersOfType.byFacadeId[facadeId];
	        if (Array.isArray(facadeListeners)) {
	          for (let i = 0; i < facadeListeners.length; i++) {
	            tryCall(callback, scope, facadeListeners[i], facadeId);
	          }
	        } else {
	          tryCall(callback, scope, facadeListeners, facadeId);
	        }
	      }
	    }
	  };

	  this.dispatchEventOnFacade = (facade, event) => {
	    let currentTarget = facade;
	    function callHandler(handler) {
	      handler.call(currentTarget, event);
	    }
	    event.target = facade;
	    while (currentTarget && !event.propagationStopped) { //TODO should defaultPrevented mean anything here?
	      event.currentTarget = currentTarget;
	      this.forEachFacadeListenerOfType(currentTarget, event.type, callHandler, null);
	      if (event.bubbles) {
	        currentTarget = currentTarget.parent;
	      } else {
	        break
	      }
	    }
	  };
	}

	const TAP_DISTANCE_THRESHOLD = 10;
	const TAP_GESTURE_MAX_DUR = 300;
	const TAP_DBLCLICK_MAX_DUR = 300;
	const DEFAULT_EVENT_SOURCE = {};

	const domPointerMotionEventTypes = [
	  'mousemove',
	  'mouseout',
	  'touchmove'
	];
	const domPointerActionEventTypes = [
	  'mousedown',
	  'mouseup',
	  'click',
	  'dblclick',
	  'wheel',
	  'touchstart',
	  'touchend',
	  'touchcancel'
	];
	const dropEventTypes = [
	  'mouseup',
	  'touchend',
	  'touchcancel'
	];
	const pointerActionEventTypeMappings = {
	  'touchstart': 'mousedown',
	  'touchend': 'mouseup',
	  'touchcancel': 'mouseup'
	};

	const touchDragPropsToNormalize = ['clientX', 'clientY', 'screenX', 'screenY', 'pageX', 'pageY'];

	class SyntheticEvent {
	  constructor(nativeEvent, type, target, relatedTarget, extraProps) {
	    // Copy native event properties - TODO investigate using a Proxy
	    for (let prop in nativeEvent) {
	      // NOTE: we don't check hasOwnProperty in this loop because properties that will return
	      // false for properties that are defined by getters on inherited prototypes
	      if (typeof nativeEvent[prop] !== 'function') {
	        this[prop] = nativeEvent[prop];
	      }
	    }

	    // Adjust to custom params
	    this.target = target;
	    this.relatedTarget = relatedTarget;
	    this.type = type;
	    this.nativeEvent = nativeEvent;
	    assign$6(this, extraProps);

	    // normalize position properties on touch events with a single touch, to facilitate
	    // downstream handlers that expect them to look like mouse events
	    // NOTE: can't do this in _normalizePointerEvent() as these props are unwritable on native Event objects
	    if (nativeEvent.touches) {
	      let touches = isTouchEndOrCancel(nativeEvent) ? nativeEvent.changedTouches : nativeEvent.touches;
	      if (touches.length === 1) {
	        touchDragPropsToNormalize.forEach(prop => {
	          this[prop] = touches[0][prop];
	        });
	      }
	    }
	  }

	  preventDefault() {
	    this.defaultPrevented = true;
	    this.nativeEvent.preventDefault();
	  }

	  stopPropagation() {
	    this.propagationStopped = true;
	    this.nativeEvent.stopPropagation();
	  }
	}

	function isTouchEndOrCancel(e) {
	  return e.type === 'touchend' || e.type === 'touchcancel'
	}

	function killEvent(e) {
	  e.stopPropagation();
	  e.preventDefault();
	}


	class WorldBaseFacade extends ParentFacade {
	  constructor(element) {
	    super(null);

	    this.width = this.height = 1;
	    this._element = element;
	    this._htmlOverlays = Object.create(null);

	    // Bind events
	    this.eventRegistry = new EventRegistry();
	    this._onPointerMotionEvent = this._onPointerMotionEvent.bind(this);
	    this._onPointerActionEvent = this._onPointerActionEvent.bind(this);
	    this._onDropEvent = this._onDropEvent.bind(this);
	    this._togglePointerListeners(true);
	  }

	  afterUpdate() {
	    this._queueRender();
	    super.afterUpdate();
	  }

	  onNotifyWorld(source, message, data) {
	    let handler = this._notifyWorldHandlers[message];
	    if (handler) {
	      handler.call(this, source, data);
	    }
	  }

	  _isContinuousRender() {
	    return this.continuousRender
	  }

	  /**
	   * @property {{requestAnimationFrame, cancelAnimationFrame}} renderingScheduler
	   * The object holding `requestAnimationFrame` and `cancelAnimationFrame` scheduling
	   * functions. Defaults to `window` but can be switched to another implementation, e.g.
	   * to use an XRSession's custom scheduler.
	   */
	  set renderingScheduler(scheduler) {
	    scheduler = scheduler || window;
	    if (scheduler !== this.renderingScheduler) {
	      const activeHandle = this._nextFrameTimer;
	      if (activeHandle) {
	        this.renderingScheduler.cancelAnimationFrame(activeHandle);
	        this._nextFrameTimer = null;
	      }
	      this._renderingScheduler = scheduler;
	    }
	  }
	  get renderingScheduler() {
	    return this._renderingScheduler || window
	  }

	  // Schedule a render pass on the next frame
	  _queueRender() {
	    if (!this._nextFrameTimer) {
	      const handler = this._nextFrameHandler || (this._nextFrameHandler = (...args) => {
	        let {onStatsUpdate, onBeforeRender, onAfterRender} = this;
	        let start = onStatsUpdate && Date.now();

	        if (onBeforeRender) onBeforeRender(this);

	        this.doRender(...args);

	        if (onStatsUpdate) {
	          let now = Date.now();
	          onStatsUpdate({
	            'Render CPU Time (ms)': now - start,
	            'Time Between Frames (ms)': this._lastFrameTime ? now - this._lastFrameTime : '?',
	            'FPS': this._lastFrameTime ? Math.round(1000 / (now - this._lastFrameTime)) : '?'
	          });
	          this._lastFrameTime = now;
	        }

	        this._doRenderHtmlItems();

	        if (onAfterRender) onAfterRender(this);

	        this._nextFrameTimer = null;

	        if (this._isContinuousRender()) {
	          this._queueRender();
	        }
	      });
	      this._nextFrameTimer = this.renderingScheduler.requestAnimationFrame(handler);
	    }
	  }

	  /**
	   * @abstract
	   */
	  doRender(/*...frameArgs*/) {
	  }

	  /**
	   * @abstract
	   */
	  getFacadeUserSpaceXYZ(/*facade*/) {
	  }

	  _doRenderHtmlItems() {
	    if (this.renderHtmlItems) {
	      let htmlItemsData = [];
	      let overlayFacades = this._htmlOverlays;
	      for (let key in overlayFacades) {
	        let facade = overlayFacades[key];
	        let data = this.getFacadeUserSpaceXYZ(facade);
	        if (data.z >= 0) { //Ignore objects with negative z (behind the camera)
	          data.key = facade.$facadeId;
	          data.html = facade.html;
	          data.exact = facade.exact;
	          htmlItemsData.push(data);
	        }
	      }
	      this.renderHtmlItems(htmlItemsData);
	    }
	  }

	  /**
	   * Hook allowing world implementations to pre-normalize native pointer events, for instance
	   * computing derived worldspace properties that are simpler for downstream code to use.
	   * @param {Event} e
	   * @protected
	   */
	  _normalizePointerEvent(e) {
	  }

	  /**
	   * Entry point for handling events related to pointer motion (e.g. mouse or touch movement).
	   * This will be called by the code that wraps this World facade to bridge native DOM events
	   * into the Troika world.
	   * @param {Event} e
	   */
	  _onPointerMotionEvent(e) {
	    this._normalizePointerEvent(e);
	    const eventState = this._getPointerEventState(e);

	    if (pointerMotionEventTypes.some(this.eventRegistry.hasAnyListenersOfType)) {
	      const hoverInfo = (e.type === 'mouseout' || isTouchEndOrCancel(e)) ? null : this._findHoverTarget(e);
	      let lastHovered = eventState.hoveredFacade;
	      let hovered = eventState.hoveredFacade = hoverInfo && hoverInfo.facade;

	      let dragInfo = eventState.dragInfo;
	      if (dragInfo) {
	        if (!dragInfo.dragStartFired) {
	          this._firePointerEvent('dragstart', dragInfo.dragStartEvent, dragInfo.draggedFacade, null, hoverInfo);
	          dragInfo.dragStartFired = true;
	        }
	        this._firePointerEvent('drag', e, dragInfo.draggedFacade, null, hoverInfo);
	      }

	      if (hovered !== lastHovered) {
	        if (lastHovered) {
	          this._firePointerEvent('mouseout', e, lastHovered, hovered, hoverInfo);
	          if (dragInfo) {
	            this._firePointerEvent('dragleave', e, lastHovered, hovered, hoverInfo);
	          }
	        }
	        if (hovered) {
	          this._firePointerEvent('mouseover', e, hovered, lastHovered, hoverInfo);
	          if (dragInfo) {
	            this._firePointerEvent('dragenter', e, hovered, lastHovered, hoverInfo);
	          }
	        }
	      }
	      if (hovered) {
	        this._firePointerEvent('mousemove', e, hovered, null, hoverInfo);
	        if (dragInfo) {
	          this._firePointerEvent('dragover', e, hovered, null, hoverInfo);
	        }
	      }
	    }

	    // Cancel tap gesture if moving past threshold
	    let tapInfo = eventState.tapInfo;
	    if (tapInfo && e.type === 'touchmove') {
	      let touch = e.changedTouches[0];
	      if (touch && Math.sqrt(Math.pow(touch.clientX - tapInfo.x, 2) + Math.pow(touch.clientY - tapInfo.y, 2)) > TAP_DISTANCE_THRESHOLD) {
	        eventState.tapInfo = null;
	      }
	    }
	  }

	  /**
	   * Entry point for handling events related to pointer motion (e.g. mouse clicks or touch taps).
	   * This will be called by the code that wraps this World facade to bridge native DOM events
	   * into the Troika world.
	   * @param {Event} e
	   */
	  _onPointerActionEvent(e) {
	    this._normalizePointerEvent(e);

	    // Handle drop events, in the case they weren't captured by the listeners on `document`
	    // e.g. synthetic events dispatched internally
	    if (dropEventTypes.indexOf(e.type) > -1) {
	      this._onDropEvent(e);
	    }

	    // Map touch start to mouseover, and disable touch-hold context menu
	    if (e.type === 'touchstart') {
	      if (e.touches.length === 1) {
	        this._onPointerMotionEvent(e);
	      }
	      this._enableContextMenu(false);
	    }

	    const eventRegistry = this.eventRegistry;
	    if (eventRegistry.hasAnyListenersOfType('dragstart') || pointerActionEventTypes.some(eventRegistry.hasAnyListenersOfType)) {
	      let hoverInfo = this._findHoverTarget(e);
	      let facade = hoverInfo && hoverInfo.facade;
	      if (facade) {
	        const eventState = this._getPointerEventState(e);
	        this._firePointerEvent(pointerActionEventTypeMappings[e.type] || e.type, e, facade, null, hoverInfo);

	        // touchstart/touchend could be start/end of a tap - map to click
	        if (eventRegistry.findBubblingEventTarget(facade, 'click') || eventRegistry.findBubblingEventTarget(facade, 'dblclick')) {
	          let tapInfo = eventState.tapInfo;
	          if (e.type === 'touchstart' && e.touches.length === 1) {
	            eventState.tapInfo = {
	              facade: facade,
	              x: e.touches[0].clientX,
	              y: e.touches[0].clientY,
	              startTime: Date.now(),
	              isDblClick: tapInfo && Date.now() - tapInfo.startTime < TAP_DBLCLICK_MAX_DUR
	            };
	          } else {
	            if (
	              tapInfo && tapInfo.facade === facade && e.type === 'touchend' &&
	              e.touches.length === 0 && e.changedTouches.length === 1 &&
	              Date.now() - tapInfo.startTime < TAP_GESTURE_MAX_DUR
	            ) {
	              this._firePointerEvent('click', e, facade, null, hoverInfo);
	              if (tapInfo.isDblClick) {
	                this._firePointerEvent('dblclick', e, facade, null, hoverInfo);
	              }
	            }
	          }
	        }

	        // mousedown/touchstart could be prepping for drag gesture
	        if (e.type === 'mousedown' || e.type === 'touchstart') {
	          const dragger = eventRegistry.findBubblingEventTarget(facade, 'dragstart');
	          if (dragger) {
	            let dragStartEvent = new SyntheticEvent(e, 'dragstart', dragger, null, {intersection: hoverInfo});
	            eventState.dragInfo = {
	              draggedFacade: dragger,
	              dragStartFired: false,
	              dragStartEvent: dragStartEvent
	            };
	            // handle release outside canvas
	            this._toggleDropListeners(true);
	          }
	        }
	      }
	      e.preventDefault(); //prevent e.g. touch scroll
	    }

	    // Map touch end to mouseout
	    if (isTouchEndOrCancel(e)) {
	      if (e.changedTouches.length === 1) {
	        this._onPointerMotionEvent(e);
	      }
	      this._enableContextMenu(true);
	    }
	  }

	  _onDropEvent(e) {
	    const eventState = this._getPointerEventState(e);
	    let dragInfo = eventState.dragInfo;
	    if (dragInfo) {
	      this._normalizePointerEvent(e);
	      let hoverInfo = this._findHoverTarget(e);
	      let targetFacade = hoverInfo && hoverInfo.facade;
	      if (targetFacade) {
	        this._firePointerEvent('drop', e, targetFacade, null, hoverInfo);
	      }
	      this._firePointerEvent('dragend', e, dragInfo.draggedFacade, null, hoverInfo);
	      this._toggleDropListeners(false);
	      eventState.dragInfo = null;
	    }
	  }

	  _firePointerEvent(eventType, originalEvent, targetFacade, relatedTargetFacade, intersection) {
	    let newEvent = (originalEvent instanceof SyntheticEvent) ?
	      originalEvent :
	      new SyntheticEvent(
	        originalEvent,
	        eventType,
	        targetFacade,
	        relatedTargetFacade,
	        {
	          bubbles: true,
	          intersection
	        }
	      );
	    // Dispatch with bubbling
	    this.eventRegistry.dispatchEventOnFacade(targetFacade, newEvent);
	  }

	  _getPointerEventState(e) {
	    const states = this._pointerEventStates || (this._pointerEventStates = new WeakMap());
	    const eventSource = e.eventSource || DEFAULT_EVENT_SOURCE;
	    let eventState = states.get(eventSource);
	    if (!eventState) {
	      states.set(eventSource, eventState = {});
	    }
	    return eventState
	  }

	  _toggleDropListeners(on) {
	    dropEventTypes.forEach(type => {
	      document[(on ? 'add' : 'remove') + 'EventListener'](type, this._onDropEvent, true);
	    });
	  }

	  _togglePointerListeners(on) {
	    let canvas = this._element;
	    if (canvas && on !== this._pointerListenersAttached) {
	      let method = (on ? 'add' : 'remove') + 'EventListener';
	      domPointerMotionEventTypes.forEach(type => {
	        canvas[method](type, this._onPointerMotionEvent, false);
	      });
	      domPointerActionEventTypes.forEach(type => {
	        canvas[method](type, this._onPointerActionEvent, false);
	      });
	      this._pointerListenersAttached = on;
	    }
	  }

	  _enableContextMenu(enable) {
	    let canvas = this._element;
	    if (canvas) {
	      canvas[(enable ? 'remove' : 'add') + 'EventListener']('contextmenu', killEvent, true);
	    }
	  }

	  /**
	   * @abstract
	   * Given a pointer-related Event, find and return all facade objects that are intersected
	   * by that event. If any hits are found, this should return an array of objects that contain
	   * at least `facade` and `distance` properties. Any additional properties will be exposed to
	   * event listeners on the synthetic event object as an `intersection` property.
	   * @param {Event} e
	   * @param {Function} [filterFn]
	   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
	   */
	  getFacadesAtEvent(e, filterFn) {
	    throw new Error('getFacadesAtEvent: no impl')
	  }

	  _findHoverTarget(e) {
	    //only handle single touches for now
	    if (e.touches && e.touches.length > 1) {
	      return null
	    }

	    let allHits = this.getFacadesAtEvent(e, facade =>
	      facade.isPointerEventTarget && facade.interceptsPointerEvents(this.eventRegistry)
	    );
	    if (allHits) {
	      // Find the closest by comparing distance, or distanceBias if distance is the same
	      let closestHit = allHits[0];
	      for (let i = 1; i < allHits.length; i++) {
	        if (allHits[i].distance < closestHit.distance ||
	          (allHits[i].distance === closestHit.distance && (allHits[i].distanceBias || 0) < (closestHit.distanceBias || 0))
	        ) {
	          closestHit = allHits[i];
	        }
	      }
	      return closestHit
	    }

	    return null
	  }

	  destructor() {
	    if (this._nextFrameTimer) {
	      this.renderingScheduler.cancelAnimationFrame(this._nextFrameTimer);
	    }
	    this._togglePointerListeners(false);
	    this._toggleDropListeners(false);
	    super.destructor();
	  }

	}

	Object.defineProperty(WorldBaseFacade.prototype, 'isWorld', {value: true});

	WorldBaseFacade.prototype._notifyWorldHandlers = {
	  needsRender() {
	    this._queueRender();
	  },
	  addEventListener(source, data) {
	    this.eventRegistry.addListenerForFacade(source, data.type, data.handler);
	  },
	  removeEventListener(source, data) {
	    this.eventRegistry.removeListenerForFacade(source, data.type, data.handler);
	  },
	  removeAllEventListeners(source) {
	    this.eventRegistry.removeAllListenersForFacade(source);
	  },
	  dispatchEvent(source, event) {
	    if (!(event instanceof SyntheticEvent)) {
	      event = new SyntheticEvent(event, event.type, event.target, event.relatedTarget);
	    }
	    this.eventRegistry.dispatchEventOnFacade(source, event);
	  },
	  addHtmlOverlay(source) {
	    this._htmlOverlays[source.$facadeId] = source;
	  },
	  removeHtmlOverlay(source) {
	    delete this._htmlOverlays[source.$facadeId];
	  },
	  statsUpdate(source, data) {
	    let onStatsUpdate = this.onStatsUpdate;
	    if (onStatsUpdate) onStatsUpdate(data);
	  }
	};

	/**
	 * Regular expression for matching the `void main() {` opener line in GLSL.
	 * @type {RegExp}
	 */
	const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;

	/**
	 * Recursively expands all `#include <xyz>` statements within string of shader code.
	 * Copied from three's WebGLProgram#parseIncludes for external use.
	 *
	 * @param {string} source - The GLSL source code to evaluate
	 * @return {string} The GLSL code with all includes expanded
	 */
	function expandShaderIncludes( source ) {
	  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
	  function replace(match, include) {
	    let chunk = ShaderChunk[include];
	    return chunk ? expandShaderIncludes(chunk) : match
	  }
	  return source.replace( pattern, replace )
	}

	/*
	 * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three
	 * versions before 0.113.0 as it was changed from Math to MathUtils in that version.
	 * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16
	 */

	const _lut = [];

	for (let i = 0; i < 256; i++) {
	  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
	}

	function generateUUID() {

	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	  const d0 = Math.random() * 0xffffffff | 0;
	  const d1 = Math.random() * 0xffffffff | 0;
	  const d2 = Math.random() * 0xffffffff | 0;
	  const d3 = Math.random() * 0xffffffff | 0;
	  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
	    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
	    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
	    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

	  // .toUpperCase() here flattens concatenated strings to save heap memory space.
	  return uuid.toUpperCase()

	}

	// Local assign polyfill to avoid importing troika-core
	const assign$5 = Object.assign || function(/*target, ...sources*/) {
	  let target = arguments[0];
	  for (let i = 1, len = arguments.length; i < len; i++) {
	    let source = arguments[i];
	    if (source) {
	      for (let prop in source) {
	        if (Object.prototype.hasOwnProperty.call(source, prop)) {
	          target[prop] = source[prop];
	        }
	      }
	    }
	  }
	  return target
	};


	const epoch = Date.now();
	const CONSTRUCTOR_CACHE = new WeakMap();
	const SHADER_UPGRADE_CACHE = new Map();

	// Material ids must be integers, but we can't access the increment from Three's `Material` module,
	// so let's choose a sufficiently large starting value that should theoretically never collide.
	let materialInstanceId = 1e10;

	/**
	 * A utility for creating a custom shader material derived from another material's
	 * shaders. This allows you to inject custom shader logic and transforms into the
	 * builtin ThreeJS materials without having to recreate them from scratch.
	 *
	 * @param {THREE.Material} baseMaterial - the original material to derive from
	 *
	 * @param {Object} options - How the base material should be modified.
	 * @param {Object} options.defines - Custom `defines` for the material
	 * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`
	 * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can
	 *        be accessed and manipulated via the resulting material's `uniforms` property, just like
	 *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.
	 * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into
	 *        both shaders, and it will automatically be updated on each render frame with a number of
	 *        elapsed milliseconds. The "zero" epoch time is not significant so don't rely on this as a
	 *        true calendar time.
	 * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level
	 *        definitions, above the `void main()` function.
	 * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex
	 *        shader's `void main` function.
	 * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex
	 *        shader's `void main` function.
	 * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,
	 *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with
	 *        those attributes exposed by their normal names as read/write values.
	 * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level
	 *        definitions, above the `void main()` function.
	 * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment
	 *        shader's `void main` function.
	 * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment
	 *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes
	 *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you
	 *        want those to apply to your changes use `fragmentColorTransform` instead.
	 * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`
	 *        output value. Will be injected near the end of the `void main` function, but before any
	 *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the
	 *        `fragmentMainOutro`.
	 * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function
	 *        for performing custom rewrites of the full shader code. Useful if you need to do something
	 *        special that's not covered by the other builtin options. This function will be executed before
	 *        any other transforms are applied.
	 * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base
	 *        material, rather than the default behavior of copying it. This allows the derived material to
	 *        automatically pick up changes made to the base material and its properties. This can be useful
	 *        where the derived material is hidden from the user as an implementation detail, allowing them
	 *        to work with the original material like normal. But it can result in unexpected behavior if not
	 *        handled carefully.
	 *
	 * @return {THREE.Material}
	 *
	 * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,
	 * which can be called to get a variant of the derived material for use in shadow casting. If the
	 * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`
	 * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to
	 * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These
	 * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look
	 * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance
	 * scenarios, e.g. skipping antialiasing or expensive shader logic.
	 */
	function createDerivedMaterial(baseMaterial, options) {
	  // Generate a key that is unique to the content of these `options`. We'll use this
	  // throughout for caching and for generating the upgraded shader code. This increases
	  // the likelihood that the resulting shaders will line up across multiple calls so
	  // their GL programs can be shared and cached.
	  const optionsKey = getKeyForOptions(options);

	  // First check to see if we've already derived from this baseMaterial using this
	  // unique set of options, and if so reuse the constructor to avoid some allocations.
	  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
	  if (!ctorsByDerivation) {
	    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));
	  }
	  if (ctorsByDerivation[optionsKey]) {
	    return new ctorsByDerivation[optionsKey]()
	  }

	  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;

	  // Private onBeforeCompile handler that injects the modified shaders and uniforms when
	  // the renderer switches to this material's program
	  const onBeforeCompile = function (shaderInfo, renderer) {
	    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);

	    // Upgrade the shaders, caching the result by incoming source code
	    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;
	    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
	    if (!upgradedShaders) {
	      const upgraded = upgradeShaders$1(this, shaderInfo, options, optionsKey);
	      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
	    }

	    // Inject upgraded shaders and uniforms into the program
	    shaderInfo.vertexShader = upgradedShaders.vertexShader;
	    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
	    assign$5(shaderInfo.uniforms, this.uniforms);

	    // Inject auto-updating time uniform if requested
	    if (options.timeUniform) {
	      shaderInfo.uniforms[options.timeUniform] = {
	        get value() {return Date.now() - epoch}
	      };
	    }

	    // Users can still add their own handlers on top of ours
	    if (this[privateBeforeCompileProp]) {
	      this[privateBeforeCompileProp](shaderInfo);
	    }
	  };

	  const DerivedMaterial = function DerivedMaterial() {
	    return derive(options.chained ? baseMaterial : baseMaterial.clone())
	  };

	  const derive = function(base) {
	    // Prototype chain to the base material
	    const derived = Object.create(base, descriptor);

	    // Store the baseMaterial for reference; this is always the original even when cloning
	    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });

	    // Needs its own ids
	    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });
	    derived.uuid = generateUUID();

	    // Merge uniforms, defines, and extensions
	    derived.uniforms = assign$5({}, base.uniforms, options.uniforms);
	    derived.defines = assign$5({}, base.defines, options.defines);
	    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material
	    derived.extensions = assign$5({}, base.extensions, options.extensions);

	    // Don't inherit EventDispatcher listeners
	    derived._listeners = undefined;

	    return derived
	  };

	  const descriptor = {
	    constructor: {value: DerivedMaterial},
	    isDerivedMaterial: {value: true},

	    customProgramCacheKey: {
	      writable: true,
	      configurable: true,
	      value: function () {
	        return baseMaterial.customProgramCacheKey() + '|' + optionsKey
	      }
	    },

	    onBeforeCompile: {
	      get() {
	        return onBeforeCompile
	      },
	      set(fn) {
	        this[privateBeforeCompileProp] = fn;
	      }
	    },

	    copy: {
	      writable: true,
	      configurable: true,
	      value: function (source) {
	        baseMaterial.copy.call(this, source);
	        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
	          assign$5(this.extensions, source.extensions);
	          assign$5(this.defines, source.defines);
	          assign$5(this.uniforms, UniformsUtils.clone(source.uniforms));
	        }
	        return this
	      }
	    },

	    clone: {
	      writable: true,
	      configurable: true,
	      value: function () {
	        const newBase = new baseMaterial.constructor();
	        return derive(newBase).copy(this)
	      }
	    },

	    /**
	     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
	     * transformations and discarded fragments.
	     */
	    getDepthMaterial: {
	      writable: true,
	      configurable: true,
	      value: function() {
	        let depthMaterial = this._depthMaterial;
	        if (!depthMaterial) {
	          depthMaterial = this._depthMaterial = createDerivedMaterial(
	            baseMaterial.isDerivedMaterial
	              ? baseMaterial.getDepthMaterial()
	              : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
	            options
	          );
	          depthMaterial.defines.IS_DEPTH_MATERIAL = '';
	          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
	        }
	        return depthMaterial
	      }
	    },

	    /**
	     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
	     * transformations and discarded fragments.
	     */
	    getDistanceMaterial: {
	      writable: true,
	      configurable: true,
	      value: function() {
	        let distanceMaterial = this._distanceMaterial;
	        if (!distanceMaterial) {
	          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
	            baseMaterial.isDerivedMaterial
	              ? baseMaterial.getDistanceMaterial()
	              : new MeshDistanceMaterial(),
	            options
	          );
	          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';
	          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
	        }
	        return distanceMaterial
	      }
	    },

	    dispose: {
	      writable: true,
	      configurable: true,
	      value() {
	        const {_depthMaterial, _distanceMaterial} = this;
	        if (_depthMaterial) _depthMaterial.dispose();
	        if (_distanceMaterial) _distanceMaterial.dispose();
	        baseMaterial.dispose.call(this);
	      }
	    }
	  };

	  ctorsByDerivation[optionsKey] = DerivedMaterial;
	  return new DerivedMaterial()
	}


	function upgradeShaders$1(material, {vertexShader, fragmentShader}, options, key) {
	  let {
	    vertexDefs,
	    vertexMainIntro,
	    vertexMainOutro,
	    vertexTransform,
	    fragmentDefs,
	    fragmentMainIntro,
	    fragmentMainOutro,
	    fragmentColorTransform,
	    customRewriter,
	    timeUniform
	  } = options;

	  vertexDefs = vertexDefs || '';
	  vertexMainIntro = vertexMainIntro || '';
	  vertexMainOutro = vertexMainOutro || '';
	  fragmentDefs = fragmentDefs || '';
	  fragmentMainIntro = fragmentMainIntro || '';
	  fragmentMainOutro = fragmentMainOutro || '';

	  // Expand includes if needed
	  if (vertexTransform || customRewriter) {
	    vertexShader = expandShaderIncludes(vertexShader);
	  }
	  if (fragmentColorTransform || customRewriter) {
	    // We need to be able to find postprocessing chunks after include expansion in order to
	    // put them after the fragmentColorTransform, so mark them with comments first. Even if
	    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,
	    // so we still mark them.
	    fragmentShader = fragmentShader.replace(
	      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
	      '\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n'
	    );
	    fragmentShader = expandShaderIncludes(fragmentShader);
	  }

	  // Apply custom rewriter function
	  if (customRewriter) {
	    let res = customRewriter({vertexShader, fragmentShader});
	    vertexShader = res.vertexShader;
	    fragmentShader = res.fragmentShader;
	  }

	  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract
	  // those and re-insert them into the outro in the correct place:
	  if (fragmentColorTransform) {
	    let postChunks = [];
	    fragmentShader = fragmentShader.replace(
	      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines
	      match => {
	        postChunks.push(match);
	        return ''
	      }
	    );
	    fragmentMainOutro = `${fragmentColorTransform}\n${postChunks.join('\n')}\n${fragmentMainOutro}`;
	  }

	  // Inject auto-updating time uniform if requested
	  if (timeUniform) {
	    const code = `\nuniform float ${timeUniform};\n`;
	    vertexDefs = code + vertexDefs;
	    fragmentDefs = code + fragmentDefs;
	  }

	  // Inject a function for the vertexTransform and rename all usages of position/normal/uv
	  if (vertexTransform) {
	    // Hoist these defs to the very top so they work in other function defs
	    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
	    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
	    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
	    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
	      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`
	    });

	    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'
	    // Perhaps the other textures too going forward?
	    if (!(material.map && material.map.channel > 0)) {
	      vertexShader = vertexShader.replace(/\bMAP_UV\b/g, `troika_uv_${key}`);
	    }
	  }

	  // Inject defs and intro/outro snippets
	  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
	  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);

	  return {
	    vertexShader,
	    fragmentShader
	  }
	}

	function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
	  if (intro || outro || defs) {
	    shaderCode = shaderCode.replace(voidMainRegExp, `
${defs}
void troikaOrigMain${id}() {`
	    );
	    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
	  }
	  return shaderCode
	}


	function optionsJsonReplacer(key, value) {
	  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value
	}

	let _idCtr = 0;
	const optionsHashesToIds = new Map();
	function getKeyForOptions(options) {
	  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
	  let id = optionsHashesToIds.get(optionsHash);
	  if (id == null) {
	    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));
	  }
	  return id
	}

	// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders
	// TODO how can we keep this from getting stale?
	const MATERIAL_TYPES_TO_SHADERS = {
	  MeshDepthMaterial: 'depth',
	  MeshDistanceMaterial: 'distanceRGBA',
	  MeshNormalMaterial: 'normal',
	  MeshBasicMaterial: 'basic',
	  MeshLambertMaterial: 'lambert',
	  MeshPhongMaterial: 'phong',
	  MeshToonMaterial: 'toon',
	  MeshStandardMaterial: 'physical',
	  MeshPhysicalMaterial: 'physical',
	  MeshMatcapMaterial: 'matcap',
	  LineBasicMaterial: 'basic',
	  LineDashedMaterial: 'dashed',
	  PointsMaterial: 'points',
	  ShadowMaterial: 'shadow',
	  SpriteMaterial: 'sprite'
	};

	/**
	 * Given a Three.js `Material` instance, find the shaders/uniforms that will be
	 * used to render that material.
	 *
	 * @param material - the Material instance
	 * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`
	 */
	function getShadersForMaterial(material) {
	  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];
	  return builtinType ? ShaderLib[builtinType] : material //TODO fallback for unknown type?
	}

	/**
	 * Find all uniforms and their types within a shader code string.
	 *
	 * @param {string} shader - The shader code to parse
	 * @return {object} mapping of uniform names to their glsl type
	 */
	function getShaderUniformTypes(shader) {
	  let uniformRE = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g;
	  let uniforms = Object.create(null);
	  let match;
	  while ((match = uniformRE.exec(shader)) !== null) {
	    uniforms[match[2]] = match[1];
	  }
	  return uniforms
	}

	/**
	 * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion
	 * that happened in ThreeJS r123.
	 * @param {Matrix4} srcMatrix
	 * @param {Matrix4} [tgtMatrix]
	 */
	function invertMatrix4(srcMatrix, tgtMatrix = new Matrix4()) {
	  if (typeof tgtMatrix.invert === 'function') {
	    tgtMatrix.copy(srcMatrix).invert();
	  } else {
	    tgtMatrix.getInverse(srcMatrix);
	  }
	  return tgtMatrix
	}

	const {assign: assign$3, forOwn: forOwn$1} = utils;
	const singletonVec3 = new Vector3();
	const singletonVec3b = new Vector3();
	const notifyWorldGetter = (function() {
	  const obj = {
	    callback: function(pos) {
	      obj.value = pos;
	    },
	    value: null
	  };
	  return obj
	})();
	const removedEvent = {type: 'removed'};
	const singletonIntersects = [];

	function ascDistanceSort(a, b) {
	  return a.distance - b.distance
	}

	function canObjectBeOrphaned(obj) {
	  return obj.isRenderable === false && (
	    !obj.children.length || obj.children.every(canObjectBeOrphaned)
	  )
	}

	let _worldMatrixVersion = 0;
	let _geometrySphereVersion = 0;

	class Object3DFacade extends PointerEventTarget {
	  constructor(parent, threeObject) {
	    super(parent);

	    if (!threeObject) {
	      threeObject = this.initThreeObject();
	    }

	    // We'll track matrix updates manually
	    threeObject.matrixAutoUpdate = false;

	    // Set bidirectional refs
	    this.threeObject = threeObject;
	    threeObject.$facade = this;

	    // Subclasses may set isRenderable=false on the threeObject, to trigger some scene graph optimizations.
	    // The first is to remove it from all layer masks to short-circuit WebGLRenderer.projectObject.
	    let isRenderable = threeObject.isRenderable !== false;
	    if (!isRenderable) {
	      threeObject.layers.mask = 0;
	    }

	    // Add it as a child of the nearest parent threeObject, if one exists
	    while (parent) {
	      if (parent.isObject3DFacade) {
	        this._parentObject3DFacade = parent; //reference to nearest Object3DFacade ancestor
	        if (isRenderable) {
	          this._addToThreeObjectTree();
	        }
	        break
	      }
	      parent = parent.parent;
	    }

	    this.notifyWorld('object3DAdded');
	  }

	  /**
	   * Lifecycle method, called at constructor time, that creates and returns a Three.js `Object3D`
	   * instance which will become the `threeObject` for this facade. This is a more ergonomic
	   * alternative than overriding the constructor to pass the `threeObject` as a second argument
	   * to the super() call. By default it creates a plain Object3D marked as non-renderable so it
	   * is not added to the Three.js tree.
	   * @return {Object3D}
	   * @protected
	   */
	  initThreeObject() {
	    const obj = new Object3D();
	    obj.isRenderable = false; //trigger optimizations
	    return obj
	  }

	  afterUpdate() {
	    // Update matrix and worldMatrix before processing children
	    this.updateMatrices();
	    this._checkBoundsChange();

	    // If the world matrix was modified, and we won't be doing an update pass on child facades due
	    // to `shouldUpdateChildren` optimization, we need to manually update their matrices to match.
	    if (this._worldMatrixVersion > this._worldMatrixVersionAfterLastUpdate) {
	      if (!this.shouldUpdateChildren()) {
	        this.traverse((facade, rootFacade) => {
	          if (facade !== rootFacade && facade.updateMatrices) {
	            facade.updateMatrices();
	            facade._checkBoundsChange();
	          }
	        }, this);
	      }
	      this._worldMatrixVersionAfterLastUpdate = this._worldMatrixVersion;
	    }

	    // Process children
	    super.afterUpdate();

	    // If any children were removed during the update, remove them from the threejs
	    // object in a single batch; this avoids threejs's very expensive single-item remove.
	    this._flushQueuedChildRemovals();
	  }

	  /**
	   * Update the underlying threeObject's `matrix` and `matrixWorld` to the current state if necessary.
	   * This bypasses the `updateMatrix` and `updateMatrixWorld` methods of the threejs objects with a more
	   * efficient approach that doesn't require traversing the entire tree prior to every render. This is possible
	   * since we control the update lifecycle; as long as this is called from the `afterUpdate` lifecycle
	   * method or later, it can be safely assumed that the world matrices of all ancestors have already been
	   * similarly updated so the result should always be accurate.
	   */
	  updateMatrices() {
	    let threeObj = this.threeObject;
	    let parent3DFacade = this._parentObject3DFacade;
	    let needsWorldMatrixUpdate;
	    if (this._matrixChanged) {
	      threeObj.matrix.compose(threeObj.position, threeObj.quaternion, threeObj.scale);
	      this._matrixChanged = false;
	      needsWorldMatrixUpdate = true;
	    } else {
	      needsWorldMatrixUpdate = parent3DFacade && parent3DFacade._worldMatrixVersion > this._worldMatrixVersion;
	    }
	    if (needsWorldMatrixUpdate) {
	      if (parent3DFacade) {
	        threeObj.matrixWorld.multiplyMatrices(parent3DFacade.threeObject.matrixWorld, threeObj.matrix);
	      } else {
	        threeObj.matrixWorld.copy(threeObj.matrix);
	      }

	      // If the threeObject has children that were manually added (not managed by facades), we'll need to update them too
	      // TODO can we determine this state without a full loop that will likely return nothing?
	      let threeKids = threeObj.children;
	      for (let i = 0, len = threeKids.length; i < len; i++) {
	        if (!threeKids[i].$facade) {
	          threeKids[i].updateMatrixWorld(true);
	        }
	      }

	      this.markWorldMatrixDirty();
	    }
	  }

	  /**
	   * If the `threeObject.matrixWorld` is modified manually instead of via the individual transformation
	   * properties, you can call this to tell the facade its caches need to be recalculated.
	   */
	  markWorldMatrixDirty() {
	    this._worldMatrixVersion = ++_worldMatrixVersion;
	    this._boundsChanged = true;
	  }

	  _checkBoundsChange() {
	    let changed = this._boundsChanged;
	    if (!changed) {
	      const geomSphere = this._getGeometryBoundingSphere();
	      if (geomSphere && geomSphere.version !== this._lastGeometrySphereVersion) {
	        changed = true;
	        this._lastGeometrySphereVersion = geomSphere.version;
	      }
	    }
	    if (changed) {
	      this.notifyWorld('object3DBoundsChanged');
	      this._boundsChanged = false;
	    }
	  }

	  /**
	   * Get this object's current position in world space
	   * @param {Vector3} [vec3] - optional Vector3 object to populate with the position;
	   *                  if not passed in a new one will be created.
	   * @returns {Vector3}
	   */
	  getWorldPosition(vec3 ) {
	    this.updateMatrices();
	    return (vec3 || new Vector3()).setFromMatrixPosition(this.threeObject.matrixWorld)
	  }

	  /**
	   * Get the current position vector of the world's camera.
	   * @param {Vector3} [vec3] - optional Vector3 object to populate with the position;
	   *                  if not passed in a new one will be created.
	   * @returns {Vector3}
	   */
	  getCameraPosition(vec3 ) {
	    vec3 = vec3 || new Vector3();
	    this.notifyWorld('getCameraPosition', vec3);
	    return vec3
	  }

	  /**
	   * Get the facade object for the world's camera. Can be used to get to low-level info
	   * about the camera such as its various matrices, but be careful not to make modifications
	   * to the camera as that can lead to things getting out of sync.
	   * @returns {Camera3DFacade}
	   */
	  getCameraFacade() {
	    notifyWorldGetter.value = null;
	    this.notifyWorld('getCameraFacade', notifyWorldGetter);
	    return notifyWorldGetter.value
	  }

	  /**
	   * Calculate the distance in world units between this object's origin and the camera.
	   * @returns {Number}
	   */
	  getCameraDistance() {
	    let cameraPos = this.getCameraPosition(singletonVec3b);
	    let objectPos = this.getWorldPosition(singletonVec3);
	    return cameraPos.distanceTo(objectPos)
	  }

	  /**
	   * Get the current projected user space position for this object, or for a specific position
	   * in its object space.
	   * @returns {Vector3} x and y are in screen pixels, z is worldspace distance from camera. The
	   *                    z may be negative, which means it is out of view behind the camera.
	   */
	  getProjectedPosition(x, y, z) {
	    this.updateMatrices();
	    notifyWorldGetter.value = null;
	    notifyWorldGetter.worldPosition = singletonVec3.set(x || 0, y || 0, z || 0).applyMatrix4(this.threeObject.matrixWorld);
	    this.notifyWorld('projectWorldPosition', notifyWorldGetter);
	    return notifyWorldGetter.value
	  }

	  /**
	   * Get the facade object for the world's scene.
	   * @returns {Scene3DFacade}
	   */
	  getSceneFacade() {
	    notifyWorldGetter.value = null;
	    this.notifyWorld('getSceneFacade', notifyWorldGetter);
	    return notifyWorldGetter.value
	  }

	  /**
	   * Return a {@link Sphere} encompassing the bounds of this object in worldspace, or `null` if
	   * it has no physical bounds. This is used for optimized raycasting.
	   *
	   * The default implementation attempts to be as efficient as possible, only updating the sphere
	   * when necessary, and assumes the threeObject has a geometry that accurately describes its bounds.
	   * Override this method to provide custom bounds calculation logic, for example when additional meshes
	   * need to be checked or a vertex shader manipulates the geometry; you'll probably also need to override
	   * {@link #raycast} to match.
	   *
	   * TODO: this needs to be easier to override without having to reimplement large chunks of logic
	   */
	  getBoundingSphere() {
	    // Get the geometry's current bounding sphere
	    let geomSphere = this._getGeometryBoundingSphere();
	    if (!geomSphere) return null

	    // Ensure world matrix is up to date
	    this.updateMatrices();

	    // Lazily create our Sphere
	    let sphere = this._boundingSphere;
	    if (!sphere) {
	      sphere = this._boundingSphere = new Sphere();
	    }

	    // If the geometry, the geometry's bounding sphere, or this object's world matrix changed,
	    // update our bounding sphere to match them.
	    if (sphere._geometrySphereVersion !== geomSphere.version || sphere._worldMatrixVersion !== this._worldMatrixVersion) {
	      sphere.copy(geomSphere);
	      sphere.applyMatrix4(this.threeObject.matrixWorld);
	      sphere._worldMatrixVersion = this._worldMatrixVersion;
	      sphere._geometrySphereVersion = geomSphere.version;
	    }

	    return sphere
	  }

	  /**
	   * Ensure the object's geometry, if any, has an up-to-date bounding Sphere, and return that Sphere.
	   * The returned Sphere will be assigned a unique `version` property when it is modified, which can
	   * be used elsewhere for tracking changes.
	   * @private
	   */
	  _getGeometryBoundingSphere() {
	    const geometry = this.getGeometry();
	    if (geometry) {
	      let geomSphere = geometry.boundingSphere;
	      let geomSphereChanged = false;
	      if (geomSphere) {
	        if (geometry.isBufferGeometry) {
	          // For a BufferGeometry we can look at the `position` attribute's `version` (incremented
	          // when the user sets `geom.needsUpdate = true`) to detect the need for bounds recalc
	          const posAttr = geometry.attributes.position;
	          if (posAttr && geomSphere._posAttrVersion !== posAttr.version) {
	            geometry.computeBoundingSphere();
	            geomSphere._posAttrVersion = posAttr.version;
	            geomSphereChanged = true;
	          }
	        } else {
	          // For a non-buffer Geometry (not recommended!) users will have to manually call
	          // `geom.computeBoundingSphere()` after changing its vertices, and we'll do a brute force
	          // check for changes to the sphere's properties
	          if (!geometry._lastBoundingSphere || !geomSphere.equals(geometry._lastBoundingSphere)) {
	            geometry._lastBoundingSphere = geomSphere.clone();
	            geomSphereChanged = true;
	          }
	        }
	      } else {
	        geometry.computeBoundingSphere();
	        geomSphere = geometry.boundingSphere;
	        geomSphereChanged = true;
	      }
	      if (geomSphereChanged) {
	        geomSphere.version = ++_geometrySphereVersion;
	      }
	      return geomSphere
	    } else {
	      return null
	    }
	  }

	  /**
	   * @protected Extension point for subclasses that don't use their threeObject's geometry, e.g. Instanceable
	   */
	  getGeometry() {
	    const obj = this.threeObject;
	    return obj && obj.geometry
	  }

	  /**
	   * Determine if this facade's threeObject intersects a Raycaster. Override this method to provide
	   * custom raycasting logic, for example when additional meshes need to be checked or a vertex shader
	   * manipulates the geometry; you'll probably also need to override {@link #getBoundingSphere} to match.
	   *
	   * The return value can be:
	   *   - An array of hit objects for this facade, matching the format returned by `Raycaster.intersectObject`
	   *   - `null`, if this facade has no hits
	   */
	  raycast(raycaster) {
	    return this.threeObject ? this._raycastObject(this.threeObject, raycaster) : null
	  }

	  /**
	   * Custom optimized raycast that, unlike Raycaster.intersectObject(), avoids creating a
	   * new array unless there are actually hits. It also supports the custom `raycastSide`
	   * override property, hit on sides other than the material's configured `side`.
	   * @protected
	   */
	  _raycastObject(obj, raycaster) {
	    if (obj.visible) {
	      singletonIntersects.length = 0;
	      let origSide = null;
	      const raycastSide = this.raycastSide;
	      if (raycastSide != null) {
	        origSide = obj.material.side;
	        obj.material.side = raycastSide;
	      }
	      obj.raycast(raycaster, singletonIntersects);
	      if (origSide !== null) {
	        obj.material.side = origSide;
	      }
	      if (singletonIntersects.length) {
	        singletonIntersects.sort(ascDistanceSort);
	        return singletonIntersects.slice()
	      }
	    }
	    return null
	  }

	  _addToThreeObjectTree() {
	    let parent = this._parentObject3DFacade;
	    if (parent) {
	      if (this.threeObject.parent !== parent.threeObject) {
	        parent.threeObject.add(this.threeObject);
	        parent._addToThreeObjectTree();
	      }
	    }
	  }

	  _queueRemoveChildObject3D(threeObjectId) {
	    let removeChildIds = this._removeChildIds || (this._removeChildIds = Object.create(null));
	    removeChildIds[threeObjectId] = true;
	  }

	  _flushQueuedChildRemovals() {
	    // If any children were queued for removal, remove them from the threejs
	    // object in a single batch; this avoids threejs's very expensive single-item remove.
	    if (this._removeChildIds) {
	      let threeObject = this.threeObject;
	      let removeChildIds = this._removeChildIds;
	      threeObject.children = threeObject.children.filter(child => {
	        if (child.id in removeChildIds) {
	          child.parent = null;
	          child.dispatchEvent(removedEvent);
	          return false
	        }
	        return true
	      });

	      // If that resulted in a non-renderable object having no renderable children,
	      // remove it from the threejs object tree, recursively upward.
	      let parentObj3D = this._parentObject3DFacade;
	      if (canObjectBeOrphaned(threeObject) && parentObj3D && parentObj3D.threeObject === threeObject.parent) {
	        parentObj3D._queueRemoveChildObject3D(threeObject.id);
	        parentObj3D._flushQueuedChildRemovals(); //if we don't force a parent flush, tree can get in a bad state
	      }

	      this._removeChildIds = null;
	    }
	  }

	  destructor() {
	    this.notifyWorld('object3DRemoved');
	    let parentObj3D = this._parentObject3DFacade;
	    if (parentObj3D) {
	      parentObj3D._queueRemoveChildObject3D(this.threeObject.id);
	    }
	    delete this.threeObject;
	    super.destructor();
	  }
	}


	// Convenience setters for Object3D simple properties
	['castShadow', 'receiveShadow', 'renderOrder', 'visible'].forEach(prop => {
	  Object.defineProperty(Object3DFacade.prototype, prop, {
	    get() {
	      return this.threeObject[prop]
	    },
	    set(value) {
	      this.threeObject[prop] = value;
	    }
	  });
	});

	/**
	 * @property {null|number} raycastSide
	 * Hook to force a different `side` than that of the material for mesh raycasting.
	 * Should be set to `FrontSide`|`BackSide`|`DoubleSide`, or `null` to use the
	 * material's side.
	 */
	Object3DFacade.prototype.raycastSide = null;


	// Create flat property setters for individual position/scale/rotation properties
	forOwn$1({
	  position: {
	    x: 'x',
	    y: 'y',
	    z: 'z'
	  },
	  scale: {
	    x: 'scaleX',
	    y: 'scaleY',
	    z: 'scaleZ'
	  },
	  rotation: {
	    x: 'rotateX',
	    y: 'rotateY',
	    z: 'rotateZ',
	    order: 'rotateOrder'
	  },
	  quaternion: {
	    x: 'quaternionX',
	    y: 'quaternionY',
	    z: 'quaternionZ',
	    w: 'quaternionW'
	  }
	}, (attrs, aspect) => {
	  forOwn$1(attrs, (propName, attr) => {
	    // Compile functions to avoid runtime cost of aspect/attr evaluation
	    Object.defineProperty(Object3DFacade.prototype, propName, {
	      get: new Function(`return function ${propName}$get() {
  return this.threeObject.${aspect}.${attr}
}`)(),
	      set: new Function(`return function ${propName}$set(value) {
  //let obj = this.threeObject.${aspect}
  if (this.threeObject.${aspect}.${attr} !== value) {
    this.threeObject.${aspect}.${attr} = value
    if (!this._matrixChanged) {
      this._matrixChanged = true
    }
  }
}`)()
	    });
	  });
	});

	// ...and a special shortcut for uniform scale
	Object.defineProperty(Object3DFacade.prototype, 'scale', {
	  get() {
	    // can't guarantee scale was already uniform, so just use scaleX arbitrarily
	    return this.threeObject.scale.x
	  },
	  set(value) {
	    const scaleObj = this.threeObject.scale;
	    if (value !== scaleObj.x || value !== scaleObj.y || value !== scaleObj.z) {
	      scaleObj.x = scaleObj.y = scaleObj.z = value;
	      if (!this._matrixChanged) {
	        this._matrixChanged = true;
	      }
	    }
	  }
	});


	Object.defineProperty(Object3DFacade.prototype, 'isObject3DFacade', {value: true});

	// Predefine shape to facilitate JS engine optimization
	assign$3(Object3DFacade.prototype, {
	  threeObject: null,
	  _parentObject3DFacade: null,
	  _removeChildIds: null,
	  _matrixChanged: true,
	  _worldMatrixVersion: -1,
	  _worldMatrixVersionAfterLastUpdate: -1,
	  _boundingSphereChanged: false
	});

	// Define onBeforeRender/onAfterRender event handler properties
	Facade.defineEventProperty(Object3DFacade, 'onBeforeRender', 'beforerender');
	Facade.defineEventProperty(Object3DFacade, 'onAfterRender', 'afterrender');

	const noop$1 = function() {};
	const tempRaycaster = new Raycaster();
	const tempVec2$1 = new Vector2();
	const tempVec3$1 = new Vector3();
	const tempMat4$3 = new Matrix4();
	const tempQuat = new Quaternion();
	const lookAtUp = new Vector3(0, 1, 0);

	let _projectionMatrixVersion = 0;

	function createCameraFacade(threeJsCameraClass, projectionProps, otherProps) {
	  class Camera3DFacade extends Object3DFacade {
	    constructor(parent) {
	      super(parent);
	      this.lookAt = this.up = null;
	      this._projectionChanged = false;
	      this._frustum = new Frustum();
	    }

	    initThreeObject () {
	      const camera = new threeJsCameraClass();
	      // Forcibly prevent updateMatrixWorld from doing anything when called; the renderer
	      // likes to call this even though matrixAutoUpdate=false which can sometimes clobber
	      // our optimized `updateMatrices` handling and any custom adjustments it may make.
	      // TODO consider doing this at the Object3DFacade level?
	      camera.updateMatrixWorld = noop$1;
	      return camera
	    }

	    afterUpdate() {
	      // Apply lookAt+up as a final transform - applied as individual quaternion
	      // properties so they can selectively trigger updates, be transitioned, etc.
	      if (this.lookAt) {
	        tempVec3$1.copy(this.lookAt);
	        lookAtUp.copy(this.up || Object3D.DefaultUp);
	        tempMat4$3.lookAt(this.threeObject.position, tempVec3$1, lookAtUp);
	        tempQuat.setFromRotationMatrix(tempMat4$3);
	        this.quaternionX = tempQuat.x;
	        this.quaternionY = tempQuat.y;
	        this.quaternionZ = tempQuat.z;
	        this.quaternionW = tempQuat.w;
	      }
	      super.afterUpdate();
	    }

	    updateMatrices() {
	      let camObj = this.threeObject;

	      // Projection changes require a projection matrix rebuild - see setters below
	      if (this._projectionChanged) {
	        camObj.updateProjectionMatrix();
	        this._projectionChanged = false;
	        this._projectionMatrixVersion = _projectionMatrixVersion++;
	      }

	      // If changing the world matrix, also update its inverse
	      let matrixVersionBeforeUpdate = this._worldMatrixVersion;
	      super.updateMatrices();
	      if (matrixVersionBeforeUpdate !== this._worldMatrixVersion) {
	        invertMatrix4(camObj.matrixWorld, camObj.matrixWorldInverse);
	      }
	    }

	    /**
	     * Utility method that returns a Frustum object which is initialized to match this camera's
	     * current state. This can be used for example to optimize updates to the Facade tree by
	     * avoiding work for objects that fall outside the camera's view.
	     *
	     * You can access this by calling `this.getCameraFacade().getFrustum()` from any Object3DFacade's
	     * `afterUpdate` lifecycle method or later.
	     *
	     * Be careful that this Frustum does not get modified after it is requested, as it is cached for
	     * the lifetime of the camera's current world matrix and modifiying it would result in bad state
	     * for other code requesting it within that lifetime.
	     *
	     * @return {Frustum}
	     */
	    getFrustum() {
	      this.updateMatrices();
	      let frustum = this._frustum;
	      let {_worldMatrixVersion, _projectionMatrixVersion} = this;
	      if (frustum._lastWorldMatrixVersion !== _worldMatrixVersion || frustum._lastProjMatrixVersion !== _projectionMatrixVersion) {
	        let camObj = this.threeObject;
	        let matrix = new Matrix4().multiplyMatrices(camObj.projectionMatrix, camObj.matrixWorldInverse);
	        frustum.setFromMatrix(matrix);
	        frustum._lastWorldMatrixVersion = _worldMatrixVersion;
	        frustum._lastProjMatrixVersion = _projectionMatrixVersion;
	      }
	      return frustum
	    }

	    /**
	     * Given a set of camera projection coordinates (u,v in the range [-1, 1]), return a `Ray`
	     * representing that line of sight in worldspace.
	     * @param {number} u
	     * @param {number} v
	     * @return Ray
	     */
	    getRayAtProjectedCoords(u, v) {
	      // By default we use the builtin Raycaster functionality, but this can be overridden
	      const ray = tempRaycaster.ray = new Ray();
	      tempRaycaster.setFromCamera(tempVec2$1.set(u, v), this.threeObject);
	      return ray
	    }
	  }

	  // Setters for properties which require a matrix update
	  function defineProp(prop, affectsProjection) {
	    Object.defineProperty(Camera3DFacade.prototype, prop, {
	      set(val) {
	        if (val !== this.threeObject[prop]) {
	          this.threeObject[prop] = val;
	          if (affectsProjection) this._projectionChanged = true;
	        }
	      },
	      get() {
	        return this.threeObject[prop]
	      }
	    });
	  }

	  projectionProps.forEach(prop => {
	    defineProp(prop, true);
	  });

	  if (otherProps) {
	    otherProps.forEach(prop => {
	      defineProp(prop, false);
	    });
	  }

	  return Camera3DFacade
	}


	const PerspectiveCamera3DFacade = createCameraFacade(PerspectiveCamera, ['fov', 'aspect', 'near', 'far'], ['focus', 'filmGauge', 'filmOffset']);
	createCameraFacade(OrthographicCamera, ['left', 'right', 'top', 'bottom', 'near', 'far']);

	class Group3DFacade extends Object3DFacade {
	  initThreeObject() {
	    let group = new Group();
	    group.isRenderable = false; //trigger optimizations
	    return group
	  }
	}

	//import {ShadowMapViewer} from 'three/examples/jsm/utils/ShadowMapViewer.js'


	// Common superclass with setters for all possible light properties
	class Light3DFacade extends Object3DFacade {
	  set color(c) {
	    this.threeObject.color.set(c);
	  }
	  get color() {
	    return this.threeObject.color.getHex()
	  }

	  // Shadow map configurable by deep object copy:
	  get shadow() {
	    return this.threeObject.shadow
	  }
	  set shadow(val) {
	    utils.assignDeep(this.threeObject.shadow, val);
	  }
	}
	// Setters for simple properties to be copied
	['intensity', 'distance', 'angle', 'penumbra', 'decay', 'castShadow', 'width', 'height'].forEach(propName => {
	  Object.defineProperty(Light3DFacade.prototype, propName, {
	    get() {
	      return this.threeObject[propName]
	    },
	    set(value) {
	      this.threeObject[propName] = value;
	    }
	  });
	});


	function createLightFacade(ThreeJsLightClass, HelperClass, customProtoDefs) {
	  const Cls = class extends Light3DFacade {
	    initThreeObject() {
	      return new ThreeJsLightClass()
	    }
	    set showHelper(showHelper) {
	      let helper = this._helper;
	      if (!!showHelper !== !!helper) {
	        if (showHelper) {
	          this.threeObject.add(this._helper = new HelperClass(this.threeObject));
	        } else if (helper) {
	          helper.dispose();
	          this.threeObject.remove(helper);
	          this._helper = null;
	        }
	      }
	    }
	    afterUpdate () {
	      super.afterUpdate();
	      if (this._helper) {
	        this._helper.update();
	      }
	    }
	  };
	  if (customProtoDefs) {
	    Object.defineProperties(Cls.prototype, customProtoDefs);
	  }
	  return Cls
	}

	const AmbientLight3DFacade = createLightFacade(AmbientLight);
	const DirectionalLight3DFacade = createLightFacade(DirectionalLight, DirectionalLightHelper);
	const SpotLight3DFacade = createLightFacade(SpotLight, SpotLightHelper);
	const PointLight3DFacade = createLightFacade(PointLight, PointLightHelper);
	const HemisphereLight3DFacade = createLightFacade(HemisphereLight, HemisphereLightHelper, {
	  groundColor: {
	    set(c) {
	      this.threeObject.groundColor.set(c);
	    },
	    get() {
	      return this.threeObject.groundColor.getHex()
	    }
	  }
	});
	createLightFacade(RectAreaLight);

	const inverseFunction = `
#if __VERSION__ < 300
// matrix inversion utility for pre-ES3 - credit https://github.com/stackgl/glsl-inverse
mat3 inverse(mat3 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22 * a11 - a12 * a21;
  float b11 = -a22 * a10 + a12 * a20;
  float b21 = a21 * a10 - a11 * a20;

  float det = a00 * b01 + a01 * b11 + a02 * b21;

  return mat3(
    b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
    b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
    b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)
  ) / det;
}
#endif
`;

	const vertexCommonDefs = `
attribute vec4 troika_modelMatrixRow0;
attribute vec4 troika_modelMatrixRow1;
attribute vec4 troika_modelMatrixRow2;
mat4 troika_modelMatrix;
mat4 troika_modelViewMatrix;
mat3 troika_normalMatrix;
`;

	const modelMatrixVarAssignment = `
troika_modelMatrix = mat4(
  %0.x, %1.x, %2.x, 0.0,
  %0.y, %1.y, %2.y, 0.0,
  %0.z, %1.z, %2.z, 0.0,
  %0.w, %1.w, %2.w, 1.0
);
`.replace(/%/g, 'troika_modelMatrixRow');

	const modelViewMatrixVarAssignment = `
troika_modelViewMatrix = viewMatrix * troika_modelMatrix;
`;

	const normalMatrixVarAssignment = `
troika_normalMatrix = transposeMat3(inverse(mat3(troika_modelViewMatrix)));
`;


	const modelMatrixRefRE = /\bmodelMatrix\b/g;
	const modelViewMatrixRefRE = /\bmodelViewMatrix\b/g;
	const normalMatrixRefRE = /\bnormalMatrix\b/g;
	const precededByUniformRE = /\buniform\s+(int|float|vec[234])\s+$/;
	const attrRefReplacer = (name, index, str) => precededByUniformRE.test(str.substr(0, index)) ? name : `troika_${name}`;
	const varyingRefReplacer = (name, index, str) => precededByUniformRE.test(str.substr(0, index)) ? name : `troika_vary_${name}`;

	const CACHE = new WeakMap();

	/**
	 * Get a derived material with instancing upgrades for the given base material.
	 * The result is cached by baseMaterial+instanceUniforms so we always get the same instance
	 * back rather than getting a clone each time and having to re-upgrade every frame.
	 */
	function getInstancingDerivedMaterial(baseMaterial, instanceUniforms) {
	  let instanceUniformsKey = instanceUniforms ? instanceUniforms.sort().join('|') : '';
	  let derived = CACHE.get(baseMaterial);
	  if (!derived || derived._instanceUniformsKey !== instanceUniformsKey) {
	    derived = createDerivedMaterial(baseMaterial, {
	      defines: {
	        TROIKA_INSTANCED_UNIFORMS: instanceUniformsKey
	      },
	      customRewriter({vertexShader, fragmentShader}) {
	        return upgradeShaders(vertexShader, fragmentShader, instanceUniforms)
	      }
	    });
	    derived._instanceUniformsKey = instanceUniformsKey;
	    CACHE.set(baseMaterial, derived);
	  }
	  return derived
	}


	/**
	 * Transform the given vertex and fragment shader pair so they accept instancing
	 * attributes for the builtin matrix uniforms as well as any other uniforms that
	 * have been declared as instanceable.
	 */
	function upgradeShaders(vertexShader, fragmentShader, instanceUniforms) {
	  // See what gets used
	  let usesModelMatrix = modelMatrixRefRE.test(vertexShader);
	  let usesModelViewMatrix = modelViewMatrixRefRE.test(vertexShader);
	  let usesNormalMatrix = normalMatrixRefRE.test(vertexShader);

	  // Find what uniforms are declared in which shader and their types
	  let vertexUniforms = getShaderUniformTypes(vertexShader);
	  let fragmentUniforms = getShaderUniformTypes(fragmentShader);

	  let vertexDeclarations = [vertexCommonDefs];
	  let vertexAssignments = [];
	  let fragmentDeclarations = [];

	  // Add variable assignments for, and rewrite references to, builtin matrices
	  if (usesModelMatrix || usesModelViewMatrix || usesNormalMatrix) {
	    vertexShader = vertexShader.replace(modelMatrixRefRE, attrRefReplacer);
	    vertexAssignments.push(modelMatrixVarAssignment);
	  }
	  if (usesModelViewMatrix || usesNormalMatrix) {
	    vertexShader = vertexShader.replace(modelViewMatrixRefRE, attrRefReplacer);
	    vertexAssignments.push(modelViewMatrixVarAssignment);
	  }
	  if (usesNormalMatrix) {
	    vertexShader = vertexShader.replace(normalMatrixRefRE, attrRefReplacer);
	    vertexAssignments.push(normalMatrixVarAssignment);
	    // Add the inverse() glsl polyfill if there isn't already one defined
	    if (!/\binverse\s*\(/.test(vertexShader)) {
	      vertexDeclarations.push(inverseFunction);
	    }
	  }

	  // Add attributes and varyings for, and rewrite references to, instanceUniforms
	  if (instanceUniforms) {
	    instanceUniforms.forEach(name => {
	      let vertType = vertexUniforms[name];
	      let fragType = fragmentUniforms[name];
	      if (vertType || fragType) {
	        let finder = new RegExp(`\\b${name}\\b`, 'g');
	        vertexDeclarations.push(`attribute ${vertType || fragType} troika_${name};`);
	        if (vertType) {
	          vertexShader = vertexShader.replace(finder, attrRefReplacer);
	        }
	        if (fragType) {
	          fragmentShader = fragmentShader.replace(finder, varyingRefReplacer);
	          let varyingDecl = `varying ${fragType} troika_vary_${name};`;
	          vertexDeclarations.push(varyingDecl);
	          fragmentDeclarations.push(varyingDecl);
	          vertexAssignments.push(`troika_vary_${name} = troika_${name};`);
	        }
	      }
	    });
	  }

	  // Inject vertex shader declarations and assignments
	  vertexShader = `
${vertexDeclarations.join('\n')}
${vertexShader.replace(voidMainRegExp, `
  $&
  ${ vertexAssignments.join('\n') }
`)}`;

	  // Inject fragment shader declarations
	  if (fragmentDeclarations.length) {
	    fragmentShader = `
${fragmentDeclarations.join('\n')}
${fragmentShader}`;
	  }

	  return {vertexShader, fragmentShader}
	}

	const { assign: assign$2 } = utils;

	const INSTANCE_BATCH_SIZE = 128; //TODO make this an option?
	const DYNAMIC_DRAW = 0x88E8; //can't import DynamicDrawUsage from three without breaking older versions

	/**
	 * An InstancingManager handles aggregating all Instanceable3DFacade descendants into
	 * instancing batches. For each batch it creates a clone of the instancedThreeObject,
	 * populates a pooled InstancedBufferGeometry with buffer attributes holding the world
	 * matrices of all the batch's instances, and temporarily inserts that into the
	 * scene to be rendered.
	 *
	 * As an additional "turbo" optimization, the instancing batch objects/geometries will be
	 * reused untouched between rendering frames if none of the managed Instanceable3DFacade
	 * objects have changed in a way that would affect the batches or world matrix attributes.
	 *
	 * There is a global InstancingManager automatically added to the main scene, and it does
	 * nothing if there are no Instanceable3DFacades in the scene, so in most cases you should
	 * not need to touch this yourself. But it is also possible to insert additional
	 * InstancingManager facades further down in the scene if you wish to control the scope
	 * of instancing, e.g. to increase the likelihood of the aforementioned "turbo" optimization
	 * kicking in.
	 *
	 * Also see InstancingShaderUpgrades, which modifies material shaders so they accept the matrix
	 * and custom uniform values coming in as attributes. This allows built-in materials as well
	 * as custom shaders to work with instancing without manual modification.
	 */
	class InstancingManager extends Group3DFacade {
	  constructor(parent) {
	    super(parent);
	    this._instanceables = Object.create(null);
	    this._batchGeometryPool = new BatchGeometryPool();
	    this._needsRebatch = true;
	    this.addEventListener('beforerender', this._setupBatchObjects.bind(this));
	    this.addEventListener('afterrender', this._teardownBatchObjects.bind(this));
	  }

	  onNotifyWorld(source, message, data) {
	    let handler = this._notifyWorldHandlers[message];
	    if (handler) {
	      handler.call(this, source, data);
	    } else if (this.parent) {
	      this.parent.onNotifyWorld(source, message, data);
	    }
	  }

	  _setupBatchObjects(renderer, scene, camera) {
	    let instanceables = this._instanceables;
	    let batchObjectsByKey = this._batchObjectsByKey;
	    let needsRebatch = this._needsRebatch;

	    if (!needsRebatch) {
	      // We'll already know about most types of changes (instanceable addition/removal, instancedThreeObject
	      // changes, matrix changes) but if any of the instancedThreeObjects changed their geometry or material
	      // internally we'll need to detect that here and deoptimize.
	      for (let key in batchObjectsByKey) {
	        let batchObj = batchObjectsByKey[key][0];
	        if (this._getBatchKey(batchObj.$troikaBatchBaseObj) !== key) {
	          needsRebatch = true;
	          break
	        }
	      }
	    }

	    if (needsRebatch) {
	      batchObjectsByKey = this._batchObjectsByKey = Object.create(null);
	      let geometryPool = this._batchGeometryPool;
	      for (let facadeId in instanceables) {
	        let facade = instanceables[facadeId];
	        let instanceObject = facade.threeObject;
	        let protoObject = facade.instancedThreeObject;

	        if (protoObject && instanceObject.visible) {
	          // Find or create the batch object for this facade's instancedThreeObject
	          let batchKey = this._getBatchKey(protoObject);
	          let instanceUniforms = this._getInstanceUniformNames(protoObject);
	          let batchObjects = batchObjectsByKey[batchKey] || (batchObjectsByKey[batchKey] = []);
	          let batchObject = batchObjects[batchObjects.length - 1];
	          let batchGeometry = batchObject && batchObject.geometry;
	          if (!batchGeometry || getInstanceCount(batchGeometry) === INSTANCE_BATCH_SIZE) {
	            batchObject = this._getBatchObject(protoObject);
	            batchGeometry = batchObject.geometry;
	            let attrs = batchGeometry._instanceAttrs.matrix;
	            for (let row = 0; row < 3; row++) {
	              attrs[row].version++;
	            }
	            if (instanceUniforms) {
	              attrs = batchGeometry._instanceAttrs.uniforms;
	              for (let i = instanceUniforms.length; i--;) {
	                attrs[instanceUniforms[i]].version++;
	              }
	            }
	            batchObjects.push(batchObject);
	          }

	          // Put the instance's world matrix into the batch geometry's instancing attributes
	          let attrOffset = getInstanceCount(batchGeometry);
	          setInstanceCount(batchGeometry, attrOffset + 1);
	          let attrs = batchGeometry._instanceAttrs.matrix;
	          let elements = instanceObject.matrixWorld.elements; //column order
	          attrs[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]);
	          attrs[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]);
	          attrs[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]);

	          // Put the instance's values for instanceUniforms into the corresponding attributes
	          if (instanceUniforms) {
	            attrs = batchGeometry._instanceAttrs.uniforms;
	            for (let i = instanceUniforms.length; i--;) {
	              let uniform = instanceUniforms[i];
	              let attr = attrs[uniform];
	              let facadeUniforms = facade._instanceUniforms;
	              let value = facadeUniforms && (uniform in facadeUniforms) ?
	                facadeUniforms[uniform] : getDefaultUniformValue(protoObject.material, uniform);
	              setAttributeValue(attr, attrOffset, value);
	            }
	          }

	          // Save pointers for possible reuse next frame
	          facade._instancingBatchObject = batchObject;
	          facade._instancingBatchAttrOffset = attrOffset;
	        } else {
	          facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
	        }
	      }

	      // Dispose any old batch geometries that were unused during this render pass
	      // TODO should this be delayed any to prevent thrashing?
	      geometryPool.disposeUnused();
	    }

	    // Add the batch objects to the scene
	    let batchCount = 0;
	    let batchGrpCount = 0;
	    let instanceCount = 0;
	    for (let id in batchObjectsByKey) {
	      let batchObjects = batchObjectsByKey[id];
	      scene.children.push.apply(scene.children, batchObjects);

	      // increment stats
	      batchGrpCount++;
	      for (let i = batchObjects.length; i--;) {
	        batchCount++;
	        instanceCount += getInstanceCount(batchObjects[i].geometry);
	      }
	    }

	    this.notifyWorld('statsUpdate', {
	      'Instancing Batch Groups': batchGrpCount,
	      'Instancing Batches': batchCount,
	      'Instanced Objects': instanceCount
	    });

	    this._needsRebatch = false;
	  }

	  _onInstanceAdded(facade) {
	    this._instanceables[facade.$facadeId] = facade;
	    this._needsRebatch = true;
	  }

	  _onInstanceRemoved(facade) {
	    delete this._instanceables[facade.$facadeId];
	    this._needsRebatch = true;
	  }

	  _onInstanceChanged(facade) {
	    this._needsRebatch = true;
	  }

	  _onInstanceMatrixChanged(facade) {
	    // If a single instance's matrix changed and the batches are still otherwise valid, avoid a
	    // full rebatch by updating just this instance's values in the matrix attributes directly.
	    if (!this._needsRebatch) {
	      let protoObject = facade.instancedThreeObject;
	      let batchObject = facade._instancingBatchObject;
	      let attrOffset = facade._instancingBatchAttrOffset;
	      if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)) {
	        let attrs = batchObject.geometry._instanceAttrs.matrix;
	        let elements = facade.threeObject.matrixWorld.elements;
	        attrs[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]).version++;
	        attrs[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]).version++;
	        attrs[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]).version++;
	      } else {
	        // Fallback just in case something didn't line up above - clear pointers and trigger rebatch
	        facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
	        this._needsRebatch = true;
	      }
	    }
	  }

	  _onInstanceUniformChanged(facade, uniformName) {
	    if (!this._needsRebatch) {
	      let protoObject = facade.instancedThreeObject;
	      let batchObject = facade._instancingBatchObject;
	      let attr;
	      if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)
	        && (attr = batchObject.geometry._instanceAttrs.uniforms[uniformName])) {
	        setAttributeValue(attr, facade._instancingBatchAttrOffset, facade._instanceUniforms[uniformName]);
	        attr.version++; //skip setter
	      } else {
	        // Fallback just in case something didn't line up above - clear pointers and trigger rebatch
	        facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
	        this._needsRebatch = true;
	      }
	    }
	  }

	  _getBatchKey(object) {
	    let cache = this._batchKeysCache || (this._batchKeysCache = Object.create(null)); //cache results for duration of this frame
	    let key = cache && cache[object.id];
	    if (!key) {
	      let uniforms = this._getInstanceUniformNames(object);
	      key = `${object.geometry.id}|${object.material.id}|${uniforms ? uniforms.sort().join(',') : ''}`;
	      cache[object.id] = key;
	    }
	    return key
	  }

	  _getInstanceUniformNames(object) {
	    let namesSet = object._instanceUniformNames;
	    if (!namesSet) return null
	    let cache = this._uniformNamesCache || (this._uniformNamesCache = new Map());
	    let namesArray = cache.get(namesSet);
	    if (!namesArray) {
	      namesArray = Array.from(namesSet);
	      cache.set(namesSet, namesArray);
	    }
	    return namesArray
	  }

	  _getInstanceUniformSizes(material, uniformNames) {
	    // Cache results per material for duration of this frame
	    let cache = this._uniformSizesCache || (this._uniformSizesCache = new Map());
	    let result = cache.get(material);
	    if (!result) {
	      result = Object.create(null);
	      if (uniformNames) {
	        uniformNames.forEach(name => {
	          let size = getUniformItemSize(material, name);
	          if (size > 0) {
	            result[name] = size;
	          }
	        });
	      }
	      cache.set(material, result);
	    }
	    return result
	  }

	  _getBatchObject(instancedObject) {
	    let {geometry, material} = instancedObject;

	    // Upgrade the geometry to an instanced one
	    if (!geometry.isBufferGeometry) {
	      throw new Error('Instanceable proto object must use a BufferGeometry')
	    }
	    let batchKey = this._getBatchKey(instancedObject);
	    let uniformNames = this._getInstanceUniformNames(instancedObject);
	    let uniformSizes = this._getInstanceUniformSizes(material, uniformNames);
	    let batchGeometry = this._batchGeometryPool.borrow(batchKey, geometry, uniformSizes);
	    setInstanceCount(batchGeometry, 0);

	    // Upgrade the material to one with the shader modifications for instancing
	    let batchMaterial = getInstancingDerivedMaterial(material, uniformNames);
	    let depthMaterial, distanceMaterial;

	    // Create a new mesh object to hold it all
	    let batchObject = Object.create(instancedObject, {
	      // Redefine properties rather than setting them so we don't inadvertently trigger setters on
	      // the base object:
	      geometry: { value: batchGeometry },
	      material: { value: batchMaterial },
	      visible: { value: true },
	      frustumCulled: { value: false },

	      // Lazy getters for shadow materials:
	      customDepthMaterial: {
	        get() {
	          if (!depthMaterial) {
	            depthMaterial = batchMaterial.getDepthMaterial();
	            // We need to trick WebGLRenderer into setting the `viewMatrix` uniform, which it doesn't
	            // normally do for MeshDepthMaterial but it's needed by the instancing shader code. It does
	            // for ShaderMaterials so we pretend to be one.
	            depthMaterial.isShaderMaterial = true;
	            depthMaterial.uniformsGroups = depthMaterial.uniformsGroups || [];
	          }
	          return depthMaterial
	        }
	      },
	      customDistanceMaterial: {
	        get() {
	          if (!distanceMaterial) {
	            distanceMaterial = batchMaterial.getDistanceMaterial();
	            // We need to trick WebGLRenderer into setting the `viewMatrix` uniform, which it doesn't
	            // normally do for MeshDistanceMaterial but it's needed by the instancing shader code. It does
	            // for ShaderMaterials so we pretend to be one.
	            distanceMaterial.isShaderMaterial = true;
	            distanceMaterial.uniformsGroups = distanceMaterial.uniformsGroups || [];

	            // Additionally, WebGLShadowMap.render() rotates a single camera 6 times per object, which fails
	            // to trigger the code in WebGLRenderer.setProgram() that updates the viewMatrix uniform for
	            // directions 2 through 6. Since we need a correct viewMatrix in the instancing shader code,
	            // we hack it by defining our own viewMatrix uniform on the distance material and manually
	            // updating it before each view of the distance cube is rendered. Unfortunately intercepting the
	            // view changes in a way that has access to the shadow camera's viewMatrix has proven quite
	            // difficult; the least-awful way I've found is to monkeypatch the `modelViewMatrix.multiplyMatrices()`
	            // function which is always called - see (*!) below.
	            distanceMaterial.uniforms = assign$2({
	              viewMatrix: { value: new Matrix4() }
	            }, distanceMaterial.uniforms);
	          }
	          return distanceMaterial
	        }
	      },
	      // (*!) Hack for updating viewMatrix uniform on the distance material - see explanation above.
	      modelViewMatrix: {
	        value: function() {
	          const modelViewMatrix = new Matrix4();
	          modelViewMatrix.multiplyMatrices = function(viewMatrix, matrixWorld) {
	            if (distanceMaterial) {
	              distanceMaterial.uniforms.viewMatrix.value.copy(viewMatrix);
	              distanceMaterial.uniformsNeedUpdate = true; //undocumented flag for ShaderMaterial
	            }
	            return Matrix4.prototype.multiplyMatrices.call(this, viewMatrix, matrixWorld)
	          };
	          return modelViewMatrix
	        }()
	      }
	    });
	    batchObject.$troikaBatchBaseObj = instancedObject;
	    batchObject.$troikaInstancingManager = this;
	    // NOTE other props are inherited so don't need to copy them
	    return batchObject
	  }

	  _teardownBatchObjects(renderer, scene, camera) {
	    // Release geometries to the pool for next time
	    this._batchGeometryPool.releaseAll();

	    // Clear caches from this render frame
	    this._batchKeysCache = null;
	    this._uniformNamesCache = null;
	    this._uniformSizesCache = null;

	    // Remove batch objects from scene
	    scene.children = scene.children.filter(obj => obj.$troikaInstancingManager !== this);
	  }

	  destructor() {
	    let pool = this._batchGeometryPool;
	    pool.releaseAll();
	    pool.disposeUnused();
	    super.destructor();
	  }
	}


	/**
	 * Pool for the instancing batch geometries
	 */
	class BatchGeometryPool {
	  constructor() {
	    this._poolsByKey = Object.create(null);
	  }

	  borrow(key, baseGeometry, instanceUniformSizes) {
	    let poolsByKey = this._poolsByKey;
	    let pool = poolsByKey[key] || (poolsByKey[key] = {geometries: [], firstFree: 0});
	    let batchGeometry = pool.geometries[pool.firstFree++];

	    if (!batchGeometry) {
	      batchGeometry = new InstancedBufferGeometry();
	      assign$2(batchGeometry, baseGeometry);
	      batchGeometry.attributes = assign$2({}, baseGeometry.attributes);
	      let instanceAttrs = batchGeometry._instanceAttrs = {matrix: [], uniforms: Object.create(null)}; //separate collections for quicker lookup

	      // Create instancing attributes for the modelMatrix's rows
	      for (let row = 0; row < 3; row++) {
	        let attr = new InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * 4), 4);
	        if (attr.setUsage) {
	          attr.setUsage(DYNAMIC_DRAW);
	        } else {
	          attr.dynamic = true;
	        }
	        batchGeometry.attributes[`troika_modelMatrixRow${row}`] = attr;
	        instanceAttrs.matrix[row] = attr;
	      }

	      // Create instancing attributes for the instanceUniforms
	      for (let name in instanceUniformSizes) {
	        let itemSize = instanceUniformSizes[name];
	        let attr = new InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * itemSize), itemSize);
	        if (attr.setUsage) {
	          attr.setUsage(DYNAMIC_DRAW);
	        } else {
	          attr.dynamic = true;
	        }
	        batchGeometry.attributes[`troika_${name}`] = attr;
	        instanceAttrs.uniforms[name] = attr;
	      }

	      pool.geometries.push(batchGeometry);
	    }

	    return batchGeometry
	  }

	  releaseAll() {
	    let pools = this._poolsByKey;
	    if (pools) {
	      for (let key in pools) {
	        pools[key].firstFree = 0;
	      }
	    }
	  }

	  disposeUnused() {
	    let pools = this._poolsByKey;
	    if (pools) {
	      for (let key in pools) {
	        let {firstFree, geometries} = pools[key];
	        for (let i = firstFree, len = geometries.length; i < len; i++) {
	          // Only allow the instancing attributes to be disposed; those copied from the
	          // original geometry will be up to the author to dispose of properly
	          let attrs = geometries[i].attributes;
	          for (let attrName in attrs) {
	            if (attrs.hasOwnProperty(attrName) && attrName.indexOf('troika_') !== 0) {
	              delete attrs[attrName];
	            }
	          }
	          try {
	            // can throw if it's already been disposed or hasn't yet been rendered
	            geometries[i].dispose();
	          } catch(e) { /* empty */ }
	          geometries[i]._instanceAttrs = null;
	        }
	        geometries.length = firstFree;
	      }
	    }
	  }
	}


	const proto = InstancingManager.prototype;
	proto._notifyWorldHandlers = {
	  instanceableAdded: proto._onInstanceAdded,
	  instanceableRemoved: proto._onInstanceRemoved,
	  instanceableChanged: proto._onInstanceChanged,
	  instanceableMatrixChanged: proto._onInstanceMatrixChanged,
	  instanceableUniformChanged: proto._onInstanceUniformChanged
	};


	function setAttributeValue(attr, offset, value) {
	  let size = attr.itemSize;
	  if (size === 1) {
	    attr.setX(offset, value);
	  }
	  else if (size === 2) {
	    attr.setXY(offset, value.x, value.y);
	  }
	  else if (size === 3) {
	    if (value.isColor) {
	      attr.setXYZ(offset, value.r, value.g, value.b);
	    } else {
	      attr.setXYZ(offset, value.x, value.y, value.z);
	    }
	  } else if (size === 4) {
	    attr.setXYZW(offset, value.x, value.y, value.z, value.w);
	  }
	}

	function getDefaultUniformValue(material, name) {
	  // Try uniforms on the material itself, then try the builtin material shaders
	  let uniforms = material.uniforms;
	  if (uniforms && uniforms[name]) {
	    return uniforms[name].value
	  }
	  uniforms = getShadersForMaterial(material).uniforms;
	  if (uniforms && uniforms[name]) {
	    return uniforms[name].value
	  }
	  return null
	}

	function getUniformItemSize(material, name) {
	  return getItemSizeForValue(getDefaultUniformValue(material, name))
	}

	function getItemSizeForValue(value) {
	  return value == null ? 0
	    : typeof value === 'number' ? 1
	    : value.isVector2 ? 2
	    : (value.isVector3 || value.isColor) ? 3
	    : value.isVector4 ? 4
	    : Array.isArray(value) ? value.length
	    : 0
	}

	// Handle maxInstancedCount -> instanceCount rename that happened in three r117
	function getInstanceCount(geom) {
	  return geom[geom.hasOwnProperty('instanceCount') ? 'instanceCount' : 'maxInstancedCount']
	}
	function setInstanceCount(geom, count) {
	  geom[geom.hasOwnProperty('instanceCount') ? 'instanceCount' : 'maxInstancedCount'] = count;
	}

	const LIGHT_TYPES = {
	  ambient: AmbientLight3DFacade,
	  directional: DirectionalLight3DFacade,
	  spot: SpotLight3DFacade,
	  point: PointLight3DFacade,
	  hemisphere: HemisphereLight3DFacade
	};

	const RAY_INTERSECTION = [{distance: Infinity}];
	const INFINITE_SPHERE = new Sphere(undefined, Infinity);
	const tempArr = [null];

	class Scene3DFacade extends Object3DFacade {
	  initThreeObject() {
	    const scene = new Scene();
	    // We always manually update world matrices when needed - see Object3DFacade.updateMatrices() -
	    // so the additional auto-update pass done by threejs before render is not needed.
	    // The flag was renamed autoUpdate->matrixWorldAutoUpdate in r144
	    if ('matrixWorldAutoUpdate' in scene) {
	      scene.matrixWorldAutoUpdate = false;
	    } else {
	      scene.autoUpdate = false;
	    }
	    return scene
	  }

	  afterUpdate () {
	    let scene = this.threeObject;
	    scene.background = this.background || null;
	    scene.environment = this.environment || null;
	    super.afterUpdate();
	  }

	  describeChildren() {
	    // Add root instancing manager
	    let children = {
	      key: 'instancingMgr',
	      facade: InstancingManager,
	      children: this.objects
	    };

	    // Map light definitions to their appropriate classes
	    let {lights} = this;
	    if (lights) {
	      children = [children];
	      if (!Array.isArray(lights)) {
	        tempArr[0] = lights;
	        lights = tempArr;
	      }
	      lights.forEach((def, i) => {
	        let facade = def.facade || LIGHT_TYPES[def.type];
	        if (typeof facade === 'function') {
	          let realDef = utils.assign({}, def);
	          delete realDef.type;
	          realDef.key = def.key || `light${ i }`;
	          realDef.facade = facade;
	          children.push(realDef);
	        }
	      });
	    }

	    return children
	  }

	  set fog(def) {
	    let fogObj = this._fogObj;
	    if (def) {
	      let isExp2 = 'density' in def;
	      let fogClass = isExp2 ? FogExp2 : Fog;
	      if (!fogObj || !(fogObj instanceof fogClass)) {
	        fogObj = this._fogObj = new fogClass();
	      }
	      fogObj.color.set(def.color);
	      if (isExp2) {
	        fogObj.density = def.density;
	      } else {
	        fogObj.near = def.near;
	        fogObj.far = def.far;
	      }
	    } else {
	      fogObj = this._fogObj = null;
	    }
	    this.threeObject.fog = fogObj;
	  }

	  getBoundingSphere() {
	    return INFINITE_SPHERE
	  }

	  raycast(raycaster) {
	    // Scene3DFacade will always intersect, but as the furthest from the camera
	    return RAY_INTERSECTION
	  }
	}

	const { assign: assign$1$1, forOwn } = utils;
	const tempSphere = new Sphere();
	const SQRT3 = Math.sqrt(3);
	const PRECISION = 1e-8;


	class BoundingSphereOctree {
	  constructor() {
	    this.root = null;
	    this.keysToLeaves = Object.create(null);
	  }

	  putSpheres(spheres) {
	    forOwn(spheres, (sphere, key) => {
	      this.putSphere(key, sphere);
	    });
	  }

	  putSphere(key, sphere) {
	    const {center, radius} = sphere;

	    // Sanity check
	    if (!sphere || isNaN(radius) || isNaN(center.x)) {
	      return
	    }

	    // To prevent excessively deep trees when spheres are very close together, apply a rounding
	    // precision below which spheres will be treated as coincident and stored in the same leaf.
	    center._roundedX = Math.round(center.x / PRECISION) * PRECISION;
	    center._roundedY = Math.round(center.y / PRECISION) * PRECISION;
	    center._roundedZ = Math.round(center.z / PRECISION) * PRECISION;

	    this._putSphere(key, sphere);
	  }

	  _putSphere(key, sphere) {
	    const {center} = sphere;
	    const {root} = this;
	    let {_roundedX, _roundedY, _roundedZ} = center;

	    // If we already have a sphere for this key, perform an update
	    if (key in this.keysToLeaves) {
	      return this._updateSphere(key, sphere)
	    }

	    // First sphere being added: create a leaf octant and set it as the root. This will be replaced as
	    // soon as a second item is added, so we can start with an initial root bounding cube that matches
	    // our actual dataset rather than an arbitrary one.
	    if (!root) {
	      const newRoot = new Octant();
	      newRoot.isLeaf = true;
	      newRoot.addSphereData(key, sphere);
	      this.root = newRoot;
	      this.keysToLeaves[key] = newRoot;
	    }

	    // Second sphere being added:
	    else if (root.isLeaf) {
	      const oldRoot = this.root;
	      const {dataX, dataY, dataZ} = root;

	      // Handle special case where the second sphere has the same center point as the first, we still
	      // can't determine good starting bounds so just append to the existing leaf
	      if (dataX === _roundedX && dataY === _roundedY && dataZ === _roundedZ) {
	        this._insertIntoOctant(key, sphere, root);
	      }
	      // Non-coincident: we can now choose an appropriate size for the root node's box. Overwrite the
	      // root with a new branch octant, and set its position/size to the smallest whole-integer cube
	      // that contains both sphere centerpoints. (Cube rounded to whole ints to avoid floating point issues)
	      else {
	        const newRoot = new Octant();
	        const cx = newRoot.cx = Math.round((dataX + _roundedX) / 2);
	        const cy = newRoot.cy = Math.round((dataY + _roundedY) / 2);
	        const cz = newRoot.cz = Math.round((dataZ + _roundedZ) / 2);
	        newRoot.cr = Math.ceil(Math.max(Math.abs(cx - dataX), Math.abs(cy - dataY), Math.abs(cz - dataZ)) + 1e-5);
	        this.root = newRoot;

	        // Re-add the original leaf's sphere(s) and the new sphere under the new branch root, and exit
	        oldRoot.forEachLeafSphere((_sphere, _key) => this._insertIntoOctant(_key, _sphere, newRoot));
	        this._insertIntoOctant(key, sphere, newRoot);
	      }
	    }

	    // Expand the root to cover the new centerpoint if necessary, and insert the sphere within it
	    else {
	      this._expandToCoverPoint(_roundedX, _roundedY, _roundedZ);
	      this._insertIntoOctant(key, sphere, this.root);
	    }
	  }

	  _expandToCoverPoint(x, y, z) {
	    // Loop until the root cube contains the new point...
	    while (!this.root.containsPoint(x, y, z)) {
	      // Create a larger branch, expanded by 2x in the corner direction closest to the new point
	      const oldRoot = this.root;
	      const {cx, cy, cz, cr} = oldRoot;
	      const newRoot = new Octant();
	      newRoot.maxRadius = oldRoot.maxRadius;
	      newRoot.sphereCount = oldRoot.sphereCount;
	      newRoot.leafCount = oldRoot.leafCount;

	      newRoot.cx = cx + cr * (x < cx ? -1 : 1);
	      newRoot.cy = cy + cr * (y < cy ? -1 : 1);
	      newRoot.cz = cz + cr * (z < cz ? -1 : 1);
	      newRoot.cr = cr * 2;

	      // Move the old root to be a child of the new outer box, and make the outer box the new root
	      const octantIdx = newRoot.getSubOctantIndexForPoint(cx, cy, cz);
	      oldRoot.parent = newRoot;
	      oldRoot.index = octantIdx;
	      newRoot[octantIdx] = oldRoot;
	      this.root = newRoot;
	    }
	  }

	  _insertIntoOctant(key, sphere, octant) {
	    const {center, radius} = sphere;
	    const {_roundedX, _roundedY, _roundedZ} = center;

	    // If the parent octant is a leaf:
	    if (octant.isLeaf) {
	      const {dataX, dataY, dataZ} = octant;

	      // If the new sphere's center matches that of the leaf, add it to the leaf's members
	      if (_roundedX === dataX && _roundedY === dataY && _roundedZ === dataZ) {
	        octant.addSphereData(key, sphere);

	        // Increase maxRadius up the parent tree as needed
	        for (let oct = octant.parent; oct; oct = oct.parent) {
	          if (radius > oct.maxRadius) { oct.maxRadius = radius; }
	        }

	        // Add to index
	        this.keysToLeaves[key] =  octant;
	      }

	      // Otherwise split the leaf into a branch, push the old leaf down, and try again
	      else {
	        const newBranch = _createBranchFromLeaf(octant);
	        octant.parent[octant.index] = newBranch;
	        newBranch.addOctantForPoint(octant, dataX, dataY, dataZ);
	        this._insertIntoOctant(key, sphere, newBranch); //recurse
	      }
	    }

	    // The parent octant is a branch:
	    else {
	      // Always increment branch's total count
	      octant.sphereCount++;

	      // Find the suboctant index in which the new center point falls
	      const subOctantIndex = octant.getSubOctantIndexForPoint(_roundedX, _roundedY, _roundedZ);

	      // If there is nothing at that index yet, insert a new leaf octant
	      let subOctant = octant[subOctantIndex];
	      if (!subOctant) {
	        const newLeaf = new Octant();
	        newLeaf.isLeaf = true;
	        octant.addOctantForPoint(newLeaf, _roundedX, _roundedY, _roundedZ);
	        newLeaf.addSphereData(key, sphere);

	        // Increment leafCount and maxRadius up the parent tree
	        for (let oct = newLeaf.parent; oct; oct = oct.parent) {
	          if (radius > oct.maxRadius) { oct.maxRadius = radius; }
	          oct.leafCount++;
	        }

	        // Add to index
	        this.keysToLeaves[key] = newLeaf;
	      }

	      // If there was already a sub-octant at that index, recurse
	      else {
	        return this._insertIntoOctant(key, sphere, subOctant)
	      }
	    }
	  }

	  removeSphere(key) {
	    // Find the existing leaf that holds the sphere
	    let leafOctant = this.keysToLeaves[key];
	    if (!leafOctant) { return }

	    // Preemptively decrement sphereCount up the parent tree
	    let oct = leafOctant.parent;
	    while (oct) {
	      oct.sphereCount--;
	      oct = oct.parent;
	    }

	    // If there are other members in the leaf, remove it from the leaf's members and keep the leaf in place
	    if (leafOctant.sphereCount > 1) {
	      // Remove sphere from the leaf data
	      leafOctant.removeSphereData(key);

	      // Update maxRadius up the tree
	      leafOctant.updateMaxRadii();
	    }

	    // It was the only member of the leaf; remove the leaf and any ancestor branches that are now empty
	    else {
	      // Walk up the tree and remove all empty branches
	      oct = leafOctant;
	      let lowestRemainingOctant;
	      do {
	        const parent = oct.parent;
	        lowestRemainingOctant = parent;
	        if (parent) {
	          parent[oct.index] = null;
	        }
	        oct = oct.parent;
	      } while (oct && oct.sphereCount === 0)

	      // If we got to the top of the tree, it's totally empty so set the root to null and exit
	      if (!lowestRemainingOctant) {
	        this.root = null;
	        return
	      }

	      // Continue up the tree, decrementing the leafCount and looking for the highest branch point with only
	      // a single remaining leaf underneath it, if any
	      let highestSingleLeafBranch = null;
	      oct = lowestRemainingOctant;
	      while (oct) {
	        oct.leafCount--;
	        if (oct.leafCount === 1) {
	          highestSingleLeafBranch = oct;
	        }
	        oct = oct.parent;
	      }

	      // If we were left with a branch with only one leaf descendant, move that leaf up to the branch point
	      if (highestSingleLeafBranch) {
	        let leaf = this._findSingleLeaf(highestSingleLeafBranch);
	        const parent = highestSingleLeafBranch.parent;
	        if (parent) {
	          parent.addOctantForPoint(leaf, leaf.cx, leaf.cy, leaf.cz);
	          parent.updateMaxRadii();
	        } else {
	          this.root = leaf;
	        }
	      } else {
	        // Update the max radii up the tree from the lowest remaining node
	        lowestRemainingOctant.updateMaxRadii();
	      }
	    }

	    // Delete it from the index
	    delete this.keysToLeaves[key];
	  }

	  _updateSphere(key, sphere) {
	    // Find the existing leaf octant that holds the sphere
	    let leaf = this.keysToLeaves[key];

	    const center = sphere.center;
	    const {_roundedX, _roundedY, _roundedZ} = center;

	    // If its center point still falls within the leaf's cube, we can fast-path the changes:
	    if (leaf.containsPoint(_roundedX, _roundedY, _roundedZ)) {
	      const isMulti = leaf.sphereCount > 1;

	      const hasMoved = _roundedX !== leaf.dataX ||
	        _roundedY !== leaf.dataY ||
	        _roundedZ !== leaf.dataZ;

	      // If it was not the only member and has changed position, split that leaf; we can do this
	      // slightly faster than a full remove+add because we know this will be the branch point and can
	      // avoid some unnecessary upward tree walking
	      if (isMulti && hasMoved) {
	        leaf.removeSphereData(key);
	        leaf.updateMaxRadii();
	        this._insertIntoOctant(key, sphere, leaf);
	      }

	      // Otherwise we can just update this leaf
	      else {
	        if (hasMoved) {
	          leaf.dataX = _roundedX;
	          leaf.dataY = _roundedY;
	          leaf.dataZ = _roundedZ;
	        }
	        if (sphere.radius !== leaf.maxRadius) {
	          leaf.updateMaxRadii();
	        }
	      }
	    }

	    // If its center point is no longer within the leaf, delegate to full remove+add
	    // TODO possible faster path: remove only up to lowest common ancestor branch point,
	    // collapse remaining up to that point, and insert sphere under that point
	    else {
	      this.removeSphere(key);
	      this._putSphere(key, sphere);
	    }
	  }

	  // Optimized utility for finding single descendant leaf without creating a function
	  _findSingleLeaf(octant) {
	    let leaf;
	    function visit(oct) {
	      if (oct.isLeaf) leaf = oct;
	    }
	    function find(oct) {
	      leaf = null;
	      this.walkBranch(oct, visit);
	      return leaf
	    }
	    this._findSingleLeaf = find; //reuse closure after first call
	    return find.call(this, octant)
	  }


	  /**
	   * Perform a depth-first walk of the tree structure, invoking a `callback` function for
	   * each node. The `callback` will be passed the current tree node object, and will be invoked
	   * for parent branch nodes first before their child nodes.
	   *
	   * If the function returns `false` for a branch node, none of that branch's children will be
	   * visited; this is how you can efficiently query the tree by filtering out the majority of branches.
	   *
	   * @param {Function} callback
	   */
	  walkTree(callback) {
	    if (this.root) {
	      this.walkBranch(this.root, callback);
	    }
	  }
	  walkBranch(root, callback) {
	    if (callback(root) !== false && !root.isLeaf) {
	      for (let i = 0; i < 8; i++) {
	        if (root[i] !== null) {
	          this.walkBranch(root[i], callback);
	        }
	      }
	    }
	  }


	  /**
	   * Given a {@link Ray}, search the octree for any spheres that intersect that ray and invoke
	   * the given `callback` function, passing it the sphere and its key as arguments.
	   * TODO need to handle near/far
	   *
	   * @param {Ray} ray
	   * @param {Function} callback
	   * @param {Object} scope
	   */
	  forEachSphereOnRay(ray, callback, scope) {
	    return this._forEachMatchingSphere(ray.intersectsSphere.bind(ray), callback, scope)
	  }

	  forEachIntersectingSphere(sphere, callback, scope) {
	    return this._forEachMatchingSphere(sphere.intersectsSphere.bind(sphere), callback, scope)
	  }

	  _forEachMatchingSphere(testFn, callback, scope) {
	    // const startTime = performance.now()
	    // let branchTests = 0
	    // let sphereTests = 0
	    // let sphereHits = 0

	    function visitSphere(sphere, key) {
	      // sphereTests++
	      if (testFn(sphere)) {
	        // sphereHits++
	        callback.call(scope, sphere, key);
	      }
	    }

	    this.walkTree((octant) => {
	      if (octant.isLeaf) { //leaf
	        octant.forEachLeafSphere(visitSphere);
	      } else { //branch
	        // branchTests++
	        // Test using a sphere large enough to cover the maximum constituent bounding sphere with
	        // its center anywhere within the octant's box. This will obviously catch some false positives
	        // but those will be filtered at the leaf level.
	        // TODO investigate using a Box3 test, which could have fewer false positives, but only if that
	        // outweighs its slower speed (see https://jsperf.com/ray-intersectsphere-vs-intersectbox)
	        tempSphere.center.set(octant.cx, octant.cy, octant.cz);
	        tempSphere.radius = octant.cr * SQRT3 + octant.maxRadius;
	        if (!testFn(tempSphere)) {
	          return false //ignore this branch
	        }
	      }
	      return true
	    });

	    //console.log(`Raycast search: ${branchTests} branch tests, ${sphereTests} sphere tests, and ${sphereHits} hits, in ${performance.now() - startTime}ms`)
	  }
	}




	class Octant {
	  containsPoint(x, y, z) {
	    const {cx, cy, cz, cr} = this;
	    return x >= cx - cr && x < cx + cr &&
	      y >= cy - cr && y < cy + cr &&
	      z >= cz - cr && z < cz + cr
	  }

	  getSubOctantIndexForPoint(x, y, z) {
	    return (z < this.cz ? 0 : 4) + (y < this.cy ? 0 : 2) + (x < this.cx ? 0 : 1)
	  }

	  addOctantForPoint(subOctant, x, y, z) {
	    const index = this.getSubOctantIndexForPoint(x, y, z);
	    const subCR = this.cr / 2;

	    subOctant.parent = this;
	    subOctant.index = index;
	    subOctant.cx = this.cx + subCR * (x < this.cx ? -1 : 1);
	    subOctant.cy = this.cy + subCR * (y < this.cy ? -1 : 1);
	    subOctant.cz = this.cz + subCR * (z < this.cz ? -1 : 1);
	    subOctant.cr = subCR;

	    this[index] = subOctant;
	    return subOctant
	  }

	  findMaxSphereRadius() {
	    let maxRadius = 0;
	    if (this.isLeaf) {
	      const data = this.data;
	      if (this.sphereCount > 1) {
	        for (let key in data) {
	          const r = data[key].radius;
	          if (r > maxRadius) maxRadius = r;
	        }
	      } else {
	        maxRadius = data.radius;
	      }
	    } else {
	      for (let i = 0; i < 8; i++) {
	        if (this[i] !== null && this[i].maxRadius > maxRadius) {
	          maxRadius = this[i].maxRadius;
	        }
	      }
	    }
	    return maxRadius
	  }

	  updateMaxRadii() {
	    // Find the max maxRadius of the leaf octant's members
	    let maxRadius = this.findMaxSphereRadius();

	    // If the max radius has grown, just do a simple increase of the ancestor maxRadius values
	    if (maxRadius > this.maxRadius) {
	      let octant = this;
	      while (octant) {
	        if (maxRadius > octant.maxRadius) {
	          octant.maxRadius = maxRadius;
	        }
	        octant = octant.parent;
	      }
	    }
	    // If the max radius has shrunk, set it and repeat the process up the parent tree
	    else if (maxRadius < this.maxRadius) {
	      this.maxRadius = maxRadius;
	      if (this.parent) {
	        this.parent.updateMaxRadii();
	      }
	    }
	  }

	  addSphereData(key, sphere) {
	    const count = this.sphereCount++;
	    if (count === 0) {
	      this.leafCount = 1;
	      this.data = sphere;
	      this.dataKey = key;
	      // copy center coords from the first added sphere
	      const {_roundedX, _roundedY, _roundedZ} = sphere.center;
	      this.dataX = _roundedX;
	      this.dataY = _roundedY;
	      this.dataZ = _roundedZ;
	    }
	    else if (count === 1) {
	      const oldSphere = this.data;
	      const newData = this.data = Object.create(null);
	      newData[this.dataKey] = oldSphere;
	      newData[key] = sphere;
	      this.dataKey = null;
	    }
	    else if (count > 1) {
	      this.data[key] = sphere;
	    }

	    if (sphere.radius > this.maxRadius) {
	      this.maxRadius = sphere.radius;
	    }
	  }

	  removeSphereData(key) {
	    const data = this.data;
	    if (data) {
	      const count = this.sphereCount--;
	      if (count > 2) {
	        delete data[key];
	      }
	      else if (count === 2) {
	        for (let _key in data) {
	          if (_key !== key) {
	            this.dataKey = _key;
	            this.data = data[_key];
	            break
	          }
	        }
	      }
	      else {
	        this.data = null;
	      }
	    }
	  }

	  forEachLeafSphere(fn, scope) {
	    const data = this.data;
	    if (data) {
	      if (this.sphereCount > 1) {
	        for (let key in data) {
	          fn.call(scope, data[key], key);
	        }
	      } else {
	        fn.call(scope, data, this.dataKey);
	      }
	    }
	  }
	}
	assign$1$1(Octant.prototype, {
	  // Relationships
	  parent: null,
	  index: -1,

	  // Cube bounds
	  cx: 0, //center x
	  cy: 0, //center y
	  cz: 0, //center z
	  cr: 0, //cubic radius (dist from center to edge)

	  // Sub-octants
	  0: null,
	  1: null,
	  2: null,
	  3: null,
	  4: null,
	  5: null,
	  6: null,
	  7: null,

	  // Leaf data
	  // For a single-item leaf (probably the vast majority) `data` will be the Sphere object and `dataKey`
	  // will be its key. For a multi-item leaf, `data` will be an object of key->Sphere mappings and
	  // `dataKey` will be null. I'm not a huge fan of the asymmetry but this lets us avoid an extra
	  // sub-object for the majority of leaves while keeping the Octant's shape predictable for the JS engine.
	  isLeaf: false,
	  data: null,
	  dataKey: null,
	  // The first sphere added to the leaf will have its center position copied for easier access and
	  // to avoid issues with the Sphere objects being mutated elsewhere.
	  dataX: 0,
	  dataY: 0,
	  dataZ: 0,

	  // Stats
	  sphereCount: 0,
	  leafCount: 0,
	  maxRadius: 0
	});



	const _createBranchFromLeaf = (function() {
	  const copyProps = ['parent', 'index', 'cx', 'cy', 'cz', 'cr', 'sphereCount', 'leafCount', 'maxRadius'];
	  return function(leaf) {
	    const branch = new Octant();
	    for (let i = copyProps.length; i--;) {
	      branch[copyProps[i]] = leaf[copyProps[i]];
	    }
	    return branch
	  }
	})();

	const { assign: assign$4 } = utils;
	const tmpVec2 = new Vector2();
	const tmpVec3 = new Vector3();
	const raycaster = new Raycaster();


	class World3DFacade extends WorldBaseFacade {
	  constructor(canvas) {
	    super(canvas);
	    this._object3DFacadesById = Object.create(null);
	    this._onBgClick = this._onBgClick.bind(this);
	  }

	  afterUpdate() {
	    let {width, height, antialias, backgroundColor, contextAttributes, _element:canvas} = this;

	    // Set up renderer
	    let renderer = this._threeRenderer;
	    const RendererClass = this.rendererClass || WebGLRenderer;
	    if (!renderer || !(renderer instanceof RendererClass)) {
	      if (renderer) {
	        renderer.dispose();
	      }
	      // Init the context manually so we can prefer webgl2
	      contextAttributes = assign$4({
	        alpha: true,
	        antialias
	      }, contextAttributes);
	      const context = canvas.getContext('webgl2', contextAttributes) || undefined;
	      renderer = this._threeRenderer = new RendererClass(assign$4({
	        canvas,
	        context
	      }, contextAttributes));
	    }

	    const shadows = this.shadows;
	    renderer.shadowMap.enabled = !!shadows;
	    if (shadows && typeof shadows === 'object') {
	      assign$4(renderer.shadowMap, shadows);
	    }

	    if (backgroundColor !== this._bgColor) {
	      renderer.setClearColor(new Color(backgroundColor || 0), backgroundColor != null ? 1 : 0);
	      this._bgColor = backgroundColor;
	    }


	    //backwards compatibility support for output encoding and color space
	    //set colorspace to SRGBColorSpace or LinearSRGBColorSpace
	    if ('outputColorSpace' in renderer && this.outputColorSpace) {
	      renderer.outputColorSpace = this.outputColorSpace;
	    } else {
	      renderer.outputEncoding = this.outputEncoding || 3000;
	    }

	    renderer.toneMapping = this.toneMapping || NoToneMapping;

	    // Update render canvas size
	    this._updateDrawingBufferSize(width, height, this.pixelRatio || window.devicePixelRatio || 1);

	    super.afterUpdate();
	  }

	  describeChildren() {
	    return [
	      this._getCameraDef(),
	      this._getSceneDef()
	    ]
	  }

	  /**
	   * Build a normalized definition for the camera facade
	   * @protected
	   */
	  _getCameraDef() {
	    const {camera} = this;
	    return assign$4({
	      key: 'camera',
	      facade: PerspectiveCamera3DFacade,
	      aspect: this.width / this.height
	    }, camera)
	  }

	  /**
	   * Build a normalized definition for the scene facade
	   * @protected
	   */
	  _getSceneDef() {
	    return {
	      key: 'scene',
	      facade: Scene3DFacade,
	      lights: this.lights,
	      objects: this.objects,
	      fog: this.fog,
	      background: this.background,
	      environment: this.environment,
	      onClick: this.onBackgroundClick ? this._onBgClick : null
	    }
	  }

	  /**
	   * Update the renderer's drawing buffer size
	   * @protected
	   */
	  _updateDrawingBufferSize(width, height, pixelRatio) {
	    const renderer = this._threeRenderer;
	    renderer.getSize(tmpVec2);
	    if (tmpVec2.width !== width || tmpVec2.height !== height || renderer.getPixelRatio() !== pixelRatio) {
	      renderer.setDrawingBufferSize(width, height, pixelRatio);
	    }
	  }

	  doRender(/*...frameArgs*/) {
	    let sceneFacade = this.getChildByKey('scene');
	    let scene = sceneFacade.threeObject;
	    let camera = this.getChildByKey('camera').threeObject;
	    let renderer = this._threeRenderer;

	    // Invoke any onBeforeRender listeners
	    let registry = this.eventRegistry;
	    function invokeHandler(handler, facadeId) {
	      handler.call(this._object3DFacadesById[facadeId], renderer, scene, camera);
	    }
	    registry.forEachListenerOfType('beforerender', invokeHandler, this);

	    // Render scene
	    renderer.render(scene, camera);

	    // Invoke any onAfterRender listeners
	    registry.forEachListenerOfType('afterrender', invokeHandler, this);

	    let onStatsUpdate = this.onStatsUpdate;
	    if (onStatsUpdate) {
	      const {memory, render} = renderer.info;
	      const stats = {
	        'WebGL Draw Calls': render.calls,
	        'WebGL Geometries': memory.geometries,
	        'WebGL Textures': memory.textures,
	        'WebGL Triangles': render.triangles
	      };
	      if (render.points) {
	        stats['WebGL Points'] = render.points;
	      }
	      if (render.lines) {
	        stats['WebGL Lines'] = render.lines;
	      }
	      onStatsUpdate(stats);
	    }
	  }

	  /**
	   * Implementation of abstract
	   */
	  getFacadeUserSpaceXYZ(facade) {
	    let matrixEls = facade.threeObject.matrixWorld.elements;
	    return this.projectWorldPosition(matrixEls[12], matrixEls[13], matrixEls[14])
	  }

	  projectWorldPosition(x, y, z) {
	    tmpVec3.set(x, y, z);
	    let camera = this.getChildByKey('camera');
	    camera.updateMatrices();
	    camera = camera.threeObject;

	    // Make position relative to camera
	    tmpVec3.applyMatrix4(camera.matrixWorldInverse);

	    // Get relative distance to the point, negative if it's behind the camera
	    let signedDistance = tmpVec3.length() * (tmpVec3.z > 0 ? -1 : 1);

	    // Project x/y to screen coords
	    tmpVec3.applyMatrix4(camera.projectionMatrix);
	    let screenX = (tmpVec3.x + 1) * this.width / 2;
	    let screenY = (1 - tmpVec3.y) * this.height / 2;

	    return new Vector3(screenX, screenY, signedDistance)
	  }

	  /**
	   * @override
	   * In 3D worlds, we will normalize all pointer events so they always carry a `ray` property;
	   * handlers for these events should then only rely on that, which is guaranteed to be present,
	   * unlike `clientX/Y` etc. which are only present for pointer events originating from a screen.
	   */
	  _normalizePointerEvent(e) {
	    // All pointer events in a 3D world will be given a `ray` property.
	    if (!e.ray) {
	      // normalize touch events
	      let posInfo = e;
	      if (e.touches) {
	        let touches = /^touch(end|cancel)$/.test(e.type) ? e.changedTouches : e.touches;
	        if (touches.length === 1) {
	          posInfo = touches[0];
	        }
	      }

	      // convert mouse position to normalized device coords (-1 to 1)
	      const canvasRect = e.target.getBoundingClientRect(); //e.target is the canvas
	      let width = canvasRect.width || this.width; //use logical size if no visible rect, e.g. offscreen canvas
	      let height = canvasRect.height || this.height;
	      let u = ((posInfo.clientX || 0) - (canvasRect.left || 0)) / width * 2 - 1;
	      let v = ((posInfo.clientY || 0) - (canvasRect.top || 0)) / height * -2 + 1;

	      // ensure camera's matrix is up to date
	      let camera = this.getChildByKey('camera');
	      camera.updateMatrices();

	      // calculate the ray and put it on the event
	      e.ray = camera.getRayAtProjectedCoords(u, v);
	    }

	    super._normalizePointerEvent(e);
	  }

	  /**
	   * @override Implementation of abstract
	   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
	   */
	  getFacadesAtEvent(e, filterFn) {
	    return e.ray ? this.getFacadesOnRay(e.ray, filterFn) : null
	  }

	  getFacadesOnRay(ray, filterFn) {
	    // update bounding sphere octree
	    const octree = this._updateOctree();

	    // search bounding sphere octree to quickly filter down to a small set of likely hits,
	    // then do a true raycast on those facades
	    let allHits = null;
	    if (octree) {
	      raycaster.ray = ray;
	      octree.forEachSphereOnRay(ray, (sphere, facadeId) => {
	        const facadesById = this._object3DFacadesById;
	        const facade = facadesById && facadesById[facadeId];
	        // let the filterFn eliminate things before trying to raycast them
	        const hits = facade && (!filterFn || filterFn(facade)) && facade.raycast && facade.raycast(raycaster);
	        if (hits && hits[0]) {
	          // Ignore all but closest
	          hits[0].facade = facade
	          ;(allHits || (allHits = [])).push(hits[0]);
	        }
	      });
	    }
	    return allHits
	  }

	  _updateOctree() {
	    // update octree with any new bounding spheres
	    let octree = this._boundingSphereOctree;
	    const changes = this._octreeChangeset;
	    if (changes) {
	      if (!octree) {
	        octree = this._boundingSphereOctree = new BoundingSphereOctree();
	      }
	      const {remove, put} = changes;
	      if (remove) {
	        for (let facadeId in remove) {
	          octree.removeSphere(facadeId);
	        }
	      }
	      if (put) {
	        for (let facadeId in put) {
	          // Check for put requests for objects that are now obsolete
	          const facade = this._object3DFacadesById[facadeId];
	          if (facade && !facade.isDestroying && !(remove && remove[facadeId])) {
	            const sphere = facade.getBoundingSphere && facade.getBoundingSphere();
	            if (sphere) {
	              octree.putSphere(facadeId, sphere);
	            } else {
	              octree.removeSphere(facadeId);
	            }
	          }
	        }
	      }
	      this._octreeChangeset = null;
	    }
	    return octree
	  }

	  _queueForOctreeChange(changeType, facade) {
	    const changes = this._octreeChangeset || (this._octreeChangeset = {});
	    const map = changes[changeType] || (changes[changeType] = Object.create(null));
	    map[facade.$facadeId] = facade;
	  }

	  _onBgClick(e) {
	    // Ignore clicks that bubbled up
	    if (e.target === e.currentTarget) {
	      this.onBackgroundClick(e);
	    }
	  }

	  destructor() {
	    super.destructor();
	    this._threeRenderer.dispose();
	  }

	}



	World3DFacade.prototype._notifyWorldHandlers = assign$4(
	  Object.create(WorldBaseFacade.prototype._notifyWorldHandlers),
	  {
	    getCameraPosition(source, outputVec3) {
	      // We decompose from the world matrix here to handle pose transforms on top of the configured position
	      outputVec3.setFromMatrixPosition(this.getChildByKey('camera').threeObject.matrixWorld);
	    },
	    getCameraFacade(source, data) {
	      data.callback(this.getChildByKey('camera'));
	    },
	    getSceneFacade(source, data) {
	      data.callback(this.getChildByKey('scene'));
	    },
	    projectWorldPosition(source, data) {
	      let pos = data.worldPosition;
	      data.callback(this.projectWorldPosition(pos.x, pos.y, pos.z));
	    },
	    object3DAdded(source) {
	      this._object3DFacadesById[source.$facadeId] = source;
	      this._queueForOctreeChange('put', source);
	    },
	    object3DBoundsChanged(source) {
	      this._queueForOctreeChange('put', source);
	    },
	    object3DRemoved(source) {
	      delete this._object3DFacadesById[source.$facadeId];
	      this._queueForOctreeChange('remove', source);
	    },
	    rayPointerMotion(source, ray) {
	      // Dispatch a custom event carrying the Ray, which will be used by our `getFacadesAtEvent`
	      // override to search for a hovered facade
	      const e = new MouseEvent('mousemove');
	      e.isRayEvent = true;
	      e.ray = ray;
	      e.eventSource = source; //for tracking gesture states per ray source
	      this._onPointerMotionEvent(e);
	    },
	    rayPointerAction(source, eventParams) {
	      // Dispatch a custom event carrying the Ray, which will be used by our `getFacadesAtEvent`
	      // override to search for a hovered facade
	      const e = new (eventParams.type === 'wheel' ? WheelEvent : MouseEvent)(eventParams.type, eventParams);
	      e.isRayEvent = true;
	      e.ray = eventParams.ray;
	      e.eventSource = source; //for tracking gesture states per ray source
	      this._onPointerActionEvent(e);
	    }
	  }
	);

	/**
	 * Instanceable3DFacade is a specialized Object3DFacade that renders using GPU
	 * instancing. This can give a significant performance boost for objects that
	 * are rendered many thousands of times in a scene.
	 *
	 * Usage is nearly identical to an Object3DFacade, but instead of creating a
	 * `threeObject` in the constructor, you set its `instancedThreeObject` property
	 * to a common shared Mesh object. Any other Instanceable3DFacades in the scene
	 * that reference the same `instancedThreeObject` will be batched together and
	 * rendered using a single GPU draw call. The `instancedThreeObject` can be
	 * changed at any time, allowing dynamic appearance changes by swapping out the
	 * referenced mesh or its geometry or material.
	 *
	 * == Per-instance values: ==
	 *
	 * By default, the instances will each be rendered using their own world matrix
	 * transform, so they can be positioned/scaled/rotated independently as usual.
	 *
	 * It is also possible, with a little extra effort, to allow specific shader
	 * uniforms such as colors to be varied per instance. This works with both custom
	 * shader materials as well as the built-in materials.
	 *
	 * To enable per-instance uniforms, use the `setInstanceUniform(name, value)`
	 * method to set an instance's values for the enabled uniforms:
	 *
	 *     `this.setInstanceUniform('diffuse', new Color(color))`
	 *
	 * If an instance does not have a uniform value set this way, it will fall back to using
	 * the default value in the material's `uniforms` object.
	 *
	 * The uniform types that allow instancing are: `int`, `float`, `vec2`, `vec3`, and `vec4`.
	 * Mapping from application value types such as `Vector2` or `Color` behaves similarly to
	 * how three.js does it internally. More complex uniform types such as textures are not
	 * instanceable.
	 *
	 * == Caveats: ==
	 *
	 * It is generally not recommended to use this technique on meshes that are semi-
	 * transparent, as there is no guarantee that they will be drawn in back-to-front
	 * order relative to the camera position.
	 */
	class Instanceable3DFacade extends Object3DFacade {
	  constructor(parent) {
	    let obj = new Object3D();

	    // Trigger scene graph size optimizations
	    obj.isRenderable = false;

	    // Visibility change affects batching so listen for changes
	    obj.$troikaVisible = obj.visible;
	    Object.defineProperty(obj, 'visible', visibilityPropDef);

	    super(parent, obj);

	    this.notifyWorld('instanceableAdded');
	  }

	  /**
	   * @property {Object3D} instancedThreeObject
	   * Sets the Mesh instance to use for batching this instance with others that
	   * reference the same Mesh.
	   */

	  /**
	   * Sets this instance's value for a shader uniform.
	   * @param {String} name
	   * @param {Number|Vector2|Vector3|Vector4|Color} value
	   */
	  setInstanceUniform(name, value) {
	    let values = this._instanceUniforms || (this._instanceUniforms = Object.create(null));
	    if (values[name] !== value) {
	      // If this is a new uniform value, add it to the Set of instance uniform names
	      const obj = this.instancedThreeObject;
	      if (obj && !(name in values)) {
	        const names = obj._instanceUniformNames || (obj._instanceUniformNames = new Set());
	        names.add(name);
	      }
	      values[name] = value;
	      this.notifyWorld('instanceableUniformChanged', name);
	    }
	  }

	  afterUpdate() {
	    const newObj = this.instancedThreeObject;
	    const oldObj = this._instancedObj;
	    if (newObj !== oldObj) {
	      if (newObj && this._instanceUniforms) { //make sure new object tracks our instance uniforms
	        const names = newObj._instanceUniformNames || (newObj._instanceUniformNames = new Set());
	        for (let name in this._instanceUniforms) {
	          names.add(name);
	        }
	      }
	      this._instancedObj = newObj;
	      this.notifyWorld('instanceableChanged');
	      this._boundsChanged = true;
	    }
	    super.afterUpdate();
	  }

	  updateMatrices() {
	    const prevMatrixVersion = this._worldMatrixVersion;

	    super.updateMatrices();

	    // If the world matrix changed, we must notify the instancing manager
	    if (this._worldMatrixVersion !== prevMatrixVersion && this.threeObject.$troikaVisible) {
	      this.notifyWorld('instanceableMatrixChanged');
	    }
	  }

	  destructor() {
	    this.notifyWorld('instanceableRemoved');
	    super.destructor();
	  }

	  // Custom bounding sphere calc
	  getGeometry() {
	    let instancedObj = this.instancedThreeObject;
	    return instancedObj && instancedObj.geometry
	  }

	  // Custom raycasting based on current geometry and transform
	  raycast(raycaster) {
	    let {instancedThreeObject, threeObject} = this;
	    if (instancedThreeObject && threeObject) {
	      let origMatrix = instancedThreeObject.matrixWorld;
	      instancedThreeObject.matrixWorld = threeObject.matrixWorld;
	      let result = this._raycastObject(instancedThreeObject, raycaster); //use optimized method
	      instancedThreeObject.matrixWorld = origMatrix;
	      return result
	    }
	    return null
	  }
	}

	const visibilityPropDef = {
	  set(visible) {
	    if (visible !== this.$troikaVisible) {
	      this.$troikaVisible = visible;
	      this.$facade.notifyWorld('instanceableChanged');
	    }
	  },
	  get() {
	    return this.$troikaVisible
	  }
	};

	// Predefine shape to facilitate JS engine optimization
	utils.assign(Instanceable3DFacade.prototype, {
	  _lastInstancedMatrixVersion: -1,
	  _instancedThreeObject: null
	});

	new BufferGeometry();
	new MeshBasicMaterial();

	const MESH_MATERIALS = {
	  'basic': MeshBasicMaterial,
	  'depth': MeshDepthMaterial,
	  'distance': MeshDistanceMaterial,
	  'lambert': MeshLambertMaterial,
	  'matcap': MeshMatcapMaterial,
	  'normal': MeshNormalMaterial,
	  'phong': MeshPhongMaterial,
	  'physical': MeshPhysicalMaterial,
	  'standard': MeshStandardMaterial,
	  'toon': MeshToonMaterial,
	};

	// For all of the known mesh materials, add `material.*` setters for all of their
	// supported properties. The setters will update a "dirty" object which will then be
	// applied to the material during afterUpdate; this lets us only deal with the specific
	// material props that have been set rather than having to iterate over all props.
	const ignoreMaterialProps = {type:1, id:1, uuid:1, version:1};
	Object.keys(MESH_MATERIALS).forEach(key => {
	  let material = new MESH_MATERIALS[key]();
	  for (let mtlProp in material) {
	    if (material.hasOwnProperty(mtlProp) && !ignoreMaterialProps.hasOwnProperty(mtlProp)) ;
	  }
	});

	/**
	 * Return a singleton instance of a 1x1x1 BoxGeometry
	 * @type {function(): BoxGeometry}
	 */
	utils.memoize(() => {
	  return new BoxGeometry(1, 1, 1, 1, 1)
	});

	Object.create(null, [
	  ['low', 32],
	  ['medium', 64],
	  ['high', 128]
	].reduce((descr, [name, segments]) => {
	  descr[name] = {
	    get: utils.memoize(() =>
	      new CircleGeometry(1, segments).rotateX(-Math.PI / 2)
	    )
	  };
	  return descr
	}, {}));

	utils.memoize(() => {
	  return new PlaneGeometry(1, 1, 1, 1).rotateX(-Math.PI / 2)
	});

	Object.create(null, [
	  ['low', 16, 12],
	  ['medium', 32, 24],
	  ['high', 64, 48]
	].reduce((descr, [name, wSegs, hSegs]) => {
	  descr[name] = {
	    get: utils.memoize(() => new SphereGeometry(1, wSegs, hSegs))
	  };
	  return descr
	}, {}));

	/**
	 * Main content for the worker that handles the loading and execution of
	 * modules within it.
	 */
	function workerBootstrap() {
	  const modules = Object.create(null);

	  // Handle messages for registering a module
	  function registerModule({id, name, dependencies=[], init=function(){}, getTransferables=null}, callback) {
	    // Only register once
	    if (modules[id]) return

	    try {
	      // If any dependencies are modules, ensure they're registered and grab their value
	      dependencies = dependencies.map(dep => {
	        if (dep && dep.isWorkerModule) {
	          registerModule(dep, depResult => {
	            if (depResult instanceof Error) throw depResult
	          });
	          dep = modules[dep.id].value;
	        }
	        return dep
	      });

	      // Rehydrate functions
	      init = rehydrate(`<${name}>.init`, init);
	      if (getTransferables) {
	        getTransferables = rehydrate(`<${name}>.getTransferables`, getTransferables);
	      }

	      // Initialize the module and store its value
	      let value = null;
	      if (typeof init === 'function') {
	        value = init(...dependencies);
	      } else {
	      }
	      modules[id] = {
	        id,
	        value,
	        getTransferables
	      };
	      callback(value);
	    } catch(err) {
	      if (!(err && err.noLog)) ;
	      callback(err);
	    }
	  }

	  // Handle messages for calling a registered module's result function
	  function callModule({id, args}, callback) {
	    if (!modules[id] || typeof modules[id].value !== 'function') {
	      callback(new Error(`Worker module ${id}: not found or its 'init' did not return a function`));
	    }
	    try {
	      const result = modules[id].value(...args);
	      if (result && typeof result.then === 'function') {
	        result.then(handleResult, rej => callback(rej instanceof Error ? rej : new Error('' + rej)));
	      } else {
	        handleResult(result);
	      }
	    } catch(err) {
	      callback(err);
	    }
	    function handleResult(result) {
	      try {
	        let tx = modules[id].getTransferables && modules[id].getTransferables(result);
	        if (!tx || !Array.isArray(tx) || !tx.length) {
	          tx = undefined; //postMessage is very picky about not passing null or empty transferables
	        }
	        callback(result, tx);
	      } catch(err) {
	        callback(err);
	      }
	    }
	  }

	  function rehydrate(name, str) {
	    let result = void 0;
	    self.troikaDefine = r => result = r;
	    let url = URL.createObjectURL(
	      new Blob(
	        [`/** ${name.replace(/\*/g, '')} **/\n\ntroikaDefine(\n${str}\n)`],
	        {type: 'application/javascript'}
	      )
	    );
	    try {
	      importScripts(url);
	    } catch(err) {
	    }
	    URL.revokeObjectURL(url);
	    delete self.troikaDefine;
	    return result
	  }

	  // Handler for all messages within the worker
	  self.addEventListener('message', e => {
	    const {messageId, action, data} = e.data;
	    try {
	      // Module registration
	      if (action === 'registerModule') {
	        registerModule(data, result => {
	          if (result instanceof Error) {
	            postMessage({
	              messageId,
	              success: false,
	              error: result.message
	            });
	          } else {
	            postMessage({
	              messageId,
	              success: true,
	              result: {isCallable: typeof result === 'function'}
	            });
	          }
	        });
	      }
	      // Invocation
	      if (action === 'callModule') {
	        callModule(data, (result, transferables) => {
	          if (result instanceof Error) {
	            postMessage({
	              messageId,
	              success: false,
	              error: result.message
	            });
	          } else {
	            postMessage({
	              messageId,
	              success: true,
	              result
	            }, transferables || undefined);
	          }
	        });
	      }
	    } catch(err) {
	      postMessage({
	        messageId,
	        success: false,
	        error: err.stack
	      });
	    }
	  });
	}

	/**
	 * Fallback for `defineWorkerModule` that behaves identically but runs in the main
	 * thread, for when the execution environment doesn't support web workers or they
	 * are disallowed due to e.g. CSP security restrictions.
	 */
	function defineMainThreadModule(options) {
	  let moduleFunc = function(...args) {
	    return moduleFunc._getInitResult().then(initResult => {
	      if (typeof initResult === 'function') {
	        return initResult(...args)
	      } else {
	        throw new Error('Worker module function was called but `init` did not return a callable function')
	      }
	    })
	  };
	  moduleFunc._getInitResult = function() {
	    // We can ignore getTransferables in main thread. TODO workerId?
	    let {dependencies, init} = options;

	    // Resolve dependencies
	    dependencies = Array.isArray(dependencies) ? dependencies.map(dep =>
	      dep && dep._getInitResult ? dep._getInitResult() : dep
	    ) : [];

	    // Invoke init with the resolved dependencies
	    let initPromise = Promise.all(dependencies).then(deps => {
	      return init.apply(null, deps)
	    });

	    // Cache the resolved promise for subsequent calls
	    moduleFunc._getInitResult = () => initPromise;

	    return initPromise
	  };
	  return moduleFunc
	}

	let supportsWorkers = () => {
	  let supported = false;

	  // Only attempt worker initialization in browsers; elsewhere it would just be
	  // noise e.g. loading into a Node environment for SSR.
	  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
	    try {
	      // TODO additional checks for things like importScripts within the worker?
	      //  Would need to be an async check.
	      let worker = new Worker(
	        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))
	      );
	      worker.terminate();
	      supported = true;
	    } catch (err) {
	    }
	  }

	  // Cached result
	  supportsWorkers = () => supported;
	  return supported
	};

	let _workerModuleId = 0;
	let _messageId = 0;
	let _allowInitAsString = false;
	const workers = Object.create(null);
	const registeredModules = Object.create(null); //workerId -> Set<unregisterFn>
	const openRequests = Object.create(null);


	/**
	 * Define a module of code that will be executed with a web worker. This provides a simple
	 * interface for moving chunks of logic off the main thread, and managing their dependencies
	 * among one another.
	 *
	 * @param {object} options
	 * @param {function} options.init
	 * @param {array} [options.dependencies]
	 * @param {function} [options.getTransferables]
	 * @param {string} [options.name]
	 * @param {string} [options.workerId]
	 * @return {function(...[*]): {then}}
	 */
	function defineWorkerModule(options) {
	  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {
	    throw new Error('requires `options.init` function')
	  }
	  let {dependencies, init, getTransferables, workerId} = options;

	  if (!supportsWorkers()) {
	    return defineMainThreadModule(options)
	  }

	  if (workerId == null) {
	    workerId = '#default';
	  }
	  const id = `workerModule${++_workerModuleId}`;
	  const name = options.name || id;
	  let registrationPromise = null;

	  dependencies = dependencies && dependencies.map(dep => {
	    // Wrap raw functions as worker modules with no dependencies
	    if (typeof dep === 'function' && !dep.workerModuleData) {
	      _allowInitAsString = true;
	      dep = defineWorkerModule({
	        workerId,
	        name: `<${name}> function dependency: ${dep.name}`,
	        init: `function(){return (\n${stringifyFunction(dep)}\n)}`
	      });
	      _allowInitAsString = false;
	    }
	    // Grab postable data for worker modules
	    if (dep && dep.workerModuleData) {
	      dep = dep.workerModuleData;
	    }
	    return dep
	  });

	  function moduleFunc(...args) {
	    // Register this module if needed
	    if (!registrationPromise) {
	      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);
	      const unregister = () => {
	        registrationPromise = null;
	        registeredModules[workerId].delete(unregister);
	      }
	      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);
	    }

	    // Invoke the module, returning a promise
	    return registrationPromise.then(({isCallable}) => {
	      if (isCallable) {
	        return callWorker(workerId,'callModule', {id, args})
	      } else {
	        throw new Error('Worker module function was called but `init` did not return a callable function')
	      }
	    })
	  }
	  moduleFunc.workerModuleData = {
	    isWorkerModule: true,
	    id,
	    name,
	    dependencies,
	    init: stringifyFunction(init),
	    getTransferables: getTransferables && stringifyFunction(getTransferables)
	  };
	  return moduleFunc
	}

	/**
	 * Terminate an active Worker by a workerId that was passed to defineWorkerModule.
	 * This only terminates the Worker itself; the worker module will remain available
	 * and if you call it again its Worker will be respawned.
	 * @param {string} workerId
	 */
	function terminateWorker(workerId) {
	  // Unregister all modules that were registered in that worker
	  if (registeredModules[workerId]) {
	    registeredModules[workerId].forEach(unregister => {
	      unregister();
	    });
	  }
	  // Terminate the Worker object
	  if (workers[workerId]) {
	    workers[workerId].terminate();
	    delete workers[workerId];
	  }
	}

	/**
	 * Stringifies a function into a form that can be deserialized in the worker
	 * @param fn
	 */
	function stringifyFunction(fn) {
	  let str = fn.toString();
	  // If it was defined in object method/property format, it needs to be modified
	  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
	    str = 'function ' + str;
	  }
	  return str
	}


	function getWorker(workerId) {
	  let worker = workers[workerId];
	  if (!worker) {
	    // Bootstrap the worker's content
	    const bootstrap = stringifyFunction(workerBootstrap);

	    // Create the worker from the bootstrap function content
	    worker = workers[workerId] = new Worker(
	      URL.createObjectURL(
	        new Blob(
	          [`/** Worker Module Bootstrap: ${workerId.replace(/\*/g, '')} **/\n\n;(${bootstrap})()`],
	          {type: 'application/javascript'}
	        )
	      )
	    );

	    // Single handler for response messages from the worker
	    worker.onmessage = e => {
	      const response = e.data;
	      const msgId = response.messageId;
	      const callback = openRequests[msgId];
	      if (!callback) {
	        throw new Error('WorkerModule response with empty or unknown messageId')
	      }
	      delete openRequests[msgId];
	      callback(response);
	    };
	  }
	  return worker
	}

	// Issue a call to the worker with a callback to handle the response
	function callWorker(workerId, action, data) {
	  return new Promise((resolve, reject) => {
	    const messageId = ++_messageId;
	    openRequests[messageId] = response => {
	      if (response.success) {
	        resolve(response.result);
	      } else {
	        reject(new Error(`Error in worker ${action} call: ${response.error}`));
	      }
	    };
	    getWorker(workerId).postMessage({
	      messageId,
	      action,
	      data
	    });
	  })
	}

	/**
	 * Factory function that creates a self-contained environment for processing text typesetting requests.
	 *
	 * It is important that this function has no closure dependencies, so that it can be easily injected
	 * into the source for a Worker without requiring a build step or complex dependency loading. All its
	 * dependencies must be passed in at initialization.
	 *
	 * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns
	 * a standardized structure giving access to the font and its glyphs:
	 *   {
	 *     unitsPerEm: number,
	 *     ascender: number,
	 *     descender: number,
	 *     capHeight: number,
	 *     xHeight: number,
	 *     lineGap: number,
	 *     forEachGlyph(string, fontSize, letterSpacing, callback) {
	 *       //invokes callback for each glyph to render, passing it an object:
	 *       callback({
	 *         index: number,
	 *         advanceWidth: number,
	 *         xMin: number,
	 *         yMin: number,
	 *         xMax: number,
	 *         yMax: number,
	 *         path: string,
	 *         pathCommandCount: number
	 *       })
	 *     }
	 *   }
	 * @param {object} bidi - the bidi.js implementation object
	 * @param {Object} config
	 * @return {Object}
	 */
	function createTypesetter(fontParser, bidi, config) {

	  const {
	    defaultFontURL
	  } = config;

	  /**
	   * Holds parsed font objects by url
	   */
	  const fonts = Object.create(null);

	  const INF = Infinity;

	  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs
	  // eslint-disable-next-line no-misleading-character-class
	  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;

	  // This regex (instead of /\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces
	  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;

	  // Incomplete set of characters that allow line breaking after them
	  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14
	  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);

	  /**
	   * Load a given font url
	   */
	  function doLoadFont(url, callback) {
	    function tryLoad() {
	      const onError = err => {
	        if (url !== defaultFontURL) {
	          url = defaultFontURL;
	          tryLoad();
	        }
	      };
	      try {
	        const request = new XMLHttpRequest();
	        request.open('get', url, true);
	        request.responseType = 'arraybuffer';
	        request.onload = function () {
	          if (request.status >= 400) {
	            onError(new Error(request.statusText));
	          }
	          else if (request.status > 0) {
	            try {
	              const fontObj = fontParser(request.response);
	              callback(fontObj);
	            } catch (e) {
	              onError(e);
	            }
	          }
	        };
	        request.onerror = onError;
	        request.send();
	      } catch(err) {
	        onError();
	      }
	    }
	    tryLoad();
	  }


	  /**
	   * Load a given font url if needed, invoking a callback when it's loaded. If already
	   * loaded, the callback will be called synchronously.
	   */
	  function loadFont(fontUrl, callback) {
	    if (!fontUrl) fontUrl = defaultFontURL;
	    let font = fonts[fontUrl];
	    if (font) {
	      // if currently loading font, add to callbacks, otherwise execute immediately
	      if (font.pending) {
	        font.pending.push(callback);
	      } else {
	        callback(font);
	      }
	    } else {
	      fonts[fontUrl] = {pending: [callback]};
	      doLoadFont(fontUrl, fontObj => {
	        let callbacks = fonts[fontUrl].pending;
	        fonts[fontUrl] = fontObj;
	        callbacks.forEach(cb => cb(fontObj));
	      });
	    }
	  }


	  /**
	   * Main entry point.
	   * Process a text string with given font and formatting parameters, and return all info
	   * necessary to render all its glyphs.
	   */
	  function typeset(
	    {
	      text='',
	      font=defaultFontURL,
	      sdfGlyphSize=64,
	      fontSize=1,
	      letterSpacing=0,
	      lineHeight='normal',
	      maxWidth=INF,
	      direction,
	      textAlign='left',
	      textIndent=0,
	      whiteSpace='normal',
	      overflowWrap='normal',
	      anchorX = 0,
	      anchorY = 0,
	      includeCaretPositions=false,
	      chunkedBoundsSize=8192,
	      colorRanges=null
	    },
	    callback,
	    metricsOnly=false
	  ) {
	    const mainStart = now();
	    const timings = {fontLoad: 0, typesetting: 0};

	    // Ensure newlines are normalized
	    if (text.indexOf('\r') > -1) {
	      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
	    }

	    // Ensure we've got numbers not strings
	    fontSize = +fontSize;
	    letterSpacing = +letterSpacing;
	    maxWidth = +maxWidth;
	    lineHeight = lineHeight || 'normal';
	    textIndent = +textIndent;

	    loadFont(font, fontObj => {
	      const hasMaxWidth = isFinite(maxWidth);
	      let glyphIds = null;
	      let glyphPositions = null;
	      let glyphData = null;
	      let glyphColors = null;
	      let caretPositions = null;
	      let visibleBounds = null;
	      let chunkedBounds = null;
	      let maxLineWidth = 0;
	      let renderableGlyphCount = 0;
	      let canWrap = whiteSpace !== 'nowrap';
	      const {ascender, descender, unitsPerEm, lineGap, capHeight, xHeight} = fontObj;
	      timings.fontLoad = now() - mainStart;
	      const typesetStart = now();

	      // Find conversion between native font units and fontSize units; this will already be done
	      // for the gx/gy values below but everything else we'll need to convert
	      const fontSizeMult = fontSize / unitsPerEm;

	      // Determine appropriate value for 'normal' line height based on the font's actual metrics
	      // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?
	      if (lineHeight === 'normal') {
	        lineHeight = (ascender - descender + lineGap) / unitsPerEm;
	      }

	      // Determine line height and leading adjustments
	      lineHeight = lineHeight * fontSize;
	      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
	      const topBaseline = -(ascender * fontSizeMult + halfLeading);
	      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
	      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;

	      // Distribute glyphs into lines based on wrapping
	      let lineXOffset = textIndent;
	      let currentLine = new TextLine();
	      const lines = [currentLine];

	      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {
	        const char = text.charAt(charIndex);
	        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
	        const curLineCount = currentLine.count;
	        let nextLine;

	        // Calc isWhitespace and isEmpty once per glyphObj
	        if (!('isEmpty' in glyphObj)) {
	          glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
	          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
	          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
	        }
	        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
	          renderableGlyphCount++;
	        }

	        // If a non-whitespace character overflows the max width, we need to soft-wrap
	        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
	          // If it's the first char after a whitespace, start a new line
	          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
	            nextLine = new TextLine();
	            lineXOffset = -glyphX;
	          } else {
	            // Back up looking for a whitespace character to wrap at
	            for (let i = curLineCount; i--;) {
	              // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'
	              if (i === 0 && overflowWrap === 'break-word') {
	                nextLine = new TextLine();
	                lineXOffset = -glyphX;
	                break
	              }
	              // Found a soft break point; move all chars since it to a new line
	              else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
	                nextLine = currentLine.splitAt(i + 1);
	                const adjustX = nextLine.glyphAt(0).x;
	                lineXOffset -= adjustX;
	                for (let j = nextLine.count; j--;) {
	                  nextLine.glyphAt(j).x -= adjustX;
	                }
	                break
	              }
	            }
	          }
	          if (nextLine) {
	            currentLine.isSoftWrapped = true;
	            currentLine = nextLine;
	            lines.push(currentLine);
	            maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width
	          }
	        }

	        let fly = currentLine.glyphAt(currentLine.count);
	        fly.glyphObj = glyphObj;
	        fly.x = glyphX + lineXOffset;
	        fly.width = glyphWidth;
	        fly.charIndex = charIndex;

	        // Handle hard line breaks
	        if (char === '\n') {
	          currentLine = new TextLine();
	          lines.push(currentLine);
	          lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;
	        }
	      });

	      // Calculate width of each line (excluding trailing whitespace) and maximum block width
	      lines.forEach(line => {
	        for (let i = line.count; i--;) {
	          let {glyphObj, x, width} = line.glyphAt(i);
	          if (!glyphObj.isWhitespace) {
	            line.width = x + width;
	            if (line.width > maxLineWidth) {
	              maxLineWidth = line.width;
	            }
	            return
	          }
	        }
	      });

	      // Find overall position adjustments for anchoring
	      let anchorXOffset = 0;
	      let anchorYOffset = 0;
	      if (anchorX) {
	        if (typeof anchorX === 'number') {
	          anchorXOffset = -anchorX;
	        }
	        else if (typeof anchorX === 'string') {
	          anchorXOffset = -maxLineWidth * (
	            anchorX === 'left' ? 0 :
	            anchorX === 'center' ? 0.5 :
	            anchorX === 'right' ? 1 :
	            parsePercent(anchorX)
	          );
	        }
	      }
	      if (anchorY) {
	        if (typeof anchorY === 'number') {
	          anchorYOffset = -anchorY;
	        }
	        else if (typeof anchorY === 'string') {
	          let height = lines.length * lineHeight;
	          anchorYOffset = anchorY === 'top' ? 0 :
	            anchorY === 'top-baseline' ? -topBaseline :
	            anchorY === 'top-cap' ? -topBaseline - capHeight * fontSizeMult :
	            anchorY === 'top-ex' ? -topBaseline - xHeight * fontSizeMult :
	            anchorY === 'middle' ? height / 2 :
	            anchorY === 'bottom' ? height :
	            anchorY === 'bottom-baseline' ? height - halfLeading + descender * fontSizeMult :
	            parsePercent(anchorY) * height;
	        }
	      }

	      if (!metricsOnly) {
	        // Resolve bidi levels
	        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);

	        // Process each line, applying alignment offsets, adding each glyph to the atlas, and
	        // collecting all renderable glyphs into a single collection.
	        glyphIds = new Uint16Array(renderableGlyphCount);
	        glyphPositions = new Float32Array(renderableGlyphCount * 2);
	        glyphData = {};
	        visibleBounds = [INF, INF, -INF, -INF];
	        chunkedBounds = [];
	        let lineYOffset = topBaseline;
	        if (includeCaretPositions) {
	          caretPositions = new Float32Array(text.length * 3);
	        }
	        if (colorRanges) {
	          glyphColors = new Uint8Array(renderableGlyphCount * 3);
	        }
	        let renderableGlyphIndex = 0;
	        let prevCharIndex = -1;
	        let colorCharIndex = -1;
	        let chunk;
	        let currentColor;
	        lines.forEach((line, lineIndex) => {
	          let {count:lineGlyphCount, width:lineWidth} = line;

	          // Ignore empty lines
	          if (lineGlyphCount > 0) {
	            // Count trailing whitespaces, we want to ignore these for certain things
	            let trailingWhitespaceCount = 0;
	            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {
	              trailingWhitespaceCount++;
	            }

	            // Apply horizontal alignment adjustments
	            let lineXOffset = 0;
	            let justifyAdjust = 0;
	            if (textAlign === 'center') {
	              lineXOffset = (maxLineWidth - lineWidth) / 2;
	            } else if (textAlign === 'right') {
	              lineXOffset = maxLineWidth - lineWidth;
	            } else if (textAlign === 'justify' && line.isSoftWrapped) {
	              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop
	              let whitespaceCount = 0;
	              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {
	                if (line.glyphAt(i).glyphObj.isWhitespace) {
	                  whitespaceCount++;
	                }
	              }
	              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
	            }
	            if (justifyAdjust || lineXOffset) {
	              let justifyOffset = 0;
	              for (let i = 0; i < lineGlyphCount; i++) {
	                let glyphInfo = line.glyphAt(i);
	                const glyphObj = glyphInfo.glyphObj;
	                glyphInfo.x += lineXOffset + justifyOffset;
	                // Expand non-trailing whitespaces for justify alignment
	                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
	                  justifyOffset += justifyAdjust;
	                  glyphInfo.width += justifyAdjust;
	                }
	              }
	            }

	            // Perform bidi range flipping
	            const flips = bidi.getReorderSegments(
	              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex
	            );
	            for (let fi = 0; fi < flips.length; fi++) {
	              const [start, end] = flips[fi];
	              // Map start/end string indices to indices in the line
	              let left = Infinity, right = -Infinity;
	              for (let i = 0; i < lineGlyphCount; i++) {
	                if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters
	                  let startInLine = i, endInLine = i;
	                  for (; endInLine < lineGlyphCount; endInLine++) {
	                    let info = line.glyphAt(endInLine);
	                    if (info.charIndex > end) {
	                      break
	                    }
	                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width
	                      left = Math.min(left, info.x);
	                      right = Math.max(right, info.x + info.width);
	                    }
	                  }
	                  for (let j = startInLine; j < endInLine; j++) {
	                    const glyphInfo = line.glyphAt(j);
	                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
	                  }
	                  break
	                }
	              }
	            }

	            // Assemble final data arrays
	            let glyphObj;
	            const setGlyphObj = g => glyphObj = g;
	            for (let i = 0; i < lineGlyphCount; i++) {
	              let glyphInfo = line.glyphAt(i);
	              glyphObj = glyphInfo.glyphObj;
	              const glyphId = glyphObj.index;

	              // Replace mirrored characters in rtl
	              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl
	              if (rtl) {
	                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
	                if (mirrored) {
	                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
	                }
	              }

	              // Add caret positions
	              if (includeCaretPositions) {
	                const {charIndex} = glyphInfo;
	                const caretLeft = glyphInfo.x + anchorXOffset;
	                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
	                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft; //start edge x
	                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight; //end edge x
	                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y

	                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret
	                // positions for those missing char indices; currently this uses a best-guess by dividing
	                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList
	                // table to get better interior caret positions.
	                const ligCount = charIndex - prevCharIndex;
	                if (ligCount > 1) {
	                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
	                }
	                prevCharIndex = charIndex;
	              }

	              // Track current color range
	              if (colorRanges) {
	                const {charIndex} = glyphInfo;
	                while(charIndex > colorCharIndex) {
	                  colorCharIndex++;
	                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
	                    currentColor = colorRanges[colorCharIndex];
	                  }
	                }
	              }

	              // Get atlas data for renderable glyphs
	              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
	                const idx = renderableGlyphIndex++;

	                // Add this glyph's path data
	                if (!glyphData[glyphId]) {
	                  glyphData[glyphId] = {
	                    path: glyphObj.path,
	                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
	                  };
	                }

	                // Determine final glyph position and add to glyphPositions array
	                const glyphX = glyphInfo.x + anchorXOffset;
	                const glyphY = lineYOffset + anchorYOffset;
	                glyphPositions[idx * 2] = glyphX;
	                glyphPositions[idx * 2 + 1] = glyphY;

	                // Track total visible bounds
	                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
	                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
	                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
	                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
	                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
	                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
	                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
	                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;

	                // Track bounding rects for each chunk of N glyphs
	                if (idx % chunkedBoundsSize === 0) {
	                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};
	                  chunkedBounds.push(chunk);
	                }
	                chunk.end++;
	                const chunkRect = chunk.rect;
	                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
	                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
	                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
	                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;

	                // Add to glyph ids array
	                glyphIds[idx] = glyphId;

	                // Add colors
	                if (colorRanges) {
	                  const start = idx * 3;
	                  glyphColors[start] = currentColor >> 16 & 255;
	                  glyphColors[start + 1] = currentColor >> 8 & 255;
	                  glyphColors[start + 2] = currentColor & 255;
	                }
	              }
	            }
	          }

	          // Increment y offset for next line
	          lineYOffset -= lineHeight;
	        });

	        // Fill in remaining caret positions in case the final character was a ligature
	        if (caretPositions) {
	          const ligCount = text.length - prevCharIndex;
	          if (ligCount > 1) {
	            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
	          }
	        }
	      }

	      // Timing stats
	      timings.typesetting = now() - typesetStart;

	      callback({
	        glyphIds, //font indices for each glyph
	        glyphPositions, //x,y of each glyph's origin in layout
	        glyphData, //dict holding data about each glyph appearing in the text
	        caretPositions, //startX,endX,bottomY caret positions for each char
	        caretHeight, //height of cursor from bottom to top
	        glyphColors, //color for each glyph, if color ranges supplied
	        chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs
	        fontSize, //calculated em height
	        unitsPerEm, //font units per em
	        ascender: ascender * fontSizeMult, //font ascender
	        descender: descender * fontSizeMult, //font descender
	        capHeight: capHeight * fontSizeMult, //font cap-height
	        xHeight: xHeight * fontSizeMult, //font x-height
	        lineHeight, //computed line height
	        topBaseline, //y coordinate of the top line's baseline
	        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight
	          anchorXOffset,
	          anchorYOffset - lines.length * lineHeight,
	          anchorXOffset + maxLineWidth,
	          anchorYOffset
	        ],
	        visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds
	        timings
	      });
	    });
	  }


	  /**
	   * For a given text string and font parameters, determine the resulting block dimensions
	   * after wrapping for the given maxWidth.
	   * @param args
	   * @param callback
	   */
	  function measure(args, callback) {
	    typeset(args, (result) => {
	      const [x0, y0, x1, y1] = result.blockBounds;
	      callback({
	        width: x1 - x0,
	        height: y1 - y0
	      });
	    }, {metricsOnly: true});
	  }

	  function parsePercent(str) {
	    let match = str.match(/^([\d.]+)%$/);
	    let pct = match ? parseFloat(match[1]) : NaN;
	    return isNaN(pct) ? 0 : pct / 100
	  }

	  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
	    const ligStartX = caretPositions[ligStartIndex * 3];
	    const ligEndX = caretPositions[ligStartIndex * 3 + 1];
	    const ligY = caretPositions[ligStartIndex * 3 + 2];
	    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
	    for (let i = 0; i < ligCount; i++) {
	      const startIndex = (ligStartIndex + i) * 3;
	      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
	      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
	      caretPositions[startIndex + 2] = ligY;
	    }
	  }

	  function now() {
	    return (self.performance || Date).now()
	  }

	  // Array-backed structure for a single line's glyphs data
	  function TextLine() {
	    this.data = [];
	  }
	  const textLineProps = ['glyphObj', 'x', 'width', 'charIndex'];
	  TextLine.prototype = {
	    width: 0,
	    isSoftWrapped: false,
	    get count() {
	      return Math.ceil(this.data.length / textLineProps.length)
	    },
	    glyphAt(i) {
	      let fly = TextLine.flyweight;
	      fly.data = this.data;
	      fly.index = i;
	      return fly
	    },
	    splitAt(i) {
	      let newLine = new TextLine();
	      newLine.data = this.data.splice(i * textLineProps.length);
	      return newLine
	    }
	  };
	  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {
	    Object.defineProperty(obj, prop, {
	      get() {
	        return this.data[this.index * textLineProps.length + i]
	      },
	      set(val) {
	        this.data[this.index * textLineProps.length + i] = val;
	      }
	    });
	    return obj
	  }, {data: null, index: 0});


	  return {
	    typeset,
	    measure,
	    loadFont
	  }
	}

	function SDFGenerator() {
	var exports = (function (exports) {

	  /**
	   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]
	   */
	  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {
	    var t2 = 1 - t;
	    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;
	    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;
	  }

	  /**
	   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]
	   */
	  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {
	    var t2 = 1 - t;
	    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;
	    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;
	  }

	  /**
	   * Parse a path string into its constituent line/curve commands, invoking a callback for each.
	   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z
	   * @param {function(
	   *   command: 'L'|'Q'|'C',
	   *   startX: number,
	   *   startY: number,
	   *   endX: number,
	   *   endY: number,
	   *   ctrl1X?: number,
	   *   ctrl1Y?: number,
	   *   ctrl2X?: number,
	   *   ctrl2Y?: number
	   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the
	   *                      command identifier (only L/Q/C commands) and its numeric arguments.
	   */
	  function forEachPathCommand(pathString, commandCallback) {
	    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
	    var match, firstX, firstY, prevX, prevY;
	    while ((match = segmentRE.exec(pathString))) {
	      var args = match[2]
	        .replace(/^\s*|\s*$/g, '')
	        .split(/[,\s]+/)
	        .map(function (v) { return parseFloat(v); });
	      switch (match[1]) {
	        case 'M':
	          prevX = firstX = args[0];
	          prevY = firstY = args[1];
	          break
	        case 'L':
	          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands
	            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));
	          }
	          break
	        case 'Q': {
	          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);
	          break
	        }
	        case 'C': {
	          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);
	          break
	        }
	        case 'Z':
	          if (prevX !== firstX || prevY !== firstY) {
	            commandCallback('L', prevX, prevY, firstX, firstY);
	          }
	          break
	      }
	    }
	  }

	  /**
	   * Convert a path string to a series of straight line segments
	   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z
	   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback
	   *        function that will be called once for every line segment
	   * @param {number} [curvePoints] - How many straight line segments to use when approximating a
	   *        bezier curve in the path. Defaults to 16.
	   */
	  function pathToLineSegments (pathString, segmentCallback, curvePoints) {
	    if ( curvePoints === void 0 ) curvePoints = 16;

	    var tempPoint = { x: 0, y: 0 };
	    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
	      switch (command) {
	        case 'L':
	          segmentCallback(startX, startY, endX, endY);
	          break
	        case 'Q': {
	          var prevCurveX = startX;
	          var prevCurveY = startY;
	          for (var i = 1; i < curvePoints; i++) {
	            pointOnQuadraticBezier(
	              startX, startY,
	              ctrl1X, ctrl1Y,
	              endX, endY,
	              i / (curvePoints - 1),
	              tempPoint
	            );
	            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
	            prevCurveX = tempPoint.x;
	            prevCurveY = tempPoint.y;
	          }
	          break
	        }
	        case 'C': {
	          var prevCurveX$1 = startX;
	          var prevCurveY$1 = startY;
	          for (var i$1 = 1; i$1 < curvePoints; i$1++) {
	            pointOnCubicBezier(
	              startX, startY,
	              ctrl1X, ctrl1Y,
	              ctrl2X, ctrl2Y,
	              endX, endY,
	              i$1 / (curvePoints - 1),
	              tempPoint
	            );
	            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
	            prevCurveX$1 = tempPoint.x;
	            prevCurveY$1 = tempPoint.y;
	          }
	          break
	        }
	      }
	    });
	  }

	  var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";

	  var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";

	  var cache = new WeakMap();

	  var glContextParams = {
	    premultipliedAlpha: false,
	    preserveDrawingBuffer: true,
	    antialias: false,
	    depth: false,
	  };

	  /**
	   * This is a little helper library for WebGL. It assists with state management for a GL context.
	   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.
	   *
	   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap
	   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback
	   */
	  function withWebGLContext (glOrCanvas, callback) {
	    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;
	    var wrapper = cache.get(gl);
	    if (!wrapper) {
	      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
	      var extensions = {};
	      var programs = {};
	      var textures = {};
	      var textureUnit = -1;
	      var framebufferStack = [];

	      gl.canvas.addEventListener('webglcontextlost', function (e) {
	        handleContextLoss();
	        e.preventDefault();
	      }, false);

	      function getExtension (name) {
	        var ext = extensions[name];
	        if (!ext) {
	          ext = extensions[name] = gl.getExtension(name);
	          if (!ext) {
	            throw new Error((name + " not supported"))
	          }
	        }
	        return ext
	      }

	      function compileShader (src, type) {
	        var shader = gl.createShader(type);
	        gl.shaderSource(shader, src);
	        gl.compileShader(shader);
	        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
	        // if (!status && !gl.isContextLost()) {
	        //   throw new Error(gl.getShaderInfoLog(shader).trim())
	        // }
	        return shader
	      }

	      function withProgram (name, vert, frag, func) {
	        if (!programs[name]) {
	          var attributes = {};
	          var uniforms = {};
	          var program = gl.createProgram();
	          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
	          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
	          gl.linkProgram(program);

	          programs[name] = {
	            program: program,
	            transaction: function transaction (func) {
	              gl.useProgram(program);
	              func({
	                setUniform: function setUniform (type, name) {
	                  var values = [], len = arguments.length - 2;
	                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

	                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));
	                  gl[("uniform" + type)].apply(gl, [ uniformLoc ].concat( values ));
	                },

	                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {
	                  var attr = attributes[name];
	                  if (!attr) {
	                    attr = attributes[name] = {
	                      buf: gl.createBuffer(), // TODO should we destroy our buffers?
	                      loc: gl.getAttribLocation(program, name),
	                      data: null
	                    };
	                  }
	                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
	                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
	                  gl.enableVertexAttribArray(attr.loc);
	                  if (isWebGL2) {
	                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);
	                  } else {
	                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
	                  }
	                  if (data !== attr.data) {
	                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);
	                    attr.data = data;
	                  }
	                }
	              });
	            }
	          };
	        }

	        programs[name].transaction(func);
	      }

	      function withTexture (name, func) {
	        textureUnit++;
	        try {
	          gl.activeTexture(gl.TEXTURE0 + textureUnit);
	          var texture = textures[name];
	          if (!texture) {
	            texture = textures[name] = gl.createTexture();
	            gl.bindTexture(gl.TEXTURE_2D, texture);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	          }
	          gl.bindTexture(gl.TEXTURE_2D, texture);
	          func(texture, textureUnit);
	        } finally {
	          textureUnit--;
	        }
	      }

	      function withTextureFramebuffer (texture, textureUnit, func) {
	        var framebuffer = gl.createFramebuffer();
	        framebufferStack.push(framebuffer);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	        gl.activeTexture(gl.TEXTURE0 + textureUnit);
	        gl.bindTexture(gl.TEXTURE_2D, texture);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	        try {
	          func(framebuffer);
	        } finally {
	          gl.deleteFramebuffer(framebuffer);
	          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
	        }
	      }

	      function handleContextLoss () {
	        extensions = {};
	        programs = {};
	        textures = {};
	        textureUnit = -1;
	        framebufferStack.length = 0;
	      }

	      cache.set(gl, wrapper = {
	        gl: gl,
	        isWebGL2: isWebGL2,
	        getExtension: getExtension,
	        withProgram: withProgram,
	        withTexture: withTexture,
	        withTextureFramebuffer: withTextureFramebuffer,
	        handleContextLoss: handleContextLoss,
	      });
	    }
	    callback(wrapper);
	  }


	  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {
	    if ( channels === void 0 ) channels = 15;
	    if ( framebuffer === void 0 ) framebuffer = null;

	    withWebGLContext(glOrCanvas, function (ref) {
	      var gl = ref.gl;
	      var withProgram = ref.withProgram;
	      var withTexture = ref.withTexture;

	      withTexture('copy', function (tex, texUnit) {
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
	        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {
	          var setUniform = ref.setUniform;
	          var setAttribute = ref.setAttribute;

	          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
	          setUniform('1i', 'image', texUnit);
	          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
	          gl.disable(gl.BLEND);
	          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
	          gl.viewport(x, y, width, height);
	          gl.scissor(x, y, width, height);
	          gl.drawArrays(gl.TRIANGLES, 0, 3);
	        });
	      });
	    });
	  }

	  /**
	   * Resizing a canvas clears its contents; this utility copies the previous contents over.
	   * @param canvas
	   * @param newWidth
	   * @param newHeight
	   */
	  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {
	    var width = canvas.width;
	    var height = canvas.height;
	    withWebGLContext(canvas, function (ref) {
	      var gl = ref.gl;

	      var data = new Uint8Array(width * height * 4);
	      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
	      canvas.width = newWidth;
	      canvas.height = newHeight;
	      renderImageData(gl, data, 0, 0, width, height);
	    });
	  }

	  var webglUtils = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    withWebGLContext: withWebGLContext,
	    renderImageData: renderImageData,
	    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing
	  });

	  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
	    if ( sdfExponent === void 0 ) sdfExponent = 1;

	    var textureData = new Uint8Array(sdfWidth * sdfHeight);

	    var viewBoxWidth = viewBox[2] - viewBox[0];
	    var viewBoxHeight = viewBox[3] - viewBox[1];

	    // Decompose all paths into straight line segments and add them to an index
	    var segments = [];
	    pathToLineSegments(path, function (x1, y1, x2, y2) {
	      segments.push({
	        x1: x1, y1: y1, x2: x2, y2: y2,
	        minX: Math.min(x1, x2),
	        minY: Math.min(y1, y2),
	        maxX: Math.max(x1, x2),
	        maxY: Math.max(y1, y2)
	      });
	    });

	    // Sort segments by maxX, this will let us short-circuit some loops below
	    segments.sort(function (a, b) { return a.maxX - b.maxX; });

	    // For each target SDF texel, find the distance from its center to its nearest line segment,
	    // map that distance to an alpha value, and write that alpha to the texel
	    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
	      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
	        var signedDist = findNearestSignedDistance(
	          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
	          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
	        );

	        // Use an exponential scale to ensure the texels very near the glyph path have adequate
	        // precision, while allowing the distance field to cover the entire texture, given that
	        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam
	        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;
	        if (signedDist < 0) {
	          alpha = 1 - alpha;
	        }

	        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp
	        textureData[sdfY * sdfWidth + sdfX] = alpha;
	      }
	    }

	    return textureData

	    /**
	     * For a given x/y, search the index for the closest line segment and return
	     * its signed distance. Negative = inside, positive = outside, zero = on edge
	     * @param x
	     * @param y
	     * @returns {number}
	     */
	    function findNearestSignedDistance (x, y) {
	      var closestDistSq = Infinity;
	      var closestDist = Infinity;

	      for (var i = segments.length; i--;) {
	        var seg = segments[i];
	        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit
	        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
	          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);
	          if (distSq < closestDistSq) {
	            closestDistSq = distSq;
	            closestDist = Math.sqrt(closestDistSq);
	          }
	        }
	      }

	      // Flip to negative distance if inside the poly
	      if (isPointInPoly(x, y)) {
	        closestDist = -closestDist;
	      }
	      return closestDist
	    }

	    /**
	     * Determine whether the given point lies inside or outside the glyph. Uses a simple
	     * winding-number ray casting algorithm using a ray pointing east from the point.
	     */
	    function isPointInPoly (x, y) {
	      var winding = 0;
	      for (var i = segments.length; i--;) {
	        var seg = segments[i];
	        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit
	        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);
	        if (intersects) {
	          winding += seg.y1 < seg.y2 ? 1 : -1;
	        }
	      }
	      return winding !== 0
	    }
	  }

	  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
	    if ( sdfExponent === void 0 ) sdfExponent = 1;
	    if ( x === void 0 ) x = 0;
	    if ( y === void 0 ) y = 0;
	    if ( channel === void 0 ) channel = 0;

	    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
	  }

	  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
	    if ( sdfExponent === void 0 ) sdfExponent = 1;
	    if ( x === void 0 ) x = 0;
	    if ( y === void 0 ) y = 0;
	    if ( channel === void 0 ) channel = 0;

	    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
	    // Expand single-channel data to rbga
	    var rgbaData = new Uint8Array(data.length * 4);
	    for (var i = 0; i < data.length; i++) {
	      rgbaData[i * 4 + channel] = data[i];
	    }
	    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);
	  }

	  /**
	   * Find the absolute distance from a point to a line segment at closest approach
	   */
	  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {
	    var ldx = lineX1 - lineX0;
	    var ldy = lineY1 - lineY0;
	    var lengthSq = ldx * ldx + ldy * ldy;
	    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
	    var dx = x - (lineX0 + t * ldx);
	    var dy = y - (lineY0 + t * ldy);
	    return dx * dx + dy * dy
	  }

	  var javascript = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    generate: generate$2,
	    generateIntoCanvas: generateIntoCanvas$2,
	    generateIntoFramebuffer: generateIntoFramebuffer$1
	  });

	  var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";

	  var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";

	  var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";

	  // Single triangle covering viewport
	  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);

	  var implicitContext = null;
	  var isTestingSupport = false;
	  var NULL_OBJECT = {};
	  var supportByCanvas = new WeakMap(); // canvas -> bool

	  function validateSupport (glOrCanvas) {
	    if (!isTestingSupport && !isSupported(glOrCanvas)) {
	      throw new Error('WebGL generation not supported')
	    }
	  }

	  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
	    if ( sdfExponent === void 0 ) sdfExponent = 1;
	    if ( glOrCanvas === void 0 ) glOrCanvas = null;

	    if (!glOrCanvas) {
	      glOrCanvas = implicitContext;
	      if (!glOrCanvas) {
	        var canvas = typeof OffscreenCanvas === 'function'
	          ? new OffscreenCanvas(1, 1)
	          : typeof document !== 'undefined'
	            ? document.createElement('canvas')
	            : null;
	        if (!canvas) {
	          throw new Error('OffscreenCanvas or DOM canvas not supported')
	        }
	        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });
	      }
	    }

	    validateSupport(glOrCanvas);

	    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari

	    // Render into a background texture framebuffer
	    withWebGLContext(glOrCanvas, function (ref) {
	      var gl = ref.gl;
	      var withTexture = ref.withTexture;
	      var withTextureFramebuffer = ref.withTextureFramebuffer;

	      withTexture('readable', function (texture, textureUnit) {
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {
	          generateIntoFramebuffer(
	            sdfWidth,
	            sdfHeight,
	            path,
	            viewBox,
	            maxDistance,
	            sdfExponent,
	            gl,
	            framebuffer,
	            0,
	            0,
	            0 // red channel
	          );
	          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
	        });
	      });
	    });

	    // Throw away all but the red channel
	    var data = new Uint8Array(sdfWidth * sdfHeight);
	    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {
	      data[j++] = rgbaData[i];
	    }

	    return data
	  }

	  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
	    if ( sdfExponent === void 0 ) sdfExponent = 1;
	    if ( x === void 0 ) x = 0;
	    if ( y === void 0 ) y = 0;
	    if ( channel === void 0 ) channel = 0;

	    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
	  }

	  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
	    if ( sdfExponent === void 0 ) sdfExponent = 1;
	    if ( x === void 0 ) x = 0;
	    if ( y === void 0 ) y = 0;
	    if ( channel === void 0 ) channel = 0;

	    // Verify support
	    validateSupport(glOrCanvas);

	    // Compute path segments
	    var lineSegmentCoords = [];
	    pathToLineSegments(path, function (x1, y1, x2, y2) {
	      lineSegmentCoords.push(x1, y1, x2, y2);
	    });
	    lineSegmentCoords = new Float32Array(lineSegmentCoords);

	    withWebGLContext(glOrCanvas, function (ref) {
	      var gl = ref.gl;
	      var isWebGL2 = ref.isWebGL2;
	      var getExtension = ref.getExtension;
	      var withProgram = ref.withProgram;
	      var withTexture = ref.withTexture;
	      var withTextureFramebuffer = ref.withTextureFramebuffer;
	      var handleContextLoss = ref.handleContextLoss;

	      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {
	        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
	          gl.texImage2D(
	            gl.TEXTURE_2D, 0, gl.RGBA,
	            intermediateTexture._lastWidth = sdfWidth,
	            intermediateTexture._lastHeight = sdfHeight,
	            0, gl.RGBA, gl.UNSIGNED_BYTE, null
	          );
	        }

	        // Unsigned distance pass
	        withProgram('main', mainVertex, mainFragment, function (ref) {
	          var setAttribute = ref.setAttribute;
	          var setUniform = ref.setUniform;

	          // Init extensions
	          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');
	          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');

	          // Init/update attributes
	          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);
	          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);

	          // Init/update uniforms
	          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));
	          setUniform('1f', 'uMaxDistance', maxDistance);
	          setUniform('1f', 'uExponent', sdfExponent);

	          // Render initial unsigned distance / winding number info to a texture
	          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {
	            gl.enable(gl.BLEND);
	            gl.colorMask(true, true, true, true);
	            gl.viewport(0, 0, sdfWidth, sdfHeight);
	            gl.scissor(0, 0, sdfWidth, sdfHeight);
	            gl.blendFunc(gl.ONE, gl.ONE);
	            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a "winding number".
	            // Alpha holds the closest (MAX) unsigned distance.
	            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
	            gl.clear(gl.COLOR_BUFFER_BIT);
	            if (isWebGL2) {
	              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
	            } else {
	              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
	            }
	            // Debug
	            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)
	            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)
	            // console.log('intermediate texture data: ', debug)
	          });
	        });

	        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.
	        withProgram('post', viewportQuadVertex, postFragment, function (program) {
	          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);
	          program.setUniform('1i', 'tex', intermediateTextureUnit);
	          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	          gl.disable(gl.BLEND);
	          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
	          gl.viewport(x, y, sdfWidth, sdfHeight);
	          gl.scissor(x, y, sdfWidth, sdfHeight);
	          gl.drawArrays(gl.TRIANGLES, 0, 3);
	        });
	      });

	      // Handle context loss occurring during any of the above calls
	      if (gl.isContextLost()) {
	        handleContextLoss();
	        throw new Error('webgl context lost')
	      }
	    });
	  }

	  function isSupported (glOrCanvas) {
	    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);
	    var supported = supportByCanvas.get(key);
	    if (supported === undefined) {
	      isTestingSupport = true;
	      var failReason = null;
	      try {
	        // Since we can't detect all failure modes up front, let's just do a trial run of a
	        // simple path and compare what we get back to the correct expected result. This will
	        // also serve to prime the shader compilation.
	        var expectedResult = [
	          97, 106, 97, 61,
	          99, 137, 118, 80,
	          80, 118, 137, 99,
	          61, 97, 106, 97
	        ];
	        var testResult = generate$1(
	          4,
	          4,
	          'M8,8L16,8L24,24L16,24Z',
	          [0, 0, 32, 32],
	          24,
	          1,
	          glOrCanvas
	        );
	        supported = testResult && expectedResult.length === testResult.length &&
	          testResult.every(function (val, i) { return val === expectedResult[i]; });
	        if (!supported) {
	          failReason = 'bad trial run results';
	          console.info(expectedResult, testResult);
	        }
	      } catch (err) {
	        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?
	        supported = false;
	        failReason = err.message;
	      }
	      if (failReason) {
	        console.warn('WebGL SDF generation not supported:', failReason);
	      }
	      isTestingSupport = false;
	      supportByCanvas.set(key, supported);
	    }
	    return supported
	  }

	  var webgl = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    generate: generate$1,
	    generateIntoCanvas: generateIntoCanvas$1,
	    generateIntoFramebuffer: generateIntoFramebuffer,
	    isSupported: isSupported
	  });

	  /**
	   * Generate an SDF texture image for a 2D path.
	   *
	   * @param {number} sdfWidth - width of the SDF output image in pixels.
	   * @param {number} sdfHeight - height of the SDF output image in pixels.
	   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.
	   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.
	   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults
	   *        to half the maximum viewBox dimension.
	   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents
	   *        will give greater precision nearer the glyph's path.
	   * @return {Uint8Array}
	   */
	  function generate(
	    sdfWidth,
	    sdfHeight,
	    path,
	    viewBox,
	    maxDistance,
	    sdfExponent
	  ) {
	    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
	    if ( sdfExponent === void 0 ) sdfExponent = 1;

	    try {
	      return generate$1.apply(webgl, arguments)
	    } catch(e) {
	      console.info('WebGL SDF generation failed, falling back to JS', e);
	      return generate$2.apply(javascript, arguments)
	    }
	  }

	  /**
	   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position
	   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels
	   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.
	   *
	   * @param {number} sdfWidth - width of the SDF output image in pixels.
	   * @param {number} sdfHeight - height of the SDF output image in pixels.
	   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.
	   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.
	   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults
	   *        to half the maximum viewBox dimension.
	   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents
	   *        will give greater precision nearer the glyph's path.
	   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.
	   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results
	   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.
	   * @param {number} x - the x position at which to render the SDF.
	   * @param {number} y - the y position at which to render the SDF.
	   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.
	   * @return {Uint8Array}
	   */
	  function generateIntoCanvas(
	    sdfWidth,
	    sdfHeight,
	    path,
	    viewBox,
	    maxDistance,
	    sdfExponent,
	    canvas,
	    x,
	    y,
	    channel
	  ) {
	    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
	    if ( sdfExponent === void 0 ) sdfExponent = 1;
	    if ( x === void 0 ) x = 0;
	    if ( y === void 0 ) y = 0;
	    if ( channel === void 0 ) channel = 0;

	    try {
	      return generateIntoCanvas$1.apply(webgl, arguments)
	    } catch(e) {
	      console.info('WebGL SDF generation failed, falling back to JS', e);
	      return generateIntoCanvas$2.apply(javascript, arguments)
	    }
	  }

	  exports.forEachPathCommand = forEachPathCommand;
	  exports.generate = generate;
	  exports.generateIntoCanvas = generateIntoCanvas;
	  exports.javascript = javascript;
	  exports.pathToLineSegments = pathToLineSegments;
	  exports.webgl = webgl;
	  exports.webglUtils = webglUtils;

	  Object.defineProperty(exports, '__esModule', { value: true });

	  return exports;

	}({}));
	return exports
	}

	const now$1 = () => (self.performance || Date).now();

	const mainThreadGenerator = /*#__PURE__*/ SDFGenerator();

	/**
	 * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a
	 * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF
	 * generation when supported.
	 */
	function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {
	  // Allow opt-out
	  if (!useWebGL) {
	    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)
	  }

	  // Attempt GPU-accelerated generation first
	  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(
	    null,
	    err => {
	      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)
	    }
	  )
	}

	const queue = [];
	const chunkTimeBudget = 5; // ms
	let timer = 0;

	function nextChunk() {
	  const start = now$1();
	  while (queue.length && now$1() - start < chunkTimeBudget) {
	    queue.shift()();
	  }
	  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
	}

	/**
	 * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded
	 * macrotask chunks to allow render frames to execute in between.
	 */
	const generateSDF_GL = (...args) => {
	  return new Promise((resolve, reject) => {
	    queue.push(() => {
	      const start = now$1();
	      try {
	        mainThreadGenerator.webgl.generateIntoCanvas(...args);
	        resolve({ timing: now$1() - start });
	      } catch (err) {
	        reject(err);
	      }
	    });
	    if (!timer) {
	      timer = setTimeout(nextChunk, 0);
	    }
	  })
	};

	const threadCount = 4; // how many workers to spawn
	const idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds
	const threads = {};
	let callNum = 0;

	/**
	 * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism
	 */
	function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {
	  const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);
	  let thread = threads[workerId];
	  if (!thread) {
	    thread = threads[workerId] = {
	      workerModule: defineWorkerModule({
	        name: workerId,
	        workerId,
	        dependencies: [
	          SDFGenerator,
	          now$1
	        ],
	        init(_createSDFGenerator, now) {
	          const generate = _createSDFGenerator().javascript.generate;
	          return function (...args) {
	            const start = now();
	            const textureData = generate(...args);
	            return {
	              textureData,
	              timing: now() - start
	            }
	          }
	        },
	        getTransferables(result) {
	          return [result.textureData.buffer]
	        }
	      }),
	      requests: 0,
	      idleTimer: null
	    };
	  }

	  thread.requests++;
	  clearTimeout(thread.idleTimer);
	  return thread.workerModule(width, height, path, viewBox, distance, exponent)
	    .then(({ textureData, timing }) => {
	      // copy result data into the canvas
	      const start = now$1();
	      // expand single-channel data into rgba
	      const imageData = new Uint8Array(textureData.length * 4);
	      for (let i = 0; i < textureData.length; i++) {
	        imageData[i * 4 + channel] = textureData[i];
	      }
	      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));
	      timing += now$1() - start;

	      // clean up workers after a while
	      if (--thread.requests === 0) {
	        thread.idleTimer = setTimeout(() => { terminateWorker(workerId); }, idleTimeout);
	      }
	      return { timing }
	    })
	}

	function warmUpSDFCanvas(canvas) {
	  if (!canvas._warm) {
	    mainThreadGenerator.webgl.isSupported(canvas);
	    canvas._warm = true;
	  }
	}

	const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;

	function bidiFactory() {
	var bidi = (function (exports) {

	  // Bidi character types data, auto generated
	  var DATA = {
	    "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
	    "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
	    "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
	    "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
	    "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
	    "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
	    "B": "a,3,f+2,2v,690",
	    "S": "9,2,k",
	    "WS": "c,k,4f4,1vk+a,u,1j,335",
	    "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
	    "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
	    "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
	    "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
	    "LRO": "6ct",
	    "RLO": "6cu",
	    "LRE": "6cq",
	    "RLE": "6cr",
	    "PDF": "6cs",
	    "LRI": "6ee",
	    "RLI": "6ef",
	    "FSI": "6eg",
	    "PDI": "6eh"
	  };

	  var TYPES = {};
	  var TYPES_TO_NAMES = {};
	  TYPES.L = 1; //L is the default
	  TYPES_TO_NAMES[1] = 'L';
	  Object.keys(DATA).forEach(function (type, i) {
	    TYPES[type] = 1 << (i + 1);
	    TYPES_TO_NAMES[TYPES[type]] = type;
	  });
	  Object.freeze(TYPES);

	  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
	  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
	  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
	  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
	  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;

	  var map = null;

	  function parseData () {
	    if (!map) {
	      //const start = performance.now()
	      map = new Map();
	      var loop = function ( type ) {
	        if (DATA.hasOwnProperty(type)) {
	          var lastCode = 0;
	          DATA[type].split(',').forEach(function (range) {
	            var ref = range.split('+');
	            var skip = ref[0];
	            var step = ref[1];
	            skip = parseInt(skip, 36);
	            step = step ? parseInt(step, 36) : 0;
	            map.set(lastCode += skip, TYPES[type]);
	            for (var i = 0; i < step; i++) {
	              map.set(++lastCode, TYPES[type]);
	            }
	          });
	        }
	      };

	      for (var type in DATA) loop( type );
	      //console.log(`char types parsed in ${performance.now() - start}ms`)
	    }
	  }

	  /**
	   * @param {string} char
	   * @return {number}
	   */
	  function getBidiCharType (char) {
	    parseData();
	    return map.get(char.codePointAt(0)) || TYPES.L
	  }

	  function getBidiCharTypeName(char) {
	    return TYPES_TO_NAMES[getBidiCharType(char)]
	  }

	  // Bidi bracket pairs data, auto generated
	  var data$1 = {
	    "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
	    "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
	  };

	  /**
	   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or
	   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object
	   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.
	   * @param {string} encodedString
	   * @param {boolean} includeReverse - true if you want reverseMap in the output
	   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}
	   */
	  function parseCharacterMap (encodedString, includeReverse) {
	    var radix = 36;
	    var lastCode = 0;
	    var map = new Map();
	    var reverseMap = includeReverse && new Map();
	    var prevPair;
	    encodedString.split(',').forEach(function visit(entry) {
	      if (entry.indexOf('+') !== -1) {
	        for (var i = +entry; i--;) {
	          visit(prevPair);
	        }
	      } else {
	        prevPair = entry;
	        var ref = entry.split('>');
	        var a = ref[0];
	        var b = ref[1];
	        a = String.fromCodePoint(lastCode += parseInt(a, radix));
	        b = String.fromCodePoint(lastCode += parseInt(b, radix));
	        map.set(a, b);
	        includeReverse && reverseMap.set(b, a);
	      }
	    });
	    return { map: map, reverseMap: reverseMap }
	  }

	  var openToClose, closeToOpen, canonical;

	  function parse$1 () {
	    if (!openToClose) {
	      //const start = performance.now()
	      var ref = parseCharacterMap(data$1.pairs, true);
	      var map = ref.map;
	      var reverseMap = ref.reverseMap;
	      openToClose = map;
	      closeToOpen = reverseMap;
	      canonical = parseCharacterMap(data$1.canonical, false).map;
	      //console.log(`brackets parsed in ${performance.now() - start}ms`)
	    }
	  }

	  function openingToClosingBracket (char) {
	    parse$1();
	    return openToClose.get(char) || null
	  }

	  function closingToOpeningBracket (char) {
	    parse$1();
	    return closeToOpen.get(char) || null
	  }

	  function getCanonicalBracket (char) {
	    parse$1();
	    return canonical.get(char) || null
	  }

	  // Local type aliases
	  var TYPE_L = TYPES.L;
	  var TYPE_R = TYPES.R;
	  var TYPE_EN = TYPES.EN;
	  var TYPE_ES = TYPES.ES;
	  var TYPE_ET = TYPES.ET;
	  var TYPE_AN = TYPES.AN;
	  var TYPE_CS = TYPES.CS;
	  var TYPE_B = TYPES.B;
	  var TYPE_S = TYPES.S;
	  var TYPE_ON = TYPES.ON;
	  var TYPE_BN = TYPES.BN;
	  var TYPE_NSM = TYPES.NSM;
	  var TYPE_AL = TYPES.AL;
	  var TYPE_LRO = TYPES.LRO;
	  var TYPE_RLO = TYPES.RLO;
	  var TYPE_LRE = TYPES.LRE;
	  var TYPE_RLE = TYPES.RLE;
	  var TYPE_PDF = TYPES.PDF;
	  var TYPE_LRI = TYPES.LRI;
	  var TYPE_RLI = TYPES.RLI;
	  var TYPE_FSI = TYPES.FSI;
	  var TYPE_PDI = TYPES.PDI;

	  /**
	   * @typedef {object} GetEmbeddingLevelsResult
	   * @property {{start, end, level}[]} paragraphs
	   * @property {Uint8Array} levels
	   */

	  /**
	   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels
	   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved
	   * base embedding level.
	   *
	   * @param {string} string - The input string
	   * @param {"ltr"|"rtl"|"auto"} [baseDirection] - Use "ltr" or "rtl" to force a base paragraph direction,
	   *        otherwise a direction will be chosen automatically from each paragraph's contents.
	   * @return {GetEmbeddingLevelsResult}
	   */
	  function getEmbeddingLevels (string, baseDirection) {
	    var MAX_DEPTH = 125;

	    // Start by mapping all characters to their unicode type, as a bitmask integer
	    var charTypes = new Uint32Array(string.length);
	    for (var i = 0; i < string.length; i++) {
	      charTypes[i] = getBidiCharType(string[i]);
	    }

	    var charTypeCounts = new Map(); //will be cleared at start of each paragraph
	    function changeCharType(i, type) {
	      var oldType = charTypes[i];
	      charTypes[i] = type;
	      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
	      if (oldType & NEUTRAL_ISOLATE_TYPES) {
	        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
	      }
	      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);
	      if (type & NEUTRAL_ISOLATE_TYPES) {
	        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
	      }
	    }

	    var embedLevels = new Uint8Array(string.length);
	    var isolationPairs = new Map(); //init->pdi and pdi->init

	    // === 3.3.1 The Paragraph Level ===
	    // 3.3.1 P1: Split the text into paragraphs
	    var paragraphs = []; // [{start, end, level}, ...]
	    var paragraph = null;
	    for (var i$1 = 0; i$1 < string.length; i$1++) {
	      if (!paragraph) {
	        paragraphs.push(paragraph = {
	          start: i$1,
	          end: string.length - 1,
	          // 3.3.1 P2-P3: Determine the paragraph level
	          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)
	        });
	      }
	      if (charTypes[i$1] & TYPE_B) {
	        paragraph.end = i$1;
	        paragraph = null;
	      }
	    }

	    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
	    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };
	    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };

	    // Everything from here on will operate per paragraph.
	    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
	      paragraph = paragraphs[paraIdx];
	      var statusStack = [{
	        _level: paragraph.level,
	        _override: 0, //0=neutral, 1=L, 2=R
	        _isolate: 0 //bool
	      }];
	      var stackTop = (void 0);
	      var overflowIsolateCount = 0;
	      var overflowEmbeddingCount = 0;
	      var validIsolateCount = 0;
	      charTypeCounts.clear();

	      // === 3.3.2 Explicit Levels and Directions ===
	      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
	        var charType = charTypes[i$2];
	        stackTop = statusStack[statusStack.length - 1];

	        // Set initial counts
	        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
	        if (charType & NEUTRAL_ISOLATE_TYPES) {
	          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
	        }

	        // Explicit Embeddings: 3.3.2 X2 - X3
	        if (charType & FORMATTING_TYPES) { //prefilter all formatters
	          if (charType & (TYPE_RLE | TYPE_LRE)) {
	            embedLevels[i$2] = stackTop._level; // 5.2
	            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
	            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
	              statusStack.push({
	                _level: level,
	                _override: 0,
	                _isolate: 0
	              });
	            } else if (!overflowIsolateCount) {
	              overflowEmbeddingCount++;
	            }
	          }

	          // Explicit Overrides: 3.3.2 X4 - X5
	          else if (charType & (TYPE_RLO | TYPE_LRO)) {
	            embedLevels[i$2] = stackTop._level; // 5.2
	            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
	            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
	              statusStack.push({
	                _level: level$1,
	                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,
	                _isolate: 0
	              });
	            } else if (!overflowIsolateCount) {
	              overflowEmbeddingCount++;
	            }
	          }

	          // Isolates: 3.3.2 X5a - X5c
	          else if (charType & ISOLATE_INIT_TYPES) {
	            // X5c - FSI becomes either RLI or LRI
	            if (charType & TYPE_FSI) {
	              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
	            }

	            embedLevels[i$2] = stackTop._level;
	            if (stackTop._override) {
	              changeCharType(i$2, stackTop._override);
	            }
	            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
	            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
	              validIsolateCount++;
	              statusStack.push({
	                _level: level$2,
	                _override: 0,
	                _isolate: 1,
	                _isolInitIndex: i$2
	              });
	            } else {
	              overflowIsolateCount++;
	            }
	          }

	          // Terminating Isolates: 3.3.2 X6a
	          else if (charType & TYPE_PDI) {
	            if (overflowIsolateCount > 0) {
	              overflowIsolateCount--;
	            } else if (validIsolateCount > 0) {
	              overflowEmbeddingCount = 0;
	              while (!statusStack[statusStack.length - 1]._isolate) {
	                statusStack.pop();
	              }
	              // Add to isolation pairs bidirectional mapping:
	              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
	              if (isolInitIndex != null) {
	                isolationPairs.set(isolInitIndex, i$2);
	                isolationPairs.set(i$2, isolInitIndex);
	              }
	              statusStack.pop();
	              validIsolateCount--;
	            }
	            stackTop = statusStack[statusStack.length - 1];
	            embedLevels[i$2] = stackTop._level;
	            if (stackTop._override) {
	              changeCharType(i$2, stackTop._override);
	            }
	          }


	          // Terminating Embeddings and Overrides: 3.3.2 X7
	          else if (charType & TYPE_PDF) {
	            if (overflowIsolateCount === 0) {
	              if (overflowEmbeddingCount > 0) {
	                overflowEmbeddingCount--;
	              } else if (!stackTop._isolate && statusStack.length > 1) {
	                statusStack.pop();
	                stackTop = statusStack[statusStack.length - 1];
	              }
	            }
	            embedLevels[i$2] = stackTop._level; // 5.2
	          }

	          // End of Paragraph: 3.3.2 X8
	          else if (charType & TYPE_B) {
	            embedLevels[i$2] = paragraph.level;
	          }
	        }

	        // Non-formatting characters: 3.3.2 X6
	        else {
	          embedLevels[i$2] = stackTop._level;
	          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage
	          if (stackTop._override && charType !== TYPE_BN) {
	            changeCharType(i$2, stackTop._override);
	          }
	        }
	      }

	      // === 3.3.3 Preparations for Implicit Processing ===

	      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9
	      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to
	      // easily ignore them all from here on out.

	      // 3.3.3 X10
	      // Compute the set of isolating run sequences as specified by BD13
	      var levelRuns = [];
	      var currentRun = null;
	      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
	        var charType$1 = charTypes[i$3];
	        if (!(charType$1 & BN_LIKE_TYPES)) {
	          var lvl = embedLevels[i$3];
	          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
	          var isPDI = charType$1 === TYPE_PDI;
	          if (currentRun && lvl === currentRun._level) {
	            currentRun._end = i$3;
	            currentRun._endsWithIsolInit = isIsolInit;
	          } else {
	            levelRuns.push(currentRun = {
	              _start: i$3,
	              _end: i$3,
	              _level: lvl,
	              _startsWithPDI: isPDI,
	              _endsWithIsolInit: isIsolInit
	            });
	          }
	        }
	      }
	      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]
	      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
	        var run = levelRuns[runIdx];
	        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {
	          var seqRuns = [currentRun = run];
	          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {
	            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
	              if (levelRuns[i$4]._start === pdiIndex) {
	                seqRuns.push(currentRun = levelRuns[i$4]);
	                break
	              }
	            }
	          }
	          // build flat list of indices across all runs:
	          var seqIndices = [];
	          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
	            var run$1 = seqRuns[i$5];
	            for (var j = run$1._start; j <= run$1._end; j++) {
	              seqIndices.push(j);
	            }
	          }
	          // determine the sos/eos types:
	          var firstLevel = embedLevels[seqIndices[0]];
	          var prevLevel = paragraph.level;
	          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
	            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2
	              prevLevel = embedLevels[i$6];
	              break
	            }
	          }
	          var lastIndex = seqIndices[seqIndices.length - 1];
	          var lastLevel = embedLevels[lastIndex];
	          var nextLevel = paragraph.level;
	          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
	            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
	              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2
	                nextLevel = embedLevels[i$7];
	                break
	              }
	            }
	          }
	          isolatingRunSeqs.push({
	            _seqIndices: seqIndices,
	            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
	            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
	          });
	        }
	      }

	      // The next steps are done per isolating run sequence
	      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
	        var ref = isolatingRunSeqs[seqIdx];
	        var seqIndices$1 = ref._seqIndices;
	        var sosType = ref._sosType;
	        var eosType = ref._eosType;
	        /**
	         * All the level runs in an isolating run sequence have the same embedding level.
	         * 
	         * DO NOT change any `embedLevels[i]` within the current scope.
	         */
	        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;

	        // === 3.3.4 Resolving Weak Types ===

	        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose
	        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its
	        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.
	        if (charTypeCounts.get(TYPE_NSM)) {
	          for (var si = 0; si < seqIndices$1.length; si++) {
	            var i$8 = seqIndices$1[si];
	            if (charTypes[i$8] & TYPE_NSM) {
	              var prevType = sosType;
	              for (var sj = si - 1; sj >= 0; sj--) {
	                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN
	                  prevType = charTypes[seqIndices$1[sj]];
	                  break
	                }
	              }
	              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);
	            }
	          }
	        }

	        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)
	        // is found. If an AL is found, change the type of the European number to Arabic number.
	        if (charTypeCounts.get(TYPE_EN)) {
	          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
	            var i$9 = seqIndices$1[si$1];
	            if (charTypes[i$9] & TYPE_EN) {
	              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
	                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
	                if (prevCharType & STRONG_TYPES) {
	                  if (prevCharType === TYPE_AL) {
	                    changeCharType(i$9, TYPE_AN);
	                  }
	                  break
	                }
	              }
	            }
	          }
	        }

	        // W3. Change all ALs to R
	        if (charTypeCounts.get(TYPE_AL)) {
	          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
	            var i$10 = seqIndices$1[si$2];
	            if (charTypes[i$10] & TYPE_AL) {
	              changeCharType(i$10, TYPE_R);
	            }
	          }
	        }

	        // W4. A single European separator between two European numbers changes to a European number. A single common
	        // separator between two numbers of the same type changes to that type.
	        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
	          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
	            var i$11 = seqIndices$1[si$3];
	            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
	              var prevType$1 = 0, nextType = 0;
	              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
	                prevType$1 = charTypes[seqIndices$1[sj$2]];
	                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2
	                  break
	                }
	              }
	              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
	                nextType = charTypes[seqIndices$1[sj$3]];
	                if (!(nextType & BN_LIKE_TYPES)) { //5.2
	                  break
	                }
	              }
	              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {
	                changeCharType(i$11, prevType$1);
	              }
	            }
	          }
	        }

	        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.
	        if (charTypeCounts.get(TYPE_EN)) {
	          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
	            var i$12 = seqIndices$1[si$4];
	            if (charTypes[i$12] & TYPE_EN) {
	              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {
	                changeCharType(seqIndices$1[sj$4], TYPE_EN);
	              }
	              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {
	                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
	                  changeCharType(seqIndices$1[si$4], TYPE_EN);
	                }
	              }
	            }
	          }
	        }

	        // W6. Otherwise, separators and terminators change to Other Neutral.
	        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
	          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
	            var i$13 = seqIndices$1[si$5];
	            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
	              changeCharType(i$13, TYPE_ON);
	              // 5.2 transform adjacent BNs too:
	              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {
	                changeCharType(seqIndices$1[sj$5], TYPE_ON);
	              }
	              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {
	                changeCharType(seqIndices$1[sj$6], TYPE_ON);
	              }
	            }
	          }
	        }

	        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)
	        // is found. If an L is found, then change the type of the European number to L.
	        // NOTE: implemented in single forward pass for efficiency
	        if (charTypeCounts.get(TYPE_EN)) {
	          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
	            var i$14 = seqIndices$1[si$6];
	            var type = charTypes[i$14];
	            if (type & TYPE_EN) {
	              if (prevStrongType === TYPE_L) {
	                changeCharType(i$14, TYPE_L);
	              }
	            } else if (type & STRONG_TYPES) {
	              prevStrongType = type;
	            }
	          }
	        }

	        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===

	        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
	          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text
	          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional
	          // types EN and AN are treated as R.
	          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);
	          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;

	          // * Identify the bracket pairs in the current isolating run sequence according to BD16.
	          var bracketPairs = [];
	          {
	            var openerStack = [];
	            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
	              // NOTE: for any potential bracket character we also test that it still carries a NI
	              // type, as that may have been changed earlier. This doesn't seem to be explicitly
	              // called out in the spec, but is required for passage of certain tests.
	              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
	                var char = string[seqIndices$1[si$7]];
	                var oppositeBracket = (void 0);
	                // Opening bracket
	                if (openingToClosingBracket(char) !== null) {
	                  if (openerStack.length < 63) {
	                    openerStack.push({ char: char, seqIndex: si$7 });
	                  } else {
	                    break
	                  }
	                }
	                // Closing bracket
	                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
	                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
	                    var stackChar = openerStack[stackIdx].char;
	                    if (stackChar === oppositeBracket ||
	                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||
	                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char
	                    ) {
	                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
	                      openerStack.length = stackIdx; //pop the matching bracket and all following
	                      break
	                    }
	                  }
	                }
	              }
	            }
	            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });
	          }
	          // * For each bracket-pair element in the list of pairs of text positions
	          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
	            var ref$1 = bracketPairs[pairIdx];
	            var openSeqIdx = ref$1[0];
	            var closeSeqIdx = ref$1[1];
	            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.
	            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both
	            // brackets in the pair to match the embedding direction.
	            var foundStrongType = false;
	            var useStrongType = 0;
	            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
	              var i$15 = seqIndices$1[si$8];
	              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
	                foundStrongType = true;
	                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                if (lr === embedDirection) {
	                  useStrongType = lr;
	                  break
	                }
	              }
	            }
	            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test
	            // for an established context with a preceding strong type by checking backwards before the opening paired
	            // bracket until the first strong type (L, R, or sos) is found.
	            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so
	            //    set the type for both brackets in the pair to that direction.
	            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.
	            if (foundStrongType && !useStrongType) {
	              useStrongType = sosType;
	              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
	                var i$16 = seqIndices$1[si$9];
	                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
	                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                  if (lr$1 !== embedDirection) {
	                    useStrongType = lr$1;
	                  } else {
	                    useStrongType = embedDirection;
	                  }
	                  break
	                }
	              }
	            }
	            if (useStrongType) {
	              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
	              // * Any number of characters that had original bidirectional character type NSM prior to the application
	              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match
	              // the type of their preceding bracket.
	              if (useStrongType !== embedDirection) {
	                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
	                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
	                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
	                      charTypes[seqIndices$1[si$10]] = useStrongType;
	                    }
	                    break
	                  }
	                }
	              }
	              if (useStrongType !== embedDirection) {
	                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
	                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
	                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
	                      charTypes[seqIndices$1[si$11]] = useStrongType;
	                    }
	                    break
	                  }
	                }
	              }
	            }
	          }

	          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the
	          // same direction.
	          // N2. Any remaining NIs take the embedding direction.
	          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
	            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
	              var niRunStart = si$12, niRunEnd = si$12;
	              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L
	              for (var si2 = si$12 - 1; si2 >= 0; si2--) {
	                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
	                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs
	                } else {
	                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                  break
	                }
	              }
	              var nextType$1 = eosType;
	              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
	                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
	                  niRunEnd = si2$1;
	                } else {
	                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
	                  break
	                }
	              }
	              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
	                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
	              }
	              si$12 = niRunEnd;
	            }
	          }
	        }
	      }

	      // === 3.3.6 Resolving Implicit Levels ===

	      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
	        var level$3 = embedLevels[i$17];
	        var type$1 = charTypes[i$17];
	        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.
	        if (level$3 & 1) {
	          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
	            embedLevels[i$17]++;
	          }
	        }
	          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level
	        // and those of type AN or EN go up two levels.
	        else {
	          if (type$1 & TYPE_R) {
	            embedLevels[i$17]++;
	          } else if (type$1 & (TYPE_AN | TYPE_EN)) {
	            embedLevels[i$17] += 2;
	          }
	        }

	        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,
	        // and otherwise to the base level.
	        if (type$1 & BN_LIKE_TYPES) {
	          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
	        }

	        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or
	        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.
	        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.
	        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
	          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {
	            embedLevels[j$1] = paragraph.level;
	          }
	        }
	      }
	    }

	    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters
	    // according to section 3.4 Reordering Resolved Levels
	    return {
	      levels: embedLevels,
	      paragraphs: paragraphs
	    }

	    function determineAutoEmbedLevel (start, isFSI) {
	      // 3.3.1 P2 - P3
	      for (var i = start; i < string.length; i++) {
	        var charType = charTypes[i];
	        if (charType & (TYPE_R | TYPE_AL)) {
	          return 1
	        }
	        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {
	          return 0
	        }
	        if (charType & ISOLATE_INIT_TYPES) {
	          var pdi = indexOfMatchingPDI(i);
	          i = pdi === -1 ? string.length : pdi;
	        }
	      }
	      return 0
	    }

	    function indexOfMatchingPDI (isolateStart) {
	      // 3.1.2 BD9
	      var isolationLevel = 1;
	      for (var i = isolateStart + 1; i < string.length; i++) {
	        var charType = charTypes[i];
	        if (charType & TYPE_B) {
	          break
	        }
	        if (charType & TYPE_PDI) {
	          if (--isolationLevel === 0) {
	            return i
	          }
	        } else if (charType & ISOLATE_INIT_TYPES) {
	          isolationLevel++;
	        }
	      }
	      return -1
	    }
	  }

	  // Bidi mirrored chars data, auto generated
	  var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";

	  var mirrorMap;

	  function parse () {
	    if (!mirrorMap) {
	      //const start = performance.now()
	      var ref = parseCharacterMap(data, true);
	      var map = ref.map;
	      var reverseMap = ref.reverseMap;
	      // Combine both maps into one
	      reverseMap.forEach(function (value, key) {
	        map.set(key, value);
	      });
	      mirrorMap = map;
	      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)
	    }
	  }

	  function getMirroredCharacter (char) {
	    parse();
	    return mirrorMap.get(char) || null
	  }

	  /**
	   * Given a string and its resolved embedding levels, build a map of indices to replacement chars
	   * for any characters in right-to-left segments that have defined mirrored characters.
	   * @param string
	   * @param embeddingLevels
	   * @param [start]
	   * @param [end]
	   * @return {Map<number, string>}
	   */
	  function getMirroredCharactersMap(string, embeddingLevels, start, end) {
	    var strLen = string.length;
	    start = Math.max(0, start == null ? 0 : +start);
	    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);

	    var map = new Map();
	    for (var i = start; i <= end; i++) {
	      if (embeddingLevels[i] & 1) { //only odd (rtl) levels
	        var mirror = getMirroredCharacter(string[i]);
	        if (mirror !== null) {
	          map.set(i, mirror);
	        }
	      }
	    }
	    return map
	  }

	  /**
	   * Given a start and end denoting a single line within a string, and a set of precalculated
	   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.
	   * @param {string} string - the full input string
	   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels
	   * @param {number} [start] - first character in a subset of the full string
	   * @param {number} [end] - last character in a subset of the full string
	   * @return {number[][]} - the list of start/end segments that should be flipped, in order.
	   */
	  function getReorderSegments(string, embeddingLevelsResult, start, end) {
	    var strLen = string.length;
	    start = Math.max(0, start == null ? 0 : +start);
	    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);

	    var segments = [];
	    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {
	      var lineStart = Math.max(start, paragraph.start);
	      var lineEnd = Math.min(end, paragraph.end);
	      if (lineStart < lineEnd) {
	        // Local slice for mutation
	        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);

	        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the
	        // end of the line to the paragraph level.
	        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {
	          lineLevels[i] = paragraph.level;
	        }

	        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels
	        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.
	        var maxLevel = paragraph.level;
	        var minOddLevel = Infinity;
	        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
	          var level = lineLevels[i$1];
	          if (level > maxLevel) { maxLevel = level; }
	          if (level < minOddLevel) { minOddLevel = level | 1; }
	        }
	        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
	          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
	            if (lineLevels[i$2] >= lvl) {
	              var segStart = i$2;
	              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
	                i$2++;
	              }
	              if (i$2 > segStart) {
	                segments.push([segStart + lineStart, i$2 + lineStart]);
	              }
	            }
	          }
	        }
	      }
	    });
	    return segments
	  }

	  /**
	   * @param {string} string
	   * @param {GetEmbeddingLevelsResult} embedLevelsResult
	   * @param {number} [start]
	   * @param {number} [end]
	   * @return {string} the new string with bidi segments reordered
	   */
	  function getReorderedString(string, embedLevelsResult, start, end) {
	    var indices = getReorderedIndices(string, embedLevelsResult, start, end);
	    var chars = [].concat( string );
	    indices.forEach(function (charIndex, i) {
	      chars[i] = (
	        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null
	      ) || string[charIndex];
	    });
	    return chars.join('')
	  }

	  /**
	   * @param {string} string
	   * @param {GetEmbeddingLevelsResult} embedLevelsResult
	   * @param {number} [start]
	   * @param {number} [end]
	   * @return {number[]} an array with character indices in their new bidi order
	   */
	  function getReorderedIndices(string, embedLevelsResult, start, end) {
	    var segments = getReorderSegments(string, embedLevelsResult, start, end);
	    // Fill an array with indices
	    var indices = [];
	    for (var i = 0; i < string.length; i++) {
	      indices[i] = i;
	    }
	    // Reverse each segment in order
	    segments.forEach(function (ref) {
	      var start = ref[0];
	      var end = ref[1];

	      var slice = indices.slice(start, end + 1);
	      for (var i = slice.length; i--;) {
	        indices[end - i] = slice[i];
	      }
	    });
	    return indices
	  }

	  exports.closingToOpeningBracket = closingToOpeningBracket;
	  exports.getBidiCharType = getBidiCharType;
	  exports.getBidiCharTypeName = getBidiCharTypeName;
	  exports.getCanonicalBracket = getCanonicalBracket;
	  exports.getEmbeddingLevels = getEmbeddingLevels;
	  exports.getMirroredCharacter = getMirroredCharacter;
	  exports.getMirroredCharactersMap = getMirroredCharactersMap;
	  exports.getReorderSegments = getReorderSegments;
	  exports.getReorderedIndices = getReorderedIndices;
	  exports.getReorderedString = getReorderedString;
	  exports.openingToClosingBracket = openingToClosingBracket;

	  Object.defineProperty(exports, '__esModule', { value: true });

	  return exports;

	}({}));
	return bidi}

	/*!
	Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
	Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
	*/
	function typrFactory(){return "undefined"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if("ttcf"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=["cmap","head","hhea","maxp","hmtx","name","OS/2","post","loca","glyf","kern","CFF ","GPOS","GSUB","SVG "],i={_data:r,_offset:n},h={},f=0;f<o;f++){var d=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[d]={offset:u,length:l};}for(f=0;f<s.length;f++){var v=s[f];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var f=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return f}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a="",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a="",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:"undefined"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var f=s.readUshort(r,t);t+=2;var d=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+f),i.featureList=e._lctf.readFeatureList(r,h+d),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=n.readUshort(r,t);t+=2;var d=e._lctf.readLookupTable(r,o+f,a);s.push(d);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,f=0;f<i;f++){var d=n.readUshort(r,t);t+=2;var u=a(r,h,o+d,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var f=a.readUshort(r,t);t+=2;for(h=0;h<f;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2;var d=e._lctf.readFeatureTable(r,n+f);d.tag=h.trim(),o.push(d);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+f);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,o.default=e._lctf.readLangSysTable(r,n+s);var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[f.trim()]=e._lctf.readLangSysTable(r,n+d);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var f=[];for(i=0;i<h.length-1;i++)f.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var d=f[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,d),d.CharStrings){t=d.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));d.CharStrings=v;}if(d.ROS){t=d.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),d.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),d.FDArray.push(p);}t+=c[c.length-1],t=d.FDSelect,d.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)d.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return d.Encoding&&(d.Encoding=e.CFF.readEncoding(r,d.Encoding,d.CharStrings.length)),d.charset&&(d.charset=e.CFF.readCharset(r,d.charset,d.CharStrings.length)),e.CFF._readFDict(r,d,l),d},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=["FamilyName","FontName","FullName","Notice","version","Copyright"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[".notdef"],o=r[t];if(t++,0!=o)throw "error: unknown encoding format: "+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[".notdef"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw "error: format: "+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var f=0;1==s?(f=r[t],t++):(f=n.readUshort(r,t),t+=2);for(i=0;i<=f;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw "unsupported offset size: "+s+", count: "+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,f=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(f=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(f=o-139,i=1),247<=o&&o<=250&&(f=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(f=256*-(o-251)-s-108,i=2),255==o&&(f=n.readInt(r,t+1)/65535,i=5),a.val=null!=f?f:"o"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;i<=20&&(d=i,f=1),12==i&&(d=100*i+h,f=2),19!=i&&20!=i||(d=i,f=2),21<=i&&i<=27&&(d=i,f=1),28==i&&(u=o.readShort(r,t+1),f=3),29<=i&&i<=31&&(d=i,f=1),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i&&(u=o.readInt(r,t+1)/65535,f=5),s.push(null!=u?u:"o"+d),t+=f;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;if(28==i&&(u=n.readShort(r,t+1),f=3),29==i&&(u=n.readInt(r,t+1),f=5),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i)throw u=n.readInt(r,t+1)/65535,f=5,"unknown number";if(30==i){var l=[];for(f=1;;){var v=r[t+f];f++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U="",g=[0,1,2,3,4,5,6,7,8,9,".","e","e-","reserved","-","endOfNumber"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(d=["version","Notice","FullName","FamilyName","Weight","FontBBox","BlueValues","OtherBlues","FamilyBlues","FamilyOtherBlues","StdHW","StdVW","escape","UniqueID","XUID","charset","Encoding","CharStrings","Private","Subrs","defaultWidthX","nominalWidthX"][i],f=1,12==i)d=["Copyright","isFixedPitch","ItalicAngle","UnderlinePosition","UnderlineThickness","PaintType","CharstringType","FontMatrix","StrokeWidth","BlueScale","BlueShift","BlueFuzz","StemSnapH","StemSnapV","ForceBold",0,0,"LanguageGroup","ExpansionFactor","initialRandomSeed","SyntheticBase","PostScript","BaseFontName","BaseFontBlend",0,0,0,0,0,0,"ROS","CIDFontVersion","CIDFontRevision","CIDFontType","CIDCount","UIDBase","FDArray","FDSelect","FontName"][h],f=2;null!=d?(o[d]=1==s.length?s[0]:s,s=[]):s.push(u),t+=f;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var f=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l="p"+f+"e"+d,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):(void 0),o.tables.push(c);}if(null!=o[l])throw "multiple tables for one platform+encoding";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var f=0;f<h;f++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),f=a.readUint(r,i+4),d=a.readUint(r,i+8);n.groups.push([h,f,d]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,"glyf",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var f=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<f;i++){var d=n[o];if(o++,s.flags.push(d),0!=(8&d)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(d),i++;}}s.xs=[];for(i=0;i<f;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<f;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<f;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var f=o.readUshort(r,a);a+=2;var d=e._lctf.numOfOnes(f);0!=f&&(i.pos=e.GPOS.readValueRecord(r,a,f));}else if(2==t&&i.fmt>=1&&i.fmt<=2){f=o.readUshort(r,a);a+=2;var u=o.readUshort(r,a);a+=2;d=e._lctf.numOfOnes(f);var l=e._lctf.numOfOnes(u);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,p,u),p+=2*l),g.push({gid2:m,val1:x,val2:P});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var _=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var C=[];for(S=0;S<_;S++){var x=null,P=null;0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,a,u),a+=2*l),C.push({val1:x,val2:P});}i.matrix.push(C);}}}else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw "invalid extension substitution";return e.GPOS.subt(r,n.ltype,s+w)}}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var f=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,f),a+=2*i.newg.length;}}else if(4==t){i.vals=[];f=o.readUshort(r,a);a+=2;for(var d=0;d<f;d++){var u=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+u));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var l=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+l),i.scset=[];var v=o.readUshort(r,a);a+=2;for(d=0;d<v;d++){var c=o.readUshort(r,a);a+=2,i.scset.push(0==c?null:e.GSUB.readSubClassSet(r,s+c));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(d=0;d<3;d++){f=o.readUshort(r,a);a+=2;for(var p=[],U=0;U<f;U++)p.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*U)));a+=2*f,0==d&&(i.backCvg=p),1==d&&(i.inptCvg=p),2==d&&(i.ahedCvg=p);}f=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,f);}}else {if(7==t&&1==i.fmt){var g=o.readUshort(r,a);a+=2;var S=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=g;else if(n.ltype!=g)throw "invalid extension substitution";return e.GSUB.subt(r,n.ltype,s+S)}}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=["backtrack","input","lookahead"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,f=0;f<n.maxp.numGlyphs;f++)f<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},f=0;f<i;f++){t+=2;a=o.readUshort(r,t);t+=2;var d=o.readUshort(r,t);t+=2;var u=d>>>8;if(0!=(u&=15))throw "unknown kern table format: "+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var f=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var d=f>>>8;if(0!=(d&=15))throw "unknown kern table format: "+d;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var d=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(f),u.vals.push(d),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var f=0;f<h;f++)s.push(o.readUshort(r,t+(f<<1))<<1);if(1==i)for(f=0;f<h;f++)s.push(o.readUint(r,t+(f<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=["copyright","fontFamily","fontSubfamily","ID","fullName","version","postScriptName","trademark","manufacturer","designer","description","urlVendor","urlDesigner","licence","licenceURL","---","typoFamilyName","typoSubfamilyName","compatibleFull","sampleText","postScriptCID","wwsFamilyName","wwsSubfamilyName","lightPalette","darkPalette"],f=t+=2,d=0;d<s;d++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=f+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw "unknown encoding "+l+", platformID: "+u;g=n.readASCII(r,m,p);}var b="p"+u+","+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return o[i]},e["OS/2"]={},e["OS/2"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e["OS/2"].version0(r,t,o);else if(1==n)e["OS/2"].version1(r,t,o);else if(2==n||3==n||4==n)e["OS/2"].version2(r,t,o);else {if(5!=n)throw "unknown OS/2 table version: "+n;e["OS/2"].version5(r,t,o);}return o},e["OS/2"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e["OS/2"].version1=function(r,t,a){var n=e._bin;return t=e["OS/2"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e["OS/2"].version2=function(r,t,a){var n=e._bin;return t=e["OS/2"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e["OS/2"].version5=function(r,t,a){var n=e._bin;return t=e["OS/2"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw "no familiar platform and encoding!";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw "unknown cmap table format "+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:("string"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,f=1&r.flags[s],d=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(f){if(!d){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else d?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);f?d&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var f=o.crds[h],d=o.crds[h+1];a.crds.push(f*i.a+d*i.b+i.tx),a.crds.push(f*i.c+d*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U.getPairAdjustment=function(r,t,a){var n=!1;if(r.GPOS)for(var o=r.GPOS,s=o.lookupList,i=o.featureList,h=[],f=0;f<i.length;f++){var d=i[f];if("kern"==d.tag){n=!0;for(var u=0;u<d.tab.length;u++)if(!h[d.tab[u]]){h[d.tab[u]]=!0;for(var l=s[d.tab[u]],v=0;v<l.tabs.length;v++)if(null!=l.tabs[v]){var c,p=l.tabs[v];if(!p.coverage||-1!=(c=e._lctf.coverageIndex(p.coverage,t)))if(1==l.ltype);else if(2==l.ltype){var U=null;if(1==p.fmt){var g=p.pairsets[c];for(f=0;f<g.length;f++)g[f].gid2==a&&(U=g[f]);}else if(2==p.fmt){var S=e.U._getGlyphClass(t,p.classDef1),m=e.U._getGlyphClass(a,p.classDef2);U=p.matrix[S][m];}if(U){var b=0;return U.val1&&U.val1[2]&&(b+=U.val1[2]),U.val2&&U.val2[0]&&(b+=U.val2[0]),b}}}}}}if(r.kern&&!n){var y=r.kern.glyph1.indexOf(t);if(-1!=y){var F=r.kern.rval[y].glyph2.indexOf(a);if(-1!=F)return r.kern.rval[y].vals[F]}}return 0},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var f=h.vals[i],d=0;d<f.length;d++){var u=f[d],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var _=b.substLookupRecords;for(d=0;d<_.length;d+=2)_[d],_[d+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var C=h.lookupRec;for(m=0;m<C.length;m+=2){U=C[m];var x=n[C[m+1]];e.U._applySubs(r,t+U,x,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,f=e.U.glyphToPath(r,i),d=0;d<f.crds.length;d+=2)n.crds.push(f.crds[d]+o),n.crds.push(f.crds[d+1]);a&&n.cmds.push(a);for(d=0;d<f.cmds.length;d++)n.cmds.push(f.cmds[d]);a&&n.cmds.push("X"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push("M"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push("L"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push("C"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push("Q"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push("Z");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,_=0,C={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,C);var x=C.val;if(u+=C.size,"o1"==x||"o18"==x)s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if("o3"==x||"o23"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if("o4"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),d&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),d=!0;else if("o5"==x)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if("o6"==x||"o7"==x)for(var P=s.length,I="o6"==x,w=0;w<P;w++){var O=s.shift();I?l+=O:v+=O,I=!I,e.U.P.lineTo(o,l,v);}else if("o8"==x||"o24"==x){P=s.length;for(var T=0;T+6<=P;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),T+=6;"o24"==x&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if("o11"==x)break;if("o1234"==x||"o1235"==x||"o1236"==x||"o1237"==x)"o1234"==x&&(p=v,U=(c=l+s.shift())+s.shift(),_=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),"o1235"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),"o1236"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),_=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),"o1237"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v));else if("o14"==x){if(s.length>0&&!h&&(f=s.shift()+a.nominalWidthX,h=!0),4==s.length){var k=s.shift(),G=s.shift(),D=s.shift(),B=s.shift(),L=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[L],t,a,n,o),t.x=k,t.y=G,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}d&&(e.U.P.closePath(o),d=!1);}else if("o19"==x||"o20"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if("o21"==x)s.length>2&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if("o22"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if("o25"==x){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if("o26"==x)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if("o27"==x)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if("o10"==x||"o29"==x){var A="o10"==x?n:a;if(0==s.length);else {var W=s.pop(),M=A.Subrs[W+A.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open;}}else if("o30"==x||"o31"==x){var V=s.length,N=(T=0,"o31"==x);for(T+=V-(P=-3&V);T<P;)N?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),P-T==5?(l=U+s.shift(),T++):l=U,N=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),P-T==5?(v=g+s.shift(),T++):v=g,N=!0),e.U.P.curveTo(o,c,p,U,g,l,v),T+=4;}else {if("o"==(x+"").charAt(0))throw x;s.push(x);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,"__esModule",{value:!0}),r}({}).Typr}

	/*!
	Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
	(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
	Original licenses apply: 
	- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
	- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
	*/
	function woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x="undefined"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,"__esModule",{value:!0}),r}({}).convert_streams}

	/**
	 * A factory wrapper parsing a font file using Typr.
	 * Also adds support for WOFF files (not WOFF2).
	 */

	function parserFactory(Typr, woff2otf) {
	  const cmdArgLengths = {
	    M: 2,
	    L: 2,
	    Q: 4,
	    C: 6,
	    Z: 0
	  };

	  // {joinType: "skip+step,..."}
	  const joiningTypeRawData = {"C":"18g,ca,368,1kz","D":"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v","R":"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6","L":"x9u,jff,a,fd,jv","T":"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"};

	  const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.
	    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.
	    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.
	    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.
	    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.
	    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,

	  let joiningTypeMap;
	  function getCharJoiningType(ch) {
	    if (!joiningTypeMap) {
	      const m = {
	        R: JT_RIGHT,
	        L: JT_LEFT,
	        D: JT_DUAL,
	        C: JT_JOIN_CAUSING,
	        U: JT_NON_JOINING,
	        T: JT_TRANSPARENT
	      };
	      joiningTypeMap = new Map();
	      for (let type in joiningTypeRawData) {
	        let lastCode = 0;
	        joiningTypeRawData[type].split(',').forEach(range => {
	          let [skip, step] = range.split('+');
	          skip = parseInt(skip,36);
	          step = step ? parseInt(step, 36) : 0;
	          joiningTypeMap.set(lastCode += skip, m[type]);
	          for (let i = step; i--;) {
	            joiningTypeMap.set(++lastCode, m[type]);
	          }
	        });
	      }
	    }
	    return joiningTypeMap.get(ch) || JT_NON_JOINING
	  }

	  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
	  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];

	  function detectJoiningForms(str) {
	    // This implements the algorithm described here:
	    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md
	    const joiningForms = new Uint8Array(str.length);
	    let prevJoiningType = JT_NON_JOINING;
	    let prevForm = ISOL;
	    let prevIndex = -1;
	    for (let i = 0; i < str.length; i++) {
	      const code = str.codePointAt(i);
	      let joiningType = getCharJoiningType(code) | 0;
	      let form = ISOL;
	      if (joiningType & JT_TRANSPARENT) {
	        continue
	      }
	      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
	        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
	          form = FINA;
	          // isol->init, fina->medi
	          if (prevForm === ISOL || prevForm === FINA) {
	            joiningForms[prevIndex]++;
	          }
	        }
	        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
	          // medi->fina, init->isol
	          if (prevForm === INIT || prevForm === MEDI) {
	            joiningForms[prevIndex]--;
	          }
	        }
	      }
	      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
	        // medi->fina, init->isol
	        if (prevForm === INIT || prevForm === MEDI) {
	          joiningForms[prevIndex]--;
	        }
	      }
	      prevForm = joiningForms[i] = form;
	      prevJoiningType = joiningType;
	      prevIndex = i;
	      if (code > 0xffff) i++;
	    }
	    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))
	    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))
	    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))
	    return joiningForms
	  }

	  function stringToGlyphs (font, str) {
	    const glyphIds = [];
	    for (let i = 0; i < str.length; i++) {
	      const cc = str.codePointAt(i);
	      if (cc > 0xffff) i++;
	      glyphIds.push(Typr.U.codeToGlyph(font, cc));
	    }

	    const gsub = font['GSUB'];
	    if (gsub) {
	      const {lookupList, featureList} = gsub;
	      let joiningForms;
	      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
	      const usedLookups = [];
	      featureList.forEach(feature => {
	        if (supportedFeatures.test(feature.tag)) {
	          for (let ti = 0; ti < feature.tab.length; ti++) {
	            if (usedLookups[feature.tab[ti]]) continue
	            usedLookups[feature.tab[ti]] = true;
	            const tab = lookupList[feature.tab[ti]];
	            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
	            if (isJoiningFeature && !joiningForms) { //lazy
	              joiningForms = detectJoiningForms(str);
	            }
	            for (let ci = 0; ci < glyphIds.length; ci++) {
	              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
	                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
	              }
	            }
	          }
	        }
	      });
	    }

	    return glyphIds
	  }

	  function firstNum(...args) {
	    for (let i = 0; i < args.length; i++) {
	      if (typeof args[i] === 'number') {
	        return args[i]
	      }
	    }
	  }

	  function wrapFontObj(typrFont) {
	    const glyphMap = Object.create(null);

	    const os2 = typrFont['OS/2'];
	    const hhea = typrFont.hhea;
	    const unitsPerEm = typrFont.head.unitsPerEm;
	    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);

	    const fontObj = {
	      unitsPerEm,
	      ascender,
	      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
	      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
	      xHeight: firstNum(os2 && os2.sxHeight, ascender),
	      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
	      forEachGlyph(text, fontSize, letterSpacing, callback) {
	        let glyphX = 0;
	        const fontScale = 1 / fontObj.unitsPerEm * fontSize;

	        const glyphIndices = stringToGlyphs(typrFont, text);
	        let charIndex = 0;
	        let prevGlyphIndex = -1;
	        glyphIndices.forEach((glyphIndex, i) => {
	          // Typr returns a glyph index per string codepoint, with -1s in place of those that
	          // were omitted due to ligature substitution. So we can track original index in the
	          // string via simple increment, and skip everything else when seeing a -1.
	          if (glyphIndex !== -1) {
	            let glyphObj = glyphMap[glyphIndex];
	            if (!glyphObj) {
	              const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphIndex);

	              // Build path string
	              let path = '';
	              let crdsIdx = 0;
	              for (let i = 0, len = cmds.length; i < len; i++) {
	                const numArgs = cmdArgLengths[cmds[i]];
	                path += cmds[i];
	                for (let j = 1; j <= numArgs; j++) {
	                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];
	                }
	              }

	              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't
	              // normalize the two, so it's simplest just to iterate ourselves.
	              let xMin, yMin, xMax, yMax;
	              if (crds.length) {
	                xMin = yMin = Infinity;
	                xMax = yMax = -Infinity;
	                for (let i = 0, len = crds.length; i < len; i += 2) {
	                  let x = crds[i];
	                  let y = crds[i + 1];
	                  if (x < xMin) xMin = x;
	                  if (y < yMin) yMin = y;
	                  if (x > xMax) xMax = x;
	                  if (y > yMax) yMax = y;
	                }
	              } else {
	                xMin = xMax = yMin = yMax = 0;
	              }

	              glyphObj = glyphMap[glyphIndex] = {
	                index: glyphIndex,
	                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
	                xMin,
	                yMin,
	                xMax,
	                yMax,
	                path,
	                pathCommandCount: cmds.length,
	                // forEachPathCommand(callback) {
	                //   let argsIndex = 0
	                //   const argsArray = []
	                //   for (let i = 0, len = cmds.length; i < len; i++) {
	                //     const numArgs = cmdArgLengths[cmds[i]]
	                //     argsArray.length = 1 + numArgs
	                //     argsArray[0] = cmds[i]
	                //     for (let j = 1; j <= numArgs; j++) {
	                //       argsArray[j] = crds[argsIndex++]
	                //     }
	                //     callback.apply(null, argsArray)
	                //   }
	                // }
	              };
	            }

	            // Kerning
	            if (prevGlyphIndex !== -1) {
	              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
	            }

	            callback.call(null, glyphObj, glyphX, charIndex);

	            if (glyphObj.advanceWidth) {
	              glyphX += glyphObj.advanceWidth * fontScale;
	            }
	            if (letterSpacing) {
	              glyphX += letterSpacing * fontSize;
	            }

	            prevGlyphIndex = glyphIndex;
	          }
	          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);
	        });
	        return glyphX
	      }
	    };

	    return fontObj
	  }

	  return function parse(buffer) {
	    // Look to see if we have a WOFF file and convert it if so:
	    const peek = new Uint8Array(buffer, 0, 4);
	    const tag = Typr._bin.readASCII(peek, 0, 4);
	    if (tag === 'wOFF') {
	      buffer = woff2otf(buffer);
	    } else if (tag === 'wOF2') {
	      throw new Error('woff2 fonts not supported')
	    }
	    return wrapFontObj(Typr.parse(buffer)[0])
	  }
	}


	const workerModule = /*#__PURE__*/defineWorkerModule({
	  name: 'Typr Font Parser',
	  dependencies: [typrFactory, woff2otfFactory, parserFactory],
	  init(typrFactory, woff2otfFactory, parserFactory) {
	    const Typr = typrFactory();
	    const woff2otf = woff2otfFactory();
	    return parserFactory(Typr, woff2otf)
	  }
	});

	const CONFIG = {
	  defaultFontURL: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff', //Roboto Regular
	  sdfGlyphSize: 64,
	  sdfMargin: 1 / 16,
	  sdfExponent: 9,
	  textureWidth: 2048
	};
	const tempColor = /*#__PURE__*/new Color();

	function now() {
	  return (self.performance || Date).now()
	}

	/**
	 * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for
	 * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.
	 *
	 *   {
	 *     [sdfGlyphSize]: {
	 *       glyphCount: number,
	 *       sdfGlyphSize: number,
	 *       sdfTexture: Texture,
	 *       sdfCanvas: HTMLCanvasElement,
	 *       contextLost: boolean,
	 *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>
	 *     }
	 *   }
	 */
	const atlases = Object.create(null);

	/**
	 * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.
	 * @property {object} parameters - The normalized input arguments to the render call.
	 * @property {Texture} sdfTexture - The SDF atlas texture.
	 * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.
	 * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.
	 * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.
	 * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.
	 * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.
	 * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is
	 *           three elements: the starting X, the ending X, and the bottom Y for the caret.
	 * @property {number} [caretHeight] - An appropriate height for all selection carets.
	 * @property {number} ascender - The font's ascender metric.
	 * @property {number} descender - The font's descender metric.
	 * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.
	 * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.
	 * @property {number} lineHeight - The final computed lineHeight measurement.
	 * @property {number} topBaseline - The y position of the top line's baseline.
	 * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;
	 *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is
	 *           equivalent to the dimensions of a block-level text element in CSS.
	 * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;
	 *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.
	 * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,
	 *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.
	 * @property {object} timings - Timing info for various parts of the rendering logic including SDF
	 *           generation, typesetting, etc.
	 * @frozen
	 */

	/**
	 * @callback getTextRenderInfo~callback
	 * @param {TroikaTextRenderInfo} textRenderInfo
	 */

	/**
	 * Main entry point for requesting the data needed to render a text string with given font parameters.
	 * This is an asynchronous call, performing most of the logic in a web worker thread.
	 * @param {object} args
	 * @param {getTextRenderInfo~callback} callback
	 */
	function getTextRenderInfo(args, callback) {
	  args = assign$1({}, args);
	  const totalStart = now();

	  // Apply default font here to avoid a 'null' atlas, and convert relative
	  // URLs to absolute so they can be resolved in the worker
	  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);

	  // Normalize text to a string
	  args.text = '' + args.text;

	  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;

	  // Normalize colors
	  if (args.colorRanges != null) {
	    let colors = {};
	    for (let key in args.colorRanges) {
	      if (args.colorRanges.hasOwnProperty(key)) {
	        let val = args.colorRanges[key];
	        if (typeof val !== 'number') {
	          val = tempColor.set(val).getHex();
	        }
	        colors[key] = val;
	      }
	    }
	    args.colorRanges = colors;
	  }

	  Object.freeze(args);

	  // Init the atlas if needed
	  const {textureWidth, sdfExponent} = CONFIG;
	  const {sdfGlyphSize} = args;
	  const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);
	  let atlas = atlases[sdfGlyphSize];
	  if (!atlas) {
	    const canvas = document.createElement('canvas');
	    canvas.width = textureWidth;
	    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs
	    atlas = atlases[sdfGlyphSize] = {
	      glyphCount: 0,
	      sdfGlyphSize,
	      sdfCanvas: canvas,
	      sdfTexture: new Texture(
	        canvas,
	        undefined,
	        undefined,
	        undefined,
	        LinearFilter,
	        LinearFilter
	      ),
	      contextLost: false,
	      glyphsByFont: new Map()
	    };
	    atlas.sdfTexture.generateMipmaps = false;
	    initContextLossHandling(atlas);
	  }

	  const {sdfTexture, sdfCanvas} = atlas;
	  let fontGlyphs = atlas.glyphsByFont.get(args.font);
	  if (!fontGlyphs) {
	    atlas.glyphsByFont.set(args.font, fontGlyphs = new Map());
	  }

	  // Issue request to the typesetting engine in the worker
	  typesetInWorker(args).then(result => {
	    const {glyphIds, glyphPositions, fontSize, unitsPerEm, timings} = result;
	    const neededSDFs = [];
	    const glyphBounds = new Float32Array(glyphIds.length * 4);
	    const fontSizeMult = fontSize / unitsPerEm;
	    let boundsIdx = 0;
	    let positionsIdx = 0;
	    const quadsStart = now();
	    glyphIds.forEach((glyphId, i) => {
	      let glyphInfo = fontGlyphs.get(glyphId);

	      // If this is a glyphId not seen before, add it to the atlas
	      if (!glyphInfo) {
	        const {path, pathBounds} = result.glyphData[glyphId];

	        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.
	        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain
	        // useful interpolated values and will be ignored anyway.
	        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])
	          / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);

	        const atlasIndex = atlas.glyphCount++;
	        const sdfViewBox = [
	          pathBounds[0] - fontUnitsMargin,
	          pathBounds[1] - fontUnitsMargin,
	          pathBounds[2] + fontUnitsMargin,
	          pathBounds[3] + fontUnitsMargin,
	        ];
	        fontGlyphs.set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));

	        // Collect those that need SDF generation
	        neededSDFs.push(glyphInfo);
	      }

	      // Calculate bounds for renderable quads
	      // TODO can we get this back off the main thread?
	      const {sdfViewBox} = glyphInfo;
	      const posX = glyphPositions[positionsIdx++];
	      const posY = glyphPositions[positionsIdx++];
	      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
	      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
	      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
	      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;

	      // Convert glyphId to SDF index for the shader
	      glyphIds[i] = glyphInfo.atlasIndex;
	    });
	    timings.quads = (timings.quads || 0) + (now() - quadsStart);

	    const sdfStart = now();
	    timings.sdf = {};

	    // Grow the texture height by power of 2 if needed
	    const currentHeight = sdfCanvas.height;
	    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
	    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
	    if (neededHeight > currentHeight) {
	      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over
	      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
	      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it
	      sdfTexture.dispose();
	    }

	    Promise.all(neededSDFs.map(glyphInfo =>
	      generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {
	        timings.sdf[glyphInfo.atlasIndex] = timing;
	      })
	    )).then(() => {
	      if (neededSDFs.length && !atlas.contextLost) {
	        safariPre15Workaround(atlas);
	        sdfTexture.needsUpdate = true;
	      }
	      timings.sdfTotal = now() - sdfStart;
	      timings.total = now() - totalStart;
	      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)

	      // Invoke callback with the text layout arrays and updated texture
	      callback(Object.freeze({
	        parameters: args,
	        sdfTexture,
	        sdfGlyphSize,
	        sdfExponent,
	        glyphBounds,
	        glyphAtlasIndices: glyphIds,
	        glyphColors: result.glyphColors,
	        caretPositions: result.caretPositions,
	        caretHeight: result.caretHeight,
	        chunkedBounds: result.chunkedBounds,
	        ascender: result.ascender,
	        descender: result.descender,
	        lineHeight: result.lineHeight,
	        capHeight: result.capHeight,
	        xHeight: result.xHeight,
	        topBaseline: result.topBaseline,
	        blockBounds: result.blockBounds,
	        visibleBounds: result.visibleBounds,
	        timings: result.timings,
	      }));
	    });
	  });

	  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is
	  // "warmed up"; the first request will be the longest due to shader program compilation so this gets
	  // a head start on that process before SDFs actually start getting processed.
	  Promise.resolve().then(() => {
	    if (!atlas.contextLost) {
	      warmUpSDFCanvas(sdfCanvas);
	    }
	  });
	}

	function generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {
	  if (contextLost) {
	    // If the context is lost there's nothing we can do, just quit silently and let it
	    // get regenerated when the context is restored
	    return Promise.resolve({timing: -1})
	  }
	  const {textureWidth, sdfExponent} = CONFIG;
	  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
	  const squareIndex = Math.floor(atlasIndex / 4);
	  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
	  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
	  const channel = atlasIndex % 4;
	  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)
	}

	function initContextLossHandling(atlas) {
	  const canvas = atlas.sdfCanvas;

	  /*
	  // Begin context loss simulation
	  if (!window.WebGLDebugUtils) {
	    let script = document.getElementById('WebGLDebugUtilsScript')
	    if (!script) {
	      script = document.createElement('script')
	      script.id = 'WebGLDebugUtils'
	      document.head.appendChild(script)
	      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'
	    }
	    script.addEventListener('load', () => {
	      initContextLossHandling(atlas)
	    })
	    return
	  }
	  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)
	  canvas.loseContextInNCalls(500)
	  canvas.addEventListener('webglcontextrestored', (event) => {
	    canvas.loseContextInNCalls(5000)
	  })
	  // End context loss simulation
	  */

	  canvas.addEventListener('webglcontextlost', (event) => {
	    event.preventDefault();
	    atlas.contextLost = true;
	  });
	  canvas.addEventListener('webglcontextrestored', (event) => {
	    atlas.contextLost = false;
	    // Regenerate all glyphs into the restored canvas:
	    const promises = [];
	    atlas.glyphsByFont.forEach(glyphMap => {
	      glyphMap.forEach(glyph => {
	        promises.push(generateGlyphSDF(glyph, atlas, true));
	      });
	    });
	    Promise.all(promises).then(() => {
	      safariPre15Workaround(atlas);
	      atlas.sdfTexture.needsUpdate = true;
	    });
	  });
	}


	// Local assign impl so we don't have to import troika-core
	function assign$1(toObj, fromObj) {
	  for (let key in fromObj) {
	    if (fromObj.hasOwnProperty(key)) {
	      toObj[key] = fromObj[key];
	    }
	  }
	  return toObj
	}

	// Utility for making URLs absolute
	let linkEl;
	function toAbsoluteURL(path) {
	  if (!linkEl) {
	    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');
	  }
	  linkEl.href = path;
	  return linkEl.href
	}

	/**
	 * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround
	 * where it reads the pixels out of that canvas and uploads them as a data texture instead, at
	 * a slight performance cost.
	 */
	function safariPre15Workaround(atlas) {
	  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers
	  // have supported it for a long while so any false positives should be minimal.
	  if (typeof createImageBitmap !== 'function') {
	    const {sdfCanvas, sdfTexture} = atlas;
	    const {width, height} = sdfCanvas;
	    const gl = atlas.sdfCanvas.getContext('webgl');
	    let pixels = sdfTexture.image.data;
	    if (!pixels || pixels.length !== width * height * 4) {
	      pixels = new Uint8Array(width * height * 4);
	      sdfTexture.image = {width, height, data: pixels};
	      sdfTexture.flipY = false;
	      sdfTexture.isDataTexture = true;
	    }
	    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	  }
	}


	const typesetterWorkerModule = /*#__PURE__*/defineWorkerModule({
	  name: 'Typesetter',
	  dependencies: [
	    CONFIG,
	    workerModule,
	    createTypesetter,
	    bidiFactory
	  ],
	  init(config, fontParser, createTypesetter, bidiFactory) {
	    const {defaultFontURL} = config;
	    return createTypesetter(fontParser, bidiFactory(), { defaultFontURL })
	  }
	});

	const typesetInWorker = /*#__PURE__*/defineWorkerModule({
	  name: 'Typesetter',
	  dependencies: [
	    typesetterWorkerModule,
	  ],
	  init(typesetter) {
	    return function(args) {
	      return new Promise(resolve => {
	        typesetter.typeset(args, resolve);
	      })
	    }
	  },
	  getTransferables(result) {
	    // Mark array buffers as transferable to avoid cloning during postMessage
	    const transferables = [
	      result.glyphPositions.buffer,
	      result.glyphIds.buffer
	    ];
	    if (result.caretPositions) {
	      transferables.push(result.caretPositions.buffer);
	    }
	    if (result.glyphColors) {
	      transferables.push(result.glyphColors.buffer);
	    }
	    return transferables
	  }
	});

	const templateGeometries = {};

	function getTemplateGeometry(detail) {
	  let geom = templateGeometries[detail];
	  if (!geom) {
	    // Geometry is two planes back-to-back, which will always be rendered FrontSide only but
	    // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.
	    // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials
	    // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967
	    const front = new PlaneGeometry(1, 1, detail, detail);
	    const back = front.clone();
	    const frontAttrs = front.attributes;
	    const backAttrs = back.attributes;
	    const combined = new BufferGeometry();
	    const vertCount = frontAttrs.uv.count;
	    for (let i = 0; i < vertCount; i++) {
	      backAttrs.position.array[i * 3] *= -1; // flip position x
	      backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z
	    }
	    ['position', 'normal', 'uv'].forEach(name => {
	      combined.setAttribute(name, new Float32BufferAttribute(
	        [...frontAttrs[name].array, ...backAttrs[name].array],
	        frontAttrs[name].itemSize)
	      );
	    });
	    combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);
	    combined.translate(0.5, 0.5, 0);
	    geom = templateGeometries[detail] = combined;
	  }
	  return geom
	}

	const glyphBoundsAttrName = 'aTroikaGlyphBounds';
	const glyphIndexAttrName = 'aTroikaGlyphIndex';
	const glyphColorAttrName = 'aTroikaGlyphColor';

	/**
	@class GlyphsGeometry

	A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to
	render the glyphs using GPU instancing of a single quad, rather than constructing a whole
	geometry with vertices, for much smaller attribute arraybuffers according to this math:

	  Where N = number of glyphs...

	  Instanced:
	  - position: 4 * 3
	  - index: 2 * 3
	  - normal: 4 * 3
	  - uv: 4 * 2
	  - glyph x/y bounds: N * 4
	  - glyph indices: N * 1
	  = 5N + 38

	  Non-instanced:
	  - position: N * 4 * 3
	  - index: N * 2 * 3
	  - normal: N * 4 * 3
	  - uv: N * 4 * 2
	  - glyph indices: N * 1
	  = 39N

	A downside of this is the rare-but-possible lack of the instanced arrays extension,
	which we could potentially work around with a fallback non-instanced implementation.

	*/
	class GlyphsGeometry extends InstancedBufferGeometry {
	  constructor() {
	    super();

	    this.detail = 1;
	    this.curveRadius = 0;

	    // Define groups for rendering text outline as a separate pass; these will only
	    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.
	    this.groups = [
	      {start: 0, count: Infinity, materialIndex: 0},
	      {start: 0, count: Infinity, materialIndex: 1}
	    ];

	    // Preallocate empty bounding objects
	    this.boundingSphere = new Sphere();
	    this.boundingBox = new Box3();
	  }

	  computeBoundingSphere () {
	    // No-op; we'll sync the boundingSphere proactively when needed.
	  }

	  computeBoundingBox() {
	    // No-op; we'll sync the boundingBox proactively when needed.
	  }

	  // Since our base geometry contains triangles for both front and back sides, we can emulate
	  // the "side" by restricting the draw range.
	  setSide(side) {
	    const verts = this.getIndex().count;
	    this.setDrawRange(side === BackSide ? verts / 2 : 0, side === DoubleSide ? verts : verts / 2);
	  }

	  set detail(detail) {
	    if (detail !== this._detail) {
	      this._detail = detail;
	      if (typeof detail !== 'number' || detail < 1) {
	        detail = 1;
	      }
	      let tpl = getTemplateGeometry(detail)
	      ;['position', 'normal', 'uv'].forEach(attr => {
	        this.attributes[attr] = tpl.attributes[attr].clone();
	      });
	      this.setIndex(tpl.getIndex().clone());
	    }
	  }
	  get detail() {
	    return this._detail
	  }

	  set curveRadius(r) {
	    if (r !== this._curveRadius) {
	      this._curveRadius = r;
	      this._updateBounds();
	    }
	  }
	  get curveRadius() {
	    return this._curveRadius
	  }

	  /**
	   * Update the geometry for a new set of glyphs.
	   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
	   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
	   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
	   *        the SDF atlas texture.
	   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
	   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
	   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
	   *        used with `applyClipRect` to choose an optimized `instanceCount`.
	   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
	   */
	  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
	    // Update the instance attributes
	    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
	    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
	    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
	    this._blockBounds = blockBounds;
	    this._chunkedBounds = chunkedBounds;
	    this.instanceCount = glyphAtlasIndices.length;
	    this._updateBounds();
	  }

	  _updateBounds() {
	    const bounds = this._blockBounds;
	    if (bounds) {
	      const { curveRadius, boundingBox: bbox } = this;
	      if (curveRadius) {
	        const { PI, floor, min, max, sin, cos } = Math;
	        const halfPi = PI / 2;
	        const twoPi = PI * 2;
	        const absR = Math.abs(curveRadius);
	        const leftAngle = bounds[0] / absR;
	        const rightAngle = bounds[2] / absR;
	        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)
	          ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
	        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)
	          ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
	        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)
	          ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
	        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
	        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
	      } else {
	        bbox.min.set(bounds[0], bounds[1], 0);
	        bbox.max.set(bounds[2], bounds[3], 0);
	      }
	      bbox.getBoundingSphere(this.boundingSphere);
	    }
	  }

	  /**
	   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
	   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
	   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
	   * be clipped anyway.
	   *
	   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
	   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
	   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
	   * but at the expense of much larger attribute buffers (see classdoc above.)
	   *
	   * @param {Vector4} clipRect
	   */
	  applyClipRect(clipRect) {
	    let count = this.getAttribute(glyphIndexAttrName).count;
	    let chunks = this._chunkedBounds;
	    if (chunks) {
	      for (let i = chunks.length; i--;) {
	        count = chunks[i].end;
	        let rect = chunks[i].rect;
	        // note: both rects are l-b-r-t
	        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
	          break
	        }
	      }
	    }
	    this.instanceCount = count;
	  }
	}


	function updateBufferAttr(geom, attrName, newArray, itemSize) {
	  const attr = geom.getAttribute(attrName);
	  if (newArray) {
	    // If length isn't changing, just update the attribute's array data
	    if (attr && attr.array.length === newArray.length) {
	      attr.array.set(newArray);
	      attr.needsUpdate = true;
	    } else {
	      geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
	      // If the new attribute has a different size, we also have to (as of r117) manually clear the
	      // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706
	      // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in
	      // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a
	      // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly
	      // implies it should be supported. It's possible we need to
	      delete geom._maxInstanceCount; //for r117+, could be fragile
	      geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like
	    }
	  } else if (attr) {
	    geom.deleteAttribute(attrName);
	  }
	}

	// language=GLSL
	const VERTEX_DEFS$1 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;

	// language=GLSL prefix="void main() {" suffix="}"
	const VERTEX_TRANSFORM$1 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the
  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts
  on some glyphs (those in the leftmost texture column) on some systems. The exact reason
  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;

	// language=GLSL
	const FRAGMENT_DEFS$1 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those
    are linearly interpolated where the encoding is exponential. Look into improving this by rounding
    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.
  */}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${''/*
    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based
    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes 
    readability and edge crispness at all sizes and screen resolutions.
  */}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${''/* 
  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...
  // This has potential but currently gives very jagged extensions, maybe due to precision issues?
  float uvStep = 1.0 / uTroikaSDFGlyphSize;
  vec2 neighbor1UV = clampedGlyphUV + (
    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :
    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :
    vec2(0.0)
  );
  vec2 neighbor2UV = clampedGlyphUV + (
    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :
    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :
    vec2(0.0)
  );
  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);
  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);
  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);
  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);
  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);
  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);
  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;
  */}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;

	// language=GLSL prefix="void main() {" suffix="}"
	const FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;


	/**
	 * Create a material for rendering text, derived from a baseMaterial
	 */
	function createTextDerivedMaterial(baseMaterial) {
	  const textMaterial = createDerivedMaterial(baseMaterial, {
	    chained: true,
	    extensions: {
	      derivatives: true
	    },
	    uniforms: {
	      uTroikaSDFTexture: {value: null},
	      uTroikaSDFTextureSize: {value: new Vector2()},
	      uTroikaSDFGlyphSize: {value: 0},
	      uTroikaSDFExponent: {value: 0},
	      uTroikaTotalBounds: {value: new Vector4(0,0,0,0)},
	      uTroikaClipRect: {value: new Vector4(0,0,0,0)},
	      uTroikaDistanceOffset: {value: 0},
	      uTroikaOutlineOpacity: {value: 0},
	      uTroikaFillOpacity: {value: 1},
	      uTroikaPositionOffset: {value: new Vector2()},
	      uTroikaCurveRadius: {value: 0},
	      uTroikaBlurRadius: {value: 0},
	      uTroikaStrokeWidth: {value: 0},
	      uTroikaStrokeColor: {value: new Color()},
	      uTroikaStrokeOpacity: {value: 1},
	      uTroikaOrient: {value: new Matrix3()},
	      uTroikaUseGlyphColors: {value: true},
	      uTroikaSDFDebug: {value: false}
	    },
	    vertexDefs: VERTEX_DEFS$1,
	    vertexTransform: VERTEX_TRANSFORM$1,
	    fragmentDefs: FRAGMENT_DEFS$1,
	    fragmentColorTransform: FRAGMENT_TRANSFORM,
	    customRewriter({vertexShader, fragmentShader}) {
	      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
	      if (uDiffuseRE.test(fragmentShader)) {
	        // Replace all instances of `diffuse` with our varying
	        fragmentShader = fragmentShader
	          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')
	          .replace(/\bdiffuse\b/g, 'vTroikaGlyphColor');
	        // Make sure the vertex shader declares the uniform so we can grab it as a fallback
	        if (!uDiffuseRE.test(vertexShader)) {
	          vertexShader = vertexShader.replace(
	            voidMainRegExp,
	            'uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n'
	          );
	        }
	      }
	      return { vertexShader, fragmentShader }
	    }
	  });

	  // Force transparency - TODO is this reasonable?
	  textMaterial.transparent = true;

	  Object.defineProperties(textMaterial, {
	    isTroikaTextMaterial: {value: true},

	    // WebGLShadowMap reverses the side of the shadow material by default, which fails
	    // for planes, so here we force the `shadowSide` to always match the main side.
	    shadowSide: {
	      get() {
	        return this.side
	      },
	      set() {
	        //no-op
	      }
	    }
	  });

	  return textMaterial
	}

	const defaultMaterial$2 = /*#__PURE__*/ new MeshBasicMaterial({
	  color: 0xffffff,
	  side: DoubleSide,
	  transparent: true
	});
	const defaultStrokeColor = 0x808080;

	const tempMat4$2 = /*#__PURE__*/ new Matrix4();
	const tempVec3a = /*#__PURE__*/ new Vector3();
	const tempVec3b = /*#__PURE__*/ new Vector3();
	const tempArray = [];
	const origin = /*#__PURE__*/ new Vector3();
	const defaultOrient = '+x+y';

	function first(o) {
	  return Array.isArray(o) ? o[0] : o
	}

	let getFlatRaycastMesh = () => {
	  const mesh = new Mesh(
	    new PlaneGeometry(1, 1),
	    defaultMaterial$2
	  );
	  getFlatRaycastMesh = () => mesh;
	  return mesh
	};
	let getCurvedRaycastMesh = () => {
	  const mesh = new Mesh(
	    new PlaneGeometry(1, 1, 32, 1),
	    defaultMaterial$2
	  );
	  getCurvedRaycastMesh = () => mesh;
	  return mesh
	};

	const syncStartEvent = { type: 'syncstart' };
	const syncCompleteEvent = { type: 'synccomplete' };

	const SYNCABLE_PROPS = [
	  'font',
	  'fontSize',
	  'letterSpacing',
	  'lineHeight',
	  'maxWidth',
	  'overflowWrap',
	  'text',
	  'direction',
	  'textAlign',
	  'textIndent',
	  'whiteSpace',
	  'anchorX',
	  'anchorY',
	  'colorRanges',
	  'sdfGlyphSize'
	];

	const COPYABLE_PROPS = SYNCABLE_PROPS.concat(
	  'material',
	  'color',
	  'depthOffset',
	  'clipRect',
	  'curveRadius',
	  'orientation',
	  'glyphGeometryDetail'
	);

	/**
	 * @class Text
	 *
	 * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance
	 * fields (SDF).
	 */
	class Text extends Mesh {
	  constructor() {
	    const geometry = new GlyphsGeometry();
	    super(geometry, null);

	    // === Text layout properties: === //

	    /**
	     * @member {string} text
	     * The string of text to be rendered.
	     */
	    this.text = '';

	    /**
	     * @member {number|string} anchorX
	     * Defines the horizontal position in the text block that should line up with the local origin.
	     * Can be specified as a numeric x position in local units, a string percentage of the total
	     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',
	     * or 'right'.
	     */
	    this.anchorX = 0;

	    /**
	     * @member {number|string} anchorX
	     * Defines the vertical position in the text block that should line up with the local origin.
	     * Can be specified as a numeric y position in local units (note: down is negative y), a string
	     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:
	     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.
	     */
	    this.anchorY = 0;

	    /**
	     * @member {number} curveRadius
	     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put
	     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave
	     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline
	     * will be aligned with the text's local origin; you can use `anchorX` to offset it.
	     *
	     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane
	     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.
	     */
	    this.curveRadius = 0;

	    /**
	     * @member {string} direction
	     * Sets the base direction for the text. The default value of "auto" will choose a direction based
	     * on the text's content according to the bidi spec. A value of "ltr" or "rtl" will force the direction.
	     */
	    this.direction = 'auto';

	    /**
	     * @member {string} font
	     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.
	     * Defaults to the Roboto font loaded from Google Fonts.
	     */
	    this.font = null; //will use default from TextBuilder

	    /**
	     * @member {number} fontSize
	     * The size at which to render the font in local units; corresponds to the em-box height
	     * of the chosen `font`.
	     */
	    this.fontSize = 0.1;

	    /**
	     * @member {number} letterSpacing
	     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive
	     * numbers increase spacing and negative numbers decrease it.
	     */
	    this.letterSpacing = 0;

	    /**
	     * @member {number|string} lineHeight
	     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'
	     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.
	     */
	    this.lineHeight = 'normal';

	    /**
	     * @member {number} maxWidth
	     * The maximum width of the text block, above which text may start wrapping according to the
	     * `whiteSpace` and `overflowWrap` properties.
	     */
	    this.maxWidth = Infinity;

	    /**
	     * @member {string} overflowWrap
	     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`
	     * to break at whitespace characters, or `'break-word'` to allow breaking within words.
	     * Defaults to `'normal'`.
	     */
	    this.overflowWrap = 'normal';

	    /**
	     * @member {string} textAlign
	     * The horizontal alignment of each line of text within the overall text bounding box.
	     */
	    this.textAlign = 'left';

	    /**
	     * @member {number} textIndent
	     * Indentation for the first character of a line; see CSS `text-indent`.
	     */
	    this.textIndent = 0;

	    /**
	     * @member {string} whiteSpace
	     * Defines whether text should wrap when a line reaches the `maxWidth`. Can
	     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,
	     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to
	     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.
	     */
	    this.whiteSpace = 'normal';


	    // === Presentation properties: === //

	    /**
	     * @member {THREE.Material} material
	     * Defines a _base_ material to be used when rendering the text. This material will be
	     * automatically replaced with a material derived from it, that adds shader code to
	     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.
	     * By default it will derive from a simple white MeshBasicMaterial, but you can use any
	     * of the other mesh materials to gain other features like lighting, texture maps, etc.
	     *
	     * Also see the `color` shortcut property.
	     */
	    this.material = null;

	    /**
	     * @member {string|number|THREE.Color} color
	     * This is a shortcut for setting the `color` of the text's material. You can use this
	     * if you don't want to specify a whole custom `material`. Also, if you do use a custom
	     * `material`, this color will only be used for this particuar Text instance, even if
	     * that same material instance is shared across multiple Text objects.
	     */
	    this.color = null;

	    /**
	     * @member {object|null} colorRanges
	     * WARNING: This API is experimental and may change.
	     * This allows more fine-grained control of colors for individual or ranges of characters,
	     * taking precedence over the material's `color`. Its format is an Object whose keys each
	     * define a starting character index for a range, and whose values are the color for each
	     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or
	     * any of the strings accepted by `THREE.Color`.
	     */
	    this.colorRanges = null;

	    /**
	     * @member {number|string} outlineWidth
	     * WARNING: This API is experimental and may change.
	     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.
	     * Can be specified as either an absolute number in local units, or as a percentage string e.g.
	     * `"12%"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means
	     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.
	     */
	    this.outlineWidth = 0;

	    /**
	     * @member {string|number|THREE.Color} outlineColor
	     * WARNING: This API is experimental and may change.
	     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.
	     * Defaults to black.
	     */
	    this.outlineColor = 0x000000;

	    /**
	     * @member {number} outlineOpacity
	     * WARNING: This API is experimental and may change.
	     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.
	     * Defaults to `1`.
	     */
	    this.outlineOpacity = 1;

	    /**
	     * @member {number|string} outlineBlur
	     * WARNING: This API is experimental and may change.
	     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is
	     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.
	     * Can be specified as either an absolute number in local units, or as a percentage string e.g.
	     * `"12%"` which is treated as a percentage of the `fontSize`. Defaults to `0`.
	     */
	    this.outlineBlur = 0;

	    /**
	     * @member {number|string} outlineOffsetX
	     * WARNING: This API is experimental and may change.
	     * A horizontal offset for the text outline.
	     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
	     * which is treated as a percentage of the `fontSize`. Defaults to `0`.
	     */
	    this.outlineOffsetX = 0;

	    /**
	     * @member {number|string} outlineOffsetY
	     * WARNING: This API is experimental and may change.
	     * A vertical offset for the text outline.
	     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
	     * which is treated as a percentage of the `fontSize`. Defaults to `0`.
	     */
	    this.outlineOffsetY = 0;

	    /**
	     * @member {number|string} strokeWidth
	     * WARNING: This API is experimental and may change.
	     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.
	     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
	     * which is treated as a percentage of the `fontSize`. Defaults to `0`.
	     */
	    this.strokeWidth = 0;

	    /**
	     * @member {string|number|THREE.Color} strokeColor
	     * WARNING: This API is experimental and may change.
	     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.
	     */
	    this.strokeColor = defaultStrokeColor;

	    /**
	     * @member {number} strokeOpacity
	     * WARNING: This API is experimental and may change.
	     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.
	     */
	    this.strokeOpacity = 1;

	    /**
	     * @member {number} fillOpacity
	     * WARNING: This API is experimental and may change.
	     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows
	     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the
	     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.
	     */
	    this.fillOpacity = 1;

	    /**
	     * @member {number} depthOffset
	     * This is a shortcut for setting the material's `polygonOffset` and related properties,
	     * which can be useful in preventing z-fighting when this text is laid on top of another
	     * plane in the scene. Positive numbers are further from the camera, negatives closer.
	     */
	    this.depthOffset = 0;

	    /**
	     * @member {Array<number>} clipRect
	     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all
	     * pixels will be discarded. This can be used for example to clip overflowing text when
	     * `whiteSpace='nowrap'`.
	     */
	    this.clipRect = null;

	    /**
	     * @member {string} orientation
	     * Defines the axis plane on which the text should be laid out when the mesh has no extra
	     * rotation transform. It is specified as a string with two axes: the horizontal axis with
	     * positive pointing right, and the vertical axis with positive pointing up. By default this
	     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y
	     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's
	     * top toward negative z and facing positive y.
	     */
	    this.orientation = defaultOrient;

	    /**
	     * @member {number} glyphGeometryDetail
	     * Controls number of vertical/horizontal segments that make up each glyph's rectangular
	     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom
	     * vertex shader effects, for example.
	     */
	    this.glyphGeometryDetail = 1;

	    /**
	     * @member {number|null} sdfGlyphSize
	     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a
	     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality
	     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing
	     * the sharpness of corners and preventing loss of very thin lines, at the expense of
	     * increased memory footprint and longer SDF generation time.
	     */
	    this.sdfGlyphSize = null;

	    /**
	     * @member {boolean} gpuAccelerateSDF
	     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,
	     * making it much faster especially for complex glyphs, and falling back to a JavaScript version
	     * executed in web workers when support isn't available. It should automatically detect support,
	     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS
	     * version if you encounter issues with it.
	     */
	    this.gpuAccelerateSDF = true;

	    this.debugSDF = false;
	  }

	  /**
	   * Updates the text rendering according to the current text-related configuration properties.
	   * This is an async process, so you can pass in a callback function to be executed when it
	   * finishes.
	   * @param {function} [callback]
	   */
	  sync(callback) {
	    if (this._needsSync) {
	      this._needsSync = false;

	      // If there's another sync still in progress, queue
	      if (this._isSyncing) {
	        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
	      } else {
	        this._isSyncing = true;
	        this.dispatchEvent(syncStartEvent);

	        getTextRenderInfo({
	          text: this.text,
	          font: this.font,
	          fontSize: this.fontSize || 0.1,
	          letterSpacing: this.letterSpacing || 0,
	          lineHeight: this.lineHeight || 'normal',
	          maxWidth: this.maxWidth,
	          direction: this.direction || 'auto',
	          textAlign: this.textAlign,
	          textIndent: this.textIndent,
	          whiteSpace: this.whiteSpace,
	          overflowWrap: this.overflowWrap,
	          anchorX: this.anchorX,
	          anchorY: this.anchorY,
	          colorRanges: this.colorRanges,
	          includeCaretPositions: true, //TODO parameterize
	          sdfGlyphSize: this.sdfGlyphSize,
	          gpuAccelerateSDF: this.gpuAccelerateSDF,
	        }, textRenderInfo => {
	          this._isSyncing = false;

	          // Save result for later use in onBeforeRender
	          this._textRenderInfo = textRenderInfo;

	          // Update the geometry attributes
	          this.geometry.updateGlyphs(
	            textRenderInfo.glyphBounds,
	            textRenderInfo.glyphAtlasIndices,
	            textRenderInfo.blockBounds,
	            textRenderInfo.chunkedBounds,
	            textRenderInfo.glyphColors
	          );

	          // If we had extra sync requests queued up, kick it off
	          const queued = this._queuedSyncs;
	          if (queued) {
	            this._queuedSyncs = null;
	            this._needsSync = true;
	            this.sync(() => {
	              queued.forEach(fn => fn && fn());
	            });
	          }

	          this.dispatchEvent(syncCompleteEvent);
	          if (callback) {
	            callback();
	          }
	        });
	      }
	    }
	  }

	  /**
	   * Initiate a sync if needed - note it won't complete until next frame at the
	   * earliest so if possible it's a good idea to call sync() manually as soon as
	   * all the properties have been set.
	   * @override
	   */
	  onBeforeRender(renderer, scene, camera, geometry, material, group) {
	    this.sync();

	    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present
	    if (material.isTroikaTextMaterial) {
	      this._prepareForRender(material);
	    }

	    // We need to force the material to FrontSide to avoid the double-draw-call performance hit
	    // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness
	    // is instead applied via drawRange in the GlyphsGeometry.
	    material._hadOwnSide = material.hasOwnProperty('side');
	    this.geometry.setSide(material._actualSide = material.side);
	    material.side = FrontSide;
	  }

	  onAfterRender(renderer, scene, camera, geometry, material, group) {
	    // Restore original material side
	    if (material._hadOwnSide) {
	      material.side = material._actualSide;
	    } else {
	      delete material.side; // back to inheriting from base material
	    }
	  }

	  /**
	   * Shortcut to dispose the geometry specific to this instance.
	   * Note: we don't also dispose the derived material here because if anything else is
	   * sharing the same base material it will result in a pause next frame as the program
	   * is recompiled. Instead users can dispose the base material manually, like normal,
	   * and we'll also dispose the derived material at that time.
	   */
	  dispose() {
	    this.geometry.dispose();
	  }

	  /**
	   * @property {TroikaTextRenderInfo|null} textRenderInfo
	   * @readonly
	   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
	   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
	   * the asynchrous `sync()` process completes.
	   */
	  get textRenderInfo() {
	    return this._textRenderInfo || null
	  }

	  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
	  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
	  get material() {
	    let derivedMaterial = this._derivedMaterial;
	    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial$2.clone());
	    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
	      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
	      // dispose the derived material when its base material is disposed:
	      baseMaterial.addEventListener('dispose', function onDispose() {
	        baseMaterial.removeEventListener('dispose', onDispose);
	        derivedMaterial.dispose();
	      });
	    }
	    // If text outline is configured, render it as a preliminary draw using Three's multi-material
	    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi
	    // materials ensures the layers are always rendered consecutively in a consistent order.
	    // Each layer will trigger onBeforeRender with the appropriate material.
	    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
	      let outlineMaterial = derivedMaterial._outlineMtl;
	      if (!outlineMaterial) {
	        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
	          id: {value: derivedMaterial.id + 0.1}
	        });
	        outlineMaterial.isTextOutlineMaterial = true;
	        outlineMaterial.depthWrite = false;
	        outlineMaterial.map = null; //???
	        derivedMaterial.addEventListener('dispose', function onDispose() {
	          derivedMaterial.removeEventListener('dispose', onDispose);
	          outlineMaterial.dispose();
	        });
	      }
	      return [
	        outlineMaterial,
	        derivedMaterial
	      ]
	    } else {
	      return derivedMaterial
	    }
	  }
	  set material(baseMaterial) {
	    if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation
	      this._derivedMaterial = baseMaterial;
	      this._baseMaterial = baseMaterial.baseMaterial;
	    } else {
	      this._baseMaterial = baseMaterial;
	    }
	  }

	  get glyphGeometryDetail() {
	    return this.geometry.detail
	  }
	  set glyphGeometryDetail(detail) {
	    this.geometry.detail = detail;
	  }

	  get curveRadius() {
	    return this.geometry.curveRadius
	  }
	  set curveRadius(r) {
	    this.geometry.curveRadius = r;
	  }

	  // Create and update material for shadows upon request:
	  get customDepthMaterial() {
	    return first(this.material).getDepthMaterial()
	  }
	  get customDistanceMaterial() {
	    return first(this.material).getDistanceMaterial()
	  }

	  _prepareForRender(material) {
	    const isOutline = material.isTextOutlineMaterial;
	    const uniforms = material.uniforms;
	    const textInfo = this.textRenderInfo;
	    if (textInfo) {
	      const {sdfTexture, blockBounds} = textInfo;
	      uniforms.uTroikaSDFTexture.value = sdfTexture;
	      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
	      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
	      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
	      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
	      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;

	      let distanceOffset = 0;
	      let blurRadius = 0;
	      let strokeWidth = 0;
	      let fillOpacity;
	      let strokeOpacity;
	      let strokeColor;
	      let offsetX = 0;
	      let offsetY = 0;

	      if (isOutline) {
	        let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;
	        distanceOffset = this._parsePercent(outlineWidth) || 0;
	        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
	        fillOpacity = outlineOpacity;
	        offsetX = this._parsePercent(outlineOffsetX) || 0;
	        offsetY = this._parsePercent(outlineOffsetY) || 0;
	      } else {
	        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
	        if (strokeWidth) {
	          strokeColor = this.strokeColor;
	          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
	          strokeOpacity = this.strokeOpacity;
	          if (strokeOpacity == null) strokeOpacity = 1;
	        }
	        fillOpacity = this.fillOpacity;
	      }

	      uniforms.uTroikaDistanceOffset.value = distanceOffset;
	      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
	      uniforms.uTroikaBlurRadius.value = blurRadius;
	      uniforms.uTroikaStrokeWidth.value = strokeWidth;
	      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
	      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
	      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;

	      let clipRect = this.clipRect;
	      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
	        uniforms.uTroikaClipRect.value.fromArray(clipRect);
	      } else {
	        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines
	        const pad = (this.fontSize || 0.1) * 100;
	        uniforms.uTroikaClipRect.value.set(
	          blockBounds[0] - pad,
	          blockBounds[1] - pad,
	          blockBounds[2] + pad,
	          blockBounds[3] + pad
	        );
	      }
	      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
	    }
	    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
	    material.polygonOffset = !!this.depthOffset;
	    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;

	    // Shortcut for setting material color via `color` prop on the mesh; this is
	    // applied only to the derived material to avoid mutating a shared base material.
	    const color = isOutline ? (this.outlineColor || 0) : this.color;

	    if (color == null) {
	      delete material.color; //inherit from base
	    } else {
	      const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new Color());
	      if (color !== colorObj._input || typeof color === 'object') {
	        colorObj.set(colorObj._input = color);
	      }
	    }

	    // base orientation
	    let orient = this.orientation || defaultOrient;
	    if (orient !== material._orientation) {
	      let rotMat = uniforms.uTroikaOrient.value;
	      orient = orient.replace(/[^-+xyz]/g, '');
	      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
	      if (match) {
	        let [, hSign, hAxis, vSign, vAxis] = match;
	        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;
	        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;
	        tempMat4$2.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
	        rotMat.setFromMatrix4(tempMat4$2);
	      } else {
	        rotMat.identity();
	      }
	      material._orientation = orient;
	    }
	  }

	  _parsePercent(value) {
	    if (typeof value === 'string') {
	      let match = value.match(/^(-?[\d.]+)%$/);
	      let pct = match ? parseFloat(match[1]) : NaN;
	      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
	    }
	    return value
	  }

	  /**
	   * Translate a point in local space to an x/y in the text plane.
	   */
	  localPositionToTextCoords(position, target = new Vector2()) {
	    target.copy(position); //simple non-curved case is 1:1
	    const r = this.curveRadius;
	    if (r) { //flatten the curve
	      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
	    }
	    return target
	  }

	  /**
	   * Translate a point in world space to an x/y in the text plane.
	   */
	  worldPositionToTextCoords(position, target = new Vector2()) {
	    tempVec3a.copy(position);
	    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)
	  }

	  /**
	   * @override Custom raycasting to test against the whole text block's max rectangular bounds
	   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
	   */
	  raycast(raycaster, intersects) {
	    const {textRenderInfo, curveRadius} = this;
	    if (textRenderInfo) {
	      const bounds = textRenderInfo.blockBounds;
	      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
	      const geom = raycastMesh.geometry;
	      const {position, uv} = geom.attributes;
	      for (let i = 0; i < uv.count; i++) {
	        let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));
	        const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));
	        let z = 0;
	        if (curveRadius) {
	          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
	          x = Math.sin(x / curveRadius) * curveRadius;
	        }
	        position.setXYZ(i, x, y, z);
	      }
	      geom.boundingSphere = this.geometry.boundingSphere;
	      geom.boundingBox = this.geometry.boundingBox;
	      raycastMesh.matrixWorld = this.matrixWorld;
	      raycastMesh.material.side = this.material.side;
	      tempArray.length = 0;
	      raycastMesh.raycast(raycaster, tempArray);
	      for (let i = 0; i < tempArray.length; i++) {
	        tempArray[i].object = this;
	        intersects.push(tempArray[i]);
	      }
	    }
	  }

	  copy(source) {
	    // Prevent copying the geometry reference so we don't end up sharing attributes between instances
	    const geom = this.geometry;
	    super.copy(source);
	    this.geometry = geom;

	    COPYABLE_PROPS.forEach(prop => {
	      this[prop] = source[prop];
	    });
	    return this
	  }

	  clone() {
	    return new this.constructor().copy(this)
	  }
	}


	// Create setters for properties that affect text layout:
	SYNCABLE_PROPS.forEach(prop => {
	  const privateKey = '_private_' + prop;
	  Object.defineProperty(Text.prototype, prop, {
	    get() {
	      return this[privateKey]
	    },
	    set(value) {
	      if (value !== this[privateKey]) {
	        this[privateKey] = value;
	        this._needsSync = true;
	      }
	    }
	  });
	});

	//=== Utility functions for dealing with carets and selection ranges ===//

	/**
	 * @typedef {object} TextCaret
	 * @property {number} x - x position of the caret
	 * @property {number} y - y position of the caret's bottom
	 * @property {number} height - height of the caret
	 * @property {number} charIndex - the index in the original input string of this caret's target
	 *   character; the caret will be for the position _before_ that character.
	 */

	/**
	 * Given a local x/y coordinate in the text block plane, find the nearest caret position.
	 * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo
	 * @param {number} x
	 * @param {number} y
	 * @return {TextCaret | null}
	 */
	function getCaretAtPoint(textRenderInfo, x, y) {
	  let closestCaret = null;
	  const {caretHeight} = textRenderInfo;
	  const caretsByRow = groupCaretsByRow(textRenderInfo);

	  // Find nearest row by y first
	  let closestRowY = Infinity;
	  caretsByRow.forEach((carets, rowY) => {
	    if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {
	      closestRowY = rowY;
	    }
	  });

	  // Then find closest caret by x within that row
	  caretsByRow.get(closestRowY).forEach(caret => {
	    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {
	      closestCaret = caret;
	    }
	  });
	  return closestCaret
	}


	const _rectsCache = new WeakMap();

	/**
	 * Given start and end character indexes, return a list of rectangles covering all the
	 * characters within that selection.
	 * @param {TroikaTextRenderInfo} textRenderInfo
	 * @param {number} start - index of the first char in the selection
	 * @param {number} end - index of the first char after the selection
	 * @return {Array<{left, top, right, bottom}> | null}
	 */
	function getSelectionRects(textRenderInfo, start, end) {
	  let rects;
	  if (textRenderInfo) {
	    // Check cache - textRenderInfo is frozen so it's safe to cache based on it
	    let prevResult = _rectsCache.get(textRenderInfo);
	    if (prevResult && prevResult.start === start && prevResult.end === end) {
	      return prevResult.rects
	    }

	    const {caretPositions, caretHeight} = textRenderInfo;

	    // Normalize
	    if (end < start) {
	      const s = start;
	      start = end;
	      end = s;
	    }
	    start = Math.max(start, 0);
	    end = Math.min(end, caretPositions.length + 1);

	    // Build list of rects, expanding the current rect for all characters in a run and starting
	    // a new rect whenever reaching a new line or a new bidi direction
	    rects = [];
	    let currentRect = null;
	    for (let i = start; i < end; i++) {
	      const x1 = caretPositions[i * 3];
	      const x2 = caretPositions[i * 3 + 1];
	      const left = Math.min(x1, x2);
	      const right = Math.max(x1, x2);
	      const bottom = caretPositions[i * 3 + 2];
	      if (!currentRect || bottom !== currentRect.bottom || left > currentRect.right || right < currentRect.left) {
	        currentRect = {
	          left: Infinity,
	          right: -Infinity,
	          bottom: bottom,
	          top: bottom + caretHeight
	        };
	        rects.push(currentRect);
	      }
	      currentRect.left = Math.min(left, currentRect.left);
	      currentRect.right = Math.max(right, currentRect.right);
	    }

	    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs
	    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);
	    for (let i = rects.length - 1; i-- > 0;) {
	      const rectA = rects[i];
	      const rectB = rects[i + 1];
	      if (rectA.bottom === rectB.bottom && rectA.left <= rectB.right && rectA.right >= rectB.left) {
	        rectB.left = Math.min(rectB.left, rectA.left);
	        rectB.right = Math.max(rectB.right, rectA.right);
	        rects.splice(i, 1);
	      }
	    }

	    _rectsCache.set(textRenderInfo, {start, end, rects});
	  }
	  return rects
	}

	const _caretsByRowCache = new WeakMap();

	function groupCaretsByRow(textRenderInfo) {
	  // textRenderInfo is frozen so it's safe to cache based on it
	  let caretsByRow = _caretsByRowCache.get(textRenderInfo);
	  if (!caretsByRow) {
	    const {caretPositions, caretHeight} = textRenderInfo;
	    caretsByRow = new Map();
	    for (let i = 0; i < caretPositions.length; i += 3) {
	      const rowY = caretPositions[i + 2];
	      let rowCarets = caretsByRow.get(rowY);
	      if (!rowCarets) {
	        caretsByRow.set(rowY, rowCarets = []);
	      }
	      rowCarets.push({
	        x: caretPositions[i],
	        y: rowY,
	        height: caretHeight,
	        charIndex: i / 3
	      });
	      // Add one more caret after the final char
	      if (i + 3 >= caretPositions.length) {
	        rowCarets.push({
	          x: caretPositions[i + 1],
	          y: rowY,
	          height: caretHeight,
	          charIndex: i / 3 + 1
	        });
	      }
	    }
	  }
	  _caretsByRowCache.set(textRenderInfo, caretsByRow);
	  return caretsByRow
	}

	// Custom build of Yoga (https://yogalayout.com/) for use in troika-flex-layout.
	// Original MIT license applies: https://github.com/facebook/yoga/blob/master/LICENSE

	function yogaFactory() {
	  
	var Yoga = (function () {

	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * 
	   * @format
	   */

	  var CONSTANTS = {
	    ALIGN_COUNT: 8,
	    ALIGN_AUTO: 0,
	    ALIGN_FLEX_START: 1,
	    ALIGN_CENTER: 2,
	    ALIGN_FLEX_END: 3,
	    ALIGN_STRETCH: 4,
	    ALIGN_BASELINE: 5,
	    ALIGN_SPACE_BETWEEN: 6,
	    ALIGN_SPACE_AROUND: 7,

	    DIMENSION_COUNT: 2,
	    DIMENSION_WIDTH: 0,
	    DIMENSION_HEIGHT: 1,

	    DIRECTION_COUNT: 3,
	    DIRECTION_INHERIT: 0,
	    DIRECTION_LTR: 1,
	    DIRECTION_RTL: 2,

	    DISPLAY_COUNT: 2,
	    DISPLAY_FLEX: 0,
	    DISPLAY_NONE: 1,

	    EDGE_COUNT: 9,
	    EDGE_LEFT: 0,
	    EDGE_TOP: 1,
	    EDGE_RIGHT: 2,
	    EDGE_BOTTOM: 3,
	    EDGE_START: 4,
	    EDGE_END: 5,
	    EDGE_HORIZONTAL: 6,
	    EDGE_VERTICAL: 7,
	    EDGE_ALL: 8,

	    EXPERIMENTAL_FEATURE_COUNT: 1,
	    EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: 0,

	    FLEX_DIRECTION_COUNT: 4,
	    FLEX_DIRECTION_COLUMN: 0,
	    FLEX_DIRECTION_COLUMN_REVERSE: 1,
	    FLEX_DIRECTION_ROW: 2,
	    FLEX_DIRECTION_ROW_REVERSE: 3,

	    JUSTIFY_COUNT: 6,
	    JUSTIFY_FLEX_START: 0,
	    JUSTIFY_CENTER: 1,
	    JUSTIFY_FLEX_END: 2,
	    JUSTIFY_SPACE_BETWEEN: 3,
	    JUSTIFY_SPACE_AROUND: 4,
	    JUSTIFY_SPACE_EVENLY: 5,

	    LOG_LEVEL_COUNT: 6,
	    LOG_LEVEL_ERROR: 0,
	    LOG_LEVEL_WARN: 1,
	    LOG_LEVEL_INFO: 2,
	    LOG_LEVEL_DEBUG: 3,
	    LOG_LEVEL_VERBOSE: 4,
	    LOG_LEVEL_FATAL: 5,

	    MEASURE_MODE_COUNT: 3,
	    MEASURE_MODE_UNDEFINED: 0,
	    MEASURE_MODE_EXACTLY: 1,
	    MEASURE_MODE_AT_MOST: 2,

	    NODE_TYPE_COUNT: 2,
	    NODE_TYPE_DEFAULT: 0,
	    NODE_TYPE_TEXT: 1,

	    OVERFLOW_COUNT: 3,
	    OVERFLOW_VISIBLE: 0,
	    OVERFLOW_HIDDEN: 1,
	    OVERFLOW_SCROLL: 2,

	    POSITION_TYPE_COUNT: 2,
	    POSITION_TYPE_RELATIVE: 0,
	    POSITION_TYPE_ABSOLUTE: 1,

	    PRINT_OPTIONS_COUNT: 3,
	    PRINT_OPTIONS_LAYOUT: 1,
	    PRINT_OPTIONS_STYLE: 2,
	    PRINT_OPTIONS_CHILDREN: 4,

	    UNIT_COUNT: 4,
	    UNIT_UNDEFINED: 0,
	    UNIT_POINT: 1,
	    UNIT_PERCENT: 2,
	    UNIT_AUTO: 3,

	    WRAP_COUNT: 3,
	    WRAP_NO_WRAP: 0,
	    WRAP_WRAP: 1,
	    WRAP_WRAP_REVERSE: 2
	  };

	  var YGEnums = CONSTANTS;

	  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * 
	   * @format
	   */



	  var Layout = function () {
	    function Layout(left, right, top, bottom, width, height) {
	      _classCallCheck(this, Layout);

	      this.left = left;
	      this.right = right;
	      this.top = top;
	      this.bottom = bottom;
	      this.width = width;
	      this.height = height;
	    }

	    _createClass(Layout, [{
	      key: 'fromJS',
	      value: function fromJS(expose) {
	        expose(this.left, this.right, this.top, this.bottom, this.width, this.height);
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        return '<Layout#' + this.left + ':' + this.right + ';' + this.top + ':' + this.bottom + ';' + this.width + ':' + this.height + '>';
	      }
	    }]);

	    return Layout;
	  }();

	  var Size = function () {
	    _createClass(Size, null, [{
	      key: 'fromJS',
	      value: function fromJS(_ref) {
	        var width = _ref.width,
	            height = _ref.height;

	        return new Size(width, height);
	      }
	    }]);

	    function Size(width, height) {
	      _classCallCheck(this, Size);

	      this.width = width;
	      this.height = height;
	    }

	    _createClass(Size, [{
	      key: 'fromJS',
	      value: function fromJS(expose) {
	        expose(this.width, this.height);
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        return '<Size#' + this.width + 'x' + this.height + '>';
	      }
	    }]);

	    return Size;
	  }();

	  var Value = function () {
	    function Value(unit, value) {
	      _classCallCheck(this, Value);

	      this.unit = unit;
	      this.value = value;
	    }

	    _createClass(Value, [{
	      key: 'fromJS',
	      value: function fromJS(expose) {
	        expose(this.unit, this.value);
	      }
	    }, {
	      key: 'toString',
	      value: function toString() {
	        switch (this.unit) {
	          case YGEnums.UNIT_POINT:
	            return String(this.value);
	          case YGEnums.UNIT_PERCENT:
	            return this.value + '%';
	          case YGEnums.UNIT_AUTO:
	            return 'auto';
	          default:
	            {
	              return this.value + '?';
	            }
	        }
	      }
	    }, {
	      key: 'valueOf',
	      value: function valueOf() {
	        return this.value;
	      }
	    }]);

	    return Value;
	  }();

	  var entryCommon = function (bind, lib) {
	    function patch(prototype, name, fn) {
	      var original = prototype[name];

	      prototype[name] = function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        return fn.call.apply(fn, [this, original].concat(args));
	      };
	    }

	    var _arr = ['setPosition', 'setMargin', 'setFlexBasis', 'setWidth', 'setHeight', 'setMinWidth', 'setMinHeight', 'setMaxWidth', 'setMaxHeight', 'setPadding'];

	    var _loop = function _loop() {
	      var _methods;

	      var fnName = _arr[_i];
	      var methods = (_methods = {}, _defineProperty(_methods, YGEnums.UNIT_POINT, lib.Node.prototype[fnName]), _defineProperty(_methods, YGEnums.UNIT_PERCENT, lib.Node.prototype[fnName + 'Percent']), _defineProperty(_methods, YGEnums.UNIT_AUTO, lib.Node.prototype[fnName + 'Auto']), _methods);

	      patch(lib.Node.prototype, fnName, function (original) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          args[_key2 - 1] = arguments[_key2];
	        }

	        // We patch all these functions to add support for the following calls:
	        // .setWidth(100) / .setWidth("100%") / .setWidth(.getWidth()) / .setWidth("auto")

	        var value = args.pop();
	        var unit = void 0,
	            asNumber = void 0;

	        if (value === 'auto') {
	          unit = YGEnums.UNIT_AUTO;
	          asNumber = undefined;
	        } else if (value instanceof Value) {
	          unit = value.unit;
	          asNumber = value.valueOf();
	        } else {
	          unit = typeof value === 'string' && value.endsWith('%') ? YGEnums.UNIT_PERCENT : YGEnums.UNIT_POINT;
	          asNumber = parseFloat(value);
	          if (!Number.isNaN(value) && Number.isNaN(asNumber)) {
	            throw new Error('Invalid value ' + value + ' for ' + fnName);
	          }
	        }

	        if (!methods[unit]) throw new Error('Failed to execute "' + fnName + '": Unsupported unit \'' + value + '\'');

	        if (asNumber !== undefined) {
	          var _methods$unit;

	          return (_methods$unit = methods[unit]).call.apply(_methods$unit, [this].concat(args, [asNumber]));
	        } else {
	          var _methods$unit2;

	          return (_methods$unit2 = methods[unit]).call.apply(_methods$unit2, [this].concat(args));
	        }
	      });
	    };

	    for (var _i = 0; _i < _arr.length; _i++) {
	      _loop();
	    }

	    patch(lib.Config.prototype, 'free', function () {
	      // Since we handle the memory allocation ourselves (via lib.Config.create),
	      // we also need to handle the deallocation
	      lib.Config.destroy(this);
	    });

	    patch(lib.Node, 'create', function (_, config) {
	      // We decide the constructor we want to call depending on the parameters
	      return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
	    });

	    patch(lib.Node.prototype, 'free', function () {
	      // Since we handle the memory allocation ourselves (via lib.Node.create),
	      // we also need to handle the deallocation
	      lib.Node.destroy(this);
	    });

	    patch(lib.Node.prototype, 'freeRecursive', function () {
	      for (var t = 0, T = this.getChildCount(); t < T; ++t) {
	        this.getChild(0).freeRecursive();
	      }
	      this.free();
	    });

	    patch(lib.Node.prototype, 'setMeasureFunc', function (original, measureFunc) {
	      // This patch is just a convenience patch, since it helps write more
	      // idiomatic source code (such as .setMeasureFunc(null))
	      // We also automatically convert the return value of the measureFunc
	      // to a Size object, so that we can return anything that has .width and
	      // .height properties
	      if (measureFunc) {
	        return original.call(this, function () {
	          return Size.fromJS(measureFunc.apply(undefined, arguments));
	        });
	      } else {
	        return this.unsetMeasureFunc();
	      }
	    });

	    patch(lib.Node.prototype, 'calculateLayout', function (original) {
	      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
	      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
	      var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : YGEnums.DIRECTION_LTR;

	      // Just a small patch to add support for the function default parameters
	      return original.call(this, width, height, direction);
	    });

	    return _extends({
	      Config: lib.Config,
	      Node: lib.Node,
	      Layout: bind('Layout', Layout),
	      Size: bind('Size', Size),
	      Value: bind('Value', Value),
	      getInstanceCount: function getInstanceCount() {
	        return lib.getInstanceCount.apply(lib, arguments);
	      }
	    }, YGEnums);
	  };

	  const $module={exports:{}};
	              (new Function('module', `!function(n,e){"function"==typeof define&&define.amd?define([],(function(){return e})):"object"==typeof module&&module.exports?module.exports=e:(n.nbind=n.nbind||{}).init=e}(this,(function(Module,cb){var Module;"function"==typeof Module&&(cb=Module,Module={}),Module.onRuntimeInitialized=function(n,e){return function(){n&&n.apply(this,arguments);try{Module.ccall("nbind_init")}catch(n){return void e(n)}e(null,{bind:Module._nbind_value,reflect:Module.NBind.reflect,queryType:Module.NBind.queryType,toggleLightGC:Module.toggleLightGC,lib:Module})}}(Module.onRuntimeInitialized,cb),Module||(Module=(void 0!==Module?Module:null)||{});var moduleOverrides={};for(var key in Module)Module.hasOwnProperty(key)&&(moduleOverrides[key]=Module[key]);var ENVIRONMENT_IS_WEB=!1,ENVIRONMENT_IS_WORKER=!1,ENVIRONMENT_IS_NODE=!1,ENVIRONMENT_IS_SHELL=!1,nodeFS,nodePath;if(Module.ENVIRONMENT)if("WEB"===Module.ENVIRONMENT)ENVIRONMENT_IS_WEB=!0;else if("WORKER"===Module.ENVIRONMENT)ENVIRONMENT_IS_WORKER=!0;else if("NODE"===Module.ENVIRONMENT)ENVIRONMENT_IS_NODE=!0;else{if("SHELL"!==Module.ENVIRONMENT)throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");ENVIRONMENT_IS_SHELL=!0}else ENVIRONMENT_IS_WEB="object"==typeof window,ENVIRONMENT_IS_WORKER="function"==typeof importScripts,ENVIRONMENT_IS_NODE="object"==typeof process&&"function"==typeof require&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER,ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(ENVIRONMENT_IS_NODE)Module.print||(Module.print=console.log),Module.printErr||(Module.printErr=console.warn),Module.read=function(n,e){nodeFS||(nodeFS={}("")),nodePath||(nodePath={}("")),n=nodePath.normalize(n);var r=nodeFS.readFileSync(n);return e?r:r.toString()},Module.readBinary=function(n){var e=Module.read(n,!0);return e.buffer||(e=new Uint8Array(e)),assert(e.buffer),e},Module.load=function(n){globalEval(read(n))},Module.thisProgram||(process.argv.length>1?Module.thisProgram=process.argv[1].replace(/\\\\/g,"/"):Module.thisProgram="unknown-program"),Module.arguments=process.argv.slice(2),"undefined"!=typeof module&&(module.exports=Module),process.on("uncaughtException",(function(n){if(!(n instanceof ExitStatus))throw n})),Module.inspect=function(){return"[Emscripten Module object]"};else if(ENVIRONMENT_IS_SHELL)Module.print||(Module.print=print),"undefined"!=typeof printErr&&(Module.printErr=printErr),"undefined"!=typeof read?Module.read=read:Module.read=function(){throw"no read() available"},Module.readBinary=function(n){if("function"==typeof readbuffer)return new Uint8Array(readbuffer(n));var e=read(n,"binary");return assert("object"==typeof e),e},"undefined"!=typeof scriptArgs?Module.arguments=scriptArgs:void 0!==arguments&&(Module.arguments=arguments),"function"==typeof quit&&(Module.quit=function(n,e){quit(n)});else{if(!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER)throw"Unknown runtime environment. Where are we?";if(Module.read=function(n){var e=new XMLHttpRequest;return e.open("GET",n,!1),e.send(null),e.responseText},ENVIRONMENT_IS_WORKER&&(Module.readBinary=function(n){var e=new XMLHttpRequest;return e.open("GET",n,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),Module.readAsync=function(n,e,r){var t=new XMLHttpRequest;t.open("GET",n,!0),t.responseType="arraybuffer",t.onload=function(){200==t.status||0==t.status&&t.response?e(t.response):r()},t.onerror=r,t.send(null)},void 0!==arguments&&(Module.arguments=arguments),"undefined"!=typeof console)Module.print||(Module.print=function(n){console.log(n)}),Module.printErr||(Module.printErr=function(n){console.warn(n)});else{var TRY_USE_DUMP=!1;Module.print||(Module.print=TRY_USE_DUMP&&"undefined"!=typeof dump?function(n){dump(n)}:function(n){})}ENVIRONMENT_IS_WORKER&&(Module.load=importScripts),void 0===Module.setWindowTitle&&(Module.setWindowTitle=function(n){document.title=n})}function globalEval(n){eval.call(null,n)}for(var key in!Module.load&&Module.read&&(Module.load=function(n){globalEval(Module.read(n))}),Module.print||(Module.print=function(){}),Module.printErr||(Module.printErr=Module.print),Module.arguments||(Module.arguments=[]),Module.thisProgram||(Module.thisProgram="./this.program"),Module.quit||(Module.quit=function(n,e){throw e}),Module.print=Module.print,Module.printErr=Module.printErr,Module.preRun=[],Module.postRun=[],moduleOverrides)moduleOverrides.hasOwnProperty(key)&&(Module[key]=moduleOverrides[key]);moduleOverrides=void 0;var Runtime={setTempRet0:function(n){return tempRet0=n,n},getTempRet0:function(){return tempRet0},stackSave:function(){return STACKTOP},stackRestore:function(n){STACKTOP=n},getNativeTypeSize:function(n){switch(n){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:if("*"===n[n.length-1])return Runtime.QUANTUM_SIZE;if("i"===n[0]){var e=parseInt(n.substr(1));return assert(e%8==0),e/8}return 0}},getNativeFieldSize:function(n){return Math.max(Runtime.getNativeTypeSize(n),Runtime.QUANTUM_SIZE)},STACK_ALIGN:16,prepVararg:function(n,e){return"double"===e||"i64"===e?7&n&&(assert(4==(7&n)),n+=4):assert(0==(3&n)),n},getAlignSize:function(n,e,r){return r||"i64"!=n&&"double"!=n?n?Math.min(e||(n?Runtime.getNativeFieldSize(n):0),Runtime.QUANTUM_SIZE):Math.min(e,8):8},dynCall:function(n,e,r){return r&&r.length?Module["dynCall_"+n].apply(null,[e].concat(r)):Module["dynCall_"+n].call(null,e)},functionPointers:[],addFunction:function(n){for(var e=0;e<Runtime.functionPointers.length;e++)if(!Runtime.functionPointers[e])return Runtime.functionPointers[e]=n,2*(1+e);throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."},removeFunction:function(n){Runtime.functionPointers[(n-2)/2]=null},warnOnce:function(n){Runtime.warnOnce.shown||(Runtime.warnOnce.shown={}),Runtime.warnOnce.shown[n]||(Runtime.warnOnce.shown[n]=1,Module.printErr(n))},funcWrappers:{},getFuncWrapper:function(n,e){if(n){assert(e),Runtime.funcWrappers[e]||(Runtime.funcWrappers[e]={});var r=Runtime.funcWrappers[e];return r[n]||(1===e.length?r[n]=function(){return Runtime.dynCall(e,n)}:2===e.length?r[n]=function(r){return Runtime.dynCall(e,n,[r])}:r[n]=function(){return Runtime.dynCall(e,n,Array.prototype.slice.call(arguments))}),r[n]}},getCompilerSetting:function(n){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"},stackAlloc:function(n){var e=STACKTOP;return STACKTOP=(STACKTOP=STACKTOP+n|0)+15&-16,e},staticAlloc:function(n){var e=STATICTOP;return STATICTOP=(STATICTOP=STATICTOP+n|0)+15&-16,e},dynamicAlloc:function(n){var e=HEAP32[DYNAMICTOP_PTR>>2],r=-16&(e+n+15|0);if((HEAP32[DYNAMICTOP_PTR>>2]=r,r>=TOTAL_MEMORY)&&!enlargeMemory())return HEAP32[DYNAMICTOP_PTR>>2]=e,0;return e},alignMemory:function(n,e){return n=Math.ceil(n/(e||16))*(e||16)},makeBigInt:function(n,e,r){return r?+(n>>>0)+4294967296*+(e>>>0):+(n>>>0)+4294967296*+(0|e)},GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module.Runtime=Runtime;var ABORT=0,EXITSTATUS=0,cwrap,ccall;function assert(n,e){n||abort("Assertion failed: "+e)}function getCFunc(ident){var func=Module["_"+ident];if(!func)try{func=eval("_"+ident)}catch(n){}return assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)"),func}function setValue(n,e,r,t){switch("*"===(r=r||"i8").charAt(r.length-1)&&(r="i32"),r){case"i1":case"i8":HEAP8[n>>0]=e;break;case"i16":HEAP16[n>>1]=e;break;case"i32":HEAP32[n>>2]=e;break;case"i64":tempI64=[e>>>0,(tempDouble=e,+Math_abs(tempDouble)>=1?tempDouble>0?(0|Math_min(+Math_floor(tempDouble/4294967296),4294967295))>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[n>>2]=tempI64[0],HEAP32[n+4>>2]=tempI64[1];break;case"float":HEAPF32[n>>2]=e;break;case"double":HEAPF64[n>>3]=e;break;default:abort("invalid type for setValue: "+r)}}function getValue(n,e,r){switch("*"===(e=e||"i8").charAt(e.length-1)&&(e="i32"),e){case"i1":case"i8":return HEAP8[n>>0];case"i16":return HEAP16[n>>1];case"i32":case"i64":return HEAP32[n>>2];case"float":return HEAPF32[n>>2];case"double":return HEAPF64[n>>3];default:abort("invalid type for setValue: "+e)}return null}!function(){var JSfuncs={stackSave:function(){Runtime.stackSave()},stackRestore:function(){Runtime.stackRestore()},arrayToC:function(n){var e=Runtime.stackAlloc(n.length);return writeArrayToMemory(n,e),e},stringToC:function(n){var e=0;if(null!=n&&0!==n){var r=1+(n.length<<2);stringToUTF8(n,e=Runtime.stackAlloc(r),r)}return e}},toC={string:JSfuncs.stringToC,array:JSfuncs.arrayToC};ccall=function(n,e,r,t,i){var u=getCFunc(n),o=[],a=0;if(t)for(var f=0;f<t.length;f++){var c=toC[r[f]];c?(0===a&&(a=Runtime.stackSave()),o[f]=c(t[f])):o[f]=t[f]}var l=u.apply(null,o);if("string"===e&&(l=Pointer_stringify(l)),0!==a){if(i&&i.async)return void EmterpreterAsync.asyncFinalizers.push((function(){Runtime.stackRestore(a)}));Runtime.stackRestore(a)}return l};var sourceRegex=/^function\\s*[a-zA-Z$_0-9]*\\s*\\(([^)]*)\\)\\s*{\\s*([^*]*?)[\\s;]*(?:return\\s*(.*?)[;\\s]*)?}$/;function parseJSFunc(n){var e=n.toString().match(sourceRegex).slice(1);return{arguments:e[0],body:e[1],returnValue:e[2]}}var JSsource=null;function ensureJSsource(){if(!JSsource)for(var n in JSsource={},JSfuncs)JSfuncs.hasOwnProperty(n)&&(JSsource[n]=parseJSFunc(JSfuncs[n]))}cwrap=function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident),numericArgs=argTypes.every((function(n){return"number"===n})),numericRet="string"!==returnType;if(numericRet&&numericArgs)return cfunc;var argNames=argTypes.map((function(n,e){return"$"+e})),funcstr="(function("+argNames.join(",")+") {",nargs=argTypes.length;if(!numericArgs){ensureJSsource(),funcstr+="var stack = "+JSsource.stackSave.body+";";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if("number"!==type){var convertCode=JSsource[type+"ToC"];funcstr+="var "+convertCode.arguments+" = "+arg+";",funcstr+=convertCode.body+";",funcstr+=arg+"=("+convertCode.returnValue+");"}}}var cfuncname=parseJSFunc((function(){return cfunc})).returnValue;if(funcstr+="var ret = "+cfuncname+"("+argNames.join(",")+");",!numericRet){var strgfy=parseJSFunc((function(){return Pointer_stringify})).returnValue;funcstr+="ret = "+strgfy+"(ret);"}return numericArgs||(ensureJSsource(),funcstr+=JSsource.stackRestore.body.replace("()","(stack)")+";"),funcstr+="return ret})",eval(funcstr)}}(),Module.ccall=ccall,Module.cwrap=cwrap,Module.setValue=setValue,Module.getValue=getValue;var ALLOC_NORMAL=0,ALLOC_STACK=1,ALLOC_STATIC=2,ALLOC_DYNAMIC=3,ALLOC_NONE=4;function allocate(n,e,r,t){var i,u;"number"==typeof n?(i=!0,u=n):(i=!1,u=n.length);var o,a="string"==typeof e?e:null;if(o=r==ALLOC_NONE?t:["function"==typeof _malloc?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][void 0===r?ALLOC_STATIC:r](Math.max(u,a?1:e.length)),i){var f;t=o;for(assert(0==(3&o)),f=o+(-4&u);t<f;t+=4)HEAP32[t>>2]=0;for(f=o+u;t<f;)HEAP8[t++>>0]=0;return o}if("i8"===a)return n.subarray||n.slice?HEAPU8.set(n,o):HEAPU8.set(new Uint8Array(n),o),o;for(var c,l,s,d=0;d<u;){var _=n[d];"function"==typeof _&&(_=Runtime.getFunctionIndex(_)),0!==(c=a||e[d])?("i64"==c&&(c="i32"),setValue(o+d,_,c),s!==c&&(l=Runtime.getNativeTypeSize(c),s=c),d+=l):d++}return o}function getMemory(n){return staticSealed?runtimeInitialized?_malloc(n):Runtime.dynamicAlloc(n):Runtime.staticAlloc(n)}function Pointer_stringify(n,e){if(0===e||!n)return"";for(var r,t=0,i=0;t|=r=HEAPU8[n+i>>0],(0!=r||e)&&(i++,!e||i!=e););e||(e=i);var u="";if(t<128){for(var o;e>0;)o=String.fromCharCode.apply(String,HEAPU8.subarray(n,n+Math.min(e,1024))),u=u?u+o:o,n+=1024,e-=1024;return u}return Module.UTF8ToString(n)}function AsciiToString(n){for(var e="";;){var r=HEAP8[n++>>0];if(!r)return e;e+=String.fromCharCode(r)}}function stringToAscii(n,e){return writeAsciiToMemory(n,e,!1)}Module.ALLOC_NORMAL=ALLOC_NORMAL,Module.ALLOC_STACK=ALLOC_STACK,Module.ALLOC_STATIC=ALLOC_STATIC,Module.ALLOC_DYNAMIC=ALLOC_DYNAMIC,Module.ALLOC_NONE=ALLOC_NONE,Module.allocate=allocate,Module.getMemory=getMemory,Module.Pointer_stringify=Pointer_stringify,Module.AsciiToString=AsciiToString,Module.stringToAscii=stringToAscii;var UTF8Decoder="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function UTF8ArrayToString(n,e){for(var r=e;n[r];)++r;if(r-e>16&&n.subarray&&UTF8Decoder)return UTF8Decoder.decode(n.subarray(e,r));for(var t,i,u,o,a,f="";;){if(!(t=n[e++]))return f;if(128&t)if(i=63&n[e++],192!=(224&t))if(u=63&n[e++],224==(240&t)?t=(15&t)<<12|i<<6|u:(o=63&n[e++],240==(248&t)?t=(7&t)<<18|i<<12|u<<6|o:(a=63&n[e++],t=248==(252&t)?(3&t)<<24|i<<18|u<<12|o<<6|a:(1&t)<<30|i<<24|u<<18|o<<12|a<<6|63&n[e++])),t<65536)f+=String.fromCharCode(t);else{var c=t-65536;f+=String.fromCharCode(55296|c>>10,56320|1023&c)}else f+=String.fromCharCode((31&t)<<6|i);else f+=String.fromCharCode(t)}}function UTF8ToString(n){return UTF8ArrayToString(HEAPU8,n)}function stringToUTF8Array(n,e,r,t){if(!(t>0))return 0;for(var i=r,u=r+t-1,o=0;o<n.length;++o){var a=n.charCodeAt(o);if(a>=55296&&a<=57343&&(a=65536+((1023&a)<<10)|1023&n.charCodeAt(++o)),a<=127){if(r>=u)break;e[r++]=a}else if(a<=2047){if(r+1>=u)break;e[r++]=192|a>>6,e[r++]=128|63&a}else if(a<=65535){if(r+2>=u)break;e[r++]=224|a>>12,e[r++]=128|a>>6&63,e[r++]=128|63&a}else if(a<=2097151){if(r+3>=u)break;e[r++]=240|a>>18,e[r++]=128|a>>12&63,e[r++]=128|a>>6&63,e[r++]=128|63&a}else if(a<=67108863){if(r+4>=u)break;e[r++]=248|a>>24,e[r++]=128|a>>18&63,e[r++]=128|a>>12&63,e[r++]=128|a>>6&63,e[r++]=128|63&a}else{if(r+5>=u)break;e[r++]=252|a>>30,e[r++]=128|a>>24&63,e[r++]=128|a>>18&63,e[r++]=128|a>>12&63,e[r++]=128|a>>6&63,e[r++]=128|63&a}}return e[r]=0,r-i}function stringToUTF8(n,e,r){return stringToUTF8Array(n,HEAPU8,e,r)}function lengthBytesUTF8(n){for(var e=0,r=0;r<n.length;++r){var t=n.charCodeAt(r);t>=55296&&t<=57343&&(t=65536+((1023&t)<<10)|1023&n.charCodeAt(++r)),t<=127?++e:e+=t<=2047?2:t<=65535?3:t<=2097151?4:t<=67108863?5:6}return e}Module.UTF8ArrayToString=UTF8ArrayToString,Module.UTF8ToString=UTF8ToString,Module.stringToUTF8Array=stringToUTF8Array,Module.stringToUTF8=stringToUTF8,Module.lengthBytesUTF8=lengthBytesUTF8;var UTF16Decoder="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0,HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64,STATIC_BASE,STATICTOP,staticSealed,STACK_BASE,STACKTOP,STACK_MAX,DYNAMIC_BASE,DYNAMICTOP_PTR;function demangle(n){var e=Module.___cxa_demangle||Module.__cxa_demangle;if(e){try{var r=n.substr(1),t=lengthBytesUTF8(r)+1,i=_malloc(t);stringToUTF8(r,i,t);var u=_malloc(4),o=e(i,0,0,u);if(0===getValue(u,"i32")&&o)return Pointer_stringify(o)}catch(n){}finally{i&&_free(i),u&&_free(u),o&&_free(o)}return n}return Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling"),n}function demangleAll(n){return n.replace(/__Z[\\w\\d_]+/g,(function(n){var e=demangle(n);return n===e?n:n+" ["+e+"]"}))}function jsStackTrace(){var n=new Error;if(!n.stack){try{throw new Error(0)}catch(e){n=e}if(!n.stack)return"(no stack trace available)"}return n.stack.toString()}function stackTrace(){var n=jsStackTrace();return Module.extraStackTrace&&(n+="\\n"+Module.extraStackTrace()),demangleAll(n)}function updateGlobalBufferViews(){Module.HEAP8=HEAP8=new Int8Array(buffer),Module.HEAP16=HEAP16=new Int16Array(buffer),Module.HEAP32=HEAP32=new Int32Array(buffer),Module.HEAPU8=HEAPU8=new Uint8Array(buffer),Module.HEAPU16=HEAPU16=new Uint16Array(buffer),Module.HEAPU32=HEAPU32=new Uint32Array(buffer),Module.HEAPF32=HEAPF32=new Float32Array(buffer),Module.HEAPF64=HEAPF64=new Float64Array(buffer)}function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function enlargeMemory(){abortOnCannotGrowMemory()}Module.stackTrace=stackTrace,STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0,staticSealed=!1;var TOTAL_STACK=Module.TOTAL_STACK||5242880,TOTAL_MEMORY=Module.TOTAL_MEMORY||134217728;function getTotalMemory(){return TOTAL_MEMORY}if(TOTAL_MEMORY<TOTAL_STACK&&Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")"),buffer=Module.buffer?Module.buffer:new ArrayBuffer(TOTAL_MEMORY),updateGlobalBufferViews(),HEAP32[0]=1668509029,HEAP16[1]=25459,115!==HEAPU8[2]||99!==HEAPU8[3])throw"Runtime error: expected the system to be little-endian!";function callRuntimeCallbacks(n){for(;n.length>0;){var e=n.shift();if("function"!=typeof e){var r=e.func;"number"==typeof r?void 0===e.arg?Module.dynCall_v(r):Module.dynCall_vi(r,e.arg):r(void 0===e.arg?null:e.arg)}else e()}}Module.HEAP=HEAP,Module.buffer=buffer,Module.HEAP8=HEAP8,Module.HEAP16=HEAP16,Module.HEAP32=HEAP32,Module.HEAPU8=HEAPU8,Module.HEAPU16=HEAPU16,Module.HEAPU32=HEAPU32,Module.HEAPF32=HEAPF32,Module.HEAPF64=HEAPF64;var __ATPRERUN__=[],__ATINIT__=[],__ATMAIN__=[],__ATEXIT__=[],__ATPOSTRUN__=[],runtimeInitialized=!1,runtimeExited=!1;function preRun(){if(Module.preRun)for("function"==typeof Module.preRun&&(Module.preRun=[Module.preRun]);Module.preRun.length;)addOnPreRun(Module.preRun.shift());callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){runtimeInitialized||(runtimeInitialized=!0,callRuntimeCallbacks(__ATINIT__))}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__),runtimeExited=!0}function postRun(){if(Module.postRun)for("function"==typeof Module.postRun&&(Module.postRun=[Module.postRun]);Module.postRun.length;)addOnPostRun(Module.postRun.shift());callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(n){__ATPRERUN__.unshift(n)}function addOnInit(n){__ATINIT__.unshift(n)}function addOnPreMain(n){__ATMAIN__.unshift(n)}function addOnExit(n){__ATEXIT__.unshift(n)}function addOnPostRun(n){__ATPOSTRUN__.unshift(n)}function intArrayFromString(n,e,r){var t=r>0?r:lengthBytesUTF8(n)+1,i=new Array(t),u=stringToUTF8Array(n,i,0,i.length);return e&&(i.length=u),i}function intArrayToString(n){for(var e=[],r=0;r<n.length;r++){var t=n[r];t>255&&(t&=255),e.push(String.fromCharCode(t))}return e.join("")}function writeStringToMemory(n,e,r){var t,i;Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!"),r&&(i=e+lengthBytesUTF8(n),t=HEAP8[i]),stringToUTF8(n,e,1/0),r&&(HEAP8[i]=t)}function writeArrayToMemory(n,e){HEAP8.set(n,e)}function writeAsciiToMemory(n,e,r){for(var t=0;t<n.length;++t)HEAP8[e++>>0]=n.charCodeAt(t);r||(HEAP8[e>>0]=0)}if(Module.addOnPreRun=addOnPreRun,Module.addOnInit=addOnInit,Module.addOnPreMain=addOnPreMain,Module.addOnExit=addOnExit,Module.addOnPostRun=addOnPostRun,Module.intArrayFromString=intArrayFromString,Module.intArrayToString=intArrayToString,Module.writeStringToMemory=writeStringToMemory,Module.writeArrayToMemory=writeArrayToMemory,Module.writeAsciiToMemory=writeAsciiToMemory,Math.imul&&-5===Math.imul(4294967295,5)||(Math.imul=function(n,e){var r=65535&n,t=65535&e;return r*t+((n>>>16)*t+r*(e>>>16)<<16)|0}),Math.imul=Math.imul,!Math.fround){var froundBuffer=new Float32Array(1);Math.fround=function(n){return froundBuffer[0]=n,froundBuffer[0]}}Math.fround=Math.fround,Math.clz32||(Math.clz32=function(n){n>>>=0;for(var e=0;e<32;e++)if(n&1<<31-e)return e;return 32}),Math.clz32=Math.clz32,Math.trunc||(Math.trunc=function(n){return n<0?Math.ceil(n):Math.floor(n)}),Math.trunc=Math.trunc;var Math_abs=Math.abs,Math_cos=Math.cos,Math_sin=Math.sin,Math_tan=Math.tan,Math_acos=Math.acos,Math_asin=Math.asin,Math_atan=Math.atan,Math_atan2=Math.atan2,Math_exp=Math.exp,Math_log=Math.log,Math_sqrt=Math.sqrt,Math_ceil=Math.ceil,Math_floor=Math.floor,Math_pow=Math.pow,Math_imul=Math.imul,Math_fround=Math.fround,Math_round=Math.round,Math_min=Math.min,Math_clz32=Math.clz32,Math_trunc=Math.trunc,runDependencies=0,runDependencyWatcher=null,dependenciesFulfilled=null;function getUniqueRunDependency(n){return n}function addRunDependency(n){runDependencies++,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies)}function removeRunDependency(n){if(runDependencies--,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies),0==runDependencies&&(null!==runDependencyWatcher&&(clearInterval(runDependencyWatcher),runDependencyWatcher=null),dependenciesFulfilled)){var e=dependenciesFulfilled;dependenciesFulfilled=null,e()}}Module.addRunDependency=addRunDependency,Module.removeRunDependency=removeRunDependency,Module.preloadedImages={},Module.preloadedAudios={};var ASM_CONSTS=[function(n,e,r,t,i,u,o,a){return _nbind.callbackSignatureList[n].apply(this,arguments)}];function _emscripten_asm_const_iiiiiiii(n,e,r,t,i,u,o,a){return ASM_CONSTS[n](e,r,t,i,u,o,a)}function _emscripten_asm_const_iiiii(n,e,r,t,i){return ASM_CONSTS[n](e,r,t,i)}function _emscripten_asm_const_iiidddddd(n,e,r,t,i,u,o,a,f){return ASM_CONSTS[n](e,r,t,i,u,o,a,f)}function _emscripten_asm_const_iiididi(n,e,r,t,i,u,o){return ASM_CONSTS[n](e,r,t,i,u,o)}function _emscripten_asm_const_iiii(n,e,r,t){return ASM_CONSTS[n](e,r,t)}function _emscripten_asm_const_iiiid(n,e,r,t,i){return ASM_CONSTS[n](e,r,t,i)}function _emscripten_asm_const_iiiiii(n,e,r,t,i,u){return ASM_CONSTS[n](e,r,t,i,u)}STATIC_BASE=Runtime.GLOBAL_BASE,STATICTOP=STATIC_BASE+12800,__ATINIT__.push({func:function(){__GLOBAL__sub_I_Yoga_cpp()}},{func:function(){__GLOBAL__sub_I_nbind_cc()}},{func:function(){__GLOBAL__sub_I_common_cc()}},{func:function(){__GLOBAL__sub_I_Binding_cc()}}),allocate([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,192,127,0,0,192,127,0,0,192,127,3,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,3,0,0,0,0,0,192,127,3,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,192,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,192,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,127,0,0,192,127,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,128,191,0,0,128,191,0,0,192,127,0,0,0,0,0,0,0,0,0,0,128,63,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,190,12,0,0,200,12,0,0,208,12,0,0,216,12,0,0,230,12,0,0,242,12,0,0,1,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,192,127,3,0,0,0,180,45,0,0,181,45,0,0,182,45,0,0,181,45,0,0,182,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,1,0,0,0,4,0,0,0,183,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,181,45,0,0,184,45,0,0,185,45,0,0,181,45,0,0,181,45,0,0,182,45,0,0,186,45,0,0,185,45,0,0,148,4,0,0,3,0,0,0,187,45,0,0,164,4,0,0,188,45,0,0,2,0,0,0,189,45,0,0,164,4,0,0,188,45,0,0,185,45,0,0,164,4,0,0,185,45,0,0,164,4,0,0,188,45,0,0,181,45,0,0,182,45,0,0,181,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,5,0,0,0,6,0,0,0,1,0,0,0,7,0,0,0,183,45,0,0,182,45,0,0,181,45,0,0,190,45,0,0,190,45,0,0,182,45,0,0,182,45,0,0,185,45,0,0,181,45,0,0,185,45,0,0,182,45,0,0,181,45,0,0,185,45,0,0,182,45,0,0,185,45,0,0,48,5,0,0,3,0,0,0,56,5,0,0,1,0,0,0,189,45,0,0,185,45,0,0,164,4,0,0,76,5,0,0,2,0,0,0,191,45,0,0,186,45,0,0,182,45,0,0,185,45,0,0,192,45,0,0,185,45,0,0,182,45,0,0,186,45,0,0,185,45,0,0,76,5,0,0,76,5,0,0,136,5,0,0,182,45,0,0,181,45,0,0,2,0,0,0,190,45,0,0,136,5,0,0,56,19,0,0,156,5,0,0,2,0,0,0,184,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,8,0,0,0,9,0,0,0,1,0,0,0,10,0,0,0,204,5,0,0,181,45,0,0,181,45,0,0,2,0,0,0,180,45,0,0,204,5,0,0,2,0,0,0,195,45,0,0,236,5,0,0,97,19,0,0,198,45,0,0,211,45,0,0,212,45,0,0,213,45,0,0,214,45,0,0,215,45,0,0,188,45,0,0,182,45,0,0,216,45,0,0,217,45,0,0,218,45,0,0,219,45,0,0,192,45,0,0,181,45,0,0,0,0,0,0,185,45,0,0,110,19,0,0,186,45,0,0,115,19,0,0,221,45,0,0,120,19,0,0,148,4,0,0,132,19,0,0,96,6,0,0,145,19,0,0,222,45,0,0,164,19,0,0,223,45,0,0,173,19,0,0,0,0,0,0,3,0,0,0,104,6,0,0,1,0,0,0,187,45,0,0,0,0,0,0,0,0,0,0,1,0,0,0,11,0,0,0,12,0,0,0,1,0,0,0,13,0,0,0,185,45,0,0,224,45,0,0,164,6,0,0,188,45,0,0,172,6,0,0,180,6,0,0,2,0,0,0,188,6,0,0,7,0,0,0,224,45,0,0,7,0,0,0,164,6,0,0,1,0,0,0,213,45,0,0,185,45,0,0,224,45,0,0,172,6,0,0,185,45,0,0,224,45,0,0,164,6,0,0,185,45,0,0,224,45,0,0,211,45,0,0,211,45,0,0,222,45,0,0,211,45,0,0,224,45,0,0,222,45,0,0,211,45,0,0,224,45,0,0,172,6,0,0,222,45,0,0,211,45,0,0,224,45,0,0,188,45,0,0,222,45,0,0,211,45,0,0,40,7,0,0,188,45,0,0,2,0,0,0,224,45,0,0,185,45,0,0,188,45,0,0,188,45,0,0,188,45,0,0,188,45,0,0,222,45,0,0,224,45,0,0,148,4,0,0,185,45,0,0,148,4,0,0,148,4,0,0,148,4,0,0,148,4,0,0,148,4,0,0,185,45,0,0,164,6,0,0,148,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,14,0,0,0,15,0,0,0,1,0,0,0,16,0,0,0,148,7,0,0,2,0,0,0,225,45,0,0,183,45,0,0,188,45,0,0,168,7,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,234,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,148,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,2,0,0,0,242,45,0,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,111,117,108,100,32,110,111,116,32,97,108,108,111,99,97,116,101,32,109,101,109,111,114,121,32,102,111,114,32,110,111,100,101,0,67,97,110,110,111,116,32,114,101,115,101,116,32,97,32,110,111,100,101,32,119,104,105,99,104,32,115,116,105,108,108,32,104,97,115,32,99,104,105,108,100,114,101,110,32,97,116,116,97,99,104,101,100,0,67,97,110,110,111,116,32,114,101,115,101,116,32,97,32,110,111,100,101,32,115,116,105,108,108,32,97,116,116,97,99,104,101,100,32,116,111,32,97,32,112,97,114,101,110,116,0,67,111,117,108,100,32,110,111,116,32,97,108,108,111,99,97,116,101,32,109,101,109,111,114,121,32,102,111,114,32,99,111,110,102,105,103,0,67,97,110,110,111,116,32,115,101,116,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,58,32,78,111,100,101,115,32,119,105,116,104,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,115,32,99,97,110,110,111,116,32,104,97,118,101,32,99,104,105,108,100,114,101,110,46,0,67,104,105,108,100,32,97,108,114,101,97,100,121,32,104,97,115,32,97,32,112,97,114,101,110,116,44,32,105,116,32,109,117,115,116,32,98,101,32,114,101,109,111,118,101,100,32,102,105,114,115,116,46,0,67,97,110,110,111,116,32,97,100,100,32,99,104,105,108,100,58,32,78,111,100,101,115,32,119,105,116,104,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,115,32,99,97,110,110,111,116,32,104,97,118,101,32,99,104,105,108,100,114,101,110,46,0,79,110,108,121,32,108,101,97,102,32,110,111,100,101,115,32,119,105,116,104,32,99,117,115,116,111,109,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,115,115,104,111,117,108,100,32,109,97,110,117,97,108,108,121,32,109,97,114,107,32,116,104,101,109,115,101,108,118,101,115,32,97,115,32,100,105,114,116,121,0,67,97,110,110,111,116,32,103,101,116,32,108,97,121,111,117,116,32,112,114,111,112,101,114,116,105,101,115,32,111,102,32,109,117,108,116,105,45,101,100,103,101,32,115,104,111,114,116,104,97,110,100,115,0,37,115,37,100,46,123,91,115,107,105,112,112,101,100,93,32,0,119,109,58,32,37,115,44,32,104,109,58,32,37,115,44,32,97,119,58,32,37,102,32,97,104,58,32,37,102,32,61,62,32,100,58,32,40,37,102,44,32,37,102,41,32,37,115,10,0,37,115,37,100,46,123,37,115,0,42,0,119,109,58,32,37,115,44,32,104,109,58,32,37,115,44,32,97,119,58,32,37,102,32,97,104,58,32,37,102,32,37,115,10,0,37,115,37,100,46,125,37,115,0,119,109,58,32,37,115,44,32,104,109,58,32,37,115,44,32,100,58,32,40,37,102,44,32,37,102,41,32,37,115,10,0,79,117,116,32,111,102,32,99,97,99,104,101,32,101,110,116,114,105,101,115,33,10,0,83,99,97,108,101,32,102,97,99,116,111,114,32,115,104,111,117,108,100,32,110,111,116,32,98,101,32,108,101,115,115,32,116,104,97,110,32,122,101,114,111,0,105,110,105,116,105,97,108,0,37,115,10,0,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0,85,78,68,69,70,73,78,69,68,0,69,88,65,67,84,76,89,0,65,84,95,77,79,83,84,0,76,65,89,95,85,78,68,69,70,73,78,69,68,0,76,65,89,95,69,88,65,67,84,76,89,0,76,65,89,95,65,84,95,77,79,83,84,0,97,118,97,105,108,97,98,108,101,87,105,100,116,104,32,105,115,32,105,110,100,101,102,105,110,105,116,101,32,115,111,32,119,105,100,116,104,77,101,97,115,117,114,101,77,111,100,101,32,109,117,115,116,32,98,101,32,89,71,77,101,97,115,117,114,101,77,111,100,101,85,110,100,101,102,105,110,101,100,0,97,118,97,105,108,97,98,108,101,72,101,105,103,104,116,32,105,115,32,105,110,100,101,102,105,110,105,116,101,32,115,111,32,104,101,105,103,104,116,77,101,97,115,117,114,101,77,111,100,101,32,109,117,115,116,32,98,101,32,89,71,77,101,97,115,117,114,101,77,111,100,101,85,110,100,101,102,105,110,101,100,0,102,108,101,120,0,115,116,114,101,116,99,104,0,109,117,108,116,105,108,105,110,101,45,115,116,114,101,116,99,104,0,69,120,112,101,99,116,101,100,32,110,111,100,101,32,116,111,32,104,97,118,101,32,99,117,115,116,111,109,32,109,101,97,115,117,114,101,32,102,117,110,99,116,105,111,110,0,109,101,97,115,117,114,101,0,69,120,112,101,99,116,32,99,117,115,116,111,109,32,98,97,115,101,108,105,110,101,32,102,117,110,99,116,105,111,110,32,116,111,32,110,111,116,32,114,101,116,117,114,110,32,78,97,78,0,97,98,115,45,109,101,97,115,117,114,101,0,97,98,115,45,108,97,121,111,117,116,0,78,111,100,101,0,99,114,101,97,116,101,68,101,102,97,117,108,116,0,99,114,101,97,116,101,87,105,116,104,67,111,110,102,105,103,0,100,101,115,116,114,111,121,0,114,101,115,101,116,0,99,111,112,121,83,116,121,108,101,0,115,101,116,80,111,115,105,116,105,111,110,84,121,112,101,0,115,101,116,80,111,115,105,116,105,111,110,0,115,101,116,80,111,115,105,116,105,111,110,80,101,114,99,101,110,116,0,115,101,116,65,108,105,103,110,67,111,110,116,101,110,116,0,115,101,116,65,108,105,103,110,73,116,101,109,115,0,115,101,116,65,108,105,103,110,83,101,108,102,0,115,101,116,70,108,101,120,68,105,114,101,99,116,105,111,110,0,115,101,116,70,108,101,120,87,114,97,112,0,115,101,116,74,117,115,116,105,102,121,67,111,110,116,101,110,116,0,115,101,116,77,97,114,103,105,110,0,115,101,116,77,97,114,103,105,110,80,101,114,99,101,110,116,0,115,101,116,77,97,114,103,105,110,65,117,116,111,0,115,101,116,79,118,101,114,102,108,111,119,0,115,101,116,68,105,115,112,108,97,121,0,115,101,116,70,108,101,120,0,115,101,116,70,108,101,120,66,97,115,105,115,0,115,101,116,70,108,101,120,66,97,115,105,115,80,101,114,99,101,110,116,0,115,101,116,70,108,101,120,71,114,111,119,0,115,101,116,70,108,101,120,83,104,114,105,110,107,0,115,101,116,87,105,100,116,104,0,115,101,116,87,105,100,116,104,80,101,114,99,101,110,116,0,115,101,116,87,105,100,116,104,65,117,116,111,0,115,101,116,72,101,105,103,104,116,0,115,101,116,72,101,105,103,104,116,80,101,114,99,101,110,116,0,115,101,116,72,101,105,103,104,116,65,117,116,111,0,115,101,116,77,105,110,87,105,100,116,104,0,115,101,116,77,105,110,87,105,100,116,104,80,101,114,99,101,110,116,0,115,101,116,77,105,110,72,101,105,103,104,116,0,115,101,116,77,105,110,72,101,105,103,104,116,80,101,114,99,101,110,116,0,115,101,116,77,97,120,87,105,100,116,104,0,115,101,116,77,97,120,87,105,100,116,104,80,101,114,99,101,110,116,0,115,101,116,77,97,120,72,101,105,103,104,116,0,115,101,116,77,97,120,72,101,105,103,104,116,80,101,114,99,101,110,116,0,115,101,116,65,115,112,101,99,116,82,97,116,105,111,0,115,101,116,66,111,114,100,101,114,0,115,101,116,80,97,100,100,105,110,103,0,115,101,116,80,97,100,100,105,110,103,80,101,114,99,101,110,116,0,103,101,116,80,111,115,105,116,105,111,110,84,121,112,101,0,103,101,116,80,111,115,105,116,105,111,110,0,103,101,116,65,108,105,103,110,67,111,110,116,101,110,116,0,103,101,116,65,108,105,103,110,73,116,101,109,115,0,103,101,116,65,108,105,103,110,83,101,108,102,0,103,101,116,70,108,101,120,68,105,114,101,99,116,105,111,110,0,103,101,116,70,108,101,120,87,114,97,112,0,103,101,116,74,117,115,116,105,102,121,67,111,110,116,101,110,116,0,103,101,116,77,97,114,103,105,110,0,103,101,116,70,108,101,120,66,97,115,105,115,0,103,101,116,70,108,101,120,71,114,111,119,0,103,101,116,70,108,101,120,83,104,114,105,110,107,0,103,101,116,87,105,100,116,104,0,103,101,116,72,101,105,103,104,116,0,103,101,116,77,105,110,87,105,100,116,104,0,103,101,116,77,105,110,72,101,105,103,104,116,0,103,101,116,77,97,120,87,105,100,116,104,0,103,101,116,77,97,120,72,101,105,103,104,116,0,103,101,116,65,115,112,101,99,116,82,97,116,105,111,0,103,101,116,66,111,114,100,101,114,0,103,101,116,79,118,101,114,102,108,111,119,0,103,101,116,68,105,115,112,108,97,121,0,103,101,116,80,97,100,100,105,110,103,0,105,110,115,101,114,116,67,104,105,108,100,0,114,101,109,111,118,101,67,104,105,108,100,0,103,101,116,67,104,105,108,100,67,111,117,110,116,0,103,101,116,80,97,114,101,110,116,0,103,101,116,67,104,105,108,100,0,115,101,116,77,101,97,115,117,114,101,70,117,110,99,0,117,110,115,101,116,77,101,97,115,117,114,101,70,117,110,99,0,109,97,114,107,68,105,114,116,121,0,105,115,68,105,114,116,121,0,99,97,108,99,117,108,97,116,101,76,97,121,111,117,116,0,103,101,116,67,111,109,112,117,116,101,100,76,101,102,116,0,103,101,116,67,111,109,112,117,116,101,100,82,105,103,104,116,0,103,101,116,67,111,109,112,117,116,101,100,84,111,112,0,103,101,116,67,111,109,112,117,116,101,100,66,111,116,116,111,109,0,103,101,116,67,111,109,112,117,116,101,100,87,105,100,116,104,0,103,101,116,67,111,109,112,117,116,101,100,72,101,105,103,104,116,0,103,101,116,67,111,109,112,117,116,101,100,76,97,121,111,117,116,0,103,101,116,67,111,109,112,117,116,101,100,77,97,114,103,105,110,0,103,101,116,67,111,109,112,117,116,101,100,66,111,114,100,101,114,0,103,101,116,67,111,109,112,117,116,101,100,80,97,100,100,105,110,103,0,67,111,110,102,105,103,0,99,114,101,97,116,101,0,115,101,116,69,120,112,101,114,105,109,101,110,116,97,108,70,101,97,116,117,114,101,69,110,97,98,108,101,100,0,115,101,116,80,111,105,110,116,83,99,97,108,101,70,97,99,116,111,114,0,105,115,69,120,112,101,114,105,109,101,110,116,97,108,70,101,97,116,117,114,101,69,110,97,98,108,101,100,0,86,97,108,117,101,0,76,97,121,111,117,116,0,83,105,122,101,0,103,101,116,73,110,115,116,97,110,99,101,67,111,117,110,116,0,73,110,116,54,52,0,1,1,1,2,2,4,4,4,4,8,8,4,8,118,111,105,100,0,98,111,111,108,0,115,116,100,58,58,115,116,114,105,110,103,0,99,98,70,117,110,99,116,105,111,110,32,38,0,99,111,110,115,116,32,99,98,70,117,110,99,116,105,111,110,32,38,0,69,120,116,101,114,110,97,108,0,66,117,102,102,101,114,0,78,66,105,110,100,73,68,0,78,66,105,110,100,0,98,105,110,100,95,118,97,108,117,101,0,114,101,102,108,101,99,116,0,113,117,101,114,121,84,121,112,101,0,108,97,108,108,111,99,0,108,114,101,115,101,116,0,123,114,101,116,117,114,110,40,95,110,98,105,110,100,46,99,97,108,108,98,97,99,107,83,105,103,110,97,116,117,114,101,76,105,115,116,91,36,48,93,46,97,112,112,108,121,40,116,104,105,115,44,97,114,103,117,109,101,110,116,115,41,41,59,125,0,95,110,98,105,110,100,95,110,101,119,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,45,43,32,32,32,48,88,48,120,0,40,110,117,108,108,41,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,105,110,102,0,73,78,70,0,110,97,110,0,78,65,78,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,46,0,84,33,34,25,13,1,2,3,17,75,28,12,16,4,11,29,18,30,39,104,110,111,112,113,98,32,5,6,15,19,20,21,26,8,22,7,40,36,23,24,9,10,14,27,31,37,35,131,130,125,38,42,43,60,61,62,63,67,71,74,77,88,89,90,91,92,93,94,95,96,97,99,100,101,102,103,105,106,107,108,114,115,116,121,122,123,124,0,73,108,108,101,103,97,108,32,98,121,116,101,32,115,101,113,117,101,110,99,101,0,68,111,109,97,105,110,32,101,114,114,111,114,0,82,101,115,117,108,116,32,110,111,116,32,114,101,112,114,101,115,101,110,116,97,98,108,101,0,78,111,116,32,97,32,116,116,121,0,80,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100,0,79,112,101,114,97,116,105,111,110,32,110,111,116,32,112,101,114,109,105,116,116,101,100,0,78,111,32,115,117,99,104,32,102,105,108,101,32,111,114,32,100,105,114,101,99,116,111,114,121,0,78,111,32,115,117,99,104,32,112,114,111,99,101,115,115,0,70,105,108,101,32,101,120,105,115,116,115,0,86,97,108,117,101,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,100,97,116,97,32,116,121,112,101,0,78,111,32,115,112,97,99,101,32,108,101,102,116,32,111,110,32,100,101,118,105,99,101,0,79,117,116,32,111,102,32,109,101,109,111,114,121,0,82,101,115,111,117,114,99,101,32,98,117,115,121,0,73,110,116,101,114,114,117,112,116,101,100,32,115,121,115,116,101,109,32,99,97,108,108,0,82,101,115,111,117,114,99,101,32,116,101,109,112,111,114,97,114,105,108,121,32,117,110,97,118,97,105,108,97,98,108,101,0,73,110,118,97,108,105,100,32,115,101,101,107,0,67,114,111,115,115,45,100,101,118,105,99,101,32,108,105,110,107,0,82,101,97,100,45,111,110,108,121,32,102,105,108,101,32,115,121,115,116,101,109,0,68,105,114,101,99,116,111,114,121,32,110,111,116,32,101,109,112,116,121,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,112,101,101,114,0,79,112,101,114,97,116,105,111,110,32,116,105,109,101,100,32,111,117,116,0,67,111,110,110,101,99,116,105,111,110,32,114,101,102,117,115,101,100,0,72,111,115,116,32,105,115,32,100,111,119,110,0,72,111,115,116,32,105,115,32,117,110,114,101,97,99,104,97,98,108,101,0,65,100,100,114,101,115,115,32,105,110,32,117,115,101,0,66,114,111,107,101,110,32,112,105,112,101,0,73,47,79,32,101,114,114,111,114,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,32,111,114,32,97,100,100,114,101,115,115,0,66,108,111,99,107,32,100,101,118,105,99,101,32,114,101,113,117,105,114,101,100,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,0,78,111,116,32,97,32,100,105,114,101,99,116,111,114,121,0,73,115,32,97,32,100,105,114,101,99,116,111,114,121,0,84,101,120,116,32,102,105,108,101,32,98,117,115,121,0,69,120,101,99,32,102,111,114,109,97,116,32,101,114,114,111,114,0,73,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116,0,65,114,103,117,109,101,110,116,32,108,105,115,116,32,116,111,111,32,108,111,110,103,0,83,121,109,98,111,108,105,99,32,108,105,110,107,32,108,111,111,112,0,70,105,108,101,110,97,109,101,32,116,111,111,32,108,111,110,103,0,84,111,111,32,109,97,110,121,32,111,112,101,110,32,102,105,108,101,115,32,105,110,32,115,121,115,116,101,109,0,78,111,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,115,32,97,118,97,105,108,97,98,108,101,0,66,97,100,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,0,78,111,32,99,104,105,108,100,32,112,114,111,99,101,115,115,0,66,97,100,32,97,100,100,114,101,115,115,0,70,105,108,101,32,116,111,111,32,108,97,114,103,101,0,84,111,111,32,109,97,110,121,32,108,105,110,107,115,0,78,111,32,108,111,99,107,115,32,97,118,97,105,108,97,98,108,101,0,82,101,115,111,117,114,99,101,32,100,101,97,100,108,111,99,107,32,119,111,117,108,100,32,111,99,99,117,114,0,83,116,97,116,101,32,110,111,116,32,114,101,99,111,118,101,114,97,98,108,101,0,80,114,101,118,105,111,117,115,32,111,119,110,101,114,32,100,105,101,100,0,79,112,101,114,97,116,105,111,110,32,99,97,110,99,101,108,101,100,0,70,117,110,99,116,105,111,110,32,110,111,116,32,105,109,112,108,101,109,101,110,116,101,100,0,78,111,32,109,101,115,115,97,103,101,32,111,102,32,100,101,115,105,114,101,100,32,116,121,112,101,0,73,100,101,110,116,105,102,105,101,114,32,114,101,109,111,118,101,100,0,68,101,118,105,99,101,32,110,111,116,32,97,32,115,116,114,101,97,109,0,78,111,32,100,97,116,97,32,97,118,97,105,108,97,98,108,101,0,68,101,118,105,99,101,32,116,105,109,101,111,117,116,0,79,117,116,32,111,102,32,115,116,114,101,97,109,115,32,114,101,115,111,117,114,99,101,115,0,76,105,110,107,32,104,97,115,32,98,101,101,110,32,115,101,118,101,114,101,100,0,80,114,111,116,111,99,111,108,32,101,114,114,111,114,0,66,97,100,32,109,101,115,115,97,103,101,0,70,105,108,101,32,100,101,115,99,114,105,112,116,111,114,32,105,110,32,98,97,100,32,115,116,97,116,101,0,78,111,116,32,97,32,115,111,99,107,101,116,0,68,101,115,116,105,110,97,116,105,111,110,32,97,100,100,114,101,115,115,32,114,101,113,117,105,114,101,100,0,77,101,115,115,97,103,101,32,116,111,111,32,108,97,114,103,101,0,80,114,111,116,111,99,111,108,32,119,114,111,110,103,32,116,121,112,101,32,102,111,114,32,115,111,99,107,101,116,0,80,114,111,116,111,99,111,108,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,80,114,111,116,111,99,111,108,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,83,111,99,107,101,116,32,116,121,112,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,78,111,116,32,115,117,112,112,111,114,116,101,100,0,80,114,111,116,111,99,111,108,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,65,100,100,114,101,115,115,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,98,121,32,112,114,111,116,111,99,111,108,0,65,100,100,114,101,115,115,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,78,101,116,119,111,114,107,32,105,115,32,100,111,119,110,0,78,101,116,119,111,114,107,32,117,110,114,101,97,99,104,97,98,108,101,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,110,101,116,119,111,114,107,0,67,111,110,110,101,99,116,105,111,110,32,97,98,111,114,116,101,100,0,78,111,32,98,117,102,102,101,114,32,115,112,97,99,101,32,97,118,97,105,108,97,98,108,101,0,83,111,99,107,101,116,32,105,115,32,99,111,110,110,101,99,116,101,100,0,83,111,99,107,101,116,32,110,111,116,32,99,111,110,110,101,99,116,101,100,0,67,97,110,110,111,116,32,115,101,110,100,32,97,102,116,101,114,32,115,111,99,107,101,116,32,115,104,117,116,100,111,119,110,0,79,112,101,114,97,116,105,111,110,32,97,108,114,101,97,100,121,32,105,110,32,112,114,111,103,114,101,115,115,0,79,112,101,114,97,116,105,111,110,32,105,110,32,112,114,111,103,114,101,115,115,0,83,116,97,108,101,32,102,105,108,101,32,104,97,110,100,108,101,0,82,101,109,111,116,101,32,73,47,79,32,101,114,114,111,114,0,81,117,111,116,97,32,101,120,99,101,101,100,101,100,0,78,111,32,109,101,100,105,117,109,32,102,111,117,110,100,0,87,114,111,110,103,32,109,101,100,105,117,109,32,116,121,112,101,0,78,111,32,101,114,114,111,114,32,105,110,102,111,114,109,97,116,105,111,110,0,0],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=STATICTOP;function _atexit(n,e){__ATEXIT__.unshift({func:n,arg:e})}function ___cxa_atexit(){return _atexit.apply(null,arguments)}function _abort(){Module.abort()}function __ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj(){Module.printErr("missing function: _ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj"),abort(-1)}function __decorate(n,e,r,t){var i,u=arguments.length,o=u<3?e:null===t?t=Object.getOwnPropertyDescriptor(e,r):t;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,r,t);else for(var a=n.length-1;a>=0;a--)(i=n[a])&&(o=(u<3?i(o):u>3?i(e,r,o):i(e,r))||o);return u>3&&o&&Object.defineProperty(e,r,o),o}function _defineHidden(n){return function(e,r){Object.defineProperty(e,r,{configurable:!1,enumerable:!1,value:n,writable:!0})}}STATICTOP+=16;var _nbind={};function __nbind_free_external(n){_nbind.externalList[n].dereference(n)}function __nbind_reference_external(n){_nbind.externalList[n].reference()}function _llvm_stackrestore(n){var e=_llvm_stacksave,r=e.LLVM_SAVEDSTACKS[n];e.LLVM_SAVEDSTACKS.splice(n,1),Runtime.stackRestore(r)}function __nbind_register_pool(n,e,r,t){_nbind.Pool.pageSize=n,_nbind.Pool.usedPtr=e/4,_nbind.Pool.rootPtr=r,_nbind.Pool.pagePtr=t/4,HEAP32[e/4]=16909060,1==HEAP8[e]&&(_nbind.bigEndian=!0),HEAP32[e/4]=0,_nbind.makeTypeKindTbl=((i={})[1024]=_nbind.PrimitiveType,i[64]=_nbind.Int64Type,i[2048]=_nbind.BindClass,i[3072]=_nbind.BindClassPtr,i[4096]=_nbind.SharedClassPtr,i[5120]=_nbind.ArrayType,i[6144]=_nbind.ArrayType,i[7168]=_nbind.CStringType,i[9216]=_nbind.CallbackType,i[10240]=_nbind.BindType,i),_nbind.makeTypeNameTbl={Buffer:_nbind.BufferType,External:_nbind.ExternalType,Int64:_nbind.Int64Type,_nbind_new:_nbind.CreateValueType,bool:_nbind.BooleanType,"cbFunction &":_nbind.CallbackType,"const cbFunction &":_nbind.CallbackType,"const std::string &":_nbind.StringType,"std::string":_nbind.StringType},Module.toggleLightGC=_nbind.toggleLightGC,_nbind.callUpcast=Module.dynCall_ii;var i,u=_nbind.makeType(_nbind.constructType,{flags:2048,id:0,name:""});u.proto=Module,_nbind.BindClass.list.push(u)}function _emscripten_set_main_loop_timing(n,e){if(Browser.mainLoop.timingMode=n,Browser.mainLoop.timingValue=e,!Browser.mainLoop.func)return 1;if(0==n)Browser.mainLoop.scheduler=function(){var n=0|Math.max(0,Browser.mainLoop.tickStartTime+e-_emscripten_get_now());setTimeout(Browser.mainLoop.runner,n)},Browser.mainLoop.method="timeout";else if(1==n)Browser.mainLoop.scheduler=function(){Browser.requestAnimationFrame(Browser.mainLoop.runner)},Browser.mainLoop.method="rAF";else if(2==n){if(!window.setImmediate){var r=[];window.addEventListener("message",(function(n){n.source===window&&"setimmediate"===n.data&&(n.stopPropagation(),r.shift()())}),!0),window.setImmediate=function(n){r.push(n),ENVIRONMENT_IS_WORKER?(void 0===Module.setImmediates&&(Module.setImmediates=[]),Module.setImmediates.push(n),window.postMessage({target:"setimmediate"})):window.postMessage("setimmediate","*")}}Browser.mainLoop.scheduler=function(){window.setImmediate(Browser.mainLoop.runner)},Browser.mainLoop.method="immediate"}return 0}function _emscripten_get_now(){abort()}function _emscripten_set_main_loop(n,e,r,t,i){var u;Module.noExitRuntime=!0,assert(!Browser.mainLoop.func,"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."),Browser.mainLoop.func=n,Browser.mainLoop.arg=t,u=void 0!==t?function(){Module.dynCall_vi(n,t)}:function(){Module.dynCall_v(n)};var o=Browser.mainLoop.currentlyRunningMainloop;if(Browser.mainLoop.runner=function(){if(!ABORT)if(Browser.mainLoop.queue.length>0){var n=Date.now(),e=Browser.mainLoop.queue.shift();if(e.func(e.arg),Browser.mainLoop.remainingBlockers){var r=Browser.mainLoop.remainingBlockers,t=r%1==0?r-1:Math.floor(r);e.counted?Browser.mainLoop.remainingBlockers=t:(t+=.5,Browser.mainLoop.remainingBlockers=(8*r+t)/9)}if(console.log('main loop blocker "'+e.name+'" took '+(Date.now()-n)+" ms"),Browser.mainLoop.updateStatus(),o<Browser.mainLoop.currentlyRunningMainloop)return;setTimeout(Browser.mainLoop.runner,0)}else o<Browser.mainLoop.currentlyRunningMainloop||(Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0,1==Browser.mainLoop.timingMode&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0?Browser.mainLoop.scheduler():(0==Browser.mainLoop.timingMode&&(Browser.mainLoop.tickStartTime=_emscripten_get_now()),"timeout"===Browser.mainLoop.method&&Module.ctx&&(Module.printErr("Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!"),Browser.mainLoop.method=""),Browser.mainLoop.runIter(u),o<Browser.mainLoop.currentlyRunningMainloop||("object"==typeof SDL&&SDL.audio&&SDL.audio.queueNewAudioData&&SDL.audio.queueNewAudioData(),Browser.mainLoop.scheduler())))},i||(e&&e>0?_emscripten_set_main_loop_timing(0,1e3/e):_emscripten_set_main_loop_timing(1,1),Browser.mainLoop.scheduler()),r)throw"SimulateInfiniteLoop"}var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function(){Browser.mainLoop.scheduler=null,Browser.mainLoop.currentlyRunningMainloop++},resume:function(){Browser.mainLoop.currentlyRunningMainloop++;var n=Browser.mainLoop.timingMode,e=Browser.mainLoop.timingValue,r=Browser.mainLoop.func;Browser.mainLoop.func=null,_emscripten_set_main_loop(r,0,!1,Browser.mainLoop.arg,!0),_emscripten_set_main_loop_timing(n,e),Browser.mainLoop.scheduler()},updateStatus:function(){if(Module.setStatus){var n=Module.statusMessage||"Please wait...",e=Browser.mainLoop.remainingBlockers,r=Browser.mainLoop.expectedBlockers;e?e<r?Module.setStatus(n+" ("+(r-e)+"/"+r+")"):Module.setStatus(n):Module.setStatus("")}},runIter:function(n){if(!ABORT){if(Module.preMainLoop)if(!1===Module.preMainLoop())return;try{n()}catch(n){if(n instanceof ExitStatus)return;throw n&&"object"==typeof n&&n.stack&&Module.printErr("exception thrown: "+[n,n.stack]),n}Module.postMainLoop&&Module.postMainLoop()}}},isFullscreen:!1,pointerLock:!1,moduleContextCreatedCallbacks:[],workers:[],init:function(){if(Module.preloadPlugins||(Module.preloadPlugins=[]),!Browser.initted){Browser.initted=!0;try{new Blob,Browser.hasBlobConstructor=!0}catch(n){Browser.hasBlobConstructor=!1,console.log("warning: no blob constructor, cannot create blobs with mimetypes")}Browser.BlobBuilder="undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:Browser.hasBlobConstructor?null:console.log("warning: no BlobBuilder"),Browser.URLObject="undefined"!=typeof window?window.URL?window.URL:window.webkitURL:void 0,Module.noImageDecoding||void 0!==Browser.URLObject||(console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available."),Module.noImageDecoding=!0);var n={canHandle:function(n){return!Module.noImageDecoding&&/\\.(jpg|jpeg|png|bmp)$/i.test(n)},handle:function(n,e,r,t){var i=null;if(Browser.hasBlobConstructor)try{(i=new Blob([n],{type:Browser.getMimetype(e)})).size!==n.length&&(i=new Blob([new Uint8Array(n).buffer],{type:Browser.getMimetype(e)}))}catch(n){Runtime.warnOnce("Blob constructor present but fails: "+n+"; falling back to blob builder")}if(!i){var u=new Browser.BlobBuilder;u.append(new Uint8Array(n).buffer),i=u.getBlob()}var o=Browser.URLObject.createObjectURL(i),a=new Image;a.onload=function(){assert(a.complete,"Image "+e+" could not be decoded");var t=document.createElement("canvas");t.width=a.width,t.height=a.height,t.getContext("2d").drawImage(a,0,0),Module.preloadedImages[e]=t,Browser.URLObject.revokeObjectURL(o),r&&r(n)},a.onerror=function(n){console.log("Image "+o+" could not be decoded"),t&&t()},a.src=o}};Module.preloadPlugins.push(n);var e={canHandle:function(n){return!Module.noAudioDecoding&&n.substr(-4)in{".ogg":1,".wav":1,".mp3":1}},handle:function(n,e,r,t){var i=!1;function u(t){i||(i=!0,Module.preloadedAudios[e]=t,r&&r(n))}function o(){i||(i=!0,Module.preloadedAudios[e]=new Audio,t&&t())}if(!Browser.hasBlobConstructor)return o();try{var a=new Blob([n],{type:Browser.getMimetype(e)})}catch(n){return o()}var f=Browser.URLObject.createObjectURL(a),c=new Audio;c.addEventListener("canplaythrough",(function(){u(c)}),!1),c.onerror=function(r){i||(console.log("warning: browser could not fully decode audio "+e+", trying slower base64 approach"),c.src="data:audio/x-"+e.substr(-3)+";base64,"+function(n){for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r="",t=0,i=0,u=0;u<n.length;u++)for(t=t<<8|n[u],i+=8;i>=6;){var o=t>>i-6&63;i-=6,r+=e[o]}return 2==i?(r+=e[(3&t)<<4],r+="=="):4==i&&(r+=e[(15&t)<<2],r+="="),r}(n),u(c))},c.src=f,Browser.safeSetTimeout((function(){u(c)}),1e4)}};Module.preloadPlugins.push(e);var r=Module.canvas;r&&(r.requestPointerLock=r.requestPointerLock||r.mozRequestPointerLock||r.webkitRequestPointerLock||r.msRequestPointerLock||function(){},r.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock||document.msExitPointerLock||function(){},r.exitPointerLock=r.exitPointerLock.bind(document),document.addEventListener("pointerlockchange",t,!1),document.addEventListener("mozpointerlockchange",t,!1),document.addEventListener("webkitpointerlockchange",t,!1),document.addEventListener("mspointerlockchange",t,!1),Module.elementPointerLock&&r.addEventListener("click",(function(n){!Browser.pointerLock&&Module.canvas.requestPointerLock&&(Module.canvas.requestPointerLock(),n.preventDefault())}),!1))}function t(){Browser.pointerLock=document.pointerLockElement===Module.canvas||document.mozPointerLockElement===Module.canvas||document.webkitPointerLockElement===Module.canvas||document.msPointerLockElement===Module.canvas}},createContext:function(n,e,r,t){if(e&&Module.ctx&&n==Module.canvas)return Module.ctx;var i,u;if(e){var o={antialias:!1,alpha:!1};if(t)for(var a in t)o[a]=t[a];(u=GL.createContext(n,o))&&(i=GL.getContext(u).GLctx)}else i=n.getContext("2d");return i?(r&&(e||assert("undefined"==typeof GLctx,"cannot set in module if GLctx is used, but we are a non-GL context that would replace it"),Module.ctx=i,e&&GL.makeContextCurrent(u),Module.useWebGL=e,Browser.moduleContextCreatedCallbacks.forEach((function(n){n()})),Browser.init()),i):null},destroyContext:function(n,e,r){},fullscreenHandlersInstalled:!1,lockPointer:void 0,resizeCanvas:void 0,requestFullscreen:function(n,e,r){Browser.lockPointer=n,Browser.resizeCanvas=e,Browser.vrDevice=r,void 0===Browser.lockPointer&&(Browser.lockPointer=!0),void 0===Browser.resizeCanvas&&(Browser.resizeCanvas=!1),void 0===Browser.vrDevice&&(Browser.vrDevice=null);var t=Module.canvas;function i(){Browser.isFullscreen=!1;var n=t.parentNode;(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===n?(t.exitFullscreen=document.exitFullscreen||document.cancelFullScreen||document.mozCancelFullScreen||document.msExitFullscreen||document.webkitCancelFullScreen||function(){},t.exitFullscreen=t.exitFullscreen.bind(document),Browser.lockPointer&&t.requestPointerLock(),Browser.isFullscreen=!0,Browser.resizeCanvas&&Browser.setFullscreenCanvasSize()):(n.parentNode.insertBefore(t,n),n.parentNode.removeChild(n),Browser.resizeCanvas&&Browser.setWindowedCanvasSize()),Module.onFullScreen&&Module.onFullScreen(Browser.isFullscreen),Module.onFullscreen&&Module.onFullscreen(Browser.isFullscreen),Browser.updateCanvasDimensions(t)}Browser.fullscreenHandlersInstalled||(Browser.fullscreenHandlersInstalled=!0,document.addEventListener("fullscreenchange",i,!1),document.addEventListener("mozfullscreenchange",i,!1),document.addEventListener("webkitfullscreenchange",i,!1),document.addEventListener("MSFullscreenChange",i,!1));var u=document.createElement("div");t.parentNode.insertBefore(u,t),u.appendChild(t),u.requestFullscreen=u.requestFullscreen||u.mozRequestFullScreen||u.msRequestFullscreen||(u.webkitRequestFullscreen?function(){u.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT)}:null)||(u.webkitRequestFullScreen?function(){u.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}:null),r?u.requestFullscreen({vrDisplay:r}):u.requestFullscreen()},requestFullScreen:function(n,e,r){return Module.printErr("Browser.requestFullScreen() is deprecated. Please call Browser.requestFullscreen instead."),Browser.requestFullScreen=function(n,e,r){return Browser.requestFullscreen(n,e,r)},Browser.requestFullscreen(n,e,r)},nextRAF:0,fakeRequestAnimationFrame:function(n){var e=Date.now();if(0===Browser.nextRAF)Browser.nextRAF=e+1e3/60;else for(;e+2>=Browser.nextRAF;)Browser.nextRAF+=1e3/60;var r=Math.max(Browser.nextRAF-e,0);setTimeout(n,r)},requestAnimationFrame:function(n){"undefined"==typeof window?Browser.fakeRequestAnimationFrame(n):(window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||Browser.fakeRequestAnimationFrame),window.requestAnimationFrame(n))},safeCallback:function(n){return function(){if(!ABORT)return n.apply(null,arguments)}},allowAsyncCallbacks:!0,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function(){Browser.allowAsyncCallbacks=!1},resumeAsyncCallbacks:function(){if(Browser.allowAsyncCallbacks=!0,Browser.queuedAsyncCallbacks.length>0){var n=Browser.queuedAsyncCallbacks;Browser.queuedAsyncCallbacks=[],n.forEach((function(n){n()}))}},safeRequestAnimationFrame:function(n){return Browser.requestAnimationFrame((function(){ABORT||(Browser.allowAsyncCallbacks?n():Browser.queuedAsyncCallbacks.push(n))}))},safeSetTimeout:function(n,e){return Module.noExitRuntime=!0,setTimeout((function(){ABORT||(Browser.allowAsyncCallbacks?n():Browser.queuedAsyncCallbacks.push(n))}),e)},safeSetInterval:function(n,e){return Module.noExitRuntime=!0,setInterval((function(){ABORT||Browser.allowAsyncCallbacks&&n()}),e)},getMimetype:function(n){return{jpg:"image/jpeg",jpeg:"image/jpeg",png:"image/png",bmp:"image/bmp",ogg:"audio/ogg",wav:"audio/wav",mp3:"audio/mpeg"}[n.substr(n.lastIndexOf(".")+1)]},getUserMedia:function(n){window.getUserMedia||(window.getUserMedia=navigator.getUserMedia||navigator.mozGetUserMedia),window.getUserMedia(n)},getMovementX:function(n){return n.movementX||n.mozMovementX||n.webkitMovementX||0},getMovementY:function(n){return n.movementY||n.mozMovementY||n.webkitMovementY||0},getMouseWheelDelta:function(n){var e=0;switch(n.type){case"DOMMouseScroll":e=n.detail;break;case"mousewheel":e=n.wheelDelta;break;case"wheel":e=n.deltaY;break;default:throw"unrecognized mouse wheel event: "+n.type}return e},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(n){if(Browser.pointerLock)"mousemove"!=n.type&&"mozMovementX"in n?Browser.mouseMovementX=Browser.mouseMovementY=0:(Browser.mouseMovementX=Browser.getMovementX(n),Browser.mouseMovementY=Browser.getMovementY(n)),"undefined"!=typeof SDL?(Browser.mouseX=SDL.mouseX+Browser.mouseMovementX,Browser.mouseY=SDL.mouseY+Browser.mouseMovementY):(Browser.mouseX+=Browser.mouseMovementX,Browser.mouseY+=Browser.mouseMovementY);else{var e=Module.canvas.getBoundingClientRect(),r=Module.canvas.width,t=Module.canvas.height,i=void 0!==window.scrollX?window.scrollX:window.pageXOffset,u=void 0!==window.scrollY?window.scrollY:window.pageYOffset;if("touchstart"===n.type||"touchend"===n.type||"touchmove"===n.type){var o=n.touch;if(void 0===o)return;var a=o.pageX-(i+e.left),f=o.pageY-(u+e.top),c={x:a*=r/e.width,y:f*=t/e.height};if("touchstart"===n.type)Browser.lastTouches[o.identifier]=c,Browser.touches[o.identifier]=c;else if("touchend"===n.type||"touchmove"===n.type){var l=Browser.touches[o.identifier];l||(l=c),Browser.lastTouches[o.identifier]=l,Browser.touches[o.identifier]=c}return}var s=n.pageX-(i+e.left),d=n.pageY-(u+e.top);s*=r/e.width,d*=t/e.height,Browser.mouseMovementX=s-Browser.mouseX,Browser.mouseMovementY=d-Browser.mouseY,Browser.mouseX=s,Browser.mouseY=d}},asyncLoad:function(n,e,r,t){var i=t?"":getUniqueRunDependency("al "+n);Module.readAsync(n,(function(r){assert(r,'Loading data file "'+n+'" failed (no arrayBuffer).'),e(new Uint8Array(r)),i&&removeRunDependency(i)}),(function(e){if(!r)throw'Loading data file "'+n+'" failed.';r()})),i&&addRunDependency(i)},resizeListeners:[],updateResizeListeners:function(){var n=Module.canvas;Browser.resizeListeners.forEach((function(e){e(n.width,n.height)}))},setCanvasSize:function(n,e,r){var t=Module.canvas;Browser.updateCanvasDimensions(t,n,e),r||Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function(){if("undefined"!=typeof SDL){var n=HEAPU32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2];n|=8388608,HEAP32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2]=n}Browser.updateResizeListeners()},setWindowedCanvasSize:function(){if("undefined"!=typeof SDL){var n=HEAPU32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2];n&=-8388609,HEAP32[SDL.screen+0*Runtime.QUANTUM_SIZE>>2]=n}Browser.updateResizeListeners()},updateCanvasDimensions:function(n,e,r){e&&r?(n.widthNative=e,n.heightNative=r):(e=n.widthNative,r=n.heightNative);var t=e,i=r;if(Module.forcedAspectRatio&&Module.forcedAspectRatio>0&&(t/i<Module.forcedAspectRatio?t=Math.round(i*Module.forcedAspectRatio):i=Math.round(t/Module.forcedAspectRatio)),(document.fullscreenElement||document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement||document.webkitCurrentFullScreenElement)===n.parentNode&&"undefined"!=typeof screen){var u=Math.min(screen.width/t,screen.height/i);t=Math.round(t*u),i=Math.round(i*u)}Browser.resizeCanvas?(n.width!=t&&(n.width=t),n.height!=i&&(n.height=i),void 0!==n.style&&(n.style.removeProperty("width"),n.style.removeProperty("height"))):(n.width!=e&&(n.width=e),n.height!=r&&(n.height=r),void 0!==n.style&&(t!=e||i!=r?(n.style.setProperty("width",t+"px","important"),n.style.setProperty("height",i+"px","important")):(n.style.removeProperty("width"),n.style.removeProperty("height"))))},wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function(){var n=Browser.nextWgetRequestHandle;return Browser.nextWgetRequestHandle++,n}},SYSCALLS={varargs:0,get:function(n){return SYSCALLS.varargs+=4,HEAP32[SYSCALLS.varargs-4>>2]},getStr:function(){return Pointer_stringify(SYSCALLS.get())},get64:function(){var n=SYSCALLS.get(),e=SYSCALLS.get();return assert(n>=0?0===e:-1===e),n},getZero:function(){assert(0===SYSCALLS.get())}};function ___syscall6(n,e){SYSCALLS.varargs=e;try{var r=SYSCALLS.getStreamFromFD();return FS.close(r),0}catch(n){return"undefined"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function ___syscall54(n,e){SYSCALLS.varargs=e;try{return 0}catch(n){return"undefined"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function _typeModule(n){var e=[[0,1,"X"],[1,1,"const X"],[128,1,"X *"],[256,1,"X &"],[384,1,"X &&"],[512,1,"std::shared_ptr<X>"],[640,1,"std::unique_ptr<X>"],[5120,1,"std::vector<X>"],[6144,2,"std::array<X, Y>"],[9216,-1,"std::function<X (Y)>"]];function r(n,e,r,t,i,u){if(1==e){var o=896&t;128!=o&&256!=o&&384!=o||(n="X const")}return(u?r.replace("X",n).replace("Y",i):n.replace("X",r).replace("Y",i)).replace(/([*&]) (?=[*&])/g,"$1")}function t(n,e){var r=e.flags,t=896&r,i=15360&r;return e.name||1024!=i||(1==e.ptrSize?e.name=(16&r?"":(8&r?"un":"")+"signed ")+"char":e.name=(8&r?"u":"")+(32&r?"float":"int")+8*e.ptrSize+"_t"),8!=e.ptrSize||32&r||(i=64),2048==i&&(512==t||640==t?i=4096:t&&(i=3072)),n(i,e)}var i={Type:function(){function n(n){this.id=n.id,this.name=n.name,this.flags=n.flags,this.spec=n}return n.prototype.toString=function(){return this.name},n}(),getComplexType:function n(i,u,o,a,f,c,l,s){void 0===c&&(c="X"),void 0===s&&(s=1);var d=o(i);if(d)return d;var _,v=a(i),p=v.placeholderFlag,m=e[p];l&&m&&(c=r(l[2],l[0],c,m[0],"?",!0)),0==p&&(_="Unbound"),p>=10&&(_="Corrupt"),s>20&&(_="Deeply nested"),_&&function(n,e,r,t,i){throw new Error(n+" type "+r.replace("X",e+"?")+(t?" with flag "+t:"")+" in "+i)}(_,i,c,p,f||"?");var b,h=n(v.paramList[0],u,o,a,f,c,m,s+1),y={flags:m[0],id:i,name:"",paramList:[h]},w=[],M="?";switch(v.placeholderFlag){case 1:b=h.spec;break;case 2:if(1024==(15360&h.flags)&&1==h.spec.ptrSize){y.flags=7168;break}case 3:case 6:case 5:b=h.spec,h.flags;break;case 8:M=""+v.paramList[1],y.paramList.push(v.paramList[1]);break;case 9:for(var k=0,g=v.paramList[1];k<g.length;k++){var T=n(g[k],u,o,a,f,c,m,s+1);w.push(T.name),y.paramList.push(T)}M=w.join(", ")}if(y.name=r(m[2],m[0],h.name,h.flags,M),b){for(var A=0,S=Object.keys(b);A<S.length;A++){var E=S[A];y[E]=y[E]||b[E]}y.flags|=b.flags}return t(u,y)},makeType:t,structureList:e};return n.output=i,n.output||i}function __nbind_register_type(n,e){var r={flags:10240,id:n,name:_nbind.readAsciiString(e)};_nbind.makeType(_nbind.constructType,r)}function __nbind_register_callback_signature(n,e){var r=_nbind.readTypeIdList(n,e),t=_nbind.callbackSignatureList.length;return _nbind.callbackSignatureList[t]=_nbind.makeJSCaller(r),t}function __extends(n,e){for(var r in e)e.hasOwnProperty(r)&&(n[r]=e[r]);function t(){this.constructor=n}t.prototype=e.prototype,n.prototype=new t}function __nbind_register_class(n,e,r,t,i,u,o){var a=_nbind.readAsciiString(o),f=_nbind.readPolicyList(e),c=HEAPU32.subarray(n/4,n/4+2),l={flags:2048|(f.Value?2:0),id:c[0],name:a},s=_nbind.makeType(_nbind.constructType,l);s.ptrType=_nbind.getComplexType(c[1],_nbind.constructType,_nbind.getType,_nbind.queryType),s.destroy=_nbind.makeMethodCaller(s.ptrType,{boundID:l.id,flags:0,name:"destroy",num:0,ptr:u,title:s.name+".free",typeList:["void","uint32_t","uint32_t"]}),i&&(s.superIdList=Array.prototype.slice.call(HEAPU32.subarray(r/4,r/4+i)),s.upcastList=Array.prototype.slice.call(HEAPU32.subarray(t/4,t/4+i))),Module[s.name]=s.makeBound(f),_nbind.BindClass.list.push(s)}function _removeAccessorPrefix(n){return n.replace(/^[Gg]et_?([A-Z]?([A-Z]?))/,(function(n,e,r){return r?e:e.toLowerCase()}))}function __nbind_register_function(n,e,r,t,i,u,o,a,f,c){var l,s=_nbind.getType(n),d=_nbind.readPolicyList(e),_=_nbind.readTypeIdList(r,t);if(5==o)l=[{direct:i,name:"__nbindConstructor",ptr:0,title:s.name+" constructor",typeList:["uint32_t"].concat(_.slice(1))},{direct:u,name:"__nbindValueConstructor",ptr:0,title:s.name+" value constructor",typeList:["void","uint32_t"].concat(_.slice(1))}];else{var v=_nbind.readAsciiString(a),p=(s.name&&s.name+".")+v;3!=o&&4!=o||(v=_removeAccessorPrefix(v)),l=[{boundID:n,direct:u,name:v,ptr:i,title:p,typeList:_}]}for(var m=0,b=l;m<b.length;m++){var h=b[m];h.signatureType=o,h.policyTbl=d,h.num=f,h.flags=c,s.addMethod(h)}}function _nbind_value(n,e){_nbind.typeNameTbl[n]||_nbind.throwError("Unknown value type "+n),Module.NBind.bind_value(n,e),_defineHidden(_nbind.typeNameTbl[n].proto.prototype.__nbindValueConstructor)(e.prototype,"__nbindValueConstructor")}function __nbind_get_value_object(n,e){var r=_nbind.popValue(n);if(!r.fromJS)throw new Error("Object "+r+" has no fromJS function");r.fromJS((function(){r.__nbindValueConstructor.apply(this,Array.prototype.concat.apply([e],arguments))}))}function _emscripten_memcpy_big(n,e,r){return HEAPU8.set(HEAPU8.subarray(e,e+r),n),n}function __nbind_register_primitive(n,e,r){var t={flags:1024|r,id:n,ptrSize:e};_nbind.makeType(_nbind.constructType,t)}Module._nbind_value=_nbind_value;var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",ALLOC_STATIC);function ___setErrNo(n){return Module.___errno_location&&(HEAP32[Module.___errno_location()>>2]=n),n}function _llvm_stacksave(){var n=_llvm_stacksave;return n.LLVM_SAVEDSTACKS||(n.LLVM_SAVEDSTACKS=[]),n.LLVM_SAVEDSTACKS.push(Runtime.stackSave()),n.LLVM_SAVEDSTACKS.length-1}function ___syscall140(n,e){SYSCALLS.varargs=e;try{var r=SYSCALLS.getStreamFromFD(),t=(SYSCALLS.get(),SYSCALLS.get()),i=SYSCALLS.get(),u=SYSCALLS.get(),o=t;return FS.llseek(r,o,u),HEAP32[i>>2]=r.position,r.getdents&&0===o&&0===u&&(r.getdents=null),0}catch(n){return"undefined"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function ___syscall146(n,e){SYSCALLS.varargs=e;try{var r=SYSCALLS.get(),t=SYSCALLS.get(),i=SYSCALLS.get(),u=0;___syscall146.buffer||(___syscall146.buffers=[null,[],[]],___syscall146.printChar=function(n,e){var r=___syscall146.buffers[n];assert(r),0===e||10===e?((1===n?Module.print:Module.printErr)(UTF8ArrayToString(r,0)),r.length=0):r.push(e)});for(var o=0;o<i;o++){for(var a=HEAP32[t+8*o>>2],f=HEAP32[t+(8*o+4)>>2],c=0;c<f;c++)___syscall146.printChar(r,HEAPU8[a+c]);u+=f}return u}catch(n){return"undefined"!=typeof FS&&n instanceof FS.ErrnoError||abort(n),-n.errno}}function __nbind_finish(){for(var n=0,e=_nbind.BindClass.list;n<e.length;n++){e[n].finish()}}var ___dso_handle=STATICTOP;function invoke_viiiii(n,e,r,t,i,u){try{Module.dynCall_viiiii(n,e,r,t,i,u)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_vif(n,e,r){try{Module.dynCall_vif(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_vid(n,e,r){try{Module.dynCall_vid(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_fiff(n,e,r,t){try{return Module.dynCall_fiff(n,e,r,t)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_vi(n,e){try{Module.dynCall_vi(n,e)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_vii(n,e,r){try{Module.dynCall_vii(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_ii(n,e){try{return Module.dynCall_ii(n,e)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viddi(n,e,r,t,i){try{Module.dynCall_viddi(n,e,r,t,i)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_vidd(n,e,r,t){try{Module.dynCall_vidd(n,e,r,t)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_iiii(n,e,r,t){try{return Module.dynCall_iiii(n,e,r,t)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_diii(n,e,r,t){try{return Module.dynCall_diii(n,e,r,t)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_di(n,e){try{return Module.dynCall_di(n,e)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_iid(n,e,r){try{return Module.dynCall_iid(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_iii(n,e,r){try{return Module.dynCall_iii(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiddi(n,e,r,t,i,u){try{Module.dynCall_viiddi(n,e,r,t,i,u)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiiiii(n,e,r,t,i,u,o){try{Module.dynCall_viiiiii(n,e,r,t,i,u,o)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_dii(n,e,r){try{return Module.dynCall_dii(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_i(n){try{return Module.dynCall_i(n)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_iiiiii(n,e,r,t,i,u){try{return Module.dynCall_iiiiii(n,e,r,t,i,u)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiid(n,e,r,t,i){try{Module.dynCall_viiid(n,e,r,t,i)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viififi(n,e,r,t,i,u,o){try{Module.dynCall_viififi(n,e,r,t,i,u,o)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viii(n,e,r,t){try{Module.dynCall_viii(n,e,r,t)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_v(n){try{Module.dynCall_v(n)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viid(n,e,r,t){try{Module.dynCall_viid(n,e,r,t)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_idd(n,e,r){try{return Module.dynCall_idd(n,e,r)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}function invoke_viiii(n,e,r,t,i){try{Module.dynCall_viiii(n,e,r,t,i)}catch(n){if("number"!=typeof n&&"longjmp"!==n)throw n;Module.setThrew(1,0)}}STATICTOP+=16,function(_nbind){var typeIdTbl={};_nbind.typeNameTbl={};var Pool=function(){function n(){}return n.lalloc=function(e){e=e+7&-8;var r=HEAPU32[n.usedPtr];return e>n.pageSize/2||e>n.pageSize-r?_nbind.typeNameTbl.NBind.proto.lalloc(e):(HEAPU32[n.usedPtr]=r+e,n.rootPtr+r)},n.lreset=function(e,r){HEAPU32[n.pagePtr]?_nbind.typeNameTbl.NBind.proto.lreset(e,r):HEAPU32[n.usedPtr]=e},n}();function constructType(n,e){var r=new(10240==n?_nbind.makeTypeNameTbl[e.name]||_nbind.BindType:_nbind.makeTypeKindTbl[n])(e);return typeIdTbl[e.id]=r,_nbind.typeNameTbl[e.name]=r,r}function getType(n){return typeIdTbl[n]}function queryType(n){var e=HEAPU8[n],r=_nbind.structureList[e][1];n/=4,r<0&&(++n,r=HEAPU32[n]+1);var t=Array.prototype.slice.call(HEAPU32.subarray(n+1,n+1+r));return 9==e&&(t=[t[0],t.slice(1)]),{paramList:t,placeholderFlag:e}}function getTypes(n,e){return n.map((function(n){return"number"==typeof n?_nbind.getComplexType(n,constructType,getType,queryType,e):_nbind.typeNameTbl[n]}))}function readTypeIdList(n,e){return Array.prototype.slice.call(HEAPU32,n/4,n/4+e)}function readAsciiString(n){for(var e=n;HEAPU8[e++];);return String.fromCharCode.apply("",HEAPU8.subarray(n,e-1))}function readPolicyList(n){var e={};if(n)for(;;){var r=HEAPU32[n/4];if(!r)break;e[readAsciiString(r)]=!0,n+=4}return e}function getDynCall(n,e){var r={float32_t:"d",float64_t:"d",int64_t:"d",uint64_t:"d",void:"v"},t=n.map((function(n){return r[n.name]||"i"})).join(""),i=Module["dynCall_"+t];if(!i)throw new Error("dynCall_"+t+" not found for "+e+"("+n.map((function(n){return n.name})).join(", ")+")");return i}function addMethod(n,e,r,t){var i=n[e];n.hasOwnProperty(e)&&i?((i.arity||0===i.arity)&&(i=_nbind.makeOverloader(i,i.arity),n[e]=i),i.addMethod(r,t)):(r.arity=t,n[e]=r)}function throwError(n){throw new Error(n)}_nbind.Pool=Pool,_nbind.constructType=constructType,_nbind.getType=getType,_nbind.queryType=queryType,_nbind.getTypes=getTypes,_nbind.readTypeIdList=readTypeIdList,_nbind.readAsciiString=readAsciiString,_nbind.readPolicyList=readPolicyList,_nbind.getDynCall=getDynCall,_nbind.addMethod=addMethod,_nbind.throwError=throwError,_nbind.bigEndian=!1;var _a=_typeModule(_typeModule);_nbind.Type=_a.Type,_nbind.makeType=_a.makeType,_nbind.getComplexType=_a.getComplexType,_nbind.structureList=_a.structureList;var BindType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.heap=HEAPU32,e.ptrSize=4,e}return __extends(e,n),e.prototype.needsWireRead=function(n){return!!this.wireRead||!!this.makeWireRead},e.prototype.needsWireWrite=function(n){return!!this.wireWrite||!!this.makeWireWrite},e}(_nbind.Type);_nbind.BindType=BindType;var PrimitiveType=function(n){function e(e){var r=n.call(this,e)||this,t=32&e.flags?{32:HEAPF32,64:HEAPF64}:8&e.flags?{8:HEAPU8,16:HEAPU16,32:HEAPU32}:{8:HEAP8,16:HEAP16,32:HEAP32};return r.heap=t[8*e.ptrSize],r.ptrSize=e.ptrSize,r}return __extends(e,n),e.prototype.needsWireWrite=function(n){return!!n&&!!n.Strict},e.prototype.makeWireWrite=function(n,e){return e&&e.Strict&&function(n){if("number"==typeof n)return n;throw new Error("Type mismatch")}},e}(BindType);function pushCString(n,e){if(null==n){if(e&&e.Nullable)return 0;throw new Error("Type mismatch")}if(e&&e.Strict){if("string"!=typeof n)throw new Error("Type mismatch")}else n=n.toString();var r=Module.lengthBytesUTF8(n)+1,t=_nbind.Pool.lalloc(r);return Module.stringToUTF8Array(n,HEAPU8,t,r),t}function popCString(n){return 0===n?null:Module.Pointer_stringify(n)}_nbind.PrimitiveType=PrimitiveType,_nbind.pushCString=pushCString,_nbind.popCString=popCString;var CStringType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=popCString,e.wireWrite=pushCString,e.readResources=[_nbind.resources.pool],e.writeResources=[_nbind.resources.pool],e}return __extends(e,n),e.prototype.makeWireWrite=function(n,e){return function(n){return pushCString(n,e)}},e}(BindType);_nbind.CStringType=CStringType;var BooleanType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=function(n){return!!n},e}return __extends(e,n),e.prototype.needsWireWrite=function(n){return!!n&&!!n.Strict},e.prototype.makeWireRead=function(n){return"!!("+n+")"},e.prototype.makeWireWrite=function(n,e){return e&&e.Strict&&function(n){if("boolean"==typeof n)return n;throw new Error("Type mismatch")}||n},e}(BindType);_nbind.BooleanType=BooleanType;var Wrapper=function(){function n(){}return n.prototype.persist=function(){this.__nbindState|=1},n}();function makeBound(n,e){var r=function(n){function r(e,t,i,u){var o=n.call(this)||this;if(!(o instanceof r))return new(Function.prototype.bind.apply(r,Array.prototype.concat.apply([null],arguments)));var a=t,f=i,c=u;if(e!==_nbind.ptrMarker){var l=o.__nbindConstructor.apply(o,arguments);a=4608,c=HEAPU32[l/4],f=HEAPU32[l/4+1]}var s={configurable:!0,enumerable:!1,value:null,writable:!1},d={__nbindFlags:a,__nbindPtr:f};c&&(d.__nbindShared=c,_nbind.mark(o));for(var _=0,v=Object.keys(d);_<v.length;_++){var p=v[_];s.value=d[p],Object.defineProperty(o,p,s)}return _defineHidden(0)(o,"__nbindState"),o}return __extends(r,n),r.prototype.free=function(){e.destroy.call(this,this.__nbindShared,this.__nbindFlags),this.__nbindState|=2,disableMember(this,"__nbindShared"),disableMember(this,"__nbindPtr")},r}(Wrapper);return __decorate([_defineHidden()],r.prototype,"__nbindConstructor",void 0),__decorate([_defineHidden()],r.prototype,"__nbindValueConstructor",void 0),__decorate([_defineHidden(n)],r.prototype,"__nbindPolicies",void 0),r}function disableMember(n,e){function r(){throw new Error("Accessing deleted object")}Object.defineProperty(n,e,{configurable:!1,enumerable:!1,get:r,set:r})}_nbind.Wrapper=Wrapper,_nbind.makeBound=makeBound,_nbind.ptrMarker={};var BindClass=function(n){function e(e){var r=n.call(this,e)||this;return r.wireRead=function(n){return _nbind.popValue(n,r.ptrType)},r.wireWrite=function(n){return pushPointer(n,r.ptrType,!0)},r.pendingSuperCount=0,r.ready=!1,r.methodTbl={},e.paramList?(r.classType=e.paramList[0].classType,r.proto=r.classType.proto):r.classType=r,r}return __extends(e,n),e.prototype.makeBound=function(n){var e=_nbind.makeBound(n,this);return this.proto=e,this.ptrType.proto=e,e},e.prototype.addMethod=function(n){var e=this.methodTbl[n.name]||[];e.push(n),this.methodTbl[n.name]=e},e.prototype.registerMethods=function(n,e){for(var r,t=0,i=Object.keys(n.methodTbl);t<i.length;t++)for(var u=i[t],o=0,a=n.methodTbl[u];o<a.length;o++){var f=a[o],c=void 0,l=void 0;if(c=this.proto.prototype,!e||1==f.signatureType)switch(f.signatureType){case 1:c=this.proto;case 5:l=_nbind.makeCaller(f),_nbind.addMethod(c,f.name,l,f.typeList.length-1);break;case 4:r=_nbind.makeMethodCaller(n.ptrType,f);break;case 3:Object.defineProperty(c,f.name,{configurable:!0,enumerable:!1,get:_nbind.makeMethodCaller(n.ptrType,f),set:r});break;case 2:l=_nbind.makeMethodCaller(n.ptrType,f),_nbind.addMethod(c,f.name,l,f.typeList.length-1)}}},e.prototype.registerSuperMethods=function(n,e,r){if(!r[n.name]){r[n.name]=!0;for(var t,i=0,u=0,o=n.superIdList||[];u<o.length;u++){var a=o[u],f=_nbind.getType(a);t=i++<e||e<0?-1:0,this.registerSuperMethods(f,t,r)}this.registerMethods(n,e<0)}},e.prototype.finish=function(){if(this.ready)return this;this.ready=!0,this.superList=(this.superIdList||[]).map((function(n){return _nbind.getType(n).finish()}));var n=this.proto;if(this.superList.length){var e=function(){this.constructor=n};e.prototype=this.superList[0].proto.prototype,n.prototype=new e}return n!=Module&&(n.prototype.__nbindType=this),this.registerSuperMethods(this,1,{}),this},e.prototype.upcastStep=function(n,e){if(n==this)return e;for(var r=0;r<this.superList.length;++r){var t=this.superList[r].upcastStep(n,_nbind.callUpcast(this.upcastList[r],e));if(t)return t}return 0},e}(_nbind.BindType);function popPointer(n,e){return n?new e.proto(_nbind.ptrMarker,e.flags,n):null}function pushPointer(n,e,r){if(!(n instanceof _nbind.Wrapper)){if(r)return _nbind.pushValue(n);throw new Error("Type mismatch")}var t=n.__nbindPtr,i=n.__nbindType.classType,u=e.classType;if(n instanceof e.proto)for(;i!=u;)t=_nbind.callUpcast(i.upcastList[0],t),i=i.superList[0];else if(!(t=i.upcastStep(u,t)))throw new Error("Type mismatch");return t}function pushMutablePointer(n,e){var r=pushPointer(n,e);if(1&n.__nbindFlags)throw new Error("Passing a const value as a non-const argument");return r}BindClass.list=[],_nbind.BindClass=BindClass,_nbind.popPointer=popPointer,_nbind.pushPointer=pushPointer;var BindClassPtr=function(n){function e(e){var r=n.call(this,e)||this;r.classType=e.paramList[0].classType,r.proto=r.classType.proto;var t=1&e.flags,i=256==(896&r.flags)&&2&e.flags,u=t?pushPointer:pushMutablePointer,o=i?_nbind.popValue:popPointer;return r.makeWireWrite=function(n,e){return e.Nullable?function(n){return n?u(n,r):0}:function(n){return u(n,r)}},r.wireRead=function(n){return o(n,r)},r.wireWrite=function(n){return u(n,r)},r}return __extends(e,n),e}(_nbind.BindType);function popShared(n,e){var r=HEAPU32[n/4],t=HEAPU32[n/4+1];return t?new e.proto(_nbind.ptrMarker,e.flags,t,r):null}function pushShared(n,e){if(!(n instanceof e.proto))throw new Error("Type mismatch");return n.__nbindShared}function pushMutableShared(n,e){if(!(n instanceof e.proto))throw new Error("Type mismatch");if(1&n.__nbindFlags)throw new Error("Passing a const value as a non-const argument");return n.__nbindShared}_nbind.BindClassPtr=BindClassPtr,_nbind.popShared=popShared;var SharedClassPtr=function(n){function e(e){var r=n.call(this,e)||this;r.readResources=[_nbind.resources.pool],r.classType=e.paramList[0].classType,r.proto=r.classType.proto;var t=1&e.flags?pushShared:pushMutableShared;return r.wireRead=function(n){return popShared(n,r)},r.wireWrite=function(n){return t(n,r)},r}return __extends(e,n),e}(_nbind.BindType);_nbind.SharedClassPtr=SharedClassPtr,_nbind.externalList=[0];var firstFreeExternal=0,External=function(){function n(n){this.refCount=1,this.data=n}return n.prototype.register=function(){var n=firstFreeExternal;return n?firstFreeExternal=_nbind.externalList[n]:n=_nbind.externalList.length,_nbind.externalList[n]=this,n},n.prototype.reference=function(){++this.refCount},n.prototype.dereference=function(n){0==--this.refCount&&(this.free&&this.free(),_nbind.externalList[n]=firstFreeExternal,firstFreeExternal=n)},n}();function popExternal(n){var e=_nbind.externalList[n];return e.dereference(n),e.data}function pushExternal(n){var e=new External(n);return e.reference(),e.register()}_nbind.External=External;var ExternalType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=popExternal,e.wireWrite=pushExternal,e}return __extends(e,n),e}(_nbind.BindType);_nbind.ExternalType=ExternalType,_nbind.callbackSignatureList=[];var CallbackType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireWrite=function(n){return"function"!=typeof n&&_nbind.throwError("Type mismatch"),new _nbind.External(n).register()},e}return __extends(e,n),e}(_nbind.BindType);_nbind.CallbackType=CallbackType,_nbind.valueList=[0];var firstFreeValue=0;function pushValue(n){var e=firstFreeValue;return e?firstFreeValue=_nbind.valueList[e]:e=_nbind.valueList.length,_nbind.valueList[e]=n,2*e+1}function popValue(n,e){if(n||_nbind.throwError("Value type JavaScript class is missing or not registered"),1&n){n>>=1;var r=_nbind.valueList[n];return _nbind.valueList[n]=firstFreeValue,firstFreeValue=n,r}if(e)return _nbind.popShared(n,e);throw new Error("Invalid value slot "+n)}_nbind.pushValue=pushValue,_nbind.popValue=popValue;var valueBase=0x10000000000000000;function push64(n){return"number"==typeof n?n:4096*pushValue(n)+valueBase}function pop64(n){return n<valueBase?n:popValue((n-valueBase)/4096)}var CreateValueType=function(n){function e(){return null!==n&&n.apply(this,arguments)||this}return __extends(e,n),e.prototype.makeWireWrite=function(n){return"(_nbind.pushValue(new "+n+"))"},e}(_nbind.BindType);_nbind.CreateValueType=CreateValueType;var Int64Type=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireWrite=push64,e.wireRead=pop64,e}return __extends(e,n),e}(_nbind.BindType);function pushArray(n,e){if(!n)return 0;var r=n.length;if((e.size||0===e.size)&&r<e.size)throw new Error("Type mismatch");var t=e.memberType.ptrSize,i=_nbind.Pool.lalloc(4+r*t);HEAPU32[i/4]=r;var u=e.memberType.heap,o=(i+4)/t,a=e.memberType.wireWrite,f=0;if(a)for(;f<r;)u[o++]=a(n[f++]);else for(;f<r;)u[o++]=n[f++];return i}function popArray(n,e){if(0===n)return null;var r=HEAPU32[n/4],t=new Array(r),i=e.memberType.heap;n=(n+4)/e.memberType.ptrSize;var u=e.memberType.wireRead,o=0;if(u)for(;o<r;)t[o++]=u(i[n++]);else for(;o<r;)t[o++]=i[n++];return t}_nbind.Int64Type=Int64Type,_nbind.pushArray=pushArray,_nbind.popArray=popArray;var ArrayType=function(n){function e(e){var r=n.call(this,e)||this;return r.wireRead=function(n){return popArray(n,r)},r.wireWrite=function(n){return pushArray(n,r)},r.readResources=[_nbind.resources.pool],r.writeResources=[_nbind.resources.pool],r.memberType=e.paramList[0],e.paramList[1]&&(r.size=e.paramList[1]),r}return __extends(e,n),e}(_nbind.BindType);function pushString(n,e){if(null==n){if(!e||!e.Nullable)throw new Error("Type mismatch");n=""}if(e&&e.Strict){if("string"!=typeof n)throw new Error("Type mismatch")}else n=n.toString();var r=Module.lengthBytesUTF8(n),t=_nbind.Pool.lalloc(4+r+1);return HEAPU32[t/4]=r,Module.stringToUTF8Array(n,HEAPU8,t+4,r+1),t}function popString(n){if(0===n)return null;var e=HEAPU32[n/4];return Module.Pointer_stringify(n+4,e)}_nbind.ArrayType=ArrayType,_nbind.pushString=pushString,_nbind.popString=popString;var StringType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireRead=popString,e.wireWrite=pushString,e.readResources=[_nbind.resources.pool],e.writeResources=[_nbind.resources.pool],e}return __extends(e,n),e.prototype.makeWireWrite=function(n,e){return function(n){return pushString(n,e)}},e}(_nbind.BindType);function makeArgList(n){return Array.apply(null,Array(n)).map((function(n,e){return"a"+(e+1)}))}function anyNeedsWireWrite(n,e){return n.reduce((function(n,r){return n||r.needsWireWrite(e)}),!1)}function anyNeedsWireRead(n,e){return n.reduce((function(n,r){return n||!!r.needsWireRead(e)}),!1)}function makeWireRead(n,e,r,t){var i=n.length;return r.makeWireRead?r.makeWireRead(t,n,i):r.wireRead?(n[i]=r.wireRead,"(convertParamList["+i+"]("+t+"))"):t}function makeWireWrite(n,e,r,t){var i,u=n.length;return(i=r.makeWireWrite?r.makeWireWrite(t,e,n,u):r.wireWrite)?"string"==typeof i?i:(n[u]=i,"(convertParamList["+u+"]("+t+"))"):t}function buildCallerFunction(dynCall,ptrType,ptr,num,policyTbl,needsWireWrite,prefix,returnType,argTypeList,mask,err){var argList=makeArgList(argTypeList.length),convertParamList=[],callExpression=makeWireRead(convertParamList,policyTbl,returnType,"dynCall("+[prefix].concat(argList.map((function(n,e){return makeWireWrite(convertParamList,policyTbl,argTypeList[e],n)}))).join(",")+")"),resourceSet=_nbind.listResources([returnType],argTypeList),sourceCode="function("+argList.join(",")+"){"+(mask?"this.__nbindFlags&mask&&err();":"")+resourceSet.makeOpen()+"var r="+callExpression+";"+resourceSet.makeClose()+"return r;}";return eval("("+sourceCode+")")}function buildJSCallerFunction(returnType,argTypeList){var argList=makeArgList(argTypeList.length),convertParamList=[],callExpression=makeWireWrite(convertParamList,null,returnType,"_nbind.externalList[num].data("+argList.map((function(n,e){return makeWireRead(convertParamList,null,argTypeList[e],n)})).join(",")+")"),resourceSet=_nbind.listResources(argTypeList,[returnType]);resourceSet.remove(_nbind.resources.pool);var sourceCode="function("+["dummy","num"].concat(argList).join(",")+"){"+resourceSet.makeOpen()+"var r="+callExpression+";"+resourceSet.makeClose()+"return r;}";return eval("("+sourceCode+")")}function makeJSCaller(n){var e=n.length-1,r=_nbind.getTypes(n,"callback"),t=r[0],i=r.slice(1),u=anyNeedsWireRead(i,null);if(!t.needsWireWrite(null)&&!u)switch(e){case 0:return function(n,e){return _nbind.externalList[e].data()};case 1:return function(n,e,r){return _nbind.externalList[e].data(r)};case 2:return function(n,e,r,t){return _nbind.externalList[e].data(r,t)};case 3:return function(n,e,r,t,i){return _nbind.externalList[e].data(r,t,i)}}return buildJSCallerFunction(t,i)}function makeMethodCaller(n,e){var r=e.typeList.length-1,t=e.typeList.slice(0);t.splice(1,0,"uint32_t",e.boundID);var i=_nbind.getTypes(t,e.title),u=i[0],o=i.slice(3),a=u.needsWireRead(e.policyTbl),f=anyNeedsWireWrite(o,e.policyTbl),c=e.ptr,l=e.num,s=_nbind.getDynCall(i,e.title),d=1&~e.flags;function _(){throw new Error("Calling a non-const method on a const object")}if(!a&&!f)switch(r){case 0:return function(){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n))};case 1:return function(e){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n),e)};case 2:return function(e,r){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n),e,r)};case 3:return function(e,r,t){return this.__nbindFlags&d?_():s(c,l,_nbind.pushPointer(this,n),e,r,t)}}return buildCallerFunction(s,n,c,l,e.policyTbl,f,"ptr,num,pushPointer(this,ptrType)",u,o,d,_)}function makeCaller(n){var e,r=n.typeList.length-1,t=_nbind.getTypes(n.typeList,n.title),i=t[0],u=t.slice(1),o=i.needsWireRead(n.policyTbl),a=anyNeedsWireWrite(u,n.policyTbl),f=n.direct,c=n.ptr;if(n.direct&&!o&&!a){var l=_nbind.getDynCall(t,n.title);switch(r){case 0:return function(){return l(f)};case 1:return function(n){return l(f,n)};case 2:return function(n,e){return l(f,n,e)};case 3:return function(n,e,r){return l(f,n,e,r)}}c=0}if(c){var s=n.typeList.slice(0);s.splice(1,0,"uint32_t"),t=_nbind.getTypes(s,n.title),e="ptr,num"}else c=f,e="ptr";return buildCallerFunction(_nbind.getDynCall(t,n.title),null,c,n.num,n.policyTbl,a,e,i,u)}function makeOverloader(n,e){var r=[];function t(){return r[arguments.length].apply(this,arguments)}return t.addMethod=function(n,e){r[e]=n},t.addMethod(n,e),t}_nbind.StringType=StringType,_nbind.buildJSCallerFunction=buildJSCallerFunction,_nbind.makeJSCaller=makeJSCaller,_nbind.makeMethodCaller=makeMethodCaller,_nbind.makeCaller=makeCaller,_nbind.makeOverloader=makeOverloader;var Resource=function(){function n(n,e){var r=this;this.makeOpen=function(){return Object.keys(r.openTbl).join("")},this.makeClose=function(){return Object.keys(r.closeTbl).join("")},this.openTbl={},this.closeTbl={},n&&(this.openTbl[n]=!0),e&&(this.closeTbl[e]=!0)}return n.prototype.add=function(n){for(var e=0,r=Object.keys(n.openTbl);e<r.length;e++){var t=r[e];this.openTbl[t]=!0}for(var i=0,u=Object.keys(n.closeTbl);i<u.length;i++){t=u[i];this.closeTbl[t]=!0}},n.prototype.remove=function(n){for(var e=0,r=Object.keys(n.openTbl);e<r.length;e++){var t=r[e];delete this.openTbl[t]}for(var i=0,u=Object.keys(n.closeTbl);i<u.length;i++){t=u[i];delete this.closeTbl[t]}},n}();function listResources(n,e){for(var r=new Resource,t=0,i=n;t<i.length;t++)for(var u=0,o=i[t].readResources||[];u<o.length;u++){var a=o[u];r.add(a)}for(var f=0,c=e;f<c.length;f++)for(var l=0,s=c[f].writeResources||[];l<s.length;l++){a=s[l];r.add(a)}return r}_nbind.Resource=Resource,_nbind.listResources=listResources,_nbind.resources={pool:new Resource("var used=HEAPU32[_nbind.Pool.usedPtr],page=HEAPU32[_nbind.Pool.pagePtr];","_nbind.Pool.lreset(used,page);")};var ExternalBuffer=function(n){function e(e,r){var t=n.call(this,e)||this;return t.ptr=r,t}return __extends(e,n),e.prototype.free=function(){_free(this.ptr)},e}(_nbind.External);function getBuffer(n){return n instanceof ArrayBuffer?new Uint8Array(n):n instanceof DataView?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n}function pushBuffer(n,e){if(null==n&&e&&e.Nullable&&(n=[]),"object"!=typeof n)throw new Error("Type mismatch");var r=n,t=r.byteLength||r.length;if(!t&&0!==t&&0!==r.byteLength)throw new Error("Type mismatch");var i=_nbind.Pool.lalloc(8),u=_malloc(t),o=i/4;return HEAPU32[o++]=t,HEAPU32[o++]=u,HEAPU32[o++]=new ExternalBuffer(n,u).register(),HEAPU8.set(getBuffer(n),u),i}var BufferType=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.wireWrite=pushBuffer,e.readResources=[_nbind.resources.pool],e.writeResources=[_nbind.resources.pool],e}return __extends(e,n),e.prototype.makeWireWrite=function(n,e){return function(n){return pushBuffer(n,e)}},e}(_nbind.BindType);function commitBuffer(n,e,r){var t=_nbind.externalList[n].data,i=Buffer;if("function"!=typeof Buffer&&(i=function(){}),t instanceof Array);else{var u=HEAPU8.subarray(e,e+r);if(t instanceof i){("function"==typeof Buffer.from&&Buffer.from.length>=3?Buffer.from(u):new Buffer(u)).copy(t)}else getBuffer(t).set(u)}}_nbind.BufferType=BufferType,_nbind.commitBuffer=commitBuffer;var dirtyList=[],gcTimer=0;function sweep(){for(var n=0,e=dirtyList;n<e.length;n++){var r=e[n];3&r.__nbindState||r.free()}dirtyList=[],gcTimer=0}function toggleLightGC(n){_nbind.mark=n?function(n){dirtyList.push(n),gcTimer||(gcTimer=setTimeout(sweep,0))}:function(n){}}_nbind.mark=function(n){},_nbind.toggleLightGC=toggleLightGC}(_nbind),Module.requestFullScreen=function(n,e,r){Module.printErr("Module.requestFullScreen is deprecated. Please call Module.requestFullscreen instead."),Module.requestFullScreen=Module.requestFullscreen,Browser.requestFullScreen(n,e,r)},Module.requestFullscreen=function(n,e,r){Browser.requestFullscreen(n,e,r)},Module.requestAnimationFrame=function(n){Browser.requestAnimationFrame(n)},Module.setCanvasSize=function(n,e,r){Browser.setCanvasSize(n,e,r)},Module.pauseMainLoop=function(){Browser.mainLoop.pause()},Module.resumeMainLoop=function(){Browser.mainLoop.resume()},Module.getUserMedia=function(){Browser.getUserMedia()},Module.createContext=function(n,e,r,t){return Browser.createContext(n,e,r,t)},_emscripten_get_now=ENVIRONMENT_IS_NODE?function(){var n=process.hrtime();return 1e3*n[0]+n[1]/1e6}:"undefined"!=typeof dateNow?dateNow:"object"==typeof self&&self.performance&&"function"==typeof self.performance.now?function(){return self.performance.now()}:"object"==typeof performance&&"function"==typeof performance.now?function(){return performance.now()}:Date.now,__ATEXIT__.push((function(){var n=Module._fflush;n&&n(0);var e=___syscall146.printChar;if(e){var r=___syscall146.buffers;r[1].length&&e(1,10),r[2].length&&e(2,10)}})),DYNAMICTOP_PTR=allocate(1,"i32",ALLOC_STATIC),STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP),STACK_MAX=STACK_BASE+TOTAL_STACK,DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX),HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE,staticSealed=!0,Module.asmGlobalArg={Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},Module.asmLibraryArg={abort:abort,assert:assert,enlargeMemory:enlargeMemory,getTotalMemory:getTotalMemory,abortOnCannotGrowMemory:abortOnCannotGrowMemory,invoke_viiiii:invoke_viiiii,invoke_vif:invoke_vif,invoke_vid:invoke_vid,invoke_fiff:invoke_fiff,invoke_vi:invoke_vi,invoke_vii:invoke_vii,invoke_ii:invoke_ii,invoke_viddi:invoke_viddi,invoke_vidd:invoke_vidd,invoke_iiii:invoke_iiii,invoke_diii:invoke_diii,invoke_di:invoke_di,invoke_iid:invoke_iid,invoke_iii:invoke_iii,invoke_viiddi:invoke_viiddi,invoke_viiiiii:invoke_viiiiii,invoke_dii:invoke_dii,invoke_i:invoke_i,invoke_iiiiii:invoke_iiiiii,invoke_viiid:invoke_viiid,invoke_viififi:invoke_viififi,invoke_viii:invoke_viii,invoke_v:invoke_v,invoke_viid:invoke_viid,invoke_idd:invoke_idd,invoke_viiii:invoke_viiii,_emscripten_asm_const_iiiii:_emscripten_asm_const_iiiii,_emscripten_asm_const_iiidddddd:_emscripten_asm_const_iiidddddd,_emscripten_asm_const_iiiid:_emscripten_asm_const_iiiid,__nbind_reference_external:__nbind_reference_external,_emscripten_asm_const_iiiiiiii:_emscripten_asm_const_iiiiiiii,_removeAccessorPrefix:_removeAccessorPrefix,_typeModule:_typeModule,__nbind_register_pool:__nbind_register_pool,__decorate:__decorate,_llvm_stackrestore:_llvm_stackrestore,___cxa_atexit:___cxa_atexit,__extends:__extends,__nbind_get_value_object:__nbind_get_value_object,__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj:__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj,_emscripten_set_main_loop_timing:_emscripten_set_main_loop_timing,__nbind_register_primitive:__nbind_register_primitive,__nbind_register_type:__nbind_register_type,_emscripten_memcpy_big:_emscripten_memcpy_big,__nbind_register_function:__nbind_register_function,___setErrNo:___setErrNo,__nbind_register_class:__nbind_register_class,__nbind_finish:__nbind_finish,_abort:_abort,_nbind_value:_nbind_value,_llvm_stacksave:_llvm_stacksave,___syscall54:___syscall54,_defineHidden:_defineHidden,_emscripten_set_main_loop:_emscripten_set_main_loop,_emscripten_get_now:_emscripten_get_now,__nbind_register_callback_signature:__nbind_register_callback_signature,_emscripten_asm_const_iiiiii:_emscripten_asm_const_iiiiii,__nbind_free_external:__nbind_free_external,_emscripten_asm_const_iiii:_emscripten_asm_const_iiii,_emscripten_asm_const_iiididi:_emscripten_asm_const_iiididi,___syscall6:___syscall6,_atexit:_atexit,___syscall140:___syscall140,___syscall146:___syscall146,DYNAMICTOP_PTR:DYNAMICTOP_PTR,tempDoublePtr:tempDoublePtr,ABORT:ABORT,STACKTOP:STACKTOP,STACK_MAX:STACK_MAX,cttz_i8:cttz_i8,___dso_handle:___dso_handle};var asm=function(n,e,r){"use asm";var t=new n.Int8Array(r);var i=new n.Int16Array(r);var u=new n.Int32Array(r);var o=new n.Uint8Array(r);var a=new n.Uint16Array(r);var f=new n.Uint32Array(r);var c=new n.Float32Array(r);var l=new n.Float64Array(r);var s=e.DYNAMICTOP_PTR|0;var d=e.tempDoublePtr|0;var _=e.ABORT|0;var v=e.STACKTOP|0;var p=e.STACK_MAX|0;var m=e.cttz_i8|0;var b=e.___dso_handle|0;var h=0;var y=0;var w=0;var M=0;var k=n.NaN,g=n.Infinity;var T=0,A=0,S=0,E=0,C=0.0;var L=0;var R=n.Math.floor;var P=n.Math.abs;var B=n.Math.sqrt;var O=n.Math.pow;var N=n.Math.cos;var I=n.Math.sin;var F=n.Math.tan;var x=n.Math.acos;var U=n.Math.asin;var H=n.Math.atan;var D=n.Math.atan2;var W=n.Math.exp;var Y=n.Math.log;var V=n.Math.ceil;var j=n.Math.imul;var q=n.Math.min;var z=n.Math.max;var G=n.Math.clz32;var K=n.Math.fround;var X=e.abort;var J=e.assert;var Z=e.enlargeMemory;var Q=e.getTotalMemory;var $=e.abortOnCannotGrowMemory;var nn=e.invoke_viiiii;var en=e.invoke_vif;var rn=e.invoke_vid;var tn=e.invoke_fiff;var un=e.invoke_vi;var on=e.invoke_vii;var an=e.invoke_ii;var fn=e.invoke_viddi;var cn=e.invoke_vidd;var ln=e.invoke_iiii;var sn=e.invoke_diii;var dn=e.invoke_di;var _n=e.invoke_iid;var vn=e.invoke_iii;var pn=e.invoke_viiddi;var mn=e.invoke_viiiiii;var bn=e.invoke_dii;var hn=e.invoke_i;var yn=e.invoke_iiiiii;var wn=e.invoke_viiid;var Mn=e.invoke_viififi;var kn=e.invoke_viii;var gn=e.invoke_v;var Tn=e.invoke_viid;var An=e.invoke_idd;var Sn=e.invoke_viiii;var En=e._emscripten_asm_const_iiiii;var Cn=e._emscripten_asm_const_iiidddddd;var Ln=e._emscripten_asm_const_iiiid;var Rn=e.__nbind_reference_external;var Pn=e._emscripten_asm_const_iiiiiiii;var Bn=e._removeAccessorPrefix;var On=e._typeModule;var Nn=e.__nbind_register_pool;var In=e.__decorate;var Fn=e._llvm_stackrestore;var xn=e.___cxa_atexit;var Un=e.__extends;var Hn=e.__nbind_get_value_object;var Dn=e.__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj;var Wn=e._emscripten_set_main_loop_timing;var Yn=e.__nbind_register_primitive;var Vn=e.__nbind_register_type;var jn=e._emscripten_memcpy_big;var qn=e.__nbind_register_function;var zn=e.___setErrNo;var Gn=e.__nbind_register_class;var Kn=e.__nbind_finish;var Xn=e._abort;var Jn=e._nbind_value;var Zn=e._llvm_stacksave;var Qn=e.___syscall54;var $n=e._defineHidden;var ne=e._emscripten_set_main_loop;var ee=e._emscripten_get_now;var re=e.__nbind_register_callback_signature;var te=e._emscripten_asm_const_iiiiii;var ie=e.__nbind_free_external;var ue=e._emscripten_asm_const_iiii;var oe=e._emscripten_asm_const_iiididi;var ae=e.___syscall6;var fe=e._atexit;var ce=e.___syscall140;var le=e.___syscall146;var se=K(0);const de=K(0);function _e(n){n=n|0;var e=0;e=v;v=v+n|0;v=v+15&-16;return e|0}function ve(){return v|0}function pe(n){n=n|0;v=n}function me(n,e){n=n|0;e=e|0;v=n;p=e}function be(n,e){n=n|0;e=e|0;if(!h){h=n;y=e}}function he(n){n=n|0;L=n}function ye(){return L|0}function we(){var n=0,e=0;iC(8104,8,400)|0;iC(8504,408,540)|0;n=9044;e=n+44|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));t[9088]=0;t[9089]=1;u[2273]=0;u[2274]=948;u[2275]=948;xn(17,8104,b|0)|0;return}function Me(n){n=n|0;ze(n+948|0);return}function ke(n){n=K(n);return((Bi(n)|0)&2147483647)>>>0>2139095040|0}function ge(n,e,r){n=n|0;e=e|0;r=r|0;n:do{if(!(u[n+(e<<3)+4>>2]|0)){if((e|2|0)==3?u[n+60>>2]|0:0){n=n+56|0;break}switch(e|0){case 0:case 2:case 4:case 5:{if(u[n+52>>2]|0){n=n+48|0;break n}break}default:{}}if(!(u[n+68>>2]|0)){n=(e|1|0)==5?948:r;break}else{n=n+64|0;break}}else n=n+(e<<3)|0}while(0);return n|0}function Te(n){n=n|0;var e=0;e=qS(1e3)|0;Ae(n,(e|0)!=0,2456);u[2276]=(u[2276]|0)+1;iC(e|0,8104,1e3)|0;if(t[n+2>>0]|0){u[e+4>>2]=2;u[e+12>>2]=4}u[e+976>>2]=n;return e|0}function Ae(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;i=v;v=v+16|0;t=i;if(!e){u[t>>2]=r;xt(n,5,3197,t)}v=i;return}function Se(){return Te(956)|0}function Ee(n){n=n|0;var e=0;e=GE(1e3)|0;Ce(e,n);Ae(u[n+976>>2]|0,1,2456);u[2276]=(u[2276]|0)+1;u[e+944>>2]=0;return e|0}function Ce(n,e){n=n|0;e=e|0;var r=0;iC(n|0,e|0,948)|0;Dt(n+948|0,e+948|0);r=n+960|0;n=e+960|0;e=r+40|0;do{u[r>>2]=u[n>>2];r=r+4|0;n=n+4|0}while((r|0)<(e|0));return}function Le(n){n=n|0;var e=0,r=0,t=0,i=0;e=n+944|0;r=u[e>>2]|0;if(r|0){Re(r+948|0,n)|0;u[e>>2]=0}r=Pe(n)|0;if(r|0){e=0;do{u[(Be(n,e)|0)+944>>2]=0;e=e+1|0}while((e|0)!=(r|0))}r=n+948|0;t=u[r>>2]|0;i=n+952|0;e=u[i>>2]|0;if((e|0)!=(t|0))u[i>>2]=e+(~((e+-4-t|0)>>>2)<<2);Oe(r);zS(n);u[2276]=(u[2276]|0)+-1;return}function Re(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0;t=u[n>>2]|0;f=n+4|0;r=u[f>>2]|0;o=r;n:do{if((t|0)==(r|0)){i=t;a=4}else{n=t;while(1){if((u[n>>2]|0)==(e|0)){i=n;a=4;break n}n=n+4|0;if((n|0)==(r|0)){n=0;break}}}}while(0);if((a|0)==4)if((i|0)!=(r|0)){t=i+4|0;n=o-t|0;e=n>>2;if(e){cC(i|0,t|0,n|0)|0;r=u[f>>2]|0}n=i+(e<<2)|0;if((r|0)==(n|0))n=1;else{u[f>>2]=r+(~((r+-4-n|0)>>>2)<<2);n=1}}else n=0;return n|0}function Pe(n){n=n|0;return(u[n+952>>2]|0)-(u[n+948>>2]|0)>>2|0}function Be(n,e){n=n|0;e=e|0;var r=0;r=u[n+948>>2]|0;if((u[n+952>>2]|0)-r>>2>>>0>e>>>0)n=u[r+(e<<2)>>2]|0;else n=0;return n|0}function Oe(n){n=n|0;var e=0,r=0,t=0,i=0;t=v;v=v+32|0;e=t;i=u[n>>2]|0;r=(u[n+4>>2]|0)-i|0;if(((u[n+8>>2]|0)-i|0)>>>0>r>>>0){i=r>>2;Oi(e,i,i,n+8|0);Ni(n,e);Ii(e)}v=t;return}function Ne(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0;l=Pe(n)|0;do{if(l|0){if((u[(Be(n,0)|0)+944>>2]|0)==(n|0)){if(!(Re(n+948|0,e)|0))break;iC(e+400|0,8504,540)|0;u[e+944>>2]=0;qe(n);break}a=u[(u[n+976>>2]|0)+12>>2]|0;f=n+948|0;c=(a|0)==0;r=0;o=0;do{t=u[(u[f>>2]|0)+(o<<2)>>2]|0;if((t|0)==(e|0))qe(n);else{i=Ee(t)|0;u[(u[f>>2]|0)+(r<<2)>>2]=i;u[i+944>>2]=n;if(!c)IL[a&15](t,i,n,r);r=r+1|0}o=o+1|0}while((o|0)!=(l|0));if(r>>>0<l>>>0){c=n+948|0;f=n+952|0;a=r;r=u[f>>2]|0;do{o=(u[c>>2]|0)+(a<<2)|0;t=o+4|0;i=r-t|0;e=i>>2;if(!e)i=r;else{cC(o|0,t|0,i|0)|0;r=u[f>>2]|0;i=r}t=o+(e<<2)|0;if((i|0)!=(t|0)){r=i+(~((i+-4-t|0)>>>2)<<2)|0;u[f>>2]=r}a=a+1|0}while((a|0)!=(l|0))}}}while(0);return}function Ie(n){n=n|0;var e=0,r=0,i=0,o=0;Fe(n,(Pe(n)|0)==0,2491);Fe(n,(u[n+944>>2]|0)==0,2545);e=n+948|0;r=u[e>>2]|0;i=n+952|0;o=u[i>>2]|0;if((o|0)!=(r|0))u[i>>2]=o+(~((o+-4-r|0)>>>2)<<2);Oe(e);e=n+976|0;r=u[e>>2]|0;iC(n|0,8104,1e3)|0;if(t[r+2>>0]|0){u[n+4>>2]=2;u[n+12>>2]=4}u[e>>2]=r;return}function Fe(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;i=v;v=v+16|0;t=i;if(!e){u[t>>2]=r;At(n,5,3197,t)}v=i;return}function xe(){return u[2276]|0}function Ue(){var n=0;n=qS(20)|0;He((n|0)!=0,2592);u[2277]=(u[2277]|0)+1;u[n>>2]=u[239];u[n+4>>2]=u[240];u[n+8>>2]=u[241];u[n+12>>2]=u[242];u[n+16>>2]=u[243];return n|0}function He(n,e){n=n|0;e=e|0;var r=0,t=0;t=v;v=v+16|0;r=t;if(!n){u[r>>2]=e;At(0,5,3197,r)}v=t;return}function De(n){n=n|0;zS(n);u[2277]=(u[2277]|0)+-1;return}function We(n,e){n=n|0;e=e|0;var r=0;if(!e){r=0;e=0}else{Fe(n,(Pe(n)|0)==0,2629);r=1}u[n+964>>2]=e;u[n+988>>2]=r;return}function Ye(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;o=t+8|0;i=t+4|0;a=t;u[i>>2]=e;Fe(n,(u[e+944>>2]|0)==0,2709);Fe(n,(u[n+964>>2]|0)==0,2763);Ve(n);e=n+948|0;u[a>>2]=(u[e>>2]|0)+(r<<2);u[o>>2]=u[a>>2];je(e,o,i)|0;u[(u[i>>2]|0)+944>>2]=n;qe(n);v=t;return}function Ve(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=Pe(n)|0;if(r|0?(u[(Be(n,0)|0)+944>>2]|0)!=(n|0):0){t=u[(u[n+976>>2]|0)+12>>2]|0;i=n+948|0;o=(t|0)==0;e=0;do{a=u[(u[i>>2]|0)+(e<<2)>>2]|0;f=Ee(a)|0;u[(u[i>>2]|0)+(e<<2)>>2]=f;u[f+944>>2]=n;if(!o)IL[t&15](a,f,n,e);e=e+1|0}while((e|0)!=(r|0))}return}function je(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0;h=v;v=v+64|0;d=h+52|0;f=h+48|0;_=h+28|0;p=h+24|0;m=h+20|0;b=h;t=u[n>>2]|0;o=t;e=t+((u[e>>2]|0)-o>>2<<2)|0;t=n+4|0;i=u[t>>2]|0;a=n+8|0;do{if(i>>>0<(u[a>>2]|0)>>>0){if((e|0)==(i|0)){u[e>>2]=u[r>>2];u[t>>2]=(u[t>>2]|0)+4;break}Fi(n,e,i,e+4|0);if(e>>>0<=r>>>0)r=(u[t>>2]|0)>>>0>r>>>0?r+4|0:r;u[e>>2]=u[r>>2]}else{t=(i-o>>2)+1|0;i=Vt(n)|0;if(i>>>0<t>>>0)DE(n);s=u[n>>2]|0;l=(u[a>>2]|0)-s|0;o=l>>1;Oi(b,l>>2>>>0<i>>>1>>>0?o>>>0<t>>>0?t:o:i,e-s>>2,n+8|0);s=b+8|0;t=u[s>>2]|0;o=b+12|0;l=u[o>>2]|0;a=l;c=t;do{if((t|0)==(l|0)){l=b+4|0;t=u[l>>2]|0;y=u[b>>2]|0;i=y;if(t>>>0<=y>>>0){t=a-i>>1;t=(t|0)==0?1:t;Oi(_,t,t>>>2,u[b+16>>2]|0);u[p>>2]=u[l>>2];u[m>>2]=u[s>>2];u[f>>2]=u[p>>2];u[d>>2]=u[m>>2];Ui(_,f,d);t=u[b>>2]|0;u[b>>2]=u[_>>2];u[_>>2]=t;t=_+4|0;y=u[l>>2]|0;u[l>>2]=u[t>>2];u[t>>2]=y;t=_+8|0;y=u[s>>2]|0;u[s>>2]=u[t>>2];u[t>>2]=y;t=_+12|0;y=u[o>>2]|0;u[o>>2]=u[t>>2];u[t>>2]=y;Ii(_);t=u[s>>2]|0;break}o=t;a=((o-i>>2)+1|0)/-2|0;f=t+(a<<2)|0;i=c-o|0;o=i>>2;if(o){cC(f|0,t|0,i|0)|0;t=u[l>>2]|0}y=f+(o<<2)|0;u[s>>2]=y;u[l>>2]=t+(a<<2);t=y}}while(0);u[t>>2]=u[r>>2];u[s>>2]=(u[s>>2]|0)+4;e=xi(n,b,e)|0;Ii(b)}}while(0);v=h;return e|0}function qe(n){n=n|0;var e=0;do{e=n+984|0;if(t[e>>0]|0)break;t[e>>0]=1;c[n+504>>2]=K(k);n=u[n+944>>2]|0}while((n|0)!=0);return}function ze(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-4-t|0)>>>2)<<2);XE(r)}return}function Ge(n){n=n|0;return u[n+944>>2]|0}function Ke(n){n=n|0;Fe(n,(u[n+964>>2]|0)!=0,2832);qe(n);return}function Xe(n){n=n|0;return(t[n+984>>0]|0)!=0|0}function Je(n,e){n=n|0;e=e|0;if(iE(n,e,400)|0){iC(n|0,e|0,400)|0;qe(n)}return}function Ze(n){n=n|0;var e=de;e=K(c[n+44>>2]);n=ke(e)|0;return K(n?K(0.0):e)}function Qe(n){n=n|0;var e=de;e=K(c[n+48>>2]);if(ke(e)|0)e=t[(u[n+976>>2]|0)+2>>0]|0?K(1.0):K(0.0);return K(e)}function $e(n,e){n=n|0;e=e|0;u[n+980>>2]=e;return}function nr(n){n=n|0;return u[n+980>>2]|0}function er(n,e){n=n|0;e=e|0;var r=0;r=n+4|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function rr(n){n=n|0;return u[n+4>>2]|0}function tr(n,e){n=n|0;e=e|0;var r=0;r=n+8|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function ir(n){n=n|0;return u[n+8>>2]|0}function ur(n,e){n=n|0;e=e|0;var r=0;r=n+12|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function or(n){n=n|0;return u[n+12>>2]|0}function ar(n,e){n=n|0;e=e|0;var r=0;r=n+16|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function fr(n){n=n|0;return u[n+16>>2]|0}function cr(n,e){n=n|0;e=e|0;var r=0;r=n+20|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function lr(n){n=n|0;return u[n+20>>2]|0}function sr(n,e){n=n|0;e=e|0;var r=0;r=n+24|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function dr(n){n=n|0;return u[n+24>>2]|0}function _r(n,e){n=n|0;e=e|0;var r=0;r=n+28|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function vr(n){n=n|0;return u[n+28>>2]|0}function pr(n,e){n=n|0;e=e|0;var r=0;r=n+32|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function mr(n){n=n|0;return u[n+32>>2]|0}function br(n,e){n=n|0;e=e|0;var r=0;r=n+36|0;if((u[r>>2]|0)!=(e|0)){u[r>>2]=e;qe(n)}return}function hr(n){n=n|0;return u[n+36>>2]|0}function yr(n,e){n=n|0;e=K(e);var r=0;r=n+40|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function wr(n,e){n=n|0;e=K(e);var r=0;r=n+44|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function Mr(n,e){n=n|0;e=K(e);var r=0;r=n+48|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function kr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+52|0;i=n+56|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function gr(n,e){n=n|0;e=K(e);var r=0,t=0;t=n+52|0;r=n+56|0;if(!(!(K(c[t>>2])!=e)?(u[r>>2]|0)==2:0)){c[t>>2]=e;t=ke(e)|0;u[r>>2]=t?3:2;qe(n)}return}function Tr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+52|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Ar(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+132+(e<<3)|0;e=n+132+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Sr(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=o?0:2;i=n+132+(e<<3)|0;e=n+132+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Er(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=e+132+(r<<3)|0;e=u[t+4>>2]|0;r=n;u[r>>2]=u[t>>2];u[r+4>>2]=e;return}function Cr(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+60+(e<<3)|0;e=n+60+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Lr(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=o?0:2;i=n+60+(e<<3)|0;e=n+60+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Rr(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=e+60+(r<<3)|0;e=u[t+4>>2]|0;r=n;u[r>>2]=u[t>>2];u[r+4>>2]=e;return}function Pr(n,e){n=n|0;e=e|0;var r=0;r=n+60+(e<<3)+4|0;if((u[r>>2]|0)!=3){c[n+60+(e<<3)>>2]=K(k);u[r>>2]=3;qe(n)}return}function Br(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+204+(e<<3)|0;e=n+204+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Or(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=o?0:2;i=n+204+(e<<3)|0;e=n+204+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Nr(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=e+204+(r<<3)|0;e=u[t+4>>2]|0;r=n;u[r>>2]=u[t>>2];u[r+4>>2]=e;return}function Ir(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0,o=0;o=ke(r)|0;t=(o^1)&1;i=n+276+(e<<3)|0;e=n+276+(e<<3)+4|0;if(!(o|K(c[i>>2])==r?(u[e>>2]|0)==(t|0):0)){c[i>>2]=r;u[e>>2]=t;qe(n)}return}function Fr(n,e){n=n|0;e=e|0;return K(c[n+276+(e<<3)>>2])}function xr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+348|0;i=n+352|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Ur(n,e){n=n|0;e=K(e);var r=0,t=0;t=n+348|0;r=n+352|0;if(!(!(K(c[t>>2])!=e)?(u[r>>2]|0)==2:0)){c[t>>2]=e;t=ke(e)|0;u[r>>2]=t?3:2;qe(n)}return}function Hr(n){n=n|0;var e=0;e=n+352|0;if((u[e>>2]|0)!=3){c[n+348>>2]=K(k);u[e>>2]=3;qe(n)}return}function Dr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+348|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Wr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+356|0;i=n+360|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Yr(n,e){n=n|0;e=K(e);var r=0,t=0;t=n+356|0;r=n+360|0;if(!(!(K(c[t>>2])!=e)?(u[r>>2]|0)==2:0)){c[t>>2]=e;t=ke(e)|0;u[r>>2]=t?3:2;qe(n)}return}function Vr(n){n=n|0;var e=0;e=n+360|0;if((u[e>>2]|0)!=3){c[n+356>>2]=K(k);u[e>>2]=3;qe(n)}return}function jr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+356|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function qr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+364|0;i=n+368|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function zr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+364|0;i=n+368|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Gr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+364|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Kr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+372|0;i=n+376|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Xr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+372|0;i=n+376|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Jr(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+372|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function Zr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+380|0;i=n+384|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function Qr(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+380|0;i=n+384|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function $r(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+380|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function nt(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=(o^1)&1;t=n+388|0;i=n+392|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function et(n,e){n=n|0;e=K(e);var r=0,t=0,i=0,o=0;o=ke(e)|0;r=o?0:2;t=n+388|0;i=n+392|0;if(!(o|K(c[t>>2])==e?(u[i>>2]|0)==(r|0):0)){c[t>>2]=e;u[i>>2]=r;qe(n)}return}function rt(n,e){n=n|0;e=e|0;var r=0,t=0;t=e+388|0;r=u[t+4>>2]|0;e=n;u[e>>2]=u[t>>2];u[e+4>>2]=r;return}function tt(n,e){n=n|0;e=K(e);var r=0;r=n+396|0;if(K(c[r>>2])!=e){c[r>>2]=e;qe(n)}return}function it(n){n=n|0;return K(c[n+396>>2])}function ut(n){n=n|0;return K(c[n+400>>2])}function ot(n){n=n|0;return K(c[n+404>>2])}function at(n){n=n|0;return K(c[n+408>>2])}function ft(n){n=n|0;return K(c[n+412>>2])}function ct(n){n=n|0;return K(c[n+416>>2])}function lt(n){n=n|0;return K(c[n+420>>2])}function st(n,e){n=n|0;e=e|0;Fe(n,(e|0)<6,2918);switch(e|0){case 0:{e=(u[n+496>>2]|0)==2?5:4;break}case 2:{e=(u[n+496>>2]|0)==2?4:5;break}default:{}}return K(c[n+424+(e<<2)>>2])}function dt(n,e){n=n|0;e=e|0;Fe(n,(e|0)<6,2918);switch(e|0){case 0:{e=(u[n+496>>2]|0)==2?5:4;break}case 2:{e=(u[n+496>>2]|0)==2?4:5;break}default:{}}return K(c[n+448+(e<<2)>>2])}function _t(n,e){n=n|0;e=e|0;Fe(n,(e|0)<6,2918);switch(e|0){case 0:{e=(u[n+496>>2]|0)==2?5:4;break}case 2:{e=(u[n+496>>2]|0)==2?4:5;break}default:{}}return K(c[n+472+(e<<2)>>2])}function vt(n,e){n=n|0;e=e|0;var r=0,t=de;r=u[n+4>>2]|0;if((r|0)==(u[e+4>>2]|0)){if(!r)n=1;else{t=K(c[n>>2]);n=K(P(K(t-K(c[e>>2]))))<K(.0000999999974)}}else n=0;return n|0}function pt(n,e){n=K(n);e=K(e);var r=0;if(ke(n)|0)r=ke(e)|0;else r=K(P(K(n-e)))<K(.0000999999974);return r|0}function mt(n,e){n=n|0;e=e|0;bt(n,e);return}function bt(n,e){n=n|0;e=e|0;var r=0,i=0;r=v;v=v+16|0;i=r+4|0;u[i>>2]=0;u[i+4>>2]=0;u[i+8>>2]=0;Dn(i|0,n|0,e|0,0);At(n,3,(t[i+11>>0]|0)<0?u[i>>2]|0:i,r);JE(i);v=r;return}function ht(n,e,r,t){n=K(n);e=K(e);r=r|0;t=t|0;var i=de;n=K(n*e);i=K(xE(n,K(1.0)));do{if(!(pt(i,K(0.0))|0)){n=K(n-i);if(pt(i,K(1.0))|0){n=K(n+K(1.0));break}if(r){n=K(n+K(1.0));break}if(!t){if(i>K(.5))i=K(1.0);else{t=pt(i,K(.5))|0;i=t?K(1.0):K(0.0)}n=K(n+i)}}else n=K(n-i)}while(0);return K(n/e)}function yt(n,e,r,t,i,u,o,a,f,l,s,d,_){n=n|0;e=K(e);r=r|0;t=K(t);i=i|0;u=K(u);o=o|0;a=K(a);f=K(f);l=K(l);s=K(s);d=K(d);_=_|0;var v=0,p=de,m=de,b=de,h=de,y=de,w=de;if(f<K(0.0)|l<K(0.0))_=0;else{if((_|0)!=0?(p=K(c[_+4>>2]),p!=K(0.0)):0){b=K(ht(e,p,0,0));h=K(ht(t,p,0,0));m=K(ht(u,p,0,0));p=K(ht(a,p,0,0))}else{m=u;b=e;p=a;h=t}if((i|0)==(n|0))v=pt(m,b)|0;else v=0;if((o|0)==(r|0))_=pt(p,h)|0;else _=0;if((!v?(y=K(e-s),!(wt(n,y,f)|0)):0)?!(Mt(n,y,i,f)|0):0)v=kt(n,y,i,u,f)|0;else v=1;if((!_?(w=K(t-d),!(wt(r,w,l)|0)):0)?!(Mt(r,w,o,l)|0):0)_=kt(r,w,o,a,l)|0;else _=1;_=v&_}return _|0}function wt(n,e,r){n=n|0;e=K(e);r=K(r);if((n|0)==1)n=pt(e,r)|0;else n=0;return n|0}function Mt(n,e,r,t){n=n|0;e=K(e);r=r|0;t=K(t);if((n|0)==2&(r|0)==0){if(!(e>=t))n=pt(e,t)|0;else n=1}else n=0;return n|0}function kt(n,e,r,t,i){n=n|0;e=K(e);r=r|0;t=K(t);i=K(i);if((n|0)==2&(r|0)==2&t>e){if(!(i<=e))n=pt(e,i)|0;else n=1}else n=0;return n|0}function gt(n,e,r,i,o,a,f,s,d,_,p){n=n|0;e=K(e);r=K(r);i=i|0;o=o|0;a=a|0;f=K(f);s=K(s);d=d|0;_=_|0;p=p|0;var m=0,b=0,h=0,y=0,w=de,M=de,k=0,g=0,T=0,A=0,S=0,E=0,C=0,L=0,R=0,P=0,B=0,O=de,N=de,I=de,F=0.0,x=0.0;B=v;v=v+160|0;L=B+152|0;C=B+120|0;E=B+104|0;T=B+72|0;y=B+56|0;S=B+8|0;g=B;A=(u[2279]|0)+1|0;u[2279]=A;R=n+984|0;if((t[R>>0]|0)!=0?(u[n+512>>2]|0)!=(u[2278]|0):0)k=4;else if((u[n+516>>2]|0)==(i|0))P=0;else k=4;if((k|0)==4){u[n+520>>2]=0;u[n+924>>2]=-1;u[n+928>>2]=-1;c[n+932>>2]=K(-1.0);c[n+936>>2]=K(-1.0);P=1}n:do{if(!(u[n+964>>2]|0)){if(d){m=n+916|0;if(!(pt(K(c[m>>2]),e)|0)){k=21;break}if(!(pt(K(c[n+920>>2]),r)|0)){k=21;break}if((u[n+924>>2]|0)!=(o|0)){k=21;break}m=(u[n+928>>2]|0)==(a|0)?m:0;k=22;break}h=u[n+520>>2]|0;if(!h)k=21;else{b=0;while(1){m=n+524+(b*24|0)|0;if(((pt(K(c[m>>2]),e)|0?pt(K(c[n+524+(b*24|0)+4>>2]),r)|0:0)?(u[n+524+(b*24|0)+8>>2]|0)==(o|0):0)?(u[n+524+(b*24|0)+12>>2]|0)==(a|0):0){k=22;break n}b=b+1|0;if(b>>>0>=h>>>0){k=21;break}}}}else{w=K(Tt(n,2,f));M=K(Tt(n,0,f));m=n+916|0;I=K(c[m>>2]);N=K(c[n+920>>2]);O=K(c[n+932>>2]);if(!(yt(o,e,a,r,u[n+924>>2]|0,I,u[n+928>>2]|0,N,O,K(c[n+936>>2]),w,M,p)|0)){h=u[n+520>>2]|0;if(!h)k=21;else{b=0;while(1){m=n+524+(b*24|0)|0;O=K(c[m>>2]);N=K(c[n+524+(b*24|0)+4>>2]);I=K(c[n+524+(b*24|0)+16>>2]);if(yt(o,e,a,r,u[n+524+(b*24|0)+8>>2]|0,O,u[n+524+(b*24|0)+12>>2]|0,N,I,K(c[n+524+(b*24|0)+20>>2]),w,M,p)|0){k=22;break n}b=b+1|0;if(b>>>0>=h>>>0){k=21;break}}}}else k=22}}while(0);do{if((k|0)==21){if(!(t[11697]|0)){m=0;k=31}else{m=0;k=28}}else if((k|0)==22){b=(t[11697]|0)!=0;if(!((m|0)!=0&(P^1)))if(b){k=28;break}else{k=31;break}y=m+16|0;u[n+908>>2]=u[y>>2];h=m+20|0;u[n+912>>2]=u[h>>2];if(!((t[11698]|0)==0|b^1)){u[g>>2]=St(A)|0;u[g+4>>2]=A;At(n,4,2972,g);b=u[n+972>>2]|0;if(b|0)vL[b&127](n);o=Et(o,d)|0;a=Et(a,d)|0;x=+K(c[y>>2]);F=+K(c[h>>2]);u[S>>2]=o;u[S+4>>2]=a;l[S+8>>3]=+e;l[S+16>>3]=+r;l[S+24>>3]=x;l[S+32>>3]=F;u[S+40>>2]=_;At(n,4,2989,S)}}}while(0);if((k|0)==28){b=St(A)|0;u[y>>2]=b;u[y+4>>2]=A;u[y+8>>2]=P?3047:11699;At(n,4,3038,y);b=u[n+972>>2]|0;if(b|0)vL[b&127](n);S=Et(o,d)|0;k=Et(a,d)|0;u[T>>2]=S;u[T+4>>2]=k;l[T+8>>3]=+e;l[T+16>>3]=+r;u[T+24>>2]=_;At(n,4,3049,T);k=31}if((k|0)==31){Ct(n,e,r,i,o,a,f,s,d,p);if(t[11697]|0){b=u[2279]|0;S=St(b)|0;u[E>>2]=S;u[E+4>>2]=b;u[E+8>>2]=P?3047:11699;At(n,4,3083,E);b=u[n+972>>2]|0;if(b|0)vL[b&127](n);S=Et(o,d)|0;E=Et(a,d)|0;F=+K(c[n+908>>2]);x=+K(c[n+912>>2]);u[C>>2]=S;u[C+4>>2]=E;l[C+8>>3]=F;l[C+16>>3]=x;u[C+24>>2]=_;At(n,4,3092,C)}u[n+516>>2]=i;if(!m){b=n+520|0;m=u[b>>2]|0;if((m|0)==16){if(t[11697]|0)At(n,4,3124,L);u[b>>2]=0;m=0}if(d)m=n+916|0;else{u[b>>2]=m+1;m=n+524+(m*24|0)|0}c[m>>2]=e;c[m+4>>2]=r;u[m+8>>2]=o;u[m+12>>2]=a;u[m+16>>2]=u[n+908>>2];u[m+20>>2]=u[n+912>>2];m=0}}if(d){u[n+416>>2]=u[n+908>>2];u[n+420>>2]=u[n+912>>2];t[n+985>>0]=1;t[R>>0]=0}u[2279]=(u[2279]|0)+-1;u[n+512>>2]=u[2278];v=B;return P|(m|0)==0|0}function Tt(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;t=K(jt(n,e,r));return K(t+K(qt(n,e,r)))}function At(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=v;v=v+16|0;i=o;u[i>>2]=t;if(!n)t=0;else t=u[n+976>>2]|0;Ut(t,n,e,r,i);v=o;return}function St(n){n=n|0;return(n>>>0>60?3201:3201+(60-n)|0)|0}function Et(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+32|0;r=i+12|0;t=i;u[r>>2]=u[254];u[r+4>>2]=u[255];u[r+8>>2]=u[256];u[t>>2]=u[257];u[t+4>>2]=u[258];u[t+8>>2]=u[259];if((n|0)>2)n=11699;else n=u[(e?t:r)+(n<<2)>>2]|0;v=i;return n|0}function Ct(n,e,r,i,a,f,l,s,_,p){n=n|0;e=K(e);r=K(r);i=i|0;a=a|0;f=f|0;l=K(l);s=K(s);_=_|0;p=p|0;var m=0,b=0,h=0,y=0,w=de,M=de,k=de,g=de,T=de,A=de,S=de,E=0,C=0,L=0,R=de,P=de,B=0,O=de,N=0,I=0,F=0,x=0,U=0,H=0,D=0,W=0,Y=0,V=0,j=0,q=0,z=0,G=0,X=0,J=0,Z=0,Q=0,$=de,nn=de,en=de,rn=de,tn=de,un=0,on=0,an=0,fn=0,cn=0,ln=de,sn=de,dn=de,_n=de,vn=de,pn=de,mn=0,bn=de,hn=de,yn=de,wn=de,Mn=de,kn=de,gn=0,Tn=0,An=de,Sn=de,En=0,Cn=0,Ln=0,Rn=0,Pn=de,Bn=0,On=0,Nn=0,In=0,Fn=0,xn=0,Un=0,Hn=de,Dn=0,Wn=0;Un=v;v=v+16|0;un=Un+12|0;on=Un+8|0;an=Un+4|0;fn=Un;Fe(n,(a|0)==0|(ke(e)|0)^1,3326);Fe(n,(f|0)==0|(ke(r)|0)^1,3406);On=Kt(n,i)|0;u[n+496>>2]=On;Fn=Xt(2,On)|0;xn=Xt(0,On)|0;c[n+440>>2]=K(jt(n,Fn,l));c[n+444>>2]=K(qt(n,Fn,l));c[n+428>>2]=K(jt(n,xn,l));c[n+436>>2]=K(qt(n,xn,l));c[n+464>>2]=K(Jt(n,Fn));c[n+468>>2]=K(Zt(n,Fn));c[n+452>>2]=K(Jt(n,xn));c[n+460>>2]=K(Zt(n,xn));c[n+488>>2]=K(Qt(n,Fn,l));c[n+492>>2]=K($t(n,Fn,l));c[n+476>>2]=K(Qt(n,xn,l));c[n+484>>2]=K($t(n,xn,l));do{if(!(u[n+964>>2]|0)){Nn=n+948|0;In=(u[n+952>>2]|0)-(u[Nn>>2]|0)>>2;if(!In){ei(n,e,r,a,f,l,s);break}if(!_?ri(n,e,r,a,f,l,s)|0:0)break;Ve(n);J=n+508|0;t[J>>0]=0;Fn=Xt(u[n+4>>2]|0,On)|0;xn=ti(Fn,On)|0;Bn=zt(Fn)|0;Z=u[n+8>>2]|0;Cn=n+28|0;Q=(u[Cn>>2]|0)!=0;Mn=Bn?l:s;An=Bn?s:l;$=K(ii(n,Fn,l));nn=K(ui(n,Fn,l));w=K(ii(n,xn,l));kn=K(oi(n,Fn,l));Sn=K(oi(n,xn,l));L=Bn?a:f;En=Bn?f:a;Pn=Bn?kn:Sn;T=Bn?Sn:kn;wn=K(Tt(n,2,l));g=K(Tt(n,0,l));M=K(K(Ot(n+364|0,l))-Pn);k=K(K(Ot(n+380|0,l))-Pn);A=K(K(Ot(n+372|0,s))-T);S=K(K(Ot(n+388|0,s))-T);en=Bn?M:A;rn=Bn?k:S;wn=K(e-wn);e=K(wn-Pn);if(ke(e)|0)Pn=e;else Pn=K(OE(K(IE(e,k)),M));hn=K(r-g);e=K(hn-T);if(ke(e)|0)yn=e;else yn=K(OE(K(IE(e,S)),A));M=Bn?Pn:yn;bn=Bn?yn:Pn;n:do{if((L|0)==1){i=0;b=0;while(1){m=Be(n,b)|0;if(!i){if(K(fi(m))>K(0.0)?K(ci(m))>K(0.0):0)i=m;else i=0}else if(ai(m)|0){y=0;break n}b=b+1|0;if(b>>>0>=In>>>0){y=i;break}}}else y=0}while(0);E=y+500|0;C=y+504|0;i=0;m=0;e=K(0.0);h=0;do{b=u[(u[Nn>>2]|0)+(h<<2)>>2]|0;if((u[b+36>>2]|0)==1){li(b);t[b+985>>0]=1;t[b+984>>0]=0}else{Pt(b);if(_)Nt(b,Kt(b,On)|0,M,bn,Pn);do{if((u[b+24>>2]|0)!=1){if((b|0)==(y|0)){u[E>>2]=u[2278];c[C>>2]=K(0.0);break}else{si(n,b,Pn,a,yn,Pn,yn,f,On,p);break}}else{if(m|0)u[m+960>>2]=b;u[b+960>>2]=0;m=b;i=(i|0)==0?b:i}}while(0);pn=K(c[b+504>>2]);e=K(e+K(pn+K(Tt(b,Fn,Pn))))}h=h+1|0}while((h|0)!=(In|0));F=e>M;mn=Q&((L|0)==2&F)?1:L;N=(En|0)==1;U=N&(_^1);H=(mn|0)==1;D=(mn|0)==2;W=976+(Fn<<2)|0;Y=(En|2|0)==2;G=N&(Q^1);V=1040+(xn<<2)|0;j=1040+(Fn<<2)|0;q=976+(xn<<2)|0;z=(En|0)!=1;F=Q&((L|0)!=0&F);I=n+976|0;N=N^1;e=M;B=0;x=0;pn=K(0.0);tn=K(0.0);while(1){n:do{if(B>>>0<In>>>0){C=u[Nn>>2]|0;h=0;S=K(0.0);A=K(0.0);k=K(0.0);M=K(0.0);b=0;m=0;y=B;while(1){E=u[C+(y<<2)>>2]|0;if((u[E+36>>2]|0)!=1?(u[E+940>>2]=x,(u[E+24>>2]|0)!=1):0){g=K(Tt(E,Fn,Pn));X=u[W>>2]|0;r=K(Ot(E+380+(X<<3)|0,Mn));T=K(c[E+504>>2]);r=K(IE(r,T));r=K(OE(K(Ot(E+364+(X<<3)|0,Mn)),r));if(Q&(h|0)!=0&K(g+K(A+r))>e){f=h;g=S;L=y;break n}g=K(g+r);r=K(A+g);g=K(S+g);if(ai(E)|0){k=K(k+K(fi(E)));M=K(M-K(T*K(ci(E))))}if(m|0)u[m+960>>2]=E;u[E+960>>2]=0;h=h+1|0;m=E;b=(b|0)==0?E:b}else{g=S;r=A}y=y+1|0;if(y>>>0<In>>>0){S=g;A=r}else{f=h;L=y;break}}}else{f=0;g=K(0.0);k=K(0.0);M=K(0.0);b=0;L=B}}while(0);X=k>K(0.0)&k<K(1.0);R=X?K(1.0):k;X=M>K(0.0)&M<K(1.0);S=X?K(1.0):M;do{if(!H){if(!(g<en&((ke(en)|0)^1))){if(!(g>rn&((ke(rn)|0)^1))){if(!(t[(u[I>>2]|0)+3>>0]|0)){if(!(R==K(0.0))?!(K(fi(n))==K(0.0)):0){X=53;break}e=g;X=53}else X=51}else{e=rn;X=51}}else{e=en;X=51}}else X=51}while(0);if((X|0)==51){X=0;if(ke(e)|0)X=53;else{P=K(e-g);O=e}}if((X|0)==53){X=0;if(g<K(0.0)){P=K(-g);O=e}else{P=K(0.0);O=e}}if(!U?(cn=(b|0)==0,!cn):0){h=u[W>>2]|0;y=P<K(0.0);T=K(P/S);E=P>K(0.0);A=K(P/R);k=K(0.0);g=K(0.0);e=K(0.0);m=b;do{r=K(Ot(m+380+(h<<3)|0,Mn));M=K(Ot(m+364+(h<<3)|0,Mn));M=K(IE(r,K(OE(M,K(c[m+504>>2])))));if(y){r=K(M*K(ci(m)));if(r!=K(-0.0)?(Hn=K(M-K(T*r)),ln=K(di(m,Fn,Hn,O,Pn)),Hn!=ln):0){k=K(k-K(ln-M));e=K(e+r)}}else if((E?(sn=K(fi(m)),sn!=K(0.0)):0)?(Hn=K(M+K(A*sn)),dn=K(di(m,Fn,Hn,O,Pn)),Hn!=dn):0){k=K(k-K(dn-M));g=K(g-sn)}m=u[m+960>>2]|0}while((m|0)!=0);e=K(S+e);M=K(P+k);if(!cn){T=K(R+g);y=u[W>>2]|0;E=M<K(0.0);C=e==K(0.0);A=K(M/e);h=M>K(0.0);T=K(M/T);e=K(0.0);do{Hn=K(Ot(b+380+(y<<3)|0,Mn));k=K(Ot(b+364+(y<<3)|0,Mn));k=K(IE(Hn,K(OE(k,K(c[b+504>>2])))));if(E){Hn=K(k*K(ci(b)));M=K(-Hn);if(Hn!=K(-0.0)){Hn=K(A*M);M=K(di(b,Fn,K(k+(C?M:Hn)),O,Pn))}else M=k}else if(h?(_n=K(fi(b)),_n!=K(0.0)):0)M=K(di(b,Fn,K(k+K(T*_n)),O,Pn));else M=k;e=K(e-K(M-k));g=K(Tt(b,Fn,Pn));r=K(Tt(b,xn,Pn));M=K(M+g);c[on>>2]=M;u[fn>>2]=1;k=K(c[b+396>>2]);n:do{if(ke(k)|0){m=ke(bn)|0;do{if(!m){if(F|(Bt(b,xn,bn)|0|N))break;if((_i(n,b)|0)!=4)break;if((u[(vi(b,xn)|0)+4>>2]|0)==3)break;if((u[(pi(b,xn)|0)+4>>2]|0)==3)break;c[un>>2]=bn;u[an>>2]=1;break n}}while(0);if(Bt(b,xn,bn)|0){m=u[b+992+(u[q>>2]<<2)>>2]|0;Hn=K(r+K(Ot(m,bn)));c[un>>2]=Hn;m=z&(u[m+4>>2]|0)==2;u[an>>2]=((ke(Hn)|0|m)^1)&1;break}else{c[un>>2]=bn;u[an>>2]=m?0:2;break}}else{Hn=K(M-g);R=K(Hn/k);Hn=K(k*Hn);u[an>>2]=1;c[un>>2]=K(r+(Bn?R:Hn))}}while(0);mi(b,Fn,O,Pn,fn,on);mi(b,xn,bn,Pn,an,un);do{if(!(Bt(b,xn,bn)|0)?(_i(n,b)|0)==4:0){if((u[(vi(b,xn)|0)+4>>2]|0)==3){m=0;break}m=(u[(pi(b,xn)|0)+4>>2]|0)!=3}else m=0}while(0);Hn=K(c[on>>2]);R=K(c[un>>2]);Dn=u[fn>>2]|0;Wn=u[an>>2]|0;gt(b,Bn?Hn:R,Bn?R:Hn,On,Bn?Dn:Wn,Bn?Wn:Dn,Pn,yn,_&(m^1),3488,p)|0;t[J>>0]=t[J>>0]|t[b+508>>0];b=u[b+960>>2]|0}while((b|0)!=0)}else e=K(0.0)}else e=K(0.0);e=K(P+e);Wn=e<K(0.0)&1;t[J>>0]=Wn|o[J>>0];if(D&e>K(0.0)){m=u[W>>2]|0;if((u[n+364+(m<<3)+4>>2]|0)!=0?(vn=K(Ot(n+364+(m<<3)|0,Mn)),vn>=K(0.0)):0)M=K(OE(K(0.0),K(vn-K(O-e))));else M=K(0.0)}else M=e;E=B>>>0<L>>>0;if(E){y=u[Nn>>2]|0;h=B;m=0;do{b=u[y+(h<<2)>>2]|0;if(!(u[b+24>>2]|0)){m=((u[(vi(b,Fn)|0)+4>>2]|0)==3&1)+m|0;m=m+((u[(pi(b,Fn)|0)+4>>2]|0)==3&1)|0}h=h+1|0}while((h|0)!=(L|0));if(m){g=K(0.0);r=K(0.0)}else X=101}else X=101;n:do{if((X|0)==101){X=0;switch(Z|0){case 1:{m=0;g=K(M*K(.5));r=K(0.0);break n}case 2:{m=0;g=M;r=K(0.0);break n}case 3:{if(f>>>0<=1){m=0;g=K(0.0);r=K(0.0);break n}r=K((f+-1|0)>>>0);m=0;g=K(0.0);r=K(K(OE(M,K(0.0)))/r);break n}case 5:{r=K(M/K((f+1|0)>>>0));m=0;g=r;break n}case 4:{r=K(M/K(f>>>0));m=0;g=K(r*K(.5));break n}default:{m=0;g=K(0.0);r=K(0.0);break n}}}}while(0);e=K($+g);if(E){k=K(M/K(m|0));h=u[Nn>>2]|0;b=B;M=K(0.0);do{m=u[h+(b<<2)>>2]|0;n:do{if((u[m+36>>2]|0)!=1){switch(u[m+24>>2]|0){case 1:{if(bi(m,Fn)|0){if(!_)break n;Hn=K(hi(m,Fn,O));Hn=K(Hn+K(Jt(n,Fn)));Hn=K(Hn+K(jt(m,Fn,Pn)));c[m+400+(u[j>>2]<<2)>>2]=Hn;break n}break}case 0:{Wn=(u[(vi(m,Fn)|0)+4>>2]|0)==3;Hn=K(k+e);e=Wn?Hn:e;if(_){Wn=m+400+(u[j>>2]<<2)|0;c[Wn>>2]=K(e+K(c[Wn>>2]))}Wn=(u[(pi(m,Fn)|0)+4>>2]|0)==3;Hn=K(k+e);e=Wn?Hn:e;if(U){Hn=K(r+K(Tt(m,Fn,Pn)));M=bn;e=K(e+K(Hn+K(c[m+504>>2])));break n}else{e=K(e+K(r+K(yi(m,Fn,Pn))));M=K(OE(M,K(yi(m,xn,Pn))));break n}}default:{}}if(_){Hn=K(g+K(Jt(n,Fn)));Wn=m+400+(u[j>>2]<<2)|0;c[Wn>>2]=K(Hn+K(c[Wn>>2]))}}}while(0);b=b+1|0}while((b|0)!=(L|0))}else M=K(0.0);r=K(nn+e);if(Y)g=K(K(di(n,xn,K(Sn+M),An,l))-Sn);else g=bn;k=K(K(di(n,xn,K(Sn+(G?bn:M)),An,l))-Sn);if(E&_){b=B;do{h=u[(u[Nn>>2]|0)+(b<<2)>>2]|0;do{if((u[h+36>>2]|0)!=1){if((u[h+24>>2]|0)==1){if(bi(h,xn)|0){Hn=K(hi(h,xn,bn));Hn=K(Hn+K(Jt(n,xn)));Hn=K(Hn+K(jt(h,xn,Pn)));m=u[V>>2]|0;c[h+400+(m<<2)>>2]=Hn;if(!(ke(Hn)|0))break}else m=u[V>>2]|0;Hn=K(Jt(n,xn));c[h+400+(m<<2)>>2]=K(Hn+K(jt(h,xn,Pn)));break}m=_i(n,h)|0;do{if((m|0)==4){if((u[(vi(h,xn)|0)+4>>2]|0)==3){X=139;break}if((u[(pi(h,xn)|0)+4>>2]|0)==3){X=139;break}if(Bt(h,xn,bn)|0){e=w;break}Dn=u[h+908+(u[W>>2]<<2)>>2]|0;u[un>>2]=Dn;e=K(c[h+396>>2]);Wn=ke(e)|0;M=(u[d>>2]=Dn,K(c[d>>2]));if(Wn)e=k;else{P=K(Tt(h,xn,Pn));Hn=K(M/e);e=K(e*M);e=K(P+(Bn?Hn:e))}c[on>>2]=e;c[un>>2]=K(K(Tt(h,Fn,Pn))+M);u[an>>2]=1;u[fn>>2]=1;mi(h,Fn,O,Pn,an,un);mi(h,xn,bn,Pn,fn,on);e=K(c[un>>2]);P=K(c[on>>2]);Hn=Bn?e:P;e=Bn?P:e;Wn=((ke(Hn)|0)^1)&1;gt(h,Hn,e,On,Wn,((ke(e)|0)^1)&1,Pn,yn,1,3493,p)|0;e=w}else X=139}while(0);n:do{if((X|0)==139){X=0;e=K(g-K(yi(h,xn,Pn)));do{if((u[(vi(h,xn)|0)+4>>2]|0)==3){if((u[(pi(h,xn)|0)+4>>2]|0)!=3)break;e=K(w+K(OE(K(0.0),K(e*K(.5)))));break n}}while(0);if((u[(pi(h,xn)|0)+4>>2]|0)==3){e=w;break}if((u[(vi(h,xn)|0)+4>>2]|0)==3){e=K(w+K(OE(K(0.0),e)));break}switch(m|0){case 1:{e=w;break n}case 2:{e=K(w+K(e*K(.5)));break n}default:{e=K(w+e);break n}}}}while(0);Hn=K(pn+e);Wn=h+400+(u[V>>2]<<2)|0;c[Wn>>2]=K(Hn+K(c[Wn>>2]))}}while(0);b=b+1|0}while((b|0)!=(L|0))}pn=K(pn+k);tn=K(OE(tn,r));f=x+1|0;if(L>>>0>=In>>>0)break;else{e=O;B=L;x=f}}do{if(_){m=f>>>0>1;if(!m?!(wi(n)|0):0)break;if(!(ke(bn)|0)){e=K(bn-pn);n:do{switch(u[n+12>>2]|0){case 3:{w=K(w+e);A=K(0.0);break}case 2:{w=K(w+K(e*K(.5)));A=K(0.0);break}case 4:{if(bn>pn)A=K(e/K(f>>>0));else A=K(0.0);break}case 7:if(bn>pn){w=K(w+K(e/K(f<<1>>>0)));A=K(e/K(f>>>0));A=m?A:K(0.0);break n}else{w=K(w+K(e*K(.5)));A=K(0.0);break n}case 6:{A=K(e/K(x>>>0));A=bn>pn&m?A:K(0.0);break}default:A=K(0.0)}}while(0);if(f|0){E=1040+(xn<<2)|0;C=976+(xn<<2)|0;y=0;b=0;while(1){n:do{if(b>>>0<In>>>0){M=K(0.0);k=K(0.0);e=K(0.0);h=b;while(1){m=u[(u[Nn>>2]|0)+(h<<2)>>2]|0;do{if((u[m+36>>2]|0)!=1?(u[m+24>>2]|0)==0:0){if((u[m+940>>2]|0)!=(y|0))break n;if(Mi(m,xn)|0){Hn=K(c[m+908+(u[C>>2]<<2)>>2]);e=K(OE(e,K(Hn+K(Tt(m,xn,Pn)))))}if((_i(n,m)|0)!=5)break;vn=K(ki(m));vn=K(vn+K(jt(m,0,Pn)));Hn=K(c[m+912>>2]);Hn=K(K(Hn+K(Tt(m,0,Pn)))-vn);vn=K(OE(k,vn));Hn=K(OE(M,Hn));M=Hn;k=vn;e=K(OE(e,K(vn+Hn)))}}while(0);m=h+1|0;if(m>>>0<In>>>0)h=m;else{h=m;break}}}else{k=K(0.0);e=K(0.0);h=b}}while(0);T=K(A+e);r=w;w=K(w+T);if(b>>>0<h>>>0){g=K(r+k);m=b;do{b=u[(u[Nn>>2]|0)+(m<<2)>>2]|0;n:do{if((u[b+36>>2]|0)!=1?(u[b+24>>2]|0)==0:0)switch(_i(n,b)|0){case 1:{Hn=K(r+K(jt(b,xn,Pn)));c[b+400+(u[E>>2]<<2)>>2]=Hn;break n}case 3:{Hn=K(K(w-K(qt(b,xn,Pn)))-K(c[b+908+(u[C>>2]<<2)>>2]));c[b+400+(u[E>>2]<<2)>>2]=Hn;break n}case 2:{Hn=K(r+K(K(T-K(c[b+908+(u[C>>2]<<2)>>2]))*K(.5)));c[b+400+(u[E>>2]<<2)>>2]=Hn;break n}case 4:{Hn=K(r+K(jt(b,xn,Pn)));c[b+400+(u[E>>2]<<2)>>2]=Hn;if(Bt(b,xn,bn)|0)break n;if(Bn){M=K(c[b+908>>2]);e=K(M+K(Tt(b,Fn,Pn)));k=T}else{k=K(c[b+912>>2]);k=K(k+K(Tt(b,xn,Pn)));e=T;M=K(c[b+908>>2])}if(pt(e,M)|0?pt(k,K(c[b+912>>2]))|0:0)break n;gt(b,e,k,On,1,1,Pn,yn,1,3501,p)|0;break n}case 5:{c[b+404>>2]=K(K(g-K(ki(b)))+K(hi(b,0,bn)));break n}default:break n}}while(0);m=m+1|0}while((m|0)!=(h|0))}y=y+1|0;if((y|0)==(f|0))break;else b=h}}}}}while(0);c[n+908>>2]=K(di(n,2,wn,l,l));c[n+912>>2]=K(di(n,0,hn,s,l));if((mn|0)!=0?(gn=u[n+32>>2]|0,Tn=(mn|0)==2,!(Tn&(gn|0)!=2)):0){if(Tn&(gn|0)==2){e=K(kn+O);e=K(OE(K(IE(e,K(gi(n,Fn,tn,Mn)))),kn));X=198}}else{e=K(di(n,Fn,tn,Mn,l));X=198}if((X|0)==198)c[n+908+(u[976+(Fn<<2)>>2]<<2)>>2]=e;if((En|0)!=0?(Ln=u[n+32>>2]|0,Rn=(En|0)==2,!(Rn&(Ln|0)!=2)):0){if(Rn&(Ln|0)==2){e=K(Sn+bn);e=K(OE(K(IE(e,K(gi(n,xn,K(Sn+pn),An)))),Sn));X=204}}else{e=K(di(n,xn,K(Sn+pn),An,l));X=204}if((X|0)==204)c[n+908+(u[976+(xn<<2)>>2]<<2)>>2]=e;if(_){if((u[Cn>>2]|0)==2){b=976+(xn<<2)|0;h=1040+(xn<<2)|0;m=0;do{y=Be(n,m)|0;if(!(u[y+24>>2]|0)){Dn=u[b>>2]|0;Hn=K(c[n+908+(Dn<<2)>>2]);Wn=y+400+(u[h>>2]<<2)|0;Hn=K(Hn-K(c[Wn>>2]));c[Wn>>2]=K(Hn-K(c[y+908+(Dn<<2)>>2]))}m=m+1|0}while((m|0)!=(In|0))}if(i|0){m=Bn?mn:a;do{Ti(n,i,Pn,m,yn,On,p);i=u[i+960>>2]|0}while((i|0)!=0)}m=(Fn|2|0)==3;b=(xn|2|0)==3;if(m|b){i=0;do{h=u[(u[Nn>>2]|0)+(i<<2)>>2]|0;if((u[h+36>>2]|0)!=1){if(m)Ai(n,h,Fn);if(b)Ai(n,h,xn)}i=i+1|0}while((i|0)!=(In|0))}}}else ni(n,e,r,a,f,l,s)}while(0);v=Un;return}function Lt(n,e){n=n|0;e=K(e);var r=0;Ae(n,e>=K(0.0),3147);r=e==K(0.0);c[n+4>>2]=r?K(0.0):e;return}function Rt(n,e,r,i){n=n|0;e=K(e);r=K(r);i=i|0;var o=de,a=de,f=0,l=0,s=0;u[2278]=(u[2278]|0)+1;Pt(n);if(!(Bt(n,2,e)|0)){o=K(Ot(n+380|0,e));if(!(o>=K(0.0))){s=((ke(e)|0)^1)&1;o=e}else s=2}else{o=K(Ot(u[n+992>>2]|0,e));s=1;o=K(o+K(Tt(n,2,e)))}if(!(Bt(n,0,r)|0)){a=K(Ot(n+388|0,r));if(!(a>=K(0.0))){l=((ke(r)|0)^1)&1;a=r}else l=2}else{a=K(Ot(u[n+996>>2]|0,r));l=1;a=K(a+K(Tt(n,0,e)))}f=n+976|0;if(gt(n,o,a,i,s,l,e,r,1,3189,u[f>>2]|0)|0?(Nt(n,u[n+496>>2]|0,e,r,e),It(n,K(c[(u[f>>2]|0)+4>>2]),K(0.0),K(0.0)),t[11696]|0):0)mt(n,7);return}function Pt(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;a=f+24|0;o=f+16|0;t=f+8|0;i=f;r=0;do{e=n+380+(r<<3)|0;if(!((u[n+380+(r<<3)+4>>2]|0)!=0?(c=e,l=u[c+4>>2]|0,s=t,u[s>>2]=u[c>>2],u[s+4>>2]=l,s=n+364+(r<<3)|0,l=u[s+4>>2]|0,c=i,u[c>>2]=u[s>>2],u[c+4>>2]=l,u[o>>2]=u[t>>2],u[o+4>>2]=u[t+4>>2],u[a>>2]=u[i>>2],u[a+4>>2]=u[i+4>>2],vt(o,a)|0):0))e=n+348+(r<<3)|0;u[n+992+(r<<2)>>2]=e;r=r+1|0}while((r|0)!=2);v=f;return}function Bt(n,e,r){n=n|0;e=e|0;r=K(r);var t=0;n=u[n+992+(u[976+(e<<2)>>2]<<2)>>2]|0;switch(u[n+4>>2]|0){case 0:case 3:{n=0;break}case 1:{if(K(c[n>>2])<K(0.0))n=0;else t=5;break}case 2:{if(K(c[n>>2])<K(0.0))n=0;else n=(ke(r)|0)^1;break}default:t=5}if((t|0)==5)n=1;return n|0}function Ot(n,e){n=n|0;e=K(e);switch(u[n+4>>2]|0){case 2:{e=K(K(K(c[n>>2])*e)/K(100.0));break}case 1:{e=K(c[n>>2]);break}default:e=K(k)}return K(e)}function Nt(n,e,r,t,i){n=n|0;e=e|0;r=K(r);t=K(t);i=K(i);var o=0,a=de;e=u[n+944>>2]|0?e:1;o=Xt(u[n+4>>2]|0,e)|0;e=ti(o,e)|0;r=K(Pi(n,o,r));t=K(Pi(n,e,t));a=K(r+K(jt(n,o,i)));c[n+400+(u[1040+(o<<2)>>2]<<2)>>2]=a;r=K(r+K(qt(n,o,i)));c[n+400+(u[1e3+(o<<2)>>2]<<2)>>2]=r;r=K(t+K(jt(n,e,i)));c[n+400+(u[1040+(e<<2)>>2]<<2)>>2]=r;i=K(t+K(qt(n,e,i)));c[n+400+(u[1e3+(e<<2)>>2]<<2)>>2]=i;return}function It(n,e,r,t){n=n|0;e=K(e);r=K(r);t=K(t);var i=0,o=0,a=de,f=de,l=0,s=0,d=de,_=0,v=de,p=de,m=de,b=de;if(!(e==K(0.0))){i=n+400|0;b=K(c[i>>2]);o=n+404|0;m=K(c[o>>2]);_=n+416|0;p=K(c[_>>2]);s=n+420|0;a=K(c[s>>2]);v=K(b+r);d=K(m+t);t=K(v+p);f=K(d+a);l=(u[n+988>>2]|0)==1;c[i>>2]=K(ht(b,e,0,l));c[o>>2]=K(ht(m,e,0,l));r=K(xE(K(p*e),K(1.0)));if(pt(r,K(0.0))|0)o=0;else o=(pt(r,K(1.0))|0)^1;r=K(xE(K(a*e),K(1.0)));if(pt(r,K(0.0))|0)i=0;else i=(pt(r,K(1.0))|0)^1;b=K(ht(t,e,l&o,l&(o^1)));c[_>>2]=K(b-K(ht(v,e,0,l)));b=K(ht(f,e,l&i,l&(i^1)));c[s>>2]=K(b-K(ht(d,e,0,l)));o=(u[n+952>>2]|0)-(u[n+948>>2]|0)>>2;if(o|0){i=0;do{It(Be(n,i)|0,e,v,d);i=i+1|0}while((i|0)!=(o|0))}}return}function Ft(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;switch(r|0){case 5:case 0:{n=uE(u[489]|0,t,i)|0;break}default:n=HE(t,i)|0}return n|0}function xt(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;i=v;v=v+16|0;o=i;u[o>>2]=t;Ut(n,0,e,r,o);v=i;return}function Ut(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;n=n|0?n:956;CL[u[n+8>>2]&1](n,e,r,t,i)|0;if((r|0)==5)Xn();else return}function Ht(n,e,r){n=n|0;e=e|0;r=r|0;t[n+e>>0]=r&1;return}function Dt(n,e){n=n|0;e=e|0;var r=0,t=0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;r=e+4|0;t=(u[r>>2]|0)-(u[e>>2]|0)>>2;if(t|0){Wt(n,t);Yt(n,u[e>>2]|0,u[r>>2]|0,t)}return}function Wt(n,e){n=n|0;e=e|0;var r=0;if((Vt(n)|0)>>>0<e>>>0)DE(n);if(e>>>0>1073741823)Xn();else{r=GE(e<<2)|0;u[n+4>>2]=r;u[n>>2]=r;u[n+8>>2]=r+(e<<2);return}}function Yt(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=n+4|0;n=r-e|0;if((n|0)>0){iC(u[t>>2]|0,e|0,n|0)|0;u[t>>2]=(u[t>>2]|0)+(n>>>2<<2)}return}function Vt(n){n=n|0;return 1073741823}function jt(n,e,r){n=n|0;e=e|0;r=K(r);if(zt(e)|0?(u[n+96>>2]|0)!=0:0)n=n+92|0;else n=ge(n+60|0,u[1040+(e<<2)>>2]|0,992)|0;return K(Gt(n,r))}function qt(n,e,r){n=n|0;e=e|0;r=K(r);if(zt(e)|0?(u[n+104>>2]|0)!=0:0)n=n+100|0;else n=ge(n+60|0,u[1e3+(e<<2)>>2]|0,992)|0;return K(Gt(n,r))}function zt(n){n=n|0;return(n|1|0)==3|0}function Gt(n,e){n=n|0;e=K(e);if((u[n+4>>2]|0)==3)e=K(0.0);else e=K(Ot(n,e));return K(e)}function Kt(n,e){n=n|0;e=e|0;n=u[n>>2]|0;return((n|0)==0?(e|0)>1?e:1:n)|0}function Xt(n,e){n=n|0;e=e|0;var r=0;n:do{if((e|0)==2){switch(n|0){case 2:{n=3;break n}case 3:break;default:{r=4;break n}}n=2}else r=4}while(0);return n|0}function Jt(n,e){n=n|0;e=e|0;var r=de;if(!((zt(e)|0?(u[n+312>>2]|0)!=0:0)?(r=K(c[n+308>>2]),r>=K(0.0)):0))r=K(OE(K(c[(ge(n+276|0,u[1040+(e<<2)>>2]|0,992)|0)>>2]),K(0.0)));return K(r)}function Zt(n,e){n=n|0;e=e|0;var r=de;if(!((zt(e)|0?(u[n+320>>2]|0)!=0:0)?(r=K(c[n+316>>2]),r>=K(0.0)):0))r=K(OE(K(c[(ge(n+276|0,u[1e3+(e<<2)>>2]|0,992)|0)>>2]),K(0.0)));return K(r)}function Qt(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;if(!((zt(e)|0?(u[n+240>>2]|0)!=0:0)?(t=K(Ot(n+236|0,r)),t>=K(0.0)):0))t=K(OE(K(Ot(ge(n+204|0,u[1040+(e<<2)>>2]|0,992)|0,r)),K(0.0)));return K(t)}function $t(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;if(!((zt(e)|0?(u[n+248>>2]|0)!=0:0)?(t=K(Ot(n+244|0,r)),t>=K(0.0)):0))t=K(OE(K(Ot(ge(n+204|0,u[1e3+(e<<2)>>2]|0,992)|0,r)),K(0.0)));return K(t)}function ni(n,e,r,t,i,o,a){n=n|0;e=K(e);r=K(r);t=t|0;i=i|0;o=K(o);a=K(a);var f=de,l=de,s=de,d=de,_=de,p=de,m=0,b=0,h=0;h=v;v=v+16|0;m=h;b=n+964|0;Fe(n,(u[b>>2]|0)!=0,3519);f=K(oi(n,2,e));l=K(oi(n,0,e));s=K(Tt(n,2,e));d=K(Tt(n,0,e));if(ke(e)|0)_=e;else _=K(OE(K(0.0),K(K(e-s)-f)));if(ke(r)|0)p=r;else p=K(OE(K(0.0),K(K(r-d)-l)));if((t|0)==1&(i|0)==1){c[n+908>>2]=K(di(n,2,K(e-s),o,o));e=K(di(n,0,K(r-d),a,o))}else{RL[u[b>>2]&1](m,n,_,t,p,i);_=K(f+K(c[m>>2]));p=K(e-s);c[n+908>>2]=K(di(n,2,(t|2|0)==2?_:p,o,o));p=K(l+K(c[m+4>>2]));e=K(r-d);e=K(di(n,0,(i|2|0)==2?p:e,a,o))}c[n+912>>2]=e;v=h;return}function ei(n,e,r,t,i,u,o){n=n|0;e=K(e);r=K(r);t=t|0;i=i|0;u=K(u);o=K(o);var a=de,f=de,l=de,s=de;l=K(oi(n,2,u));a=K(oi(n,0,u));s=K(Tt(n,2,u));f=K(Tt(n,0,u));e=K(e-s);c[n+908>>2]=K(di(n,2,(t|2|0)==2?l:e,u,u));r=K(r-f);c[n+912>>2]=K(di(n,0,(i|2|0)==2?a:r,o,u));return}function ri(n,e,r,t,i,u,o){n=n|0;e=K(e);r=K(r);t=t|0;i=i|0;u=K(u);o=K(o);var a=0,f=de,l=de;a=(t|0)==2;if((!(e<=K(0.0)&a)?!(r<=K(0.0)&(i|0)==2):0)?!((t|0)==1&(i|0)==1):0)n=0;else{f=K(Tt(n,0,u));l=K(Tt(n,2,u));a=e<K(0.0)&a|(ke(e)|0);e=K(e-l);c[n+908>>2]=K(di(n,2,a?K(0.0):e,u,u));e=K(r-f);a=r<K(0.0)&(i|0)==2|(ke(r)|0);c[n+912>>2]=K(di(n,0,a?K(0.0):e,o,u));n=1}return n|0}function ti(n,e){n=n|0;e=e|0;if(Si(n)|0)n=Xt(2,e)|0;else n=0;return n|0}function ii(n,e,r){n=n|0;e=e|0;r=K(r);r=K(Qt(n,e,r));return K(r+K(Jt(n,e)))}function ui(n,e,r){n=n|0;e=e|0;r=K(r);r=K($t(n,e,r));return K(r+K(Zt(n,e)))}function oi(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;t=K(ii(n,e,r));return K(t+K(ui(n,e,r)))}function ai(n){n=n|0;if(!(u[n+24>>2]|0)){if(K(fi(n))!=K(0.0))n=1;else n=K(ci(n))!=K(0.0)}else n=0;return n|0}function fi(n){n=n|0;var e=de;if(u[n+944>>2]|0){e=K(c[n+44>>2]);if(ke(e)|0){e=K(c[n+40>>2]);n=e>K(0.0)&((ke(e)|0)^1);return K(n?e:K(0.0))}}else e=K(0.0);return K(e)}function ci(n){n=n|0;var e=de,r=0,i=de;do{if(u[n+944>>2]|0){e=K(c[n+48>>2]);if(ke(e)|0){r=t[(u[n+976>>2]|0)+2>>0]|0;if(r<<24>>24==0?(i=K(c[n+40>>2]),i<K(0.0)&((ke(i)|0)^1)):0){e=K(-i);break}e=r<<24>>24?K(1.0):K(0.0)}}else e=K(0.0)}while(0);return K(e)}function li(n){n=n|0;var e=0,r=0;eC(n+400|0,0,540)|0;t[n+985>>0]=1;Ve(n);r=Pe(n)|0;if(r|0){e=n+948|0;n=0;do{li(u[(u[e>>2]|0)+(n<<2)>>2]|0);n=n+1|0}while((n|0)!=(r|0))}return}function si(n,e,r,t,i,o,a,f,l,s){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);o=K(o);a=K(a);f=f|0;l=l|0;s=s|0;var d=0,_=de,p=0,m=0,b=de,h=de,y=0,w=de,M=0,g=de,T=0,A=0,S=0,E=0,C=0,L=0,R=0,P=0,B=0,O=0;B=v;v=v+16|0;S=B+12|0;E=B+8|0;C=B+4|0;L=B;P=Xt(u[n+4>>2]|0,l)|0;T=zt(P)|0;_=K(Ot(Ei(e)|0,T?o:a));A=Bt(e,2,o)|0;R=Bt(e,0,a)|0;do{if(!(ke(_)|0)?!(ke(T?r:i)|0):0){d=e+504|0;if(!(ke(K(c[d>>2]))|0)){if(!(Ci(u[e+976>>2]|0,0)|0))break;if((u[e+500>>2]|0)==(u[2278]|0))break}c[d>>2]=K(OE(_,K(oi(e,P,o))))}else p=7}while(0);do{if((p|0)==7){M=T^1;if(!(M|A^1)){a=K(Ot(u[e+992>>2]|0,o));c[e+504>>2]=K(OE(a,K(oi(e,2,o))));break}if(!(T|R^1)){a=K(Ot(u[e+996>>2]|0,a));c[e+504>>2]=K(OE(a,K(oi(e,0,o))));break}c[S>>2]=K(k);c[E>>2]=K(k);u[C>>2]=0;u[L>>2]=0;w=K(Tt(e,2,o));g=K(Tt(e,0,o));if(A){b=K(w+K(Ot(u[e+992>>2]|0,o)));c[S>>2]=b;u[C>>2]=1;m=1}else{m=0;b=K(k)}if(R){_=K(g+K(Ot(u[e+996>>2]|0,a)));c[E>>2]=_;u[L>>2]=1;d=1}else{d=0;_=K(k)}p=u[n+32>>2]|0;if(!(T&(p|0)==2)){if(ke(b)|0?!(ke(r)|0):0){c[S>>2]=r;u[C>>2]=2;m=2;b=r}}else p=2;if((!((p|0)==2&M)?ke(_)|0:0)?!(ke(i)|0):0){c[E>>2]=i;u[L>>2]=2;d=2;_=i}h=K(c[e+396>>2]);y=ke(h)|0;do{if(!y){if((m|0)==1&M){c[E>>2]=K(K(b-w)/h);u[L>>2]=1;d=1;p=1;break}if(T&(d|0)==1){c[S>>2]=K(h*K(_-g));u[C>>2]=1;d=1;p=1}else p=m}else p=m}while(0);O=ke(r)|0;m=(_i(n,e)|0)!=4;if(!(T|A|((t|0)!=1|O)|(m|(p|0)==1))?(c[S>>2]=r,u[C>>2]=1,!y):0){c[E>>2]=K(K(r-w)/h);u[L>>2]=1;d=1}if(!(R|M|((f|0)!=1|(ke(i)|0))|(m|(d|0)==1))?(c[E>>2]=i,u[L>>2]=1,!y):0){c[S>>2]=K(h*K(i-g));u[C>>2]=1}mi(e,2,o,o,C,S);mi(e,0,a,o,L,E);r=K(c[S>>2]);i=K(c[E>>2]);gt(e,r,i,l,u[C>>2]|0,u[L>>2]|0,o,a,0,3565,s)|0;a=K(c[e+908+(u[976+(P<<2)>>2]<<2)>>2]);c[e+504>>2]=K(OE(a,K(oi(e,P,o))))}}while(0);u[e+500>>2]=u[2278];v=B;return}function di(n,e,r,t,i){n=n|0;e=e|0;r=K(r);t=K(t);i=K(i);t=K(gi(n,e,r,t));return K(OE(t,K(oi(n,e,i))))}function _i(n,e){n=n|0;e=e|0;e=e+20|0;e=u[((u[e>>2]|0)==0?n+16|0:e)>>2]|0;if((e|0)==5?Si(u[n+4>>2]|0)|0:0)e=1;return e|0}function vi(n,e){n=n|0;e=e|0;if(zt(e)|0?(u[n+96>>2]|0)!=0:0)e=4;else e=u[1040+(e<<2)>>2]|0;return n+60+(e<<3)|0}function pi(n,e){n=n|0;e=e|0;if(zt(e)|0?(u[n+104>>2]|0)!=0:0)e=5;else e=u[1e3+(e<<2)>>2]|0;return n+60+(e<<3)|0}function mi(n,e,r,t,i,o){n=n|0;e=e|0;r=K(r);t=K(t);i=i|0;o=o|0;r=K(Ot(n+380+(u[976+(e<<2)>>2]<<3)|0,r));r=K(r+K(Tt(n,e,t)));switch(u[i>>2]|0){case 2:case 1:{i=ke(r)|0;t=K(c[o>>2]);c[o>>2]=i|t<r?t:r;break}case 0:{if(!(ke(r)|0)){u[i>>2]=2;c[o>>2]=r}break}default:{}}return}function bi(n,e){n=n|0;e=e|0;n=n+132|0;if(zt(e)|0?(u[(ge(n,4,948)|0)+4>>2]|0)!=0:0)n=1;else n=(u[(ge(n,u[1040+(e<<2)>>2]|0,948)|0)+4>>2]|0)!=0;return n|0}function hi(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0;n=n+132|0;if(zt(e)|0?(t=ge(n,4,948)|0,(u[t+4>>2]|0)!=0):0)i=4;else{t=ge(n,u[1040+(e<<2)>>2]|0,948)|0;if(!(u[t+4>>2]|0))r=K(0.0);else i=4}if((i|0)==4)r=K(Ot(t,r));return K(r)}function yi(n,e,r){n=n|0;e=e|0;r=K(r);var t=de;t=K(c[n+908+(u[976+(e<<2)>>2]<<2)>>2]);t=K(t+K(jt(n,e,r)));return K(t+K(qt(n,e,r)))}function wi(n){n=n|0;var e=0,r=0,t=0;n:do{if(!(Si(u[n+4>>2]|0)|0)){if((u[n+16>>2]|0)!=5){r=Pe(n)|0;if(!r)e=0;else{e=0;while(1){t=Be(n,e)|0;if((u[t+24>>2]|0)==0?(u[t+20>>2]|0)==5:0){e=1;break n}e=e+1|0;if(e>>>0>=r>>>0){e=0;break}}}}else e=1}else e=0}while(0);return e|0}function Mi(n,e){n=n|0;e=e|0;var r=de;r=K(c[n+908+(u[976+(e<<2)>>2]<<2)>>2]);return r>=K(0.0)&((ke(r)|0)^1)|0}function ki(n){n=n|0;var e=de,r=0,t=0,i=0,o=0,a=0,f=0,l=de;r=u[n+968>>2]|0;if(!r){o=Pe(n)|0;do{if(o|0){r=0;i=0;while(1){t=Be(n,i)|0;if(u[t+940>>2]|0){a=8;break}if((u[t+24>>2]|0)!=1){f=(_i(n,t)|0)==5;if(f){r=t;break}else r=(r|0)==0?t:r}i=i+1|0;if(i>>>0>=o>>>0){a=8;break}}if((a|0)==8)if(!r)break;e=K(ki(r));return K(e+K(c[r+404>>2]))}}while(0);e=K(c[n+912>>2])}else{l=K(c[n+908>>2]);e=K(c[n+912>>2]);e=K(_L[r&0](n,l,e));Fe(n,(ke(e)|0)^1,3573)}return K(e)}function gi(n,e,r,t){n=n|0;e=e|0;r=K(r);t=K(t);var i=de,u=0;if(!(Si(e)|0)){if(zt(e)|0){e=0;u=3}else{t=K(k);i=K(k)}}else{e=1;u=3}if((u|0)==3){i=K(Ot(n+364+(e<<3)|0,t));t=K(Ot(n+380+(e<<3)|0,t))}u=t<r&(t>=K(0.0)&((ke(t)|0)^1));r=u?t:r;u=i>=K(0.0)&((ke(i)|0)^1)&r<i;return K(u?i:r)}function Ti(n,e,r,t,i,o,a){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);o=o|0;a=a|0;var f=de,l=de,s=0,d=0,_=de,v=de,p=de,m=0,b=0,h=0,y=0,w=de,M=0;h=Xt(u[n+4>>2]|0,o)|0;m=ti(h,o)|0;b=zt(h)|0;_=K(Tt(e,2,r));v=K(Tt(e,0,r));if(!(Bt(e,2,r)|0)){if(bi(e,2)|0?Li(e,2)|0:0){f=K(c[n+908>>2]);l=K(Jt(n,2));l=K(f-K(l+K(Zt(n,2))));f=K(hi(e,2,r));f=K(di(e,2,K(l-K(f+K(Ri(e,2,r)))),r,r))}else f=K(k)}else f=K(_+K(Ot(u[e+992>>2]|0,r)));if(!(Bt(e,0,i)|0)){if(bi(e,0)|0?Li(e,0)|0:0){l=K(c[n+912>>2]);w=K(Jt(n,0));w=K(l-K(w+K(Zt(n,0))));l=K(hi(e,0,i));l=K(di(e,0,K(w-K(l+K(Ri(e,0,i)))),i,r))}else l=K(k)}else l=K(v+K(Ot(u[e+996>>2]|0,i)));s=ke(f)|0;d=ke(l)|0;do{if(s^d?(p=K(c[e+396>>2]),!(ke(p)|0)):0)if(s){f=K(_+K(K(l-v)*p));break}else{w=K(v+K(K(f-_)/p));l=d?w:l;break}}while(0);d=ke(f)|0;s=ke(l)|0;if(d|s){M=(d^1)&1;t=r>K(0.0)&((t|0)!=0&d);f=b?f:t?r:f;gt(e,f,l,o,b?M:t?2:M,d&(s^1)&1,f,l,0,3623,a)|0;f=K(c[e+908>>2]);f=K(f+K(Tt(e,2,r)));l=K(c[e+912>>2]);l=K(l+K(Tt(e,0,r)))}gt(e,f,l,o,1,1,f,l,1,3635,a)|0;if(Li(e,h)|0?!(bi(e,h)|0):0){M=u[976+(h<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));w=K(w-K(Zt(n,h)));w=K(w-K(qt(e,h,r)));w=K(w-K(Ri(e,h,b?r:i)));c[e+400+(u[1040+(h<<2)>>2]<<2)>>2]=w}else y=21;do{if((y|0)==21){if(!(bi(e,h)|0)?(u[n+8>>2]|0)==1:0){M=u[976+(h<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(K(w-K(c[e+908+(M<<2)>>2]))*K(.5));c[e+400+(u[1040+(h<<2)>>2]<<2)>>2]=w;break}if(!(bi(e,h)|0)?(u[n+8>>2]|0)==2:0){M=u[976+(h<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));c[e+400+(u[1040+(h<<2)>>2]<<2)>>2]=w}}}while(0);if(Li(e,m)|0?!(bi(e,m)|0):0){M=u[976+(m<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));w=K(w-K(Zt(n,m)));w=K(w-K(qt(e,m,r)));w=K(w-K(Ri(e,m,b?i:r)));c[e+400+(u[1040+(m<<2)>>2]<<2)>>2]=w}else y=30;do{if((y|0)==30?!(bi(e,m)|0):0){if((_i(n,e)|0)==2){M=u[976+(m<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(K(w-K(c[e+908+(M<<2)>>2]))*K(.5));c[e+400+(u[1040+(m<<2)>>2]<<2)>>2]=w;break}M=(_i(n,e)|0)==3;if(M^(u[n+28>>2]|0)==2){M=u[976+(m<<2)>>2]|0;w=K(c[n+908+(M<<2)>>2]);w=K(w-K(c[e+908+(M<<2)>>2]));c[e+400+(u[1040+(m<<2)>>2]<<2)>>2]=w}}}while(0);return}function Ai(n,e,r){n=n|0;e=e|0;r=r|0;var t=de,i=0;i=u[976+(r<<2)>>2]|0;t=K(c[e+908+(i<<2)>>2]);t=K(K(c[n+908+(i<<2)>>2])-t);t=K(t-K(c[e+400+(u[1040+(r<<2)>>2]<<2)>>2]));c[e+400+(u[1e3+(r<<2)>>2]<<2)>>2]=t;return}function Si(n){n=n|0;return(n|1|0)==1|0}function Ei(n){n=n|0;var e=de;switch(u[n+56>>2]|0){case 0:case 3:{e=K(c[n+40>>2]);if(e>K(0.0)&((ke(e)|0)^1))n=t[(u[n+976>>2]|0)+2>>0]|0?1056:992;else n=1056;break}default:n=n+52|0}return n|0}function Ci(n,e){n=n|0;e=e|0;return(t[n+e>>0]|0)!=0|0}function Li(n,e){n=n|0;e=e|0;n=n+132|0;if(zt(e)|0?(u[(ge(n,5,948)|0)+4>>2]|0)!=0:0)n=1;else n=(u[(ge(n,u[1e3+(e<<2)>>2]|0,948)|0)+4>>2]|0)!=0;return n|0}function Ri(n,e,r){n=n|0;e=e|0;r=K(r);var t=0,i=0;n=n+132|0;if(zt(e)|0?(t=ge(n,5,948)|0,(u[t+4>>2]|0)!=0):0)i=4;else{t=ge(n,u[1e3+(e<<2)>>2]|0,948)|0;if(!(u[t+4>>2]|0))r=K(0.0);else i=4}if((i|0)==4)r=K(Ot(t,r));return K(r)}function Pi(n,e,r){n=n|0;e=e|0;r=K(r);if(bi(n,e)|0)r=K(hi(n,e,r));else r=K(-K(Ri(n,e,r)));return K(r)}function Bi(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function Oi(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>1073741823)Xn();else{i=GE(e<<2)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<2)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<2);return}function Ni(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>2)<<2)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Ii(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-4-e|0)>>>2)<<2);n=u[n>>2]|0;if(n|0)XE(n);return}function Fi(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;a=n+4|0;f=u[a>>2]|0;i=f-t|0;o=i>>2;n=e+(o<<2)|0;if(n>>>0<r>>>0){t=f;do{u[t>>2]=u[n>>2];n=n+4|0;t=(u[a>>2]|0)+4|0;u[a>>2]=t}while(n>>>0<r>>>0)}if(o|0)cC(f+(0-o<<2)|0,e|0,i|0)|0;return}function xi(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0;f=e+4|0;c=u[f>>2]|0;i=u[n>>2]|0;a=r;o=a-i|0;t=c+(0-(o>>2)<<2)|0;u[f>>2]=t;if((o|0)>0)iC(t|0,i|0,o|0)|0;i=n+4|0;o=e+8|0;t=(u[i>>2]|0)-a|0;if((t|0)>0){iC(u[o>>2]|0,r|0,t|0)|0;u[o>>2]=(u[o>>2]|0)+(t>>>2<<2)}a=u[n>>2]|0;u[n>>2]=u[f>>2];u[f>>2]=a;a=u[i>>2]|0;u[i>>2]=u[o>>2];u[o>>2]=a;a=n+8|0;r=e+12|0;n=u[a>>2]|0;u[a>>2]=u[r>>2];u[r>>2]=n;u[e>>2]=u[f>>2];return c|0}function Ui(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;a=u[e>>2]|0;o=u[r>>2]|0;if((a|0)!=(o|0)){i=n+8|0;r=((o+-4-a|0)>>>2)+1|0;n=a;t=u[i>>2]|0;do{u[t>>2]=u[n>>2];t=(u[i>>2]|0)+4|0;u[i>>2]=t;n=n+4|0}while((n|0)!=(o|0));u[e>>2]=a+(r<<2)}return}function Hi(){we();return}function Di(){var n=0;n=GE(4)|0;Wi(n);return n|0}function Wi(n){n=n|0;u[n>>2]=Ue()|0;return}function Yi(n){n=n|0;if(n|0){Vi(n);XE(n)}return}function Vi(n){n=n|0;De(u[n>>2]|0);return}function ji(n,e,r){n=n|0;e=e|0;r=r|0;Ht(u[n>>2]|0,e,r);return}function qi(n,e){n=n|0;e=K(e);Lt(u[n>>2]|0,e);return}function zi(n,e){n=n|0;e=e|0;return Ci(u[n>>2]|0,e)|0}function Gi(){var n=0;n=GE(8)|0;Ki(n,0);return n|0}function Ki(n,e){n=n|0;e=e|0;if(!e)e=Se()|0;else e=Te(u[e>>2]|0)|0;u[n>>2]=e;u[n+4>>2]=0;$e(e,n);return}function Xi(n){n=n|0;var e=0;e=GE(8)|0;Ki(e,n);return e|0}function Ji(n){n=n|0;if(n|0){Zi(n);XE(n)}return}function Zi(n){n=n|0;var e=0;Le(u[n>>2]|0);e=n+4|0;n=u[e>>2]|0;u[e>>2]=0;if(n|0){Qi(n);XE(n)}return}function Qi(n){n=n|0;$i(n);return}function $i(n){n=n|0;n=u[n>>2]|0;if(n|0)ie(n|0);return}function nu(n){n=n|0;return nr(n)|0}function eu(n){n=n|0;var e=0,r=0;r=n+4|0;e=u[r>>2]|0;u[r>>2]=0;if(e|0){Qi(e);XE(e)}Ie(u[n>>2]|0);return}function ru(n,e){n=n|0;e=e|0;Je(u[n>>2]|0,u[e>>2]|0);return}function tu(n,e){n=n|0;e=e|0;sr(u[n>>2]|0,e);return}function iu(n,e,r){n=n|0;e=e|0;r=+r;Ar(u[n>>2]|0,e,K(r));return}function uu(n,e,r){n=n|0;e=e|0;r=+r;Sr(u[n>>2]|0,e,K(r));return}function ou(n,e){n=n|0;e=e|0;ur(u[n>>2]|0,e);return}function au(n,e){n=n|0;e=e|0;ar(u[n>>2]|0,e);return}function fu(n,e){n=n|0;e=e|0;cr(u[n>>2]|0,e);return}function cu(n,e){n=n|0;e=e|0;er(u[n>>2]|0,e);return}function lu(n,e){n=n|0;e=e|0;_r(u[n>>2]|0,e);return}function su(n,e){n=n|0;e=e|0;tr(u[n>>2]|0,e);return}function du(n,e,r){n=n|0;e=e|0;r=+r;Cr(u[n>>2]|0,e,K(r));return}function _u(n,e,r){n=n|0;e=e|0;r=+r;Lr(u[n>>2]|0,e,K(r));return}function vu(n,e){n=n|0;e=e|0;Pr(u[n>>2]|0,e);return}function pu(n,e){n=n|0;e=e|0;pr(u[n>>2]|0,e);return}function mu(n,e){n=n|0;e=e|0;br(u[n>>2]|0,e);return}function bu(n,e){n=n|0;e=+e;yr(u[n>>2]|0,K(e));return}function hu(n,e){n=n|0;e=+e;kr(u[n>>2]|0,K(e));return}function yu(n,e){n=n|0;e=+e;gr(u[n>>2]|0,K(e));return}function wu(n,e){n=n|0;e=+e;wr(u[n>>2]|0,K(e));return}function Mu(n,e){n=n|0;e=+e;Mr(u[n>>2]|0,K(e));return}function ku(n,e){n=n|0;e=+e;xr(u[n>>2]|0,K(e));return}function gu(n,e){n=n|0;e=+e;Ur(u[n>>2]|0,K(e));return}function Tu(n){n=n|0;Hr(u[n>>2]|0);return}function Au(n,e){n=n|0;e=+e;Wr(u[n>>2]|0,K(e));return}function Su(n,e){n=n|0;e=+e;Yr(u[n>>2]|0,K(e));return}function Eu(n){n=n|0;Vr(u[n>>2]|0);return}function Cu(n,e){n=n|0;e=+e;qr(u[n>>2]|0,K(e));return}function Lu(n,e){n=n|0;e=+e;zr(u[n>>2]|0,K(e));return}function Ru(n,e){n=n|0;e=+e;Kr(u[n>>2]|0,K(e));return}function Pu(n,e){n=n|0;e=+e;Xr(u[n>>2]|0,K(e));return}function Bu(n,e){n=n|0;e=+e;Zr(u[n>>2]|0,K(e));return}function Ou(n,e){n=n|0;e=+e;Qr(u[n>>2]|0,K(e));return}function Nu(n,e){n=n|0;e=+e;nt(u[n>>2]|0,K(e));return}function Iu(n,e){n=n|0;e=+e;et(u[n>>2]|0,K(e));return}function Fu(n,e){n=n|0;e=+e;tt(u[n>>2]|0,K(e));return}function xu(n,e,r){n=n|0;e=e|0;r=+r;Ir(u[n>>2]|0,e,K(r));return}function Uu(n,e,r){n=n|0;e=e|0;r=+r;Br(u[n>>2]|0,e,K(r));return}function Hu(n,e,r){n=n|0;e=e|0;r=+r;Or(u[n>>2]|0,e,K(r));return}function Du(n){n=n|0;return dr(u[n>>2]|0)|0}function Wu(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;Er(i,u[e>>2]|0,r);Yu(n,i);v=t;return}function Yu(n,e){n=n|0;e=e|0;Vu(n,u[e+4>>2]|0,+K(c[e>>2]));return}function Vu(n,e,r){n=n|0;e=e|0;r=+r;u[n>>2]=e;l[n+8>>3]=r;return}function ju(n){n=n|0;return or(u[n>>2]|0)|0}function qu(n){n=n|0;return fr(u[n>>2]|0)|0}function zu(n){n=n|0;return lr(u[n>>2]|0)|0}function Gu(n){n=n|0;return rr(u[n>>2]|0)|0}function Ku(n){n=n|0;return vr(u[n>>2]|0)|0}function Xu(n){n=n|0;return ir(u[n>>2]|0)|0}function Ju(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;Rr(i,u[e>>2]|0,r);Yu(n,i);v=t;return}function Zu(n){n=n|0;return mr(u[n>>2]|0)|0}function Qu(n){n=n|0;return hr(u[n>>2]|0)|0}function $u(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Tr(t,u[e>>2]|0);Yu(n,t);v=r;return}function no(n){n=n|0;return+ +K(Ze(u[n>>2]|0))}function eo(n){n=n|0;return+ +K(Qe(u[n>>2]|0))}function ro(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Dr(t,u[e>>2]|0);Yu(n,t);v=r;return}function to(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;jr(t,u[e>>2]|0);Yu(n,t);v=r;return}function io(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Gr(t,u[e>>2]|0);Yu(n,t);v=r;return}function uo(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;Jr(t,u[e>>2]|0);Yu(n,t);v=r;return}function oo(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;$r(t,u[e>>2]|0);Yu(n,t);v=r;return}function ao(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;rt(t,u[e>>2]|0);Yu(n,t);v=r;return}function fo(n){n=n|0;return+ +K(it(u[n>>2]|0))}function co(n,e){n=n|0;e=e|0;return+ +K(Fr(u[n>>2]|0,e))}function lo(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;Nr(i,u[e>>2]|0,r);Yu(n,i);v=t;return}function so(n,e,r){n=n|0;e=e|0;r=r|0;Ye(u[n>>2]|0,u[e>>2]|0,r);return}function _o(n,e){n=n|0;e=e|0;Ne(u[n>>2]|0,u[e>>2]|0);return}function vo(n){n=n|0;return Pe(u[n>>2]|0)|0}function po(n){n=n|0;n=Ge(u[n>>2]|0)|0;if(!n)n=0;else n=nu(n)|0;return n|0}function mo(n,e){n=n|0;e=e|0;n=Be(u[n>>2]|0,e)|0;if(!n)n=0;else n=nu(n)|0;return n|0}function bo(n,e){n=n|0;e=e|0;var r=0,t=0;t=GE(4)|0;ho(t,e);r=n+4|0;e=u[r>>2]|0;u[r>>2]=t;if(e|0){Qi(e);XE(e)}We(u[n>>2]|0,1);return}function ho(n,e){n=n|0;e=e|0;Uo(n,e);return}function yo(n,e,r,t,i,u){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);u=u|0;var o=0,a=0;o=v;v=v+16|0;a=o;wo(a,nr(e)|0,+r,t,+i,u);c[n>>2]=K(+l[a>>3]);c[n+4>>2]=K(+l[a+8>>3]);v=o;return}function wo(n,e,r,t,i,o){n=n|0;e=e|0;r=+r;t=t|0;i=+i;o=o|0;var a=0,f=0,c=0,s=0,d=0;a=v;v=v+32|0;d=a+8|0;s=a+20|0;c=a;f=a+16|0;l[d>>3]=r;u[s>>2]=t;l[c>>3]=i;u[f>>2]=o;Mo(n,u[e+4>>2]|0,d,s,c,f);v=a;return}function Mo(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0;a=v;v=v+16|0;f=a;gS(f);e=ko(e)|0;go(n,e,+l[r>>3],u[t>>2]|0,+l[i>>3],u[o>>2]|0);AS(f);v=a;return}function ko(n){n=n|0;return u[n>>2]|0}function go(n,e,r,t,i,u){n=n|0;e=e|0;r=+r;t=t|0;i=+i;u=u|0;var o=0;o=Ao(To()|0)|0;r=+So(r);t=Eo(t)|0;i=+So(i);Co(n,oe(0,o|0,e|0,+r,t|0,+i,Eo(u)|0)|0);return}function To(){var n=0;if(!(t[7608]|0)){Io(9120);n=7608;u[n>>2]=1;u[n+4>>2]=0}return 9120}function Ao(n){n=n|0;return u[n+8>>2]|0}function So(n){n=+n;return+ +No(n)}function Eo(n){n=n|0;return Oo(n)|0}function Co(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+32|0;r=i;t=e;if(!(t&1)){u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=u[e+8>>2];u[n+12>>2]=u[e+12>>2]}else{Lo(r,0);Hn(t|0,r|0)|0;Ro(n,r);Po(r)}v=i;return}function Lo(n,e){n=n|0;e=e|0;Bo(n,e);u[n+8>>2]=0;t[n+24>>0]=0;return}function Ro(n,e){n=n|0;e=e|0;e=e+8|0;u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=u[e+8>>2];u[n+12>>2]=u[e+12>>2];return}function Po(n){n=n|0;t[n+24>>0]=0;return}function Bo(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function Oo(n){n=n|0;return n|0}function No(n){n=+n;return+n}function Io(n){n=n|0;xo(n,Fo()|0,4);return}function Fo(){return 1064}function xo(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;u[n+8>>2]=re(e|0,r+1|0)|0;return}function Uo(n,e){n=n|0;e=e|0;e=u[e>>2]|0;u[n>>2]=e;Rn(e|0);return}function Ho(n){n=n|0;var e=0,r=0;r=n+4|0;e=u[r>>2]|0;u[r>>2]=0;if(e|0){Qi(e);XE(e)}We(u[n>>2]|0,0);return}function Do(n){n=n|0;Ke(u[n>>2]|0);return}function Wo(n){n=n|0;return Xe(u[n>>2]|0)|0}function Yo(n,e,r,t){n=n|0;e=+e;r=+r;t=t|0;Rt(u[n>>2]|0,K(e),K(r),t);return}function Vo(n){n=n|0;return+ +K(ut(u[n>>2]|0))}function jo(n){n=n|0;return+ +K(at(u[n>>2]|0))}function qo(n){n=n|0;return+ +K(ot(u[n>>2]|0))}function zo(n){n=n|0;return+ +K(ft(u[n>>2]|0))}function Go(n){n=n|0;return+ +K(ct(u[n>>2]|0))}function Ko(n){n=n|0;return+ +K(lt(u[n>>2]|0))}function Xo(n,e){n=n|0;e=e|0;l[n>>3]=+K(ut(u[e>>2]|0));l[n+8>>3]=+K(at(u[e>>2]|0));l[n+16>>3]=+K(ot(u[e>>2]|0));l[n+24>>3]=+K(ft(u[e>>2]|0));l[n+32>>3]=+K(ct(u[e>>2]|0));l[n+40>>3]=+K(lt(u[e>>2]|0));return}function Jo(n,e){n=n|0;e=e|0;return+ +K(st(u[n>>2]|0,e))}function Zo(n,e){n=n|0;e=e|0;return+ +K(dt(u[n>>2]|0,e))}function Qo(n,e){n=n|0;e=e|0;return+ +K(_t(u[n>>2]|0,e))}function $o(){return xe()|0}function na(){ea();ra();ta();ia();ua();oa();return}function ea(){Ww(11713,4938,1);return}function ra(){ew(10448);return}function ta(){Iy(10408);return}function ia(){Qh(10324);return}function ua(){qm(10096);return}function oa(){aa(9132);return}function aa(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0,M=0,k=0,g=0,T=0,A=0,S=0,E=0,C=0,L=0,R=0,P=0,B=0,O=0,N=0,I=0,F=0,x=0,U=0,H=0,D=0,W=0,Y=0,V=0,j=0,q=0,z=0,G=0,K=0,X=0,J=0,Z=0,Q=0,$=0,nn=0,en=0,rn=0,tn=0,un=0,on=0,an=0,fn=0,cn=0,ln=0,sn=0,dn=0,_n=0,vn=0,pn=0,mn=0,bn=0,hn=0,yn=0,wn=0,Mn=0,kn=0,gn=0,Tn=0,An=0,Sn=0,En=0,Cn=0,Ln=0,Rn=0,Pn=0,Bn=0,On=0;e=v;v=v+672|0;r=e+656|0;On=e+648|0;Bn=e+640|0;Pn=e+632|0;Rn=e+624|0;Ln=e+616|0;Cn=e+608|0;En=e+600|0;Sn=e+592|0;An=e+584|0;Tn=e+576|0;gn=e+568|0;kn=e+560|0;Mn=e+552|0;wn=e+544|0;yn=e+536|0;hn=e+528|0;bn=e+520|0;mn=e+512|0;pn=e+504|0;vn=e+496|0;_n=e+488|0;dn=e+480|0;sn=e+472|0;ln=e+464|0;cn=e+456|0;fn=e+448|0;an=e+440|0;on=e+432|0;un=e+424|0;tn=e+416|0;rn=e+408|0;en=e+400|0;nn=e+392|0;$=e+384|0;Q=e+376|0;Z=e+368|0;J=e+360|0;X=e+352|0;K=e+344|0;G=e+336|0;z=e+328|0;q=e+320|0;j=e+312|0;V=e+304|0;Y=e+296|0;W=e+288|0;D=e+280|0;H=e+272|0;U=e+264|0;x=e+256|0;F=e+248|0;I=e+240|0;N=e+232|0;O=e+224|0;B=e+216|0;P=e+208|0;R=e+200|0;L=e+192|0;C=e+184|0;E=e+176|0;S=e+168|0;A=e+160|0;T=e+152|0;g=e+144|0;k=e+136|0;M=e+128|0;w=e+120|0;y=e+112|0;h=e+104|0;b=e+96|0;m=e+88|0;p=e+80|0;_=e+72|0;d=e+64|0;s=e+56|0;l=e+48|0;c=e+40|0;f=e+32|0;a=e+24|0;o=e+16|0;i=e+8|0;t=e;fa(n,3646);ca(n,3651,2)|0;la(n,3665,2)|0;sa(n,3682,18)|0;u[On>>2]=19;u[On+4>>2]=0;u[r>>2]=u[On>>2];u[r+4>>2]=u[On+4>>2];da(n,3690,r)|0;u[Bn>>2]=1;u[Bn+4>>2]=0;u[r>>2]=u[Bn>>2];u[r+4>>2]=u[Bn+4>>2];_a(n,3696,r)|0;u[Pn>>2]=2;u[Pn+4>>2]=0;u[r>>2]=u[Pn>>2];u[r+4>>2]=u[Pn+4>>2];va(n,3706,r)|0;u[Rn>>2]=1;u[Rn+4>>2]=0;u[r>>2]=u[Rn>>2];u[r+4>>2]=u[Rn+4>>2];pa(n,3722,r)|0;u[Ln>>2]=2;u[Ln+4>>2]=0;u[r>>2]=u[Ln>>2];u[r+4>>2]=u[Ln+4>>2];pa(n,3734,r)|0;u[Cn>>2]=3;u[Cn+4>>2]=0;u[r>>2]=u[Cn>>2];u[r+4>>2]=u[Cn+4>>2];va(n,3753,r)|0;u[En>>2]=4;u[En+4>>2]=0;u[r>>2]=u[En>>2];u[r+4>>2]=u[En+4>>2];va(n,3769,r)|0;u[Sn>>2]=5;u[Sn+4>>2]=0;u[r>>2]=u[Sn>>2];u[r+4>>2]=u[Sn+4>>2];va(n,3783,r)|0;u[An>>2]=6;u[An+4>>2]=0;u[r>>2]=u[An>>2];u[r+4>>2]=u[An+4>>2];va(n,3796,r)|0;u[Tn>>2]=7;u[Tn+4>>2]=0;u[r>>2]=u[Tn>>2];u[r+4>>2]=u[Tn+4>>2];va(n,3813,r)|0;u[gn>>2]=8;u[gn+4>>2]=0;u[r>>2]=u[gn>>2];u[r+4>>2]=u[gn+4>>2];va(n,3825,r)|0;u[kn>>2]=3;u[kn+4>>2]=0;u[r>>2]=u[kn>>2];u[r+4>>2]=u[kn+4>>2];pa(n,3843,r)|0;u[Mn>>2]=4;u[Mn+4>>2]=0;u[r>>2]=u[Mn>>2];u[r+4>>2]=u[Mn+4>>2];pa(n,3853,r)|0;u[wn>>2]=9;u[wn+4>>2]=0;u[r>>2]=u[wn>>2];u[r+4>>2]=u[wn+4>>2];va(n,3870,r)|0;u[yn>>2]=10;u[yn+4>>2]=0;u[r>>2]=u[yn>>2];u[r+4>>2]=u[yn+4>>2];va(n,3884,r)|0;u[hn>>2]=11;u[hn+4>>2]=0;u[r>>2]=u[hn>>2];u[r+4>>2]=u[hn+4>>2];va(n,3896,r)|0;u[bn>>2]=1;u[bn+4>>2]=0;u[r>>2]=u[bn>>2];u[r+4>>2]=u[bn+4>>2];ma(n,3907,r)|0;u[mn>>2]=2;u[mn+4>>2]=0;u[r>>2]=u[mn>>2];u[r+4>>2]=u[mn+4>>2];ma(n,3915,r)|0;u[pn>>2]=3;u[pn+4>>2]=0;u[r>>2]=u[pn>>2];u[r+4>>2]=u[pn+4>>2];ma(n,3928,r)|0;u[vn>>2]=4;u[vn+4>>2]=0;u[r>>2]=u[vn>>2];u[r+4>>2]=u[vn+4>>2];ma(n,3948,r)|0;u[_n>>2]=5;u[_n+4>>2]=0;u[r>>2]=u[_n>>2];u[r+4>>2]=u[_n+4>>2];ma(n,3960,r)|0;u[dn>>2]=6;u[dn+4>>2]=0;u[r>>2]=u[dn>>2];u[r+4>>2]=u[dn+4>>2];ma(n,3974,r)|0;u[sn>>2]=7;u[sn+4>>2]=0;u[r>>2]=u[sn>>2];u[r+4>>2]=u[sn+4>>2];ma(n,3983,r)|0;u[ln>>2]=20;u[ln+4>>2]=0;u[r>>2]=u[ln>>2];u[r+4>>2]=u[ln+4>>2];da(n,3999,r)|0;u[cn>>2]=8;u[cn+4>>2]=0;u[r>>2]=u[cn>>2];u[r+4>>2]=u[cn+4>>2];ma(n,4012,r)|0;u[fn>>2]=9;u[fn+4>>2]=0;u[r>>2]=u[fn>>2];u[r+4>>2]=u[fn+4>>2];ma(n,4022,r)|0;u[an>>2]=21;u[an+4>>2]=0;u[r>>2]=u[an>>2];u[r+4>>2]=u[an+4>>2];da(n,4039,r)|0;u[on>>2]=10;u[on+4>>2]=0;u[r>>2]=u[on>>2];u[r+4>>2]=u[on+4>>2];ma(n,4053,r)|0;u[un>>2]=11;u[un+4>>2]=0;u[r>>2]=u[un>>2];u[r+4>>2]=u[un+4>>2];ma(n,4065,r)|0;u[tn>>2]=12;u[tn+4>>2]=0;u[r>>2]=u[tn>>2];u[r+4>>2]=u[tn+4>>2];ma(n,4084,r)|0;u[rn>>2]=13;u[rn+4>>2]=0;u[r>>2]=u[rn>>2];u[r+4>>2]=u[rn+4>>2];ma(n,4097,r)|0;u[en>>2]=14;u[en+4>>2]=0;u[r>>2]=u[en>>2];u[r+4>>2]=u[en+4>>2];ma(n,4117,r)|0;u[nn>>2]=15;u[nn+4>>2]=0;u[r>>2]=u[nn>>2];u[r+4>>2]=u[nn+4>>2];ma(n,4129,r)|0;u[$>>2]=16;u[$+4>>2]=0;u[r>>2]=u[$>>2];u[r+4>>2]=u[$+4>>2];ma(n,4148,r)|0;u[Q>>2]=17;u[Q+4>>2]=0;u[r>>2]=u[Q>>2];u[r+4>>2]=u[Q+4>>2];ma(n,4161,r)|0;u[Z>>2]=18;u[Z+4>>2]=0;u[r>>2]=u[Z>>2];u[r+4>>2]=u[Z+4>>2];ma(n,4181,r)|0;u[J>>2]=5;u[J+4>>2]=0;u[r>>2]=u[J>>2];u[r+4>>2]=u[J+4>>2];pa(n,4196,r)|0;u[X>>2]=6;u[X+4>>2]=0;u[r>>2]=u[X>>2];u[r+4>>2]=u[X+4>>2];pa(n,4206,r)|0;u[K>>2]=7;u[K+4>>2]=0;u[r>>2]=u[K>>2];u[r+4>>2]=u[K+4>>2];pa(n,4217,r)|0;u[G>>2]=3;u[G+4>>2]=0;u[r>>2]=u[G>>2];u[r+4>>2]=u[G+4>>2];ba(n,4235,r)|0;u[z>>2]=1;u[z+4>>2]=0;u[r>>2]=u[z>>2];u[r+4>>2]=u[z+4>>2];ha(n,4251,r)|0;u[q>>2]=4;u[q+4>>2]=0;u[r>>2]=u[q>>2];u[r+4>>2]=u[q+4>>2];ba(n,4263,r)|0;u[j>>2]=5;u[j+4>>2]=0;u[r>>2]=u[j>>2];u[r+4>>2]=u[j+4>>2];ba(n,4279,r)|0;u[V>>2]=6;u[V+4>>2]=0;u[r>>2]=u[V>>2];u[r+4>>2]=u[V+4>>2];ba(n,4293,r)|0;u[Y>>2]=7;u[Y+4>>2]=0;u[r>>2]=u[Y>>2];u[r+4>>2]=u[Y+4>>2];ba(n,4306,r)|0;u[W>>2]=8;u[W+4>>2]=0;u[r>>2]=u[W>>2];u[r+4>>2]=u[W+4>>2];ba(n,4323,r)|0;u[D>>2]=9;u[D+4>>2]=0;u[r>>2]=u[D>>2];u[r+4>>2]=u[D+4>>2];ba(n,4335,r)|0;u[H>>2]=2;u[H+4>>2]=0;u[r>>2]=u[H>>2];u[r+4>>2]=u[H+4>>2];ha(n,4353,r)|0;u[U>>2]=12;u[U+4>>2]=0;u[r>>2]=u[U>>2];u[r+4>>2]=u[U+4>>2];ya(n,4363,r)|0;u[x>>2]=1;u[x+4>>2]=0;u[r>>2]=u[x>>2];u[r+4>>2]=u[x+4>>2];wa(n,4376,r)|0;u[F>>2]=2;u[F+4>>2]=0;u[r>>2]=u[F>>2];u[r+4>>2]=u[F+4>>2];wa(n,4388,r)|0;u[I>>2]=13;u[I+4>>2]=0;u[r>>2]=u[I>>2];u[r+4>>2]=u[I+4>>2];ya(n,4402,r)|0;u[N>>2]=14;u[N+4>>2]=0;u[r>>2]=u[N>>2];u[r+4>>2]=u[N+4>>2];ya(n,4411,r)|0;u[O>>2]=15;u[O+4>>2]=0;u[r>>2]=u[O>>2];u[r+4>>2]=u[O+4>>2];ya(n,4421,r)|0;u[B>>2]=16;u[B+4>>2]=0;u[r>>2]=u[B>>2];u[r+4>>2]=u[B+4>>2];ya(n,4433,r)|0;u[P>>2]=17;u[P+4>>2]=0;u[r>>2]=u[P>>2];u[r+4>>2]=u[P+4>>2];ya(n,4446,r)|0;u[R>>2]=18;u[R+4>>2]=0;u[r>>2]=u[R>>2];u[r+4>>2]=u[R+4>>2];ya(n,4458,r)|0;u[L>>2]=3;u[L+4>>2]=0;u[r>>2]=u[L>>2];u[r+4>>2]=u[L+4>>2];wa(n,4471,r)|0;u[C>>2]=1;u[C+4>>2]=0;u[r>>2]=u[C>>2];u[r+4>>2]=u[C+4>>2];Ma(n,4486,r)|0;u[E>>2]=10;u[E+4>>2]=0;u[r>>2]=u[E>>2];u[r+4>>2]=u[E+4>>2];ba(n,4496,r)|0;u[S>>2]=11;u[S+4>>2]=0;u[r>>2]=u[S>>2];u[r+4>>2]=u[S+4>>2];ba(n,4508,r)|0;u[A>>2]=3;u[A+4>>2]=0;u[r>>2]=u[A>>2];u[r+4>>2]=u[A+4>>2];ha(n,4519,r)|0;u[T>>2]=4;u[T+4>>2]=0;u[r>>2]=u[T>>2];u[r+4>>2]=u[T+4>>2];ka(n,4530,r)|0;u[g>>2]=19;u[g+4>>2]=0;u[r>>2]=u[g>>2];u[r+4>>2]=u[g+4>>2];ga(n,4542,r)|0;u[k>>2]=12;u[k+4>>2]=0;u[r>>2]=u[k>>2];u[r+4>>2]=u[k+4>>2];Ta(n,4554,r)|0;u[M>>2]=13;u[M+4>>2]=0;u[r>>2]=u[M>>2];u[r+4>>2]=u[M+4>>2];Aa(n,4568,r)|0;u[w>>2]=2;u[w+4>>2]=0;u[r>>2]=u[w>>2];u[r+4>>2]=u[w+4>>2];Sa(n,4578,r)|0;u[y>>2]=20;u[y+4>>2]=0;u[r>>2]=u[y>>2];u[r+4>>2]=u[y+4>>2];Ea(n,4587,r)|0;u[h>>2]=22;u[h+4>>2]=0;u[r>>2]=u[h>>2];u[r+4>>2]=u[h+4>>2];da(n,4602,r)|0;u[b>>2]=23;u[b+4>>2]=0;u[r>>2]=u[b>>2];u[r+4>>2]=u[b+4>>2];da(n,4619,r)|0;u[m>>2]=14;u[m+4>>2]=0;u[r>>2]=u[m>>2];u[r+4>>2]=u[m+4>>2];Ca(n,4629,r)|0;u[p>>2]=1;u[p+4>>2]=0;u[r>>2]=u[p>>2];u[r+4>>2]=u[p+4>>2];La(n,4637,r)|0;u[_>>2]=4;u[_+4>>2]=0;u[r>>2]=u[_>>2];u[r+4>>2]=u[_+4>>2];wa(n,4653,r)|0;u[d>>2]=5;u[d+4>>2]=0;u[r>>2]=u[d>>2];u[r+4>>2]=u[d+4>>2];wa(n,4669,r)|0;u[s>>2]=6;u[s+4>>2]=0;u[r>>2]=u[s>>2];u[r+4>>2]=u[s+4>>2];wa(n,4686,r)|0;u[l>>2]=7;u[l+4>>2]=0;u[r>>2]=u[l>>2];u[r+4>>2]=u[l+4>>2];wa(n,4701,r)|0;u[c>>2]=8;u[c+4>>2]=0;u[r>>2]=u[c>>2];u[r+4>>2]=u[c+4>>2];wa(n,4719,r)|0;u[f>>2]=9;u[f+4>>2]=0;u[r>>2]=u[f>>2];u[r+4>>2]=u[f+4>>2];wa(n,4736,r)|0;u[a>>2]=21;u[a+4>>2]=0;u[r>>2]=u[a>>2];u[r+4>>2]=u[a+4>>2];Ra(n,4754,r)|0;u[o>>2]=2;u[o+4>>2]=0;u[r>>2]=u[o>>2];u[r+4>>2]=u[o+4>>2];Ma(n,4772,r)|0;u[i>>2]=3;u[i+4>>2]=0;u[r>>2]=u[i>>2];u[r+4>>2]=u[i+4>>2];Ma(n,4790,r)|0;u[t>>2]=4;u[t+4>>2]=0;u[r>>2]=u[t>>2];u[r+4>>2]=u[t+4>>2];Ma(n,4808,r)|0;v=e;return}function fa(n,e){n=n|0;e=e|0;var r=0;r=Nm()|0;u[n>>2]=r;Im(r,e);lM(u[n>>2]|0);return}function ca(n,e,r){n=n|0;e=e|0;r=r|0;bm(n,Ba(e)|0,r,0);return n|0}function la(n,e,r){n=n|0;e=e|0;r=r|0;Jp(n,Ba(e)|0,r,0);return n|0}function sa(n,e,r){n=n|0;e=e|0;r=r|0;Op(n,Ba(e)|0,r,0);return n|0}function da(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];vp(n,e,i);v=t;return n|0}function _a(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];zv(n,e,i);v=t;return n|0}function va(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ev(n,e,i);v=t;return n|0}function pa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];fv(n,e,i);v=t;return n|0}function ma(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];V_(n,e,i);v=t;return n|0}function ba(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];T_(n,e,i);v=t;return n|0}function ha(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];u_(n,e,i);v=t;return n|0}function ya(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ad(n,e,i);v=t;return n|0}function wa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];od(n,e,i);v=t;return n|0}function Ma(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ws(n,e,i);v=t;return n|0}function ka(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ks(n,e,i);v=t;return n|0}function ga(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ns(n,e,i);v=t;return n|0}function Ta(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Nl(n,e,i);v=t;return n|0}function Aa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];pl(n,e,i);v=t;return n|0}function Sa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];zc(n,e,i);v=t;return n|0}function Ea(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];kc(n,e,i);v=t;return n|0}function Ca(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];rc(n,e,i);v=t;return n|0}function La(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Pf(n,e,i);v=t;return n|0}function Ra(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Pa(n,e,i);v=t;return n|0}function Pa(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Oa(n,r,i,1);v=t;return}function Ba(n){n=n|0;return n|0}function Oa(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Na()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Ia(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Fa(o,t)|0,t);v=i;return}function Na(){var n=0,e=0;if(!(t[7616]|0)){Ka(9136);xn(24,9136,b|0)|0;e=7616;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9136)|0)){n=9136;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Ka(9136)}return 9136}function Ia(n){n=n|0;return 0}function Fa(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Na()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Ya(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Va(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function xa(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0;a=v;v=v+32|0;_=a+24|0;d=a+20|0;c=a+16|0;s=a+12|0;l=a+8|0;f=a+4|0;p=a;u[d>>2]=e;u[c>>2]=r;u[s>>2]=t;u[l>>2]=i;u[f>>2]=o;o=n+28|0;u[p>>2]=u[o>>2];u[_>>2]=u[p>>2];Ua(n+24|0,_,d,s,l,c,f)|0;u[o>>2]=u[u[o>>2]>>2];v=a;return}function Ua(n,e,r,t,i,o,a){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;a=a|0;n=Ha(e)|0;e=GE(24)|0;Da(e+4|0,u[r>>2]|0,u[t>>2]|0,u[i>>2]|0,u[o>>2]|0,u[a>>2]|0);u[e>>2]=u[n>>2];u[n>>2]=e;return e|0}function Ha(n){n=n|0;return u[n>>2]|0}function Da(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;u[n>>2]=e;u[n+4>>2]=r;u[n+8>>2]=t;u[n+12>>2]=i;u[n+16>>2]=o;return}function Wa(n,e){n=n|0;e=e|0;return e|n|0}function Ya(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Va(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=ja(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;qa(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Ya(o,t,r);u[c>>2]=(u[c>>2]|0)+12;za(n,f);Ga(f);v=l;return}}function ja(n){n=n|0;return 357913941}function qa(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function za(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Ga(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Ka(n){n=n|0;Qa(n);return}function Xa(n){n=n|0;Za(n+24|0);return}function Ja(n){n=n|0;return u[n>>2]|0}function Za(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Qa(n){n=n|0;var e=0;e=$a()|0;rf(n,2,3,e,nf()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function $a(){return 9228}function nf(){return 1140}function ef(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=tf(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=uf(e,t)|0;v=r;return e|0}function rf(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;u[n>>2]=e;u[n+4>>2]=r;u[n+8>>2]=t;u[n+12>>2]=i;u[n+16>>2]=o;return}function tf(n){n=n|0;return(u[(Na()|0)+24>>2]|0)+(n*12|0)|0}function uf(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+48|0;t=i;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;pL[r&31](t,n);t=of(t)|0;v=i;return t|0}function of(n){n=n|0;var e=0,r=0,t=0,i=0;i=v;v=v+32|0;e=i+12|0;r=i;t=ff(af()|0)|0;if(!t)n=_f(n)|0;else{cf(e,t);lf(r,e);sf(n,r);n=df(e)|0}v=i;return n|0}function af(){var n=0;if(!(t[7632]|0)){Tf(9184);xn(25,9184,b|0)|0;n=7632;u[n>>2]=1;u[n+4>>2]=0}return 9184}function ff(n){n=n|0;return u[n+36>>2]|0}function cf(n,e){n=n|0;e=e|0;u[n>>2]=e;u[n+4>>2]=n;u[n+8>>2]=0;return}function lf(n,e){n=n|0;e=e|0;u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=0;return}function sf(n,e){n=n|0;e=e|0;hf(e,n,n+8|0,n+16|0,n+24|0,n+32|0,n+40|0)|0;return}function df(n){n=n|0;return u[(u[n+4>>2]|0)+8>>2]|0}function _f(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0;c=v;v=v+16|0;r=c+4|0;t=c;i=Dg(8)|0;o=i;a=GE(48)|0;f=a;e=f+48|0;do{u[f>>2]=u[n>>2];f=f+4|0;n=n+4|0}while((f|0)<(e|0));e=o+4|0;u[e>>2]=a;f=GE(8)|0;a=u[e>>2]|0;u[t>>2]=0;u[r>>2]=u[t>>2];vf(f,a,r);u[i>>2]=f;v=c;return o|0}function vf(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1092;u[r+12>>2]=e;u[n+4>>2]=r;return}function pf(n){n=n|0;WE(n);XE(n);return}function mf(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function bf(n){n=n|0;XE(n);return}function hf(n,e,r,t,i,o,a){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;a=a|0;o=yf(u[n>>2]|0,e,r,t,i,o,a)|0;a=n+4|0;u[(u[a>>2]|0)+8>>2]=o;return u[(u[a>>2]|0)+8>>2]|0}function yf(n,e,r,t,i,u,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;o=o|0;var a=0,f=0;a=v;v=v+16|0;f=a;gS(f);n=ko(n)|0;o=wf(n,+l[e>>3],+l[r>>3],+l[t>>3],+l[i>>3],+l[u>>3],+l[o>>3])|0;AS(f);v=a;return o|0}function wf(n,e,r,t,i,u,o){n=n|0;e=+e;r=+r;t=+t;i=+i;u=+u;o=+o;var a=0;a=Ao(Mf()|0)|0;e=+So(e);r=+So(r);t=+So(t);i=+So(i);u=+So(u);return Cn(0,a|0,n|0,+e,+r,+t,+i,+u,+ +So(o))|0}function Mf(){var n=0;if(!(t[7624]|0)){kf(9172);n=7624;u[n>>2]=1;u[n+4>>2]=0}return 9172}function kf(n){n=n|0;xo(n,gf()|0,6);return}function gf(){return 1112}function Tf(n){n=n|0;Rf(n);return}function Af(n){n=n|0;Sf(n+24|0);Ef(n+16|0);return}function Sf(n){n=n|0;Lf(n);return}function Ef(n){n=n|0;Cf(n);return}function Cf(n){n=n|0;var e=0,r=0;e=u[n>>2]|0;if(e|0)do{r=e;e=u[e>>2]|0;XE(r)}while((e|0)!=0);u[n>>2]=0;return}function Lf(n){n=n|0;var e=0,r=0;e=u[n>>2]|0;if(e|0)do{r=e;e=u[e>>2]|0;XE(r)}while((e|0)!=0);u[n>>2]=0;return}function Rf(n){n=n|0;var e=0;u[n+16>>2]=0;u[n+20>>2]=0;e=n+24|0;u[e>>2]=0;u[n+28>>2]=e;u[n+36>>2]=0;t[n+40>>0]=0;t[n+41>>0]=0;return}function Pf(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Bf(n,r,i,0);v=t;return}function Bf(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Of()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Nf(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,If(o,t)|0,t);v=i;return}function Of(){var n=0,e=0;if(!(t[7640]|0)){Yf(9232);xn(26,9232,b|0)|0;e=7640;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9232)|0)){n=9232;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Yf(9232)}return 9232}function Nf(n){n=n|0;return 0}function If(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Of()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Ff(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{xf(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Ff(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function xf(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Uf(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Hf(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Ff(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Df(n,f);Wf(f);v=l;return}}function Uf(n){n=n|0;return 357913941}function Hf(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Df(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Wf(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Yf(n){n=n|0;qf(n);return}function Vf(n){n=n|0;jf(n+24|0);return}function jf(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function qf(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,zf()|0,3);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function zf(){return 1144}function Gf(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+16|0;a=o+8|0;f=o;c=Kf(n)|0;n=u[c+4>>2]|0;u[f>>2]=u[c>>2];u[f+4>>2]=n;u[a>>2]=u[f>>2];u[a+4>>2]=u[f+4>>2];Xf(e,a,r,t,i);v=o;return}function Kf(n){n=n|0;return(u[(Of()|0)+24>>2]|0)+(n*12|0)|0}function Xf(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;var o=0,a=0,f=0,c=0,l=0;l=v;v=v+16|0;a=l+2|0;f=l+1|0;c=l;o=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)o=u[(u[n>>2]|0)+o>>2]|0;Jf(a,r);r=+Zf(a,r);Jf(f,t);t=+Zf(f,t);Qf(c,i);c=$f(c,i)|0;bL[o&1](n,r,t,c);v=l;return}function Jf(n,e){n=n|0;e=+e;return}function Zf(n,e){n=n|0;e=+e;return+ +ec(e)}function Qf(n,e){n=n|0;e=e|0;return}function $f(n,e){n=n|0;e=e|0;return nc(e)|0}function nc(n){n=n|0;return n|0}function ec(n){n=+n;return+n}function rc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];tc(n,r,i,1);v=t;return}function tc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=ic()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=uc(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,oc(o,t)|0,t);v=i;return}function ic(){var n=0,e=0;if(!(t[7648]|0)){_c(9268);xn(27,9268,b|0)|0;e=7648;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9268)|0)){n=9268;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));_c(9268)}return 9268}function uc(n){n=n|0;return 0}function oc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=ic()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];ac(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{fc(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function ac(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function fc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=cc(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;lc(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];ac(o,t,r);u[c>>2]=(u[c>>2]|0)+12;sc(n,f);dc(f);v=l;return}}function cc(n){n=n|0;return 357913941}function lc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function sc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function dc(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function _c(n){n=n|0;mc(n);return}function vc(n){n=n|0;pc(n+24|0);return}function pc(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function mc(n){n=n|0;var e=0;e=$a()|0;rf(n,2,4,e,bc()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function bc(){return 1160}function hc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=yc(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=wc(e,t)|0;v=r;return e|0}function yc(n){n=n|0;return(u[(ic()|0)+24>>2]|0)+(n*12|0)|0}function wc(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return Mc(mL[r&31](n)|0)|0}function Mc(n){n=n|0;return n&1|0}function kc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];gc(n,r,i,0);v=t;return}function gc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Tc()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Ac(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Sc(o,t)|0,t);v=i;return}function Tc(){var n=0,e=0;if(!(t[7656]|0)){Oc(9304);xn(28,9304,b|0)|0;e=7656;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9304)|0)){n=9304;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Oc(9304)}return 9304}function Ac(n){n=n|0;return 0}function Sc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Tc()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Ec(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Cc(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Ec(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Cc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Lc(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Rc(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Ec(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Pc(n,f);Bc(f);v=l;return}}function Lc(n){n=n|0;return 357913941}function Rc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Pc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Bc(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Oc(n){n=n|0;Fc(n);return}function Nc(n){n=n|0;Ic(n+24|0);return}function Ic(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Fc(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,xc()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function xc(){return 1164}function Uc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=Hc(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Dc(e,i,r);v=t;return}function Hc(n){n=n|0;return(u[(Tc()|0)+24>>2]|0)+(n*12|0)|0}function Dc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Wc(i,r);r=Yc(i,r)|0;pL[t&31](n,r);Vc(i);v=o;return}function Wc(n,e){n=n|0;e=e|0;jc(n,e);return}function Yc(n,e){n=n|0;e=e|0;return n|0}function Vc(n){n=n|0;Qi(n);return}function jc(n,e){n=n|0;e=e|0;qc(n,e);return}function qc(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function zc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Gc(n,r,i,0);v=t;return}function Gc(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Kc()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Xc(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Jc(o,t)|0,t);v=i;return}function Kc(){var n=0,e=0;if(!(t[7664]|0)){tl(9340);xn(29,9340,b|0)|0;e=7664;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9340)|0)){n=9340;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));tl(9340)}return 9340}function Xc(n){n=n|0;return 0}function Jc(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Kc()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Zc(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Qc(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Zc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Qc(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=$c(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;nl(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Zc(o,t,r);u[c>>2]=(u[c>>2]|0)+12;el(n,f);rl(f);v=l;return}}function $c(n){n=n|0;return 357913941}function nl(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function el(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function rl(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function tl(n){n=n|0;ol(n);return}function il(n){n=n|0;ul(n+24|0);return}function ul(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function ol(n){n=n|0;var e=0;e=$a()|0;rf(n,2,4,e,al()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function al(){return 1180}function fl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=cl(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=ll(e,i,r)|0;v=t;return r|0}function cl(n){n=n|0;return(u[(Kc()|0)+24>>2]|0)+(n*12|0)|0}function ll(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;sl(i,r);i=dl(i,r)|0;i=_l(gL[t&15](n,i)|0)|0;v=o;return i|0}function sl(n,e){n=n|0;e=e|0;return}function dl(n,e){n=n|0;e=e|0;return vl(e)|0}function _l(n){n=n|0;return n|0}function vl(n){n=n|0;return n|0}function pl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ml(n,r,i,0);v=t;return}function ml(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=bl()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=hl(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,yl(o,t)|0,t);v=i;return}function bl(){var n=0,e=0;if(!(t[7672]|0)){Sl(9376);xn(30,9376,b|0)|0;e=7672;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9376)|0)){n=9376;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Sl(9376)}return 9376}function hl(n){n=n|0;return 0}function yl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=bl()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];wl(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Ml(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function wl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Ml(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=kl(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;gl(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];wl(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Tl(n,f);Al(f);v=l;return}}function kl(n){n=n|0;return 357913941}function gl(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Tl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Al(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Sl(n){n=n|0;Ll(n);return}function El(n){n=n|0;Cl(n+24|0);return}function Cl(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Ll(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,Rl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Rl(){return 1196}function Pl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Bl(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Ol(e,t)|0;v=r;return e|0}function Bl(n){n=n|0;return(u[(bl()|0)+24>>2]|0)+(n*12|0)|0}function Ol(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return _l(mL[r&31](n)|0)|0}function Nl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Il(n,r,i,1);v=t;return}function Il(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Fl()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=xl(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Ul(o,t)|0,t);v=i;return}function Fl(){var n=0,e=0;if(!(t[7680]|0)){ql(9412);xn(31,9412,b|0)|0;e=7680;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9412)|0)){n=9412;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));ql(9412)}return 9412}function xl(n){n=n|0;return 0}function Ul(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Fl()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Hl(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Dl(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Hl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Dl(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Wl(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Yl(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Hl(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Vl(n,f);jl(f);v=l;return}}function Wl(n){n=n|0;return 357913941}function Yl(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Vl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function jl(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function ql(n){n=n|0;Kl(n);return}function zl(n){n=n|0;Gl(n+24|0);return}function Gl(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Kl(n){n=n|0;var e=0;e=$a()|0;rf(n,2,6,e,Xl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Xl(){return 1200}function Jl(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Zl(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Ql(e,t)|0;v=r;return e|0}function Zl(n){n=n|0;return(u[(Fl()|0)+24>>2]|0)+(n*12|0)|0}function Ql(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return $l(mL[r&31](n)|0)|0}function $l(n){n=n|0;return n|0}function ns(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];es(n,r,i,0);v=t;return}function es(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=rs()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=ts(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,is(o,t)|0,t);v=i;return}function rs(){var n=0,e=0;if(!(t[7688]|0)){ss(9448);xn(32,9448,b|0)|0;e=7688;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9448)|0)){n=9448;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));ss(9448)}return 9448}function ts(n){n=n|0;return 0}function is(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=rs()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];us(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{os(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function us(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function os(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=as(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;fs(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];us(o,t,r);u[c>>2]=(u[c>>2]|0)+12;cs(n,f);ls(f);v=l;return}}function as(n){n=n|0;return 357913941}function fs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function cs(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function ls(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function ss(n){n=n|0;vs(n);return}function ds(n){n=n|0;_s(n+24|0);return}function _s(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function vs(n){n=n|0;var e=0;e=$a()|0;rf(n,2,6,e,ps()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function ps(){return 1204}function ms(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=bs(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];hs(e,i,r);v=t;return}function bs(n){n=n|0;return(u[(rs()|0)+24>>2]|0)+(n*12|0)|0}function hs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;ys(i,r);i=ws(i,r)|0;pL[t&31](n,i);v=o;return}function ys(n,e){n=n|0;e=e|0;return}function ws(n,e){n=n|0;e=e|0;return Ms(e)|0}function Ms(n){n=n|0;return n|0}function ks(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];gs(n,r,i,0);v=t;return}function gs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Ts()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=As(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Ss(o,t)|0,t);v=i;return}function Ts(){var n=0,e=0;if(!(t[7696]|0)){Os(9484);xn(33,9484,b|0)|0;e=7696;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9484)|0)){n=9484;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Os(9484)}return 9484}function As(n){n=n|0;return 0}function Ss(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Ts()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Es(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Cs(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Es(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Cs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Ls(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Rs(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Es(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Ps(n,f);Bs(f);v=l;return}}function Ls(n){n=n|0;return 357913941}function Rs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Ps(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Bs(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Os(n){n=n|0;Fs(n);return}function Ns(n){n=n|0;Is(n+24|0);return}function Is(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Fs(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,xs()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function xs(){return 1212}function Us(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=Hs(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];Ds(e,o,r,t);v=i;return}function Hs(n){n=n|0;return(u[(Ts()|0)+24>>2]|0)+(n*12|0)|0}function Ds(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;f=v;v=v+16|0;o=f+1|0;a=f;i=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)i=u[(u[n>>2]|0)+i>>2]|0;ys(o,r);o=ws(o,r)|0;sl(a,t);a=dl(a,t)|0;PL[i&15](n,o,a);v=f;return}function Ws(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ys(n,r,i,1);v=t;return}function Ys(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Vs()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=js(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,qs(o,t)|0,t);v=i;return}function Vs(){var n=0,e=0;if(!(t[7704]|0)){Qs(9520);xn(34,9520,b|0)|0;e=7704;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9520)|0)){n=9520;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Qs(9520)}return 9520}function js(n){n=n|0;return 0}function qs(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Vs()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];zs(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Gs(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function zs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Gs(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Ks(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Xs(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];zs(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Js(n,f);Zs(f);v=l;return}}function Ks(n){n=n|0;return 357913941}function Xs(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Js(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Zs(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Qs(n){n=n|0;ed(n);return}function $s(n){n=n|0;nd(n+24|0);return}function nd(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function ed(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,rd()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function rd(){return 1224}function td(n,e,r){n=n|0;e=e|0;r=r|0;var t=0.0,i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=id(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];t=+ud(e,o,r);v=i;return+t}function id(n){n=n|0;return(u[(Vs()|0)+24>>2]|0)+(n*12|0)|0}function ud(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0.0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(i,r);i=$f(i,r)|0;a=+No(+SL[t&7](n,i));v=o;return+a}function od(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];ad(n,r,i,1);v=t;return}function ad(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=fd()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=cd(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,ld(o,t)|0,t);v=i;return}function fd(){var n=0,e=0;if(!(t[7712]|0)){bd(9556);xn(35,9556,b|0)|0;e=7712;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9556)|0)){n=9556;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));bd(9556)}return 9556}function cd(n){n=n|0;return 0}function ld(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=fd()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];sd(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{dd(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function sd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function dd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=_d(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;vd(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];sd(o,t,r);u[c>>2]=(u[c>>2]|0)+12;pd(n,f);md(f);v=l;return}}function _d(n){n=n|0;return 357913941}function vd(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function pd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function md(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function bd(n){n=n|0;wd(n);return}function hd(n){n=n|0;yd(n+24|0);return}function yd(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function wd(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,Md()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Md(){return 1232}function kd(n,e){n=n|0;e=e|0;var r=0.0,t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=gd(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=+Td(e,i);v=t;return+r}function gd(n){n=n|0;return(u[(fd()|0)+24>>2]|0)+(n*12|0)|0}function Td(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return+ +No(+ML[r&15](n))}function Ad(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Sd(n,r,i,1);v=t;return}function Sd(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Ed()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Cd(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Ld(o,t)|0,t);v=i;return}function Ed(){var n=0,e=0;if(!(t[7720]|0)){Fd(9592);xn(36,9592,b|0)|0;e=7720;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9592)|0)){n=9592;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Fd(9592)}return 9592}function Cd(n){n=n|0;return 0}function Ld(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Ed()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Rd(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Pd(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Rd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Pd(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Bd(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Od(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Rd(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Nd(n,f);Id(f);v=l;return}}function Bd(n){n=n|0;return 357913941}function Od(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Nd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Id(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Fd(n){n=n|0;Hd(n);return}function xd(n){n=n|0;Ud(n+24|0);return}function Ud(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Hd(n){n=n|0;var e=0;e=$a()|0;rf(n,2,7,e,Dd()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Dd(){return 1276}function Wd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Yd(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Vd(e,t)|0;v=r;return e|0}function Yd(n){n=n|0;return(u[(Ed()|0)+24>>2]|0)+(n*12|0)|0}function Vd(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+16|0;t=i;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;pL[r&31](t,n);t=jd(t)|0;v=i;return t|0}function jd(n){n=n|0;var e=0,r=0,t=0,i=0;i=v;v=v+32|0;e=i+12|0;r=i;t=ff(qd()|0)|0;if(!t)n=Gd(n)|0;else{cf(e,t);lf(r,e);zd(n,r);n=df(e)|0}v=i;return n|0}function qd(){var n=0;if(!(t[7736]|0)){i_(9640);xn(25,9640,b|0)|0;n=7736;u[n>>2]=1;u[n+4>>2]=0}return 9640}function zd(n,e){n=n|0;e=e|0;Qd(e,n,n+8|0)|0;return}function Gd(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=v;v=v+16|0;i=r+4|0;a=r;t=Dg(8)|0;e=t;f=GE(16)|0;u[f>>2]=u[n>>2];u[f+4>>2]=u[n+4>>2];u[f+8>>2]=u[n+8>>2];u[f+12>>2]=u[n+12>>2];o=e+4|0;u[o>>2]=f;n=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];Kd(n,o,i);u[t>>2]=n;v=r;return e|0}function Kd(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1244;u[r+12>>2]=e;u[n+4>>2]=r;return}function Xd(n){n=n|0;WE(n);XE(n);return}function Jd(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function Zd(n){n=n|0;XE(n);return}function Qd(n,e,r){n=n|0;e=e|0;r=r|0;e=$d(u[n>>2]|0,e,r)|0;r=n+4|0;u[(u[r>>2]|0)+8>>2]=e;return u[(u[r>>2]|0)+8>>2]|0}function $d(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0;t=v;v=v+16|0;i=t;gS(i);n=ko(n)|0;r=n_(n,u[e>>2]|0,+l[r>>3])|0;AS(i);v=t;return r|0}function n_(n,e,r){n=n|0;e=e|0;r=+r;var t=0;t=Ao(e_()|0)|0;e=Eo(e)|0;return Ln(0,t|0,n|0,e|0,+ +So(r))|0}function e_(){var n=0;if(!(t[7728]|0)){r_(9628);n=7728;u[n>>2]=1;u[n+4>>2]=0}return 9628}function r_(n){n=n|0;xo(n,t_()|0,2);return}function t_(){return 1264}function i_(n){n=n|0;Rf(n);return}function u_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];o_(n,r,i,1);v=t;return}function o_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=a_()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=f_(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,c_(o,t)|0,t);v=i;return}function a_(){var n=0,e=0;if(!(t[7744]|0)){m_(9684);xn(37,9684,b|0)|0;e=7744;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9684)|0)){n=9684;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));m_(9684)}return 9684}function f_(n){n=n|0;return 0}function c_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=a_()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];l_(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{s_(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function l_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function s_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=d_(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;__(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];l_(o,t,r);u[c>>2]=(u[c>>2]|0)+12;v_(n,f);p_(f);v=l;return}}function d_(n){n=n|0;return 357913941}function __(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function v_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function p_(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function m_(n){n=n|0;y_(n);return}function b_(n){n=n|0;h_(n+24|0);return}function h_(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function y_(n){n=n|0;var e=0;e=$a()|0;rf(n,2,5,e,w_()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function w_(){return 1280}function M_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=k_(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=g_(e,i,r)|0;v=t;return r|0}function k_(n){n=n|0;return(u[(a_()|0)+24>>2]|0)+(n*12|0)|0}function g_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;a=v;v=v+32|0;i=a;o=a+16|0;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(o,r);o=$f(o,r)|0;PL[t&15](i,n,o);o=jd(i)|0;v=a;return o|0}function T_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];A_(n,r,i,1);v=t;return}function A_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=S_()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=E_(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,C_(o,t)|0,t);v=i;return}function S_(){var n=0,e=0;if(!(t[7752]|0)){I_(9720);xn(38,9720,b|0)|0;e=7752;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9720)|0)){n=9720;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));I_(9720)}return 9720}function E_(n){n=n|0;return 0}function C_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=S_()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];L_(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{R_(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function L_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function R_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=P_(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;B_(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];L_(o,t,r);u[c>>2]=(u[c>>2]|0)+12;O_(n,f);N_(f);v=l;return}}function P_(n){n=n|0;return 357913941}function B_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function O_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function N_(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function I_(n){n=n|0;U_(n);return}function F_(n){n=n|0;x_(n+24|0);return}function x_(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function U_(n){n=n|0;var e=0;e=$a()|0;rf(n,2,8,e,H_()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function H_(){return 1288}function D_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=W_(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];e=Y_(e,t)|0;v=r;return e|0}function W_(n){n=n|0;return(u[(S_()|0)+24>>2]|0)+(n*12|0)|0}function Y_(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;return Oo(mL[r&31](n)|0)|0}function V_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];j_(n,r,i,0);v=t;return}function j_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=q_()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=z_(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,G_(o,t)|0,t);v=i;return}function q_(){var n=0,e=0;if(!(t[7760]|0)){nv(9756);xn(39,9756,b|0)|0;e=7760;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9756)|0)){n=9756;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));nv(9756)}return 9756}function z_(n){n=n|0;return 0}function G_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=q_()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];K_(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{X_(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function K_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function X_(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=J_(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Z_(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];K_(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Q_(n,f);$_(f);v=l;return}}function J_(n){n=n|0;return 357913941}function Z_(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Q_(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function $_(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function nv(n){n=n|0;tv(n);return}function ev(n){n=n|0;rv(n+24|0);return}function rv(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function tv(n){n=n|0;var e=0;e=$a()|0;rf(n,2,8,e,iv()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function iv(){return 1292}function uv(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=ov(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];av(e,i,r);v=t;return}function ov(n){n=n|0;return(u[(q_()|0)+24>>2]|0)+(n*12|0)|0}function av(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Jf(i,r);r=+Zf(i,r);dL[t&31](n,r);v=o;return}function fv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];cv(n,r,i,0);v=t;return}function cv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=lv()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=sv(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,dv(o,t)|0,t);v=i;return}function lv(){var n=0,e=0;if(!(t[7768]|0)){yv(9792);xn(40,9792,b|0)|0;e=7768;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9792)|0)){n=9792;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));yv(9792)}return 9792}function sv(n){n=n|0;return 0}function dv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=lv()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];_v(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{vv(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function _v(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function vv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=pv(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;mv(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];_v(o,t,r);u[c>>2]=(u[c>>2]|0)+12;bv(n,f);hv(f);v=l;return}}function pv(n){n=n|0;return 357913941}function mv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function bv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function hv(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function yv(n){n=n|0;kv(n);return}function wv(n){n=n|0;Mv(n+24|0);return}function Mv(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function kv(n){n=n|0;var e=0;e=$a()|0;rf(n,2,1,e,gv()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function gv(){return 1300}function Tv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=Av(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];Sv(e,o,r,t);v=i;return}function Av(n){n=n|0;return(u[(lv()|0)+24>>2]|0)+(n*12|0)|0}function Sv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;var i=0,o=0,a=0,f=0;f=v;v=v+16|0;o=f+1|0;a=f;i=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)i=u[(u[n>>2]|0)+i>>2]|0;Qf(o,r);o=$f(o,r)|0;Jf(a,t);t=+Zf(a,t);OL[i&15](n,o,t);v=f;return}function Ev(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Cv(n,r,i,0);v=t;return}function Cv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Lv()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Rv(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Pv(o,t)|0,t);v=i;return}function Lv(){var n=0,e=0;if(!(t[7776]|0)){Uv(9828);xn(41,9828,b|0)|0;e=7776;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9828)|0)){n=9828;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Uv(9828)}return 9828}function Rv(n){n=n|0;return 0}function Pv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Lv()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Bv(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Ov(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Bv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Ov(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Nv(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Iv(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Bv(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Fv(n,f);xv(f);v=l;return}}function Nv(n){n=n|0;return 357913941}function Iv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Fv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function xv(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Uv(n){n=n|0;Wv(n);return}function Hv(n){n=n|0;Dv(n+24|0);return}function Dv(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Wv(n){n=n|0;var e=0;e=$a()|0;rf(n,2,7,e,Yv()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Yv(){return 1312}function Vv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=jv(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];qv(e,i,r);v=t;return}function jv(n){n=n|0;return(u[(Lv()|0)+24>>2]|0)+(n*12|0)|0}function qv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(i,r);i=$f(i,r)|0;pL[t&31](n,i);v=o;return}function zv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Gv(n,r,i,0);v=t;return}function Gv(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Kv()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Xv(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Jv(o,t)|0,t);v=i;return}function Kv(){var n=0,e=0;if(!(t[7784]|0)){tp(9864);xn(42,9864,b|0)|0;e=7784;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9864)|0)){n=9864;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));tp(9864)}return 9864}function Xv(n){n=n|0;return 0}function Jv(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Kv()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];Zv(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{Qv(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function Zv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function Qv(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=$v(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;np(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];Zv(o,t,r);u[c>>2]=(u[c>>2]|0)+12;ep(n,f);rp(f);v=l;return}}function $v(n){n=n|0;return 357913941}function np(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function ep(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function rp(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function tp(n){n=n|0;op(n);return}function ip(n){n=n|0;up(n+24|0);return}function up(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function op(n){n=n|0;var e=0;e=$a()|0;rf(n,2,8,e,ap()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function ap(){return 1320}function fp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=cp(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];lp(e,i,r);v=t;return}function cp(n){n=n|0;return(u[(Kv()|0)+24>>2]|0)+(n*12|0)|0}function lp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;sp(i,r);i=dp(i,r)|0;pL[t&31](n,i);v=o;return}function sp(n,e){n=n|0;e=e|0;return}function dp(n,e){n=n|0;e=e|0;return _p(e)|0}function _p(n){n=n|0;return n|0}function vp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];pp(n,r,i,0);v=t;return}function pp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=mp()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=bp(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,hp(o,t)|0,t);v=i;return}function mp(){var n=0,e=0;if(!(t[7792]|0)){Ap(9900);xn(43,9900,b|0)|0;e=7792;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9900)|0)){n=9900;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Ap(9900)}return 9900}function bp(n){n=n|0;return 0}function hp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=mp()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];yp(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{wp(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function yp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function wp(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Mp(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;kp(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];yp(o,t,r);u[c>>2]=(u[c>>2]|0)+12;gp(n,f);Tp(f);v=l;return}}function Mp(n){n=n|0;return 357913941}function kp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function gp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Tp(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Ap(n){n=n|0;Cp(n);return}function Sp(n){n=n|0;Ep(n+24|0);return}function Ep(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Cp(n){n=n|0;var e=0;e=$a()|0;rf(n,2,22,e,Lp()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Lp(){return 1344}function Rp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0;r=v;v=v+16|0;t=r+8|0;i=r;o=Pp(n)|0;n=u[o+4>>2]|0;u[i>>2]=u[o>>2];u[i+4>>2]=n;u[t>>2]=u[i>>2];u[t+4>>2]=u[i+4>>2];Bp(e,t);v=r;return}function Pp(n){n=n|0;return(u[(mp()|0)+24>>2]|0)+(n*12|0)|0}function Bp(n,e){n=n|0;e=e|0;var r=0;r=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)r=u[(u[n>>2]|0)+r>>2]|0;vL[r&127](n);return}function Op(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=Np()|0;n=Ip(r)|0;xa(o,e,i,n,Fp(r,t)|0,t);return}function Np(){var n=0,e=0;if(!(t[7800]|0)){Vp(9936);xn(44,9936,b|0)|0;e=7800;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9936)|0)){n=9936;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Vp(9936)}return 9936}function Ip(n){n=n|0;return n|0}function Fp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=Np()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){xp(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{Up(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function xp(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function Up(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=Hp(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;Dp(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;xp(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;Wp(n,i);Yp(i);v=f;return}}function Hp(n){n=n|0;return 536870911}function Dp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function Wp(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Yp(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function Vp(n){n=n|0;zp(n);return}function jp(n){n=n|0;qp(n+24|0);return}function qp(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function zp(n){n=n|0;var e=0;e=$a()|0;rf(n,1,23,e,ps()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Gp(n,e){n=n|0;e=e|0;Xp(u[(Kp(n)|0)>>2]|0,e);return}function Kp(n){n=n|0;return(u[(Np()|0)+24>>2]|0)+(n<<3)|0}function Xp(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;ys(t,e);e=ws(t,e)|0;vL[n&127](e);v=r;return}function Jp(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=Zp()|0;n=Qp(r)|0;xa(o,e,i,n,$p(r,t)|0,t);return}function Zp(){var n=0,e=0;if(!(t[7808]|0)){om(9972);xn(45,9972,b|0)|0;e=7808;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(9972)|0)){n=9972;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));om(9972)}return 9972}function Qp(n){n=n|0;return n|0}function $p(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=Zp()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){nm(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{em(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function nm(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function em(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=rm(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;tm(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;nm(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;im(n,i);um(i);v=f;return}}function rm(n){n=n|0;return 536870911}function tm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function im(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function um(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function om(n){n=n|0;cm(n);return}function am(n){n=n|0;fm(n+24|0);return}function fm(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function cm(n){n=n|0;var e=0;e=$a()|0;rf(n,1,9,e,lm()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function lm(){return 1348}function sm(n,e){n=n|0;e=e|0;return _m(u[(dm(n)|0)>>2]|0,e)|0}function dm(n){n=n|0;return(u[(Zp()|0)+24>>2]|0)+(n<<3)|0}function _m(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;vm(t,e);e=pm(t,e)|0;e=_l(mL[n&31](e)|0)|0;v=r;return e|0}function vm(n,e){n=n|0;e=e|0;return}function pm(n,e){n=n|0;e=e|0;return mm(e)|0}function mm(n){n=n|0;return n|0}function bm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=hm()|0;n=ym(r)|0;xa(o,e,i,n,wm(r,t)|0,t);return}function hm(){var n=0,e=0;if(!(t[7816]|0)){Em(10008);xn(46,10008,b|0)|0;e=7816;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10008)|0)){n=10008;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Em(10008)}return 10008}function ym(n){n=n|0;return n|0}function wm(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=hm()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){Mm(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{km(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function Mm(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function km(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=gm(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;Tm(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;Mm(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;Am(n,i);Sm(i);v=f;return}}function gm(n){n=n|0;return 536870911}function Tm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function Am(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Sm(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function Em(n){n=n|0;Rm(n);return}function Cm(n){n=n|0;Lm(n+24|0);return}function Lm(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Rm(n){n=n|0;var e=0;e=$a()|0;rf(n,1,15,e,Rl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Pm(n){n=n|0;return Om(u[(Bm(n)|0)>>2]|0)|0}function Bm(n){n=n|0;return(u[(hm()|0)+24>>2]|0)+(n<<3)|0}function Om(n){n=n|0;return _l(EL[n&7]()|0)|0}function Nm(){var n=0;if(!(t[7832]|0)){jm(10052);xn(25,10052,b|0)|0;n=7832;u[n>>2]=1;u[n+4>>2]=0}return 10052}function Im(n,e){n=n|0;e=e|0;u[n>>2]=Fm()|0;u[n+4>>2]=xm()|0;u[n+12>>2]=e;u[n+8>>2]=Um()|0;u[n+32>>2]=2;return}function Fm(){return 11709}function xm(){return 1188}function Um(){return Ym()|0}function Hm(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){Wm(r);XE(r)}}else if(e|0){Zi(e);XE(e)}return}function Dm(n,e){n=n|0;e=e|0;return e&n|0}function Wm(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Ym(){var n=0;if(!(t[7824]|0)){u[2511]=Vm()|0;u[2512]=0;n=7824;u[n>>2]=1;u[n+4>>2]=0}return 10044}function Vm(){return 0}function jm(n){n=n|0;Rf(n);return}function qm(n){n=n|0;var e=0,r=0,t=0,i=0,o=0;e=v;v=v+32|0;r=e+24|0;o=e+16|0;i=e+8|0;t=e;zm(n,4827);Gm(n,4834,3)|0;Km(n,3682,47)|0;u[o>>2]=9;u[o+4>>2]=0;u[r>>2]=u[o>>2];u[r+4>>2]=u[o+4>>2];Xm(n,4841,r)|0;u[i>>2]=1;u[i+4>>2]=0;u[r>>2]=u[i>>2];u[r+4>>2]=u[i+4>>2];Jm(n,4871,r)|0;u[t>>2]=10;u[t+4>>2]=0;u[r>>2]=u[t>>2];u[r+4>>2]=u[t+4>>2];Zm(n,4891,r)|0;v=e;return}function zm(n,e){n=n|0;e=e|0;var r=0;r=jh()|0;u[n>>2]=r;qh(r,e);lM(u[n>>2]|0);return}function Gm(n,e,r){n=n|0;e=e|0;r=r|0;Ah(n,Ba(e)|0,r,0);return n|0}function Km(n,e,r){n=n|0;e=e|0;r=r|0;ah(n,Ba(e)|0,r,0);return n|0}function Xm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Hb(n,e,i);v=t;return n|0}function Jm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];bb(n,e,i);v=t;return n|0}function Zm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=u[r+4>>2]|0;u[o>>2]=u[r>>2];u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Qm(n,e,i);v=t;return n|0}function Qm(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];$m(n,r,i,1);v=t;return}function $m(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=nb()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=eb(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,rb(o,t)|0,t);v=i;return}function nb(){var n=0,e=0;if(!(t[7840]|0)){cb(10100);xn(48,10100,b|0)|0;e=7840;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10100)|0)){n=10100;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));cb(10100)}return 10100}function eb(n){n=n|0;return 0}function rb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=nb()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];tb(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{ib(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function tb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function ib(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=ub(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;ob(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];tb(o,t,r);u[c>>2]=(u[c>>2]|0)+12;ab(n,f);fb(f);v=l;return}}function ub(n){n=n|0;return 357913941}function ob(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function ab(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function fb(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function cb(n){n=n|0;db(n);return}function lb(n){n=n|0;sb(n+24|0);return}function sb(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function db(n){n=n|0;var e=0;e=$a()|0;rf(n,2,6,e,_b()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function _b(){return 1364}function vb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=pb(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];r=mb(e,i,r)|0;v=t;return r|0}function pb(n){n=n|0;return(u[(nb()|0)+24>>2]|0)+(n*12|0)|0}function mb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Qf(i,r);i=$f(i,r)|0;i=Mc(gL[t&15](n,i)|0)|0;v=o;return i|0}function bb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];hb(n,r,i,0);v=t;return}function hb(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=yb()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=wb(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Mb(o,t)|0,t);v=i;return}function yb(){var n=0,e=0;if(!(t[7848]|0)){Cb(10136);xn(49,10136,b|0)|0;e=7848;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10136)|0)){n=10136;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Cb(10136)}return 10136}function wb(n){n=n|0;return 0}function Mb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=yb()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];kb(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{gb(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function kb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function gb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=Tb(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Ab(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];kb(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Sb(n,f);Eb(f);v=l;return}}function Tb(n){n=n|0;return 357913941}function Ab(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Sb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Eb(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Cb(n){n=n|0;Pb(n);return}function Lb(n){n=n|0;Rb(n+24|0);return}function Rb(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function Pb(n){n=n|0;var e=0;e=$a()|0;rf(n,2,9,e,Bb()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Bb(){return 1372}function Ob(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;i=t+8|0;o=t;a=Nb(n)|0;n=u[a+4>>2]|0;u[o>>2]=u[a>>2];u[o+4>>2]=n;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Ib(e,i,r);v=t;return}function Nb(n){n=n|0;return(u[(yb()|0)+24>>2]|0)+(n*12|0)|0}function Ib(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=de;o=v;v=v+16|0;i=o;t=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)t=u[(u[n>>2]|0)+t>>2]|0;Fb(i,r);a=K(xb(i,r));sL[t&1](n,a);v=o;return}function Fb(n,e){n=n|0;e=+e;return}function xb(n,e){n=n|0;e=+e;return K(Ub(e))}function Ub(n){n=+n;return K(n)}function Hb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;i=t+8|0;o=t;f=u[r>>2]|0;a=u[r+4>>2]|0;r=Ba(e)|0;u[o>>2]=f;u[o+4>>2]=a;u[i>>2]=u[o>>2];u[i+4>>2]=u[o+4>>2];Db(n,r,i,0);v=t;return}function Db(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0;i=v;v=v+32|0;o=i+16|0;s=i+8|0;f=i;l=u[r>>2]|0;c=u[r+4>>2]|0;a=u[n>>2]|0;n=Wb()|0;u[s>>2]=l;u[s+4>>2]=c;u[o>>2]=u[s>>2];u[o+4>>2]=u[s+4>>2];r=Yb(o)|0;u[f>>2]=l;u[f+4>>2]=c;u[o>>2]=u[f>>2];u[o+4>>2]=u[f+4>>2];xa(a,e,n,r,Vb(o,t)|0,t);v=i;return}function Wb(){var n=0,e=0;if(!(t[7856]|0)){Jb(10172);xn(50,10172,b|0)|0;e=7856;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10172)|0)){n=10172;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Jb(10172)}return 10172}function Yb(n){n=n|0;return 0}function Vb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0;s=v;v=v+32|0;i=s+24|0;a=s+16|0;f=s;c=s+8|0;o=u[n>>2]|0;t=u[n+4>>2]|0;u[f>>2]=o;u[f+4>>2]=t;d=Wb()|0;l=d+24|0;n=Wa(e,4)|0;u[c>>2]=n;e=d+28|0;r=u[e>>2]|0;if(r>>>0<(u[d+32>>2]|0)>>>0){u[a>>2]=o;u[a+4>>2]=t;u[i>>2]=u[a>>2];u[i+4>>2]=u[a+4>>2];jb(r,i,n);n=(u[e>>2]|0)+12|0;u[e>>2]=n}else{qb(l,f,c);n=u[e>>2]|0}v=s;return((n-(u[l>>2]|0)|0)/12|0)+-1|0}function jb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=u[e+4>>2]|0;u[n>>2]=u[e>>2];u[n+4>>2]=t;u[n+8>>2]=r;return}function qb(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0;l=v;v=v+48|0;t=l+32|0;a=l+24|0;f=l;c=n+4|0;i=(((u[c>>2]|0)-(u[n>>2]|0)|0)/12|0)+1|0;o=zb(n)|0;if(o>>>0<i>>>0)DE(n);else{s=u[n>>2]|0;_=((u[n+8>>2]|0)-s|0)/12|0;d=_<<1;Gb(f,_>>>0<o>>>1>>>0?d>>>0<i>>>0?i:d:o,((u[c>>2]|0)-s|0)/12|0,n+8|0);c=f+8|0;o=u[c>>2]|0;i=u[e+4>>2]|0;r=u[r>>2]|0;u[a>>2]=u[e>>2];u[a+4>>2]=i;u[t>>2]=u[a>>2];u[t+4>>2]=u[a+4>>2];jb(o,t,r);u[c>>2]=(u[c>>2]|0)+12;Kb(n,f);Xb(f);v=l;return}}function zb(n){n=n|0;return 357913941}function Gb(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>357913941)Xn();else{i=GE(e*12|0)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r*12|0)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e*12|0);return}function Kb(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(((i|0)/-12|0)*12|0)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Xb(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~(((t+-12-e|0)>>>0)/12|0)*12|0);n=u[n>>2]|0;if(n|0)XE(n);return}function Jb(n){n=n|0;$b(n);return}function Zb(n){n=n|0;Qb(n+24|0);return}function Qb(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~(((e+-12-t|0)>>>0)/12|0)*12|0);XE(r)}return}function $b(n){n=n|0;var e=0;e=$a()|0;rf(n,2,3,e,nh()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function nh(){return 1380}function eh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+8|0;a=i;f=rh(n)|0;n=u[f+4>>2]|0;u[a>>2]=u[f>>2];u[a+4>>2]=n;u[o>>2]=u[a>>2];u[o+4>>2]=u[a+4>>2];th(e,o,r,t);v=i;return}function rh(n){n=n|0;return(u[(Wb()|0)+24>>2]|0)+(n*12|0)|0}function th(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;f=v;v=v+16|0;o=f+1|0;a=f;i=u[e>>2]|0;e=u[e+4>>2]|0;n=n+(e>>1)|0;if(e&1)i=u[(u[n>>2]|0)+i>>2]|0;Qf(o,r);o=$f(o,r)|0;ih(a,t);a=uh(a,t)|0;PL[i&15](n,o,a);v=f;return}function ih(n,e){n=n|0;e=e|0;return}function uh(n,e){n=n|0;e=e|0;return oh(e)|0}function oh(n){n=n|0;return(n|0)!=0|0}function ah(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=fh()|0;n=ch(r)|0;xa(o,e,i,n,lh(r,t)|0,t);return}function fh(){var n=0,e=0;if(!(t[7864]|0)){bh(10208);xn(51,10208,b|0)|0;e=7864;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10208)|0)){n=10208;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));bh(10208)}return 10208}function ch(n){n=n|0;return n|0}function lh(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=fh()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){sh(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{dh(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function sh(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function dh(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=_h(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;vh(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;sh(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;ph(n,i);mh(i);v=f;return}}function _h(n){n=n|0;return 536870911}function vh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function ph(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function mh(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function bh(n){n=n|0;wh(n);return}function hh(n){n=n|0;yh(n+24|0);return}function yh(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function wh(n){n=n|0;var e=0;e=$a()|0;rf(n,1,24,e,Mh()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Mh(){return 1392}function kh(n,e){n=n|0;e=e|0;Th(u[(gh(n)|0)>>2]|0,e);return}function gh(n){n=n|0;return(u[(fh()|0)+24>>2]|0)+(n<<3)|0}function Th(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;vm(t,e);e=pm(t,e)|0;vL[n&127](e);v=r;return}function Ah(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=Sh()|0;n=Eh(r)|0;xa(o,e,i,n,Ch(r,t)|0,t);return}function Sh(){var n=0,e=0;if(!(t[7872]|0)){Ih(10244);xn(52,10244,b|0)|0;e=7872;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10244)|0)){n=10244;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));Ih(10244)}return 10244}function Eh(n){n=n|0;return n|0}function Ch(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=Sh()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){Lh(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{Rh(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function Lh(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function Rh(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=Ph(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;Bh(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;Lh(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;Oh(n,i);Nh(i);v=f;return}}function Ph(n){n=n|0;return 536870911}function Bh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function Oh(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function Nh(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function Ih(n){n=n|0;Uh(n);return}function Fh(n){n=n|0;xh(n+24|0);return}function xh(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Uh(n){n=n|0;var e=0;e=$a()|0;rf(n,1,16,e,Hh()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Hh(){return 1400}function Dh(n){n=n|0;return Yh(u[(Wh(n)|0)>>2]|0)|0}function Wh(n){n=n|0;return(u[(Sh()|0)+24>>2]|0)+(n<<3)|0}function Yh(n){n=n|0;return Vh(EL[n&7]()|0)|0}function Vh(n){n=n|0;return n|0}function jh(){var n=0;if(!(t[7880]|0)){Zh(10280);xn(25,10280,b|0)|0;n=7880;u[n>>2]=1;u[n+4>>2]=0}return 10280}function qh(n,e){n=n|0;e=e|0;u[n>>2]=zh()|0;u[n+4>>2]=Gh()|0;u[n+12>>2]=e;u[n+8>>2]=Kh()|0;u[n+32>>2]=4;return}function zh(){return 11711}function Gh(){return 1356}function Kh(){return Ym()|0}function Xh(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){Jh(r);XE(r)}}else if(e|0){Vi(e);XE(e)}return}function Jh(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Zh(n){n=n|0;Rf(n);return}function Qh(n){n=n|0;$h(n,4920);ny(n)|0;ey(n)|0;return}function $h(n,e){n=n|0;e=e|0;var r=0;r=qd()|0;u[n>>2]=r;Ey(r,e);lM(u[n>>2]|0);return}function ny(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,py()|0);return n|0}function ey(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,ry()|0);return n|0}function ry(){var n=0;if(!(t[7888]|0)){iy(10328);xn(53,10328,b|0)|0;n=7888;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10328)|0))iy(10328);return 10328}function ty(n,e){n=n|0;e=e|0;xa(n,0,e,0,0,0);return}function iy(n){n=n|0;ay(n);cy(n,10);return}function uy(n){n=n|0;oy(n+24|0);return}function oy(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function ay(n){n=n|0;var e=0;e=$a()|0;rf(n,5,1,e,dy()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function fy(n,e,r){n=n|0;e=e|0;r=+r;ly(n,e,r);return}function cy(n,e){n=n|0;e=e|0;u[n+20>>2]=e;return}function ly(n,e,r){n=n|0;e=e|0;r=+r;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+16|0;o=t+8|0;f=t+13|0;i=t;a=t+12|0;Qf(f,e);u[o>>2]=$f(f,e)|0;Jf(a,r);l[i>>3]=+Zf(a,r);sy(n,o,i);v=t;return}function sy(n,e,r){n=n|0;e=e|0;r=r|0;Vu(n+8|0,u[e>>2]|0,+l[r>>3]);t[n+24>>0]=1;return}function dy(){return 1404}function _y(n,e){n=n|0;e=+e;return vy(n,e)|0}function vy(n,e){n=n|0;e=+e;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;t=v;v=v+16|0;o=t+4|0;a=t+8|0;f=t;i=Dg(8)|0;r=i;c=GE(16)|0;Qf(o,n);n=$f(o,n)|0;Jf(a,e);Vu(c,n,+Zf(a,e));a=r+4|0;u[a>>2]=c;n=GE(8)|0;a=u[a>>2]|0;u[f>>2]=0;u[o>>2]=u[f>>2];Kd(n,a,o);u[i>>2]=n;v=t;return r|0}function py(){var n=0;if(!(t[7896]|0)){my(10364);xn(54,10364,b|0)|0;n=7896;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10364)|0))my(10364);return 10364}function my(n){n=n|0;yy(n);cy(n,55);return}function by(n){n=n|0;hy(n+24|0);return}function hy(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function yy(n){n=n|0;var e=0;e=$a()|0;rf(n,5,4,e,Ty()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function wy(n){n=n|0;My(n);return}function My(n){n=n|0;ky(n);return}function ky(n){n=n|0;gy(n+8|0);t[n+24>>0]=1;return}function gy(n){n=n|0;u[n>>2]=0;l[n+8>>3]=0.0;return}function Ty(){return 1424}function Ay(){return Sy()|0}function Sy(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0;e=v;v=v+16|0;i=e+4|0;a=e;r=Dg(8)|0;n=r;t=GE(16)|0;gy(t);o=n+4|0;u[o>>2]=t;t=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];Kd(t,o,i);u[r>>2]=t;v=e;return n|0}function Ey(n,e){n=n|0;e=e|0;u[n>>2]=Cy()|0;u[n+4>>2]=Ly()|0;u[n+12>>2]=e;u[n+8>>2]=Ry()|0;u[n+32>>2]=5;return}function Cy(){return 11710}function Ly(){return 1416}function Ry(){return Oy()|0}function Py(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){By(r);XE(r)}}else if(e|0)XE(e);return}function By(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Oy(){var n=0;if(!(t[7904]|0)){u[2600]=Ny()|0;u[2601]=0;n=7904;u[n>>2]=1;u[n+4>>2]=0}return 10400}function Ny(){return u[357]|0}function Iy(n){n=n|0;Fy(n,4926);xy(n)|0;return}function Fy(n,e){n=n|0;e=e|0;var r=0;r=af()|0;u[n>>2]=r;Xy(r,e);lM(u[n>>2]|0);return}function xy(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,Uy()|0);return n|0}function Uy(){var n=0;if(!(t[7912]|0)){Hy(10412);xn(56,10412,b|0)|0;n=7912;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10412)|0))Hy(10412);return 10412}function Hy(n){n=n|0;Yy(n);cy(n,57);return}function Dy(n){n=n|0;Wy(n+24|0);return}function Wy(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Yy(n){n=n|0;var e=0;e=$a()|0;rf(n,5,5,e,zy()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Vy(n){n=n|0;jy(n);return}function jy(n){n=n|0;qy(n);return}function qy(n){n=n|0;var e=0,r=0;e=n+8|0;r=e+48|0;do{u[e>>2]=0;e=e+4|0}while((e|0)<(r|0));t[n+56>>0]=1;return}function zy(){return 1432}function Gy(){return Ky()|0}function Ky(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0,f=0;a=v;v=v+16|0;n=a+4|0;e=a;r=Dg(8)|0;t=r;i=GE(48)|0;o=i;f=o+48|0;do{u[o>>2]=0;o=o+4|0}while((o|0)<(f|0));o=t+4|0;u[o>>2]=i;f=GE(8)|0;o=u[o>>2]|0;u[e>>2]=0;u[n>>2]=u[e>>2];vf(f,o,n);u[r>>2]=f;v=a;return t|0}function Xy(n,e){n=n|0;e=e|0;u[n>>2]=Jy()|0;u[n+4>>2]=Zy()|0;u[n+12>>2]=e;u[n+8>>2]=Qy()|0;u[n+32>>2]=6;return}function Jy(){return 11704}function Zy(){return 1436}function Qy(){return Oy()|0}function $y(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){nw(r);XE(r)}}else if(e|0)XE(e);return}function nw(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function ew(n){n=n|0;rw(n,4933);tw(n)|0;iw(n)|0;return}function rw(n,e){n=n|0;e=e|0;var r=0;r=Ow()|0;u[n>>2]=r;Nw(r,e);lM(u[n>>2]|0);return}function tw(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,Mw()|0);return n|0}function iw(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,uw()|0);return n|0}function uw(){var n=0;if(!(t[7920]|0)){ow(10452);xn(58,10452,b|0)|0;n=7920;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10452)|0))ow(10452);return 10452}function ow(n){n=n|0;cw(n);cy(n,1);return}function aw(n){n=n|0;fw(n+24|0);return}function fw(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function cw(n){n=n|0;var e=0;e=$a()|0;rf(n,5,1,e,vw()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function lw(n,e,r){n=n|0;e=+e;r=+r;sw(n,e,r);return}function sw(n,e,r){n=n|0;e=+e;r=+r;var t=0,i=0,u=0,o=0,a=0;t=v;v=v+32|0;u=t+8|0;a=t+17|0;i=t;o=t+16|0;Jf(a,e);l[u>>3]=+Zf(a,e);Jf(o,r);l[i>>3]=+Zf(o,r);dw(n,u,i);v=t;return}function dw(n,e,r){n=n|0;e=e|0;r=r|0;_w(n+8|0,+l[e>>3],+l[r>>3]);t[n+24>>0]=1;return}function _w(n,e,r){n=n|0;e=+e;r=+r;l[n>>3]=e;l[n+8>>3]=r;return}function vw(){return 1472}function pw(n,e){n=+n;e=+e;return mw(n,e)|0}function mw(n,e){n=+n;e=+e;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;t=v;v=v+16|0;a=t+4|0;f=t+8|0;c=t;i=Dg(8)|0;r=i;o=GE(16)|0;Jf(a,n);n=+Zf(a,n);Jf(f,e);_w(o,n,+Zf(f,e));f=r+4|0;u[f>>2]=o;o=GE(8)|0;f=u[f>>2]|0;u[c>>2]=0;u[a>>2]=u[c>>2];bw(o,f,a);u[i>>2]=o;v=t;return r|0}function bw(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1452;u[r+12>>2]=e;u[n+4>>2]=r;return}function hw(n){n=n|0;WE(n);XE(n);return}function yw(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function ww(n){n=n|0;XE(n);return}function Mw(){var n=0;if(!(t[7928]|0)){kw(10488);xn(59,10488,b|0)|0;n=7928;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10488)|0))kw(10488);return 10488}function kw(n){n=n|0;Aw(n);cy(n,60);return}function gw(n){n=n|0;Tw(n+24|0);return}function Tw(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Aw(n){n=n|0;var e=0;e=$a()|0;rf(n,5,6,e,Rw()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Sw(n){n=n|0;Ew(n);return}function Ew(n){n=n|0;Cw(n);return}function Cw(n){n=n|0;Lw(n+8|0);t[n+24>>0]=1;return}function Lw(n){n=n|0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;u[n+12>>2]=0;return}function Rw(){return 1492}function Pw(){return Bw()|0}function Bw(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0;e=v;v=v+16|0;i=e+4|0;a=e;r=Dg(8)|0;n=r;t=GE(16)|0;Lw(t);o=n+4|0;u[o>>2]=t;t=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];bw(t,o,i);u[r>>2]=t;v=e;return n|0}function Ow(){var n=0;if(!(t[7936]|0)){Dw(10524);xn(25,10524,b|0)|0;n=7936;u[n>>2]=1;u[n+4>>2]=0}return 10524}function Nw(n,e){n=n|0;e=e|0;u[n>>2]=Iw()|0;u[n+4>>2]=Fw()|0;u[n+12>>2]=e;u[n+8>>2]=xw()|0;u[n+32>>2]=7;return}function Iw(){return 11700}function Fw(){return 1484}function xw(){return Oy()|0}function Uw(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){Hw(r);XE(r)}}else if(e|0)XE(e);return}function Hw(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Dw(n){n=n|0;Rf(n);return}function Ww(n,e,r){n=n|0;e=e|0;r=r|0;n=Ba(e)|0;e=Yw(r)|0;r=Vw(r,0)|0;CM(n,e,r,jw()|0,0);return}function Yw(n){n=n|0;return n|0}function Vw(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=jw()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){Qw(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{$w(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function jw(){var n=0,e=0;if(!(t[7944]|0)){qw(10568);xn(61,10568,b|0)|0;e=7944;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10568)|0)){n=10568;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));qw(10568)}return 10568}function qw(n){n=n|0;Kw(n);return}function zw(n){n=n|0;Gw(n+24|0);return}function Gw(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Kw(n){n=n|0;var e=0;e=$a()|0;rf(n,1,17,e,Xl()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Xw(n){n=n|0;return Zw(u[(Jw(n)|0)>>2]|0)|0}function Jw(n){n=n|0;return(u[(jw()|0)+24>>2]|0)+(n<<3)|0}function Zw(n){n=n|0;return $l(EL[n&7]()|0)|0}function Qw(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function $w(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=nM(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;eM(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;Qw(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;rM(n,i);tM(i);v=f;return}}function nM(n){n=n|0;return 536870911}function eM(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function rM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function tM(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function iM(){uM();return}function uM(){oM(10604);return}function oM(n){n=n|0;aM(n,4955);return}function aM(n,e){n=n|0;e=e|0;var r=0;r=fM()|0;u[n>>2]=r;cM(r,e);lM(u[n>>2]|0);return}function fM(){var n=0;if(!(t[7952]|0)){wM(10612);xn(25,10612,b|0)|0;n=7952;u[n>>2]=1;u[n+4>>2]=0}return 10612}function cM(n,e){n=n|0;e=e|0;u[n>>2]=pM()|0;u[n+4>>2]=mM()|0;u[n+12>>2]=e;u[n+8>>2]=bM()|0;u[n+32>>2]=8;return}function lM(n){n=n|0;var e=0,r=0;e=v;v=v+16|0;r=e;sM()|0;u[r>>2]=n;dM(10608,r);v=e;return}function sM(){if(!(t[11714]|0)){u[2652]=0;xn(62,10608,b|0)|0;t[11714]=1}return 10608}function dM(n,e){n=n|0;e=e|0;var r=0;r=GE(8)|0;u[r+4>>2]=u[e>>2];u[r>>2]=u[n>>2];u[n>>2]=r;return}function _M(n){n=n|0;vM(n);return}function vM(n){n=n|0;var e=0,r=0;e=u[n>>2]|0;if(e|0)do{r=e;e=u[e>>2]|0;XE(r)}while((e|0)!=0);u[n>>2]=0;return}function pM(){return 11715}function mM(){return 1496}function bM(){return Ym()|0}function hM(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){yM(r);XE(r)}}else if(e|0)XE(e);return}function yM(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function wM(n){n=n|0;Rf(n);return}function MM(n,e){n=n|0;e=e|0;var r=0,t=0;sM()|0;r=u[2652]|0;n:do{if(r|0){while(1){t=u[r+4>>2]|0;if(t|0?(tE(kM(t)|0,n)|0)==0:0)break;r=u[r>>2]|0;if(!r)break n}gM(t,e)}}while(0);return}function kM(n){n=n|0;return u[n+12>>2]|0}function gM(n,e){n=n|0;e=e|0;var r=0;n=n+36|0;r=u[n>>2]|0;if(r|0){Qi(r);XE(r)}r=GE(4)|0;ho(r,e);u[n>>2]=r;return}function TM(){if(!(t[11716]|0)){u[2664]=0;xn(63,10656,b|0)|0;t[11716]=1}return 10656}function AM(){var n=0;if(!(t[11717]|0)){SM();u[2665]=1504;t[11717]=1;n=1504}else n=u[2665]|0;return n|0}function SM(){if(!(t[11740]|0)){t[11718]=Wa(Wa(8,0)|0,0)|0;t[11719]=Wa(Wa(0,0)|0,0)|0;t[11720]=Wa(Wa(0,16)|0,0)|0;t[11721]=Wa(Wa(8,0)|0,0)|0;t[11722]=Wa(Wa(0,0)|0,0)|0;t[11723]=Wa(Wa(8,0)|0,0)|0;t[11724]=Wa(Wa(0,0)|0,0)|0;t[11725]=Wa(Wa(8,0)|0,0)|0;t[11726]=Wa(Wa(0,0)|0,0)|0;t[11727]=Wa(Wa(8,0)|0,0)|0;t[11728]=Wa(Wa(0,0)|0,0)|0;t[11729]=Wa(Wa(0,0)|0,32)|0;t[11730]=Wa(Wa(0,0)|0,32)|0;t[11740]=1}return}function EM(){return 1572}function CM(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0,s=0;o=v;v=v+32|0;s=o+16|0;l=o+12|0;c=o+8|0;f=o+4|0;a=o;u[s>>2]=n;u[l>>2]=e;u[c>>2]=r;u[f>>2]=t;u[a>>2]=i;TM()|0;LM(10656,s,l,c,f,a);v=o;return}function LM(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0;a=GE(24)|0;Da(a+4|0,u[e>>2]|0,u[r>>2]|0,u[t>>2]|0,u[i>>2]|0,u[o>>2]|0);u[a>>2]=u[n>>2];u[n>>2]=a;return}function RM(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0;w=v;v=v+32|0;m=w+20|0;b=w+8|0;h=w+4|0;y=w;e=u[e>>2]|0;if(e|0){p=m+4|0;c=m+8|0;l=b+4|0;s=b+8|0;d=b+8|0;_=m+8|0;do{a=e+4|0;f=PM(a)|0;if(f|0){i=BM(f)|0;u[m>>2]=0;u[p>>2]=0;u[c>>2]=0;t=(OM(f)|0)+1|0;NM(m,t);if(t|0)while(1){t=t+-1|0;bS(b,u[i>>2]|0);o=u[p>>2]|0;if(o>>>0<(u[_>>2]|0)>>>0){u[o>>2]=u[b>>2];u[p>>2]=(u[p>>2]|0)+4}else IM(m,b);if(!t)break;else i=i+4|0}t=FM(f)|0;u[b>>2]=0;u[l>>2]=0;u[s>>2]=0;n:do{if(u[t>>2]|0){i=0;o=0;while(1){if((i|0)==(o|0))xM(b,t);else{u[i>>2]=u[t>>2];u[l>>2]=(u[l>>2]|0)+4}t=t+4|0;if(!(u[t>>2]|0))break n;i=u[l>>2]|0;o=u[d>>2]|0}}}while(0);u[h>>2]=UM(a)|0;u[y>>2]=Ja(f)|0;HM(r,n,h,y,m,b);DM(b);WM(m)}e=u[e>>2]|0}while((e|0)!=0)}v=w;return}function PM(n){n=n|0;return u[n+12>>2]|0}function BM(n){n=n|0;return u[n+12>>2]|0}function OM(n){n=n|0;return u[n+16>>2]|0}function NM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+32|0;r=i;t=u[n>>2]|0;if((u[n+8>>2]|0)-t>>2>>>0<e>>>0){wk(r,e,(u[n+4>>2]|0)-t>>2,n+8|0);Mk(n,r);kk(r)}v=i;return}function IM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0;a=v;v=v+32|0;r=a;t=n+4|0;i=((u[t>>2]|0)-(u[n>>2]|0)>>2)+1|0;o=mk(n)|0;if(o>>>0<i>>>0)DE(n);else{f=u[n>>2]|0;l=(u[n+8>>2]|0)-f|0;c=l>>1;wk(r,l>>2>>>0<o>>>1>>>0?c>>>0<i>>>0?i:c:o,(u[t>>2]|0)-f>>2,n+8|0);o=r+8|0;u[u[o>>2]>>2]=u[e>>2];u[o>>2]=(u[o>>2]|0)+4;Mk(n,r);kk(r);v=a;return}}function FM(n){n=n|0;return u[n+8>>2]|0}function xM(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0;a=v;v=v+32|0;r=a;t=n+4|0;i=((u[t>>2]|0)-(u[n>>2]|0)>>2)+1|0;o=_k(n)|0;if(o>>>0<i>>>0)DE(n);else{f=u[n>>2]|0;l=(u[n+8>>2]|0)-f|0;c=l>>1;bk(r,l>>2>>>0<o>>>1>>>0?c>>>0<i>>>0?i:c:o,(u[t>>2]|0)-f>>2,n+8|0);o=r+8|0;u[u[o>>2]>>2]=u[e>>2];u[o>>2]=(u[o>>2]|0)+4;hk(n,r);yk(r);v=a;return}}function UM(n){n=n|0;return u[n>>2]|0}function HM(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;YM(n,e,r,t,i,u);return}function DM(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-4-t|0)>>>2)<<2);XE(r)}return}function WM(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-4-t|0)>>>2)<<2);XE(r)}return}function YM(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0,d=0;a=v;v=v+48|0;s=a+40|0;f=a+32|0;d=a+24|0;c=a+12|0;l=a;gS(f);n=ko(n)|0;u[d>>2]=u[e>>2];r=u[r>>2]|0;t=u[t>>2]|0;VM(c,i);jM(l,o);u[s>>2]=u[d>>2];qM(n,s,r,t,c,l);DM(l);WM(c);AS(f);v=a;return}function VM(n,e){n=n|0;e=e|0;var r=0,t=0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;r=e+4|0;t=(u[r>>2]|0)-(u[e>>2]|0)>>2;if(t|0){vk(n,t);pk(n,u[e>>2]|0,u[r>>2]|0,t)}return}function jM(n,e){n=n|0;e=e|0;var r=0,t=0;u[n>>2]=0;u[n+4>>2]=0;u[n+8>>2]=0;r=e+4|0;t=(u[r>>2]|0)-(u[e>>2]|0)>>2;if(t|0){sk(n,t);dk(n,u[e>>2]|0,u[r>>2]|0,t)}return}function qM(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0,d=0;a=v;v=v+32|0;s=a+28|0;d=a+24|0;f=a+12|0;c=a;l=Ao(zM()|0)|0;u[d>>2]=u[e>>2];u[s>>2]=u[d>>2];e=GM(s)|0;r=KM(r)|0;t=XM(t)|0;u[f>>2]=u[i>>2];s=i+4|0;u[f+4>>2]=u[s>>2];d=i+8|0;u[f+8>>2]=u[d>>2];u[d>>2]=0;u[s>>2]=0;u[i>>2]=0;i=JM(f)|0;u[c>>2]=u[o>>2];s=o+4|0;u[c+4>>2]=u[s>>2];d=o+8|0;u[c+8>>2]=u[d>>2];u[d>>2]=0;u[s>>2]=0;u[o>>2]=0;Pn(0,l|0,n|0,e|0,r|0,t|0,i|0,ZM(c)|0)|0;DM(c);WM(f);v=a;return}function zM(){var n=0;if(!(t[7968]|0)){ck(10708);n=7968;u[n>>2]=1;u[n+4>>2]=0}return 10708}function GM(n){n=n|0;return ek(n)|0}function KM(n){n=n|0;return $M(n)|0}function XM(n){n=n|0;return $l(n)|0}function JM(n){n=n|0;return nk(n)|0}function ZM(n){n=n|0;return QM(n)|0}function QM(n){n=n|0;var e=0,r=0,t=0;t=(u[n+4>>2]|0)-(u[n>>2]|0)|0;r=t>>2;t=Dg(t+4|0)|0;u[t>>2]=r;if(r|0){e=0;do{u[t+4+(e<<2)>>2]=$M(u[(u[n>>2]|0)+(e<<2)>>2]|0)|0;e=e+1|0}while((e|0)!=(r|0))}return t|0}function $M(n){n=n|0;return n|0}function nk(n){n=n|0;var e=0,r=0,t=0;t=(u[n+4>>2]|0)-(u[n>>2]|0)|0;r=t>>2;t=Dg(t+4|0)|0;u[t>>2]=r;if(r|0){e=0;do{u[t+4+(e<<2)>>2]=ek((u[n>>2]|0)+(e<<2)|0)|0;e=e+1|0}while((e|0)!=(r|0))}return t|0}function ek(n){n=n|0;var e=0,r=0,t=0,i=0;i=v;v=v+32|0;e=i+12|0;r=i;t=ff(rk()|0)|0;if(!t)n=tk(n)|0;else{cf(e,t);lf(r,e);wS(n,r);n=df(e)|0}v=i;return n|0}function rk(){var n=0;if(!(t[7960]|0)){fk(10664);xn(25,10664,b|0)|0;n=7960;u[n>>2]=1;u[n+4>>2]=0}return 10664}function tk(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=v;v=v+16|0;i=r+4|0;a=r;t=Dg(8)|0;e=t;f=GE(4)|0;u[f>>2]=u[n>>2];o=e+4|0;u[o>>2]=f;n=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];ik(n,o,i);u[t>>2]=n;v=r;return e|0}function ik(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1656;u[r+12>>2]=e;u[n+4>>2]=r;return}function uk(n){n=n|0;WE(n);XE(n);return}function ok(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function ak(n){n=n|0;XE(n);return}function fk(n){n=n|0;Rf(n);return}function ck(n){n=n|0;xo(n,lk()|0,5);return}function lk(){return 1676}function sk(n,e){n=n|0;e=e|0;var r=0;if((_k(n)|0)>>>0<e>>>0)DE(n);if(e>>>0>1073741823)Xn();else{r=GE(e<<2)|0;u[n+4>>2]=r;u[n>>2]=r;u[n+8>>2]=r+(e<<2);return}}function dk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=n+4|0;n=r-e|0;if((n|0)>0){iC(u[t>>2]|0,e|0,n|0)|0;u[t>>2]=(u[t>>2]|0)+(n>>>2<<2)}return}function _k(n){n=n|0;return 1073741823}function vk(n,e){n=n|0;e=e|0;var r=0;if((mk(n)|0)>>>0<e>>>0)DE(n);if(e>>>0>1073741823)Xn();else{r=GE(e<<2)|0;u[n+4>>2]=r;u[n>>2]=r;u[n+8>>2]=r+(e<<2);return}}function pk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=n+4|0;n=r-e|0;if((n|0)>0){iC(u[t>>2]|0,e|0,n|0)|0;u[t>>2]=(u[t>>2]|0)+(n>>>2<<2)}return}function mk(n){n=n|0;return 1073741823}function bk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>1073741823)Xn();else{i=GE(e<<2)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<2)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<2);return}function hk(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>2)<<2)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function yk(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-4-e|0)>>>2)<<2);n=u[n>>2]|0;if(n|0)XE(n);return}function wk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>1073741823)Xn();else{i=GE(e<<2)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<2)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<2);return}function Mk(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>2)<<2)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function kk(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-4-e|0)>>>2)<<2);n=u[n>>2]|0;if(n|0)XE(n);return}function gk(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0;b=v;v=v+32|0;s=b+20|0;d=b+12|0;l=b+16|0;_=b+4|0;p=b;m=b+8|0;f=AM()|0;o=u[f>>2]|0;a=u[o>>2]|0;if(a|0){c=u[f+8>>2]|0;f=u[f+4>>2]|0;while(1){bS(s,a);Tk(n,s,f,c);o=o+4|0;a=u[o>>2]|0;if(!a)break;else{c=c+1|0;f=f+1|0}}}o=EM()|0;a=u[o>>2]|0;if(a|0)do{bS(s,a);u[d>>2]=u[o+4>>2];Ak(e,s,d);o=o+8|0;a=u[o>>2]|0}while((a|0)!=0);o=u[(sM()|0)>>2]|0;if(o|0)do{e=u[o+4>>2]|0;bS(s,u[(Sk(e)|0)>>2]|0);u[d>>2]=kM(e)|0;Ek(r,s,d);o=u[o>>2]|0}while((o|0)!=0);bS(l,0);o=TM()|0;u[s>>2]=u[l>>2];RM(s,o,i);o=u[(sM()|0)>>2]|0;if(o|0){n=s+4|0;e=s+8|0;r=s+8|0;do{c=u[o+4>>2]|0;bS(d,u[(Sk(c)|0)>>2]|0);Lk(_,Ck(c)|0);a=u[_>>2]|0;if(a|0){u[s>>2]=0;u[n>>2]=0;u[e>>2]=0;do{bS(p,u[(Sk(u[a+4>>2]|0)|0)>>2]|0);f=u[n>>2]|0;if(f>>>0<(u[r>>2]|0)>>>0){u[f>>2]=u[p>>2];u[n>>2]=(u[n>>2]|0)+4}else IM(s,p);a=u[a>>2]|0}while((a|0)!=0);Rk(t,d,s);WM(s)}u[m>>2]=u[d>>2];l=Pk(c)|0;u[s>>2]=u[m>>2];RM(s,l,i);Ef(_);o=u[o>>2]|0}while((o|0)!=0)}v=b;return}function Tk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;qk(n,e,r,t);return}function Ak(n,e,r){n=n|0;e=e|0;r=r|0;jk(n,e,r);return}function Sk(n){n=n|0;return n|0}function Ek(n,e,r){n=n|0;e=e|0;r=r|0;Hk(n,e,r);return}function Ck(n){n=n|0;return n+16|0}function Lk(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;o=v;v=v+16|0;i=o+8|0;r=o;u[n>>2]=0;t=u[e>>2]|0;u[i>>2]=t;u[r>>2]=n;r=xk(r)|0;if(t|0){t=GE(12)|0;a=(Uk(i)|0)+4|0;n=u[a+4>>2]|0;e=t+4|0;u[e>>2]=u[a>>2];u[e+4>>2]=n;e=u[u[i>>2]>>2]|0;u[i>>2]=e;if(!e)n=t;else{e=t;while(1){n=GE(12)|0;c=(Uk(i)|0)+4|0;f=u[c+4>>2]|0;a=n+4|0;u[a>>2]=u[c>>2];u[a+4>>2]=f;u[e>>2]=n;a=u[u[i>>2]>>2]|0;u[i>>2]=a;if(!a)break;else e=n}}u[n>>2]=u[r>>2];u[r>>2]=t}v=o;return}function Rk(n,e,r){n=n|0;e=e|0;r=r|0;Bk(n,e,r);return}function Pk(n){n=n|0;return n+24|0}function Bk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+32|0;a=t+24|0;i=t+16|0;f=t+12|0;o=t;gS(i);n=ko(n)|0;u[f>>2]=u[e>>2];VM(o,r);u[a>>2]=u[f>>2];Ok(n,a,o);WM(o);AS(i);v=t;return}function Ok(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0;t=v;v=v+32|0;a=t+16|0;f=t+12|0;i=t;o=Ao(Nk()|0)|0;u[f>>2]=u[e>>2];u[a>>2]=u[f>>2];e=GM(a)|0;u[i>>2]=u[r>>2];a=r+4|0;u[i+4>>2]=u[a>>2];f=r+8|0;u[i+8>>2]=u[f>>2];u[f>>2]=0;u[a>>2]=0;u[r>>2]=0;En(0,o|0,n|0,e|0,JM(i)|0)|0;WM(i);v=t;return}function Nk(){var n=0;if(!(t[7976]|0)){Ik(10720);n=7976;u[n>>2]=1;u[n+4>>2]=0}return 10720}function Ik(n){n=n|0;xo(n,Fk()|0,2);return}function Fk(){return 1732}function xk(n){n=n|0;return u[n>>2]|0}function Uk(n){n=n|0;return u[n>>2]|0}function Hk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+32|0;o=t+16|0;i=t+8|0;a=t;gS(i);n=ko(n)|0;u[a>>2]=u[e>>2];r=u[r>>2]|0;u[o>>2]=u[a>>2];Dk(n,o,r);AS(i);v=t;return}function Dk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+16|0;o=t+4|0;a=t;i=Ao(Wk()|0)|0;u[a>>2]=u[e>>2];u[o>>2]=u[a>>2];e=GM(o)|0;En(0,i|0,n|0,e|0,KM(r)|0)|0;v=t;return}function Wk(){var n=0;if(!(t[7984]|0)){Yk(10732);n=7984;u[n>>2]=1;u[n+4>>2]=0}return 10732}function Yk(n){n=n|0;xo(n,Vk()|0,2);return}function Vk(){return 1744}function jk(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0;t=v;v=v+32|0;o=t+16|0;i=t+8|0;a=t;gS(i);n=ko(n)|0;u[a>>2]=u[e>>2];r=u[r>>2]|0;u[o>>2]=u[a>>2];Dk(n,o,r);AS(i);v=t;return}function qk(n,e,r,i){n=n|0;e=e|0;r=r|0;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+32|0;f=o+16|0;a=o+8|0;c=o;gS(a);n=ko(n)|0;u[c>>2]=u[e>>2];r=t[r>>0]|0;i=t[i>>0]|0;u[f>>2]=u[c>>2];zk(n,f,r,i);AS(a);v=o;return}function zk(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;a=i+4|0;f=i;o=Ao(Gk()|0)|0;u[f>>2]=u[e>>2];u[a>>2]=u[f>>2];e=GM(a)|0;r=Kk(r)|0;te(0,o|0,n|0,e|0,r|0,Kk(t)|0)|0;v=i;return}function Gk(){var n=0;if(!(t[7992]|0)){Jk(10744);n=7992;u[n>>2]=1;u[n+4>>2]=0}return 10744}function Kk(n){n=n|0;return Xk(n)|0}function Xk(n){n=n|0;return n&255|0}function Jk(n){n=n|0;xo(n,Zk()|0,3);return}function Zk(){return 1756}function Qk(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0;p=v;v=v+32|0;c=p+8|0;l=p+4|0;s=p+20|0;d=p;qc(n,0);i=yS(e)|0;u[c>>2]=0;_=c+4|0;u[_>>2]=0;u[c+8>>2]=0;switch(i<<24>>24){case 0:{t[s>>0]=0;$k(l,r,s);ng(n,l)|0;$i(l);break}case 8:{_=hS(e)|0;t[s>>0]=8;bS(d,u[_+4>>2]|0);eg(l,r,s,d,_+8|0);ng(n,l)|0;$i(l);break}case 9:{a=hS(e)|0;e=u[a+4>>2]|0;if(e|0){f=c+8|0;o=a+12|0;while(1){e=e+-1|0;bS(l,u[o>>2]|0);i=u[_>>2]|0;if(i>>>0<(u[f>>2]|0)>>>0){u[i>>2]=u[l>>2];u[_>>2]=(u[_>>2]|0)+4}else IM(c,l);if(!e)break;else o=o+4|0}}t[s>>0]=9;bS(d,u[a+8>>2]|0);rg(l,r,s,d,c);ng(n,l)|0;$i(l);break}default:{_=hS(e)|0;t[s>>0]=i;bS(d,u[_+4>>2]|0);tg(l,r,s,d);ng(n,l)|0;$i(l)}}WM(c);v=p;return}function $k(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,u=0;i=v;v=v+16|0;u=i;gS(u);e=ko(e)|0;bg(n,e,t[r>>0]|0);AS(u);v=i;return}function ng(n,e){n=n|0;e=e|0;var r=0;r=u[n>>2]|0;if(r|0)ie(r|0);u[n>>2]=u[e>>2];u[e>>2]=0;return n|0}function eg(n,e,r,i,o){n=n|0;e=e|0;r=r|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0;a=v;v=v+32|0;c=a+16|0;f=a+8|0;l=a;gS(f);e=ko(e)|0;r=t[r>>0]|0;u[l>>2]=u[i>>2];o=u[o>>2]|0;u[c>>2]=u[l>>2];_g(n,e,r,c,o);AS(f);v=a;return}function rg(n,e,r,i,o){n=n|0;e=e|0;r=r|0;i=i|0;o=o|0;var a=0,f=0,c=0,l=0,s=0;a=v;v=v+32|0;l=a+24|0;f=a+16|0;s=a+12|0;c=a;gS(f);e=ko(e)|0;r=t[r>>0]|0;u[s>>2]=u[i>>2];VM(c,o);u[l>>2]=u[s>>2];cg(n,e,r,l,c);WM(c);AS(f);v=a;return}function tg(n,e,r,i){n=n|0;e=e|0;r=r|0;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+32|0;f=o+16|0;a=o+8|0;c=o;gS(a);e=ko(e)|0;r=t[r>>0]|0;u[c>>2]=u[i>>2];u[f>>2]=u[c>>2];ig(n,e,r,f);AS(a);v=o;return}function ig(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0,a=0,f=0;i=v;v=v+16|0;o=i+4|0;f=i;a=Ao(ug()|0)|0;r=Kk(r)|0;u[f>>2]=u[t>>2];u[o>>2]=u[f>>2];og(n,En(0,a|0,e|0,r|0,GM(o)|0)|0);v=i;return}function ug(){var n=0;if(!(t[8e3]|0)){ag(10756);n=8e3;u[n>>2]=1;u[n+4>>2]=0}return 10756}function og(n,e){n=n|0;e=e|0;qc(n,e);return}function ag(n){n=n|0;xo(n,fg()|0,2);return}function fg(){return 1772}function cg(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0;o=v;v=v+32|0;c=o+16|0;l=o+12|0;a=o;f=Ao(lg()|0)|0;r=Kk(r)|0;u[l>>2]=u[t>>2];u[c>>2]=u[l>>2];t=GM(c)|0;u[a>>2]=u[i>>2];c=i+4|0;u[a+4>>2]=u[c>>2];l=i+8|0;u[a+8>>2]=u[l>>2];u[l>>2]=0;u[c>>2]=0;u[i>>2]=0;og(n,te(0,f|0,e|0,r|0,t|0,JM(a)|0)|0);WM(a);v=o;return}function lg(){var n=0;if(!(t[8008]|0)){sg(10768);n=8008;u[n>>2]=1;u[n+4>>2]=0}return 10768}function sg(n){n=n|0;xo(n,dg()|0,3);return}function dg(){return 1784}function _g(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0;o=v;v=v+16|0;f=o+4|0;c=o;a=Ao(vg()|0)|0;r=Kk(r)|0;u[c>>2]=u[t>>2];u[f>>2]=u[c>>2];t=GM(f)|0;og(n,te(0,a|0,e|0,r|0,t|0,XM(i)|0)|0);v=o;return}function vg(){var n=0;if(!(t[8016]|0)){pg(10780);n=8016;u[n>>2]=1;u[n+4>>2]=0}return 10780}function pg(n){n=n|0;xo(n,mg()|0,3);return}function mg(){return 1800}function bg(n,e,r){n=n|0;e=e|0;r=r|0;var t=0;t=Ao(hg()|0)|0;og(n,ue(0,t|0,e|0,Kk(r)|0)|0);return}function hg(){var n=0;if(!(t[8024]|0)){yg(10792);n=8024;u[n>>2]=1;u[n+4>>2]=0}return 10792}function yg(n){n=n|0;xo(n,wg()|0,1);return}function wg(){return 1816}function Mg(){kg();gg();Tg();return}function kg(){u[2702]=KE(65536)|0;return}function gg(){Gg(10856);return}function Tg(){Ag(10816);return}function Ag(n){n=n|0;Sg(n,5044);Eg(n)|0;return}function Sg(n,e){n=n|0;e=e|0;var r=0;r=rk()|0;u[n>>2]=r;Wg(r,e);lM(u[n>>2]|0);return}function Eg(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,Cg()|0);return n|0}function Cg(){var n=0;if(!(t[8032]|0)){Lg(10820);xn(64,10820,b|0)|0;n=8032;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(10820)|0))Lg(10820);return 10820}function Lg(n){n=n|0;Bg(n);cy(n,25);return}function Rg(n){n=n|0;Pg(n+24|0);return}function Pg(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function Bg(n){n=n|0;var e=0;e=$a()|0;rf(n,5,18,e,xg()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function Og(n,e){n=n|0;e=e|0;Ng(n,e);return}function Ng(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;r=v;v=v+16|0;t=r;i=r+4|0;sl(i,e);u[t>>2]=dl(i,e)|0;Ig(n,t);v=r;return}function Ig(n,e){n=n|0;e=e|0;Fg(n+4|0,u[e>>2]|0);t[n+8>>0]=1;return}function Fg(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function xg(){return 1824}function Ug(n){n=n|0;return Hg(n)|0}function Hg(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0;r=v;v=v+16|0;i=r+4|0;a=r;t=Dg(8)|0;e=t;f=GE(4)|0;sl(i,n);Fg(f,dl(i,n)|0);o=e+4|0;u[o>>2]=f;n=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];ik(n,o,i);u[t>>2]=n;v=r;return e|0}function Dg(n){n=n|0;var e=0,r=0;n=n+7&-8;if(n>>>0<=32768?(e=u[2701]|0,n>>>0<=(65536-e|0)>>>0):0){r=(u[2702]|0)+e|0;u[2701]=e+n;n=r}else{n=KE(n+8|0)|0;u[n>>2]=u[2703];u[2703]=n;n=n+8|0}return n|0}function Wg(n,e){n=n|0;e=e|0;u[n>>2]=Yg()|0;u[n+4>>2]=Vg()|0;u[n+12>>2]=e;u[n+8>>2]=jg()|0;u[n+32>>2]=9;return}function Yg(){return 11744}function Vg(){return 1832}function jg(){return Oy()|0}function qg(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){zg(r);XE(r)}}else if(e|0)XE(e);return}function zg(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function Gg(n){n=n|0;Kg(n,5052);Xg(n)|0;Jg(n,5058,26)|0;Zg(n,5069,1)|0;Qg(n,5077,10)|0;$g(n,5087,19)|0;eT(n,5094,27)|0;return}function Kg(n,e){n=n|0;e=e|0;var r=0;r=cS()|0;u[n>>2]=r;lS(r,e);lM(u[n>>2]|0);return}function Xg(n){n=n|0;var e=0;e=u[n>>2]|0;ty(e,KA()|0);return n|0}function Jg(n,e,r){n=n|0;e=e|0;r=r|0;EA(n,Ba(e)|0,r,0);return n|0}function Zg(n,e,r){n=n|0;e=e|0;r=r|0;cA(n,Ba(e)|0,r,0);return n|0}function Qg(n,e,r){n=n|0;e=e|0;r=r|0;UT(n,Ba(e)|0,r,0);return n|0}function $g(n,e,r){n=n|0;e=e|0;r=r|0;wT(n,Ba(e)|0,r,0);return n|0}function nT(n,e){n=n|0;e=e|0;var r=0,t=0;n:while(1){r=u[2703]|0;while(1){if((r|0)==(e|0))break n;t=u[r>>2]|0;u[2703]=t;if(!r)r=t;else break}XE(r)}u[2701]=n;return}function eT(n,e,r){n=n|0;e=e|0;r=r|0;rT(n,Ba(e)|0,r,0);return n|0}function rT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=tT()|0;n=iT(r)|0;xa(o,e,i,n,uT(r,t)|0,t);return}function tT(){var n=0,e=0;if(!(t[8040]|0)){dT(10860);xn(65,10860,b|0)|0;e=8040;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10860)|0)){n=10860;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));dT(10860)}return 10860}function iT(n){n=n|0;return n|0}function uT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=tT()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){oT(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{aT(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function oT(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function aT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=fT(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;cT(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;oT(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;lT(n,i);sT(i);v=f;return}}function fT(n){n=n|0;return 536870911}function cT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function lT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function sT(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function dT(n){n=n|0;pT(n);return}function _T(n){n=n|0;vT(n+24|0);return}function vT(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function pT(n){n=n|0;var e=0;e=$a()|0;rf(n,1,11,e,mT()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function mT(){return 1840}function bT(n,e,r){n=n|0;e=e|0;r=r|0;yT(u[(hT(n)|0)>>2]|0,e,r);return}function hT(n){n=n|0;return(u[(tT()|0)+24>>2]|0)+(n<<3)|0}function yT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,u=0;t=v;v=v+16|0;u=t+1|0;i=t;sl(u,e);e=dl(u,e)|0;sl(i,r);r=dl(i,r)|0;pL[n&31](e,r);v=t;return}function wT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=MT()|0;n=kT(r)|0;xa(o,e,i,n,gT(r,t)|0,t);return}function MT(){var n=0,e=0;if(!(t[8048]|0)){RT(10896);xn(66,10896,b|0)|0;e=8048;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10896)|0)){n=10896;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));RT(10896)}return 10896}function kT(n){n=n|0;return n|0}function gT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=MT()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){TT(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{AT(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function TT(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function AT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=ST(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;ET(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;TT(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;CT(n,i);LT(i);v=f;return}}function ST(n){n=n|0;return 536870911}function ET(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function CT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function LT(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function RT(n){n=n|0;OT(n);return}function PT(n){n=n|0;BT(n+24|0);return}function BT(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function OT(n){n=n|0;var e=0;e=$a()|0;rf(n,1,11,e,NT()|0,1);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function NT(){return 1852}function IT(n,e){n=n|0;e=e|0;return xT(u[(FT(n)|0)>>2]|0,e)|0}function FT(n){n=n|0;return(u[(MT()|0)+24>>2]|0)+(n<<3)|0}function xT(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;sl(t,e);e=dl(t,e)|0;e=$l(mL[n&31](e)|0)|0;v=r;return e|0}function UT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=HT()|0;n=DT(r)|0;xa(o,e,i,n,WT(r,t)|0,t);return}function HT(){var n=0,e=0;if(!(t[8056]|0)){KT(10932);xn(67,10932,b|0)|0;e=8056;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10932)|0)){n=10932;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));KT(10932)}return 10932}function DT(n){n=n|0;return n|0}function WT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=HT()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){YT(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{VT(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function YT(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function VT(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=jT(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;qT(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;YT(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;zT(n,i);GT(i);v=f;return}}function jT(n){n=n|0;return 536870911}function qT(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function zT(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function GT(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function KT(n){n=n|0;ZT(n);return}function XT(n){n=n|0;JT(n+24|0);return}function JT(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function ZT(n){n=n|0;var e=0;e=$a()|0;rf(n,1,7,e,QT()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function QT(){return 1860}function $T(n,e,r){n=n|0;e=e|0;r=r|0;return eA(u[(nA(n)|0)>>2]|0,e,r)|0}function nA(n){n=n|0;return(u[(HT()|0)+24>>2]|0)+(n<<3)|0}function eA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0;t=v;v=v+32|0;a=t+12|0;o=t+8|0;f=t;c=t+16|0;i=t+4|0;rA(c,e);tA(f,c,e);Wc(i,r);r=Yc(i,r)|0;u[a>>2]=u[f>>2];PL[n&15](o,a,r);r=iA(o)|0;$i(o);Vc(i);v=t;return r|0}function rA(n,e){n=n|0;e=e|0;return}function tA(n,e,r){n=n|0;e=e|0;r=r|0;uA(n,r);return}function iA(n){n=n|0;return ko(n)|0}function uA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0;i=v;v=v+16|0;r=i;t=e;if(!(t&1))u[n>>2]=u[e>>2];else{oA(r,0);Hn(t|0,r|0)|0;aA(n,r);fA(r)}v=i;return}function oA(n,e){n=n|0;e=e|0;Bo(n,e);u[n+4>>2]=0;t[n+8>>0]=0;return}function aA(n,e){n=n|0;e=e|0;u[n>>2]=u[e+4>>2];return}function fA(n){n=n|0;t[n+8>>0]=0;return}function cA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=lA()|0;n=sA(r)|0;xa(o,e,i,n,dA(r,t)|0,t);return}function lA(){var n=0,e=0;if(!(t[8064]|0)){yA(10968);xn(68,10968,b|0)|0;e=8064;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(10968)|0)){n=10968;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));yA(10968)}return 10968}function sA(n){n=n|0;return n|0}function dA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=lA()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){_A(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{vA(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function _A(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function vA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=pA(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;mA(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;_A(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;bA(n,i);hA(i);v=f;return}}function pA(n){n=n|0;return 536870911}function mA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function bA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function hA(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function yA(n){n=n|0;kA(n);return}function wA(n){n=n|0;MA(n+24|0);return}function MA(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function kA(n){n=n|0;var e=0;e=$a()|0;rf(n,1,1,e,gA()|0,5);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function gA(){return 1872}function TA(n,e,r,t,i,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;o=o|0;SA(u[(AA(n)|0)>>2]|0,e,r,t,i,o);return}function AA(n){n=n|0;return(u[(lA()|0)+24>>2]|0)+(n<<3)|0}function SA(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;var o=0,a=0,f=0,c=0,l=0,s=0;o=v;v=v+32|0;a=o+16|0;f=o+12|0;c=o+8|0;l=o+4|0;s=o;Wc(a,e);e=Yc(a,e)|0;Wc(f,r);r=Yc(f,r)|0;Wc(c,t);t=Yc(c,t)|0;Wc(l,i);i=Yc(l,i)|0;Wc(s,u);u=Yc(s,u)|0;lL[n&1](e,r,t,i,u);Vc(s);Vc(l);Vc(c);Vc(f);Vc(a);v=o;return}function EA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=u[n>>2]|0;i=CA()|0;n=LA(r)|0;xa(o,e,i,n,RA(r,t)|0,t);return}function CA(){var n=0,e=0;if(!(t[8072]|0)){xA(11004);xn(69,11004,b|0)|0;e=8072;u[e>>2]=1;u[e+4>>2]=0}if(!(Ja(11004)|0)){n=11004;e=n+36|0;do{u[n>>2]=0;n=n+4|0}while((n|0)<(e|0));xA(11004)}return 11004}function LA(n){n=n|0;return n|0}function RA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0,f=0,c=0;f=v;v=v+16|0;i=f;o=f+4|0;u[i>>2]=n;c=CA()|0;a=c+24|0;e=Wa(e,4)|0;u[o>>2]=e;r=c+28|0;t=u[r>>2]|0;if(t>>>0<(u[c+32>>2]|0)>>>0){PA(t,n,e);e=(u[r>>2]|0)+8|0;u[r>>2]=e}else{BA(a,i,o);e=u[r>>2]|0}v=f;return(e-(u[a>>2]|0)>>3)+-1|0}function PA(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;u[n+4>>2]=r;return}function BA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0;f=v;v=v+32|0;i=f;o=n+4|0;a=((u[o>>2]|0)-(u[n>>2]|0)>>3)+1|0;t=OA(n)|0;if(t>>>0<a>>>0)DE(n);else{c=u[n>>2]|0;s=(u[n+8>>2]|0)-c|0;l=s>>2;NA(i,s>>3>>>0<t>>>1>>>0?l>>>0<a>>>0?a:l:t,(u[o>>2]|0)-c>>3,n+8|0);a=i+8|0;PA(u[a>>2]|0,u[e>>2]|0,u[r>>2]|0);u[a>>2]=(u[a>>2]|0)+8;IA(n,i);FA(i);v=f;return}}function OA(n){n=n|0;return 536870911}function NA(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0;u[n+12>>2]=0;u[n+16>>2]=t;do{if(e){if(e>>>0>536870911)Xn();else{i=GE(e<<3)|0;break}}else i=0}while(0);u[n>>2]=i;t=i+(r<<3)|0;u[n+8>>2]=t;u[n+4>>2]=t;u[n+12>>2]=i+(e<<3);return}function IA(n,e){n=n|0;e=e|0;var r=0,t=0,i=0,o=0,a=0;t=u[n>>2]|0;a=n+4|0;o=e+4|0;i=(u[a>>2]|0)-t|0;r=(u[o>>2]|0)+(0-(i>>3)<<3)|0;u[o>>2]=r;if((i|0)>0){iC(r|0,t|0,i|0)|0;t=o;r=u[o>>2]|0}else t=o;o=u[n>>2]|0;u[n>>2]=r;u[t>>2]=o;o=e+8|0;i=u[a>>2]|0;u[a>>2]=u[o>>2];u[o>>2]=i;o=n+8|0;a=e+12|0;n=u[o>>2]|0;u[o>>2]=u[a>>2];u[a>>2]=n;u[e>>2]=u[t>>2];return}function FA(n){n=n|0;var e=0,r=0,t=0;e=u[n+4>>2]|0;r=n+8|0;t=u[r>>2]|0;if((t|0)!=(e|0))u[r>>2]=t+(~((t+-8-e|0)>>>3)<<3);n=u[n>>2]|0;if(n|0)XE(n);return}function xA(n){n=n|0;DA(n);return}function UA(n){n=n|0;HA(n+24|0);return}function HA(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function DA(n){n=n|0;var e=0;e=$a()|0;rf(n,1,12,e,WA()|0,2);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function WA(){return 1896}function YA(n,e,r){n=n|0;e=e|0;r=r|0;jA(u[(VA(n)|0)>>2]|0,e,r);return}function VA(n){n=n|0;return(u[(CA()|0)+24>>2]|0)+(n<<3)|0}function jA(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,u=0;t=v;v=v+16|0;u=t+4|0;i=t;qA(u,e);e=zA(u,e)|0;Wc(i,r);r=Yc(i,r)|0;pL[n&31](e,r);Vc(i);v=t;return}function qA(n,e){n=n|0;e=e|0;return}function zA(n,e){n=n|0;e=e|0;return GA(e)|0}function GA(n){n=n|0;return n|0}function KA(){var n=0;if(!(t[8080]|0)){XA(11040);xn(70,11040,b|0)|0;n=8080;u[n>>2]=1;u[n+4>>2]=0}if(!(Ja(11040)|0))XA(11040);return 11040}function XA(n){n=n|0;QA(n);cy(n,71);return}function JA(n){n=n|0;ZA(n+24|0);return}function ZA(n){n=n|0;var e=0,r=0,t=0;r=u[n>>2]|0;t=r;if(r|0){n=n+4|0;e=u[n>>2]|0;if((e|0)!=(r|0))u[n>>2]=e+(~((e+-8-t|0)>>>3)<<3);XE(r)}return}function QA(n){n=n|0;var e=0;e=$a()|0;rf(n,5,7,e,rS()|0,0);u[n+24>>2]=0;u[n+28>>2]=0;u[n+32>>2]=0;return}function $A(n){n=n|0;nS(n);return}function nS(n){n=n|0;eS(n);return}function eS(n){n=n|0;t[n+8>>0]=1;return}function rS(){return 1936}function tS(){return iS()|0}function iS(){var n=0,e=0,r=0,t=0,i=0,o=0,a=0;e=v;v=v+16|0;i=e+4|0;a=e;r=Dg(8)|0;n=r;o=n+4|0;u[o>>2]=GE(1)|0;t=GE(8)|0;o=u[o>>2]|0;u[a>>2]=0;u[i>>2]=u[a>>2];uS(t,o,i);u[r>>2]=t;v=e;return n|0}function uS(n,e,r){n=n|0;e=e|0;r=r|0;u[n>>2]=e;r=GE(16)|0;u[r+4>>2]=0;u[r+8>>2]=0;u[r>>2]=1916;u[r+12>>2]=e;u[n+4>>2]=r;return}function oS(n){n=n|0;WE(n);XE(n);return}function aS(n){n=n|0;n=u[n+12>>2]|0;if(n|0)XE(n);return}function fS(n){n=n|0;XE(n);return}function cS(){var n=0;if(!(t[8088]|0)){mS(11076);xn(25,11076,b|0)|0;n=8088;u[n>>2]=1;u[n+4>>2]=0}return 11076}function lS(n,e){n=n|0;e=e|0;u[n>>2]=sS()|0;u[n+4>>2]=dS()|0;u[n+12>>2]=e;u[n+8>>2]=_S()|0;u[n+32>>2]=10;return}function sS(){return 11745}function dS(){return 1940}function _S(){return Ym()|0}function vS(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;if((Dm(t,896)|0)==512){if(r|0){pS(r);XE(r)}}else if(e|0)XE(e);return}function pS(n){n=n|0;n=u[n+4>>2]|0;if(n|0)qE(n);return}function mS(n){n=n|0;Rf(n);return}function bS(n,e){n=n|0;e=e|0;u[n>>2]=e;return}function hS(n){n=n|0;return u[n>>2]|0}function yS(n){n=n|0;return t[u[n>>2]>>0]|0}function wS(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;u[t>>2]=u[n>>2];MS(e,t)|0;v=r;return}function MS(n,e){n=n|0;e=e|0;var r=0;r=kS(u[n>>2]|0,e)|0;e=n+4|0;u[(u[e>>2]|0)+8>>2]=r;return u[(u[e>>2]|0)+8>>2]|0}function kS(n,e){n=n|0;e=e|0;var r=0,t=0;r=v;v=v+16|0;t=r;gS(t);n=ko(n)|0;e=TS(n,u[e>>2]|0)|0;AS(t);v=r;return e|0}function gS(n){n=n|0;u[n>>2]=u[2701];u[n+4>>2]=u[2703];return}function TS(n,e){n=n|0;e=e|0;var r=0;r=Ao(SS()|0)|0;return ue(0,r|0,n|0,XM(e)|0)|0}function AS(n){n=n|0;nT(u[n>>2]|0,u[n+4>>2]|0);return}function SS(){var n=0;if(!(t[8096]|0)){ES(11120);n=8096;u[n>>2]=1;u[n+4>>2]=0}return 11120}function ES(n){n=n|0;xo(n,CS()|0,1);return}function CS(){return 1948}function LS(){RS();return}function RS(){var n=0,e=0,r=0,i=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0;h=v;v=v+16|0;_=h+4|0;p=h;Nn(65536,10804,u[2702]|0,10812);r=AM()|0;e=u[r>>2]|0;n=u[e>>2]|0;if(n|0){i=u[r+8>>2]|0;r=u[r+4>>2]|0;while(1){Yn(n|0,o[r>>0]|0|0,t[i>>0]|0);e=e+4|0;n=u[e>>2]|0;if(!n)break;else{i=i+1|0;r=r+1|0}}}n=EM()|0;e=u[n>>2]|0;if(e|0)do{Vn(e|0,u[n+4>>2]|0);n=n+8|0;e=u[n>>2]|0}while((e|0)!=0);Vn(PS()|0,5167);d=sM()|0;n=u[d>>2]|0;n:do{if(n|0){do{BS(u[n+4>>2]|0);n=u[n>>2]|0}while((n|0)!=0);n=u[d>>2]|0;if(n|0){s=d;do{while(1){a=n;n=u[n>>2]|0;a=u[a+4>>2]|0;if(!(OS(a)|0))break;u[p>>2]=s;u[_>>2]=u[p>>2];NS(d,_)|0;if(!n)break n}IS(a);s=u[s>>2]|0;e=FS(a)|0;f=Zn()|0;c=v;v=v+((1*(e<<2)|0)+15&-16)|0;l=v;v=v+((1*(e<<2)|0)+15&-16)|0;e=u[(Ck(a)|0)>>2]|0;if(e|0){r=c;i=l;while(1){u[r>>2]=u[(Sk(u[e+4>>2]|0)|0)>>2];u[i>>2]=u[e+8>>2];e=u[e>>2]|0;if(!e)break;else{r=r+4|0;i=i+4|0}}}y=Sk(a)|0;e=xS(a)|0;r=FS(a)|0;i=US(a)|0;Gn(y|0,e|0,c|0,l|0,r|0,i|0,kM(a)|0);Fn(f|0)}while((n|0)!=0)}}}while(0);n=u[(TM()|0)>>2]|0;if(n|0)do{y=n+4|0;d=PM(y)|0;a=FM(d)|0;f=BM(d)|0;c=(OM(d)|0)+1|0;l=HS(d)|0;s=DS(y)|0;d=Ja(d)|0;_=UM(y)|0;p=WS(y)|0;qn(0,a|0,f|0,c|0,l|0,s|0,d|0,_|0,p|0,YS(y)|0);n=u[n>>2]|0}while((n|0)!=0);n=u[(sM()|0)>>2]|0;n:do{if(n|0){e:while(1){e=u[n+4>>2]|0;if(e|0?(m=u[(Sk(e)|0)>>2]|0,b=u[(Pk(e)|0)>>2]|0,b|0):0){r=b;do{e=r+4|0;i=PM(e)|0;r:do{if(i|0)switch(Ja(i)|0){case 0:break e;case 4:case 3:case 2:{l=FM(i)|0;s=BM(i)|0;d=(OM(i)|0)+1|0;_=HS(i)|0;p=Ja(i)|0;y=UM(e)|0;qn(m|0,l|0,s|0,d|0,_|0,0,p|0,y|0,WS(e)|0,YS(e)|0);break r}case 1:{c=FM(i)|0;l=BM(i)|0;s=(OM(i)|0)+1|0;d=HS(i)|0;_=DS(e)|0;p=Ja(i)|0;y=UM(e)|0;qn(m|0,c|0,l|0,s|0,d|0,_|0,p|0,y|0,WS(e)|0,YS(e)|0);break r}case 5:{d=FM(i)|0;_=BM(i)|0;p=(OM(i)|0)+1|0;y=HS(i)|0;qn(m|0,d|0,_|0,p|0,y|0,VS(i)|0,Ja(i)|0,0,0,0);break r}default:break r}}while(0);r=u[r>>2]|0}while((r|0)!=0)}n=u[n>>2]|0;if(!n)break n}Xn()}}while(0);Kn();v=h;return}function PS(){return 11703}function BS(n){n=n|0;t[n+40>>0]=0;return}function OS(n){n=n|0;return(t[n+40>>0]|0)!=0|0}function NS(n,e){n=n|0;e=e|0;e=jS(e)|0;n=u[e>>2]|0;u[e>>2]=u[n>>2];XE(n);return u[e>>2]|0}function IS(n){n=n|0;t[n+40>>0]=1;return}function FS(n){n=n|0;return u[n+20>>2]|0}function xS(n){n=n|0;return u[n+8>>2]|0}function US(n){n=n|0;return u[n+32>>2]|0}function HS(n){n=n|0;return u[n+4>>2]|0}function DS(n){n=n|0;return u[n+4>>2]|0}function WS(n){n=n|0;return u[n+8>>2]|0}function YS(n){n=n|0;return u[n+16>>2]|0}function VS(n){n=n|0;return u[n+20>>2]|0}function jS(n){n=n|0;return u[n>>2]|0}function qS(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0,M=0,k=0,g=0;g=v;v=v+16|0;_=g;do{if(n>>>0<245){l=n>>>0<11?16:n+11&-8;n=l>>>3;d=u[2783]|0;r=d>>>n;if(r&3|0){e=(r&1^1)+n|0;n=11172+(e<<1<<2)|0;r=n+8|0;t=u[r>>2]|0;i=t+8|0;o=u[i>>2]|0;if((n|0)==(o|0))u[2783]=d&~(1<<e);else{u[o+12>>2]=n;u[r>>2]=o}k=e<<3;u[t+4>>2]=k|3;k=t+k+4|0;u[k>>2]=u[k>>2]|1;k=i;v=g;return k|0}s=u[2785]|0;if(l>>>0>s>>>0){if(r|0){e=2<<n;e=r<<n&(e|0-e);e=(e&0-e)+-1|0;a=e>>>12&16;e=e>>>a;r=e>>>5&8;e=e>>>r;i=e>>>2&4;e=e>>>i;n=e>>>1&2;e=e>>>n;t=e>>>1&1;t=(r|a|i|n|t)+(e>>>t)|0;e=11172+(t<<1<<2)|0;n=e+8|0;i=u[n>>2]|0;a=i+8|0;r=u[a>>2]|0;if((e|0)==(r|0)){n=d&~(1<<t);u[2783]=n}else{u[r+12>>2]=e;u[n>>2]=r;n=d}o=(t<<3)-l|0;u[i+4>>2]=l|3;t=i+l|0;u[t+4>>2]=o|1;u[t+o>>2]=o;if(s|0){i=u[2788]|0;e=s>>>3;r=11172+(e<<1<<2)|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=i;u[e+12>>2]=i;u[i+8>>2]=e;u[i+12>>2]=r}u[2785]=o;u[2788]=t;k=a;v=g;return k|0}f=u[2784]|0;if(f){r=(f&0-f)+-1|0;a=r>>>12&16;r=r>>>a;o=r>>>5&8;r=r>>>o;c=r>>>2&4;r=r>>>c;t=r>>>1&2;r=r>>>t;n=r>>>1&1;n=u[11436+((o|a|c|t|n)+(r>>>n)<<2)>>2]|0;r=(u[n+4>>2]&-8)-l|0;t=u[n+16+(((u[n+16>>2]|0)==0&1)<<2)>>2]|0;if(!t){c=n;o=r}else{do{a=(u[t+4>>2]&-8)-l|0;c=a>>>0<r>>>0;r=c?a:r;n=c?t:n;t=u[t+16+(((u[t+16>>2]|0)==0&1)<<2)>>2]|0}while((t|0)!=0);c=n;o=r}a=c+l|0;if(c>>>0<a>>>0){i=u[c+24>>2]|0;e=u[c+12>>2]|0;do{if((e|0)==(c|0)){n=c+20|0;e=u[n>>2]|0;if(!e){n=c+16|0;e=u[n>>2]|0;if(!e){r=0;break}}while(1){r=e+20|0;t=u[r>>2]|0;if(t|0){e=t;n=r;continue}r=e+16|0;t=u[r>>2]|0;if(!t)break;else{e=t;n=r}}u[n>>2]=0;r=e}else{r=u[c+8>>2]|0;u[r+12>>2]=e;u[e+8>>2]=r;r=e}}while(0);do{if(i|0){e=u[c+28>>2]|0;n=11436+(e<<2)|0;if((c|0)==(u[n>>2]|0)){u[n>>2]=r;if(!r){u[2784]=f&~(1<<e);break}}else{u[i+16+(((u[i+16>>2]|0)!=(c|0)&1)<<2)>>2]=r;if(!r)break}u[r+24>>2]=i;e=u[c+16>>2]|0;if(e|0){u[r+16>>2]=e;u[e+24>>2]=r}e=u[c+20>>2]|0;if(e|0){u[r+20>>2]=e;u[e+24>>2]=r}}}while(0);if(o>>>0<16){k=o+l|0;u[c+4>>2]=k|3;k=c+k+4|0;u[k>>2]=u[k>>2]|1}else{u[c+4>>2]=l|3;u[a+4>>2]=o|1;u[a+o>>2]=o;if(s|0){t=u[2788]|0;e=s>>>3;r=11172+(e<<1<<2)|0;e=1<<e;if(!(d&e)){u[2783]=d|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=t;u[e+12>>2]=t;u[t+8>>2]=e;u[t+12>>2]=r}u[2785]=o;u[2788]=a}k=c+8|0;v=g;return k|0}else d=l}else d=l}else d=l}else if(n>>>0<=4294967231){n=n+11|0;l=n&-8;c=u[2784]|0;if(c){t=0-l|0;n=n>>>8;if(n){if(l>>>0>16777215)f=31;else{d=(n+1048320|0)>>>16&8;M=n<<d;s=(M+520192|0)>>>16&4;M=M<<s;f=(M+245760|0)>>>16&2;f=14-(s|d|f)+(M<<f>>>15)|0;f=l>>>(f+7|0)&1|f<<1}}else f=0;r=u[11436+(f<<2)>>2]|0;n:do{if(!r){r=0;n=0;M=57}else{n=0;a=l<<((f|0)==31?0:25-(f>>>1)|0);o=0;while(1){i=(u[r+4>>2]&-8)-l|0;if(i>>>0<t>>>0)if(!i){n=r;t=0;i=r;M=61;break n}else{n=r;t=i}i=u[r+20>>2]|0;r=u[r+16+(a>>>31<<2)>>2]|0;o=(i|0)==0|(i|0)==(r|0)?o:i;i=(r|0)==0;if(i){r=o;M=57;break}else a=a<<((i^1)&1)}}}while(0);if((M|0)==57){if((r|0)==0&(n|0)==0){n=2<<f;n=c&(n|0-n);if(!n){d=l;break}d=(n&0-n)+-1|0;a=d>>>12&16;d=d>>>a;o=d>>>5&8;d=d>>>o;f=d>>>2&4;d=d>>>f;s=d>>>1&2;d=d>>>s;r=d>>>1&1;n=0;r=u[11436+((o|a|f|s|r)+(d>>>r)<<2)>>2]|0}if(!r){f=n;a=t}else{i=r;M=61}}if((M|0)==61)while(1){M=0;r=(u[i+4>>2]&-8)-l|0;d=r>>>0<t>>>0;r=d?r:t;n=d?i:n;i=u[i+16+(((u[i+16>>2]|0)==0&1)<<2)>>2]|0;if(!i){f=n;a=r;break}else{t=r;M=61}}if((f|0)!=0?a>>>0<((u[2785]|0)-l|0)>>>0:0){o=f+l|0;if(f>>>0>=o>>>0){k=0;v=g;return k|0}i=u[f+24>>2]|0;e=u[f+12>>2]|0;do{if((e|0)==(f|0)){n=f+20|0;e=u[n>>2]|0;if(!e){n=f+16|0;e=u[n>>2]|0;if(!e){e=0;break}}while(1){r=e+20|0;t=u[r>>2]|0;if(t|0){e=t;n=r;continue}r=e+16|0;t=u[r>>2]|0;if(!t)break;else{e=t;n=r}}u[n>>2]=0}else{k=u[f+8>>2]|0;u[k+12>>2]=e;u[e+8>>2]=k}}while(0);do{if(i){n=u[f+28>>2]|0;r=11436+(n<<2)|0;if((f|0)==(u[r>>2]|0)){u[r>>2]=e;if(!e){t=c&~(1<<n);u[2784]=t;break}}else{u[i+16+(((u[i+16>>2]|0)!=(f|0)&1)<<2)>>2]=e;if(!e){t=c;break}}u[e+24>>2]=i;n=u[f+16>>2]|0;if(n|0){u[e+16>>2]=n;u[n+24>>2]=e}n=u[f+20>>2]|0;if(n){u[e+20>>2]=n;u[n+24>>2]=e;t=c}else t=c}else t=c}while(0);do{if(a>>>0>=16){u[f+4>>2]=l|3;u[o+4>>2]=a|1;u[o+a>>2]=a;e=a>>>3;if(a>>>0<256){r=11172+(e<<1<<2)|0;n=u[2783]|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=o;u[e+12>>2]=o;u[o+8>>2]=e;u[o+12>>2]=r;break}e=a>>>8;if(e){if(a>>>0>16777215)e=31;else{M=(e+1048320|0)>>>16&8;k=e<<M;w=(k+520192|0)>>>16&4;k=k<<w;e=(k+245760|0)>>>16&2;e=14-(w|M|e)+(k<<e>>>15)|0;e=a>>>(e+7|0)&1|e<<1}}else e=0;r=11436+(e<<2)|0;u[o+28>>2]=e;n=o+16|0;u[n+4>>2]=0;u[n>>2]=0;n=1<<e;if(!(t&n)){u[2784]=t|n;u[r>>2]=o;u[o+24>>2]=r;u[o+12>>2]=o;u[o+8>>2]=o;break}n=a<<((e|0)==31?0:25-(e>>>1)|0);r=u[r>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(a|0)){M=97;break}t=r+16+(n>>>31<<2)|0;e=u[t>>2]|0;if(!e){M=96;break}else{n=n<<1;r=e}}if((M|0)==96){u[t>>2]=o;u[o+24>>2]=r;u[o+12>>2]=o;u[o+8>>2]=o;break}else if((M|0)==97){M=r+8|0;k=u[M>>2]|0;u[k+12>>2]=o;u[M>>2]=o;u[o+8>>2]=k;u[o+12>>2]=r;u[o+24>>2]=0;break}}else{k=a+l|0;u[f+4>>2]=k|3;k=f+k+4|0;u[k>>2]=u[k>>2]|1}}while(0);k=f+8|0;v=g;return k|0}else d=l}else d=l}else d=-1}while(0);r=u[2785]|0;if(r>>>0>=d>>>0){e=r-d|0;n=u[2788]|0;if(e>>>0>15){k=n+d|0;u[2788]=k;u[2785]=e;u[k+4>>2]=e|1;u[k+e>>2]=e;u[n+4>>2]=d|3}else{u[2785]=0;u[2788]=0;u[n+4>>2]=r|3;k=n+r+4|0;u[k>>2]=u[k>>2]|1}k=n+8|0;v=g;return k|0}a=u[2786]|0;if(a>>>0>d>>>0){w=a-d|0;u[2786]=w;k=u[2789]|0;M=k+d|0;u[2789]=M;u[M+4>>2]=w|1;u[k+4>>2]=d|3;k=k+8|0;v=g;return k|0}if(!(u[2901]|0)){u[2903]=4096;u[2902]=4096;u[2904]=-1;u[2905]=-1;u[2906]=0;u[2894]=0;n=_&-16^1431655768;u[_>>2]=n;u[2901]=n;n=4096}else n=u[2903]|0;f=d+48|0;c=d+47|0;o=n+c|0;i=0-n|0;l=o&i;if(l>>>0<=d>>>0){k=0;v=g;return k|0}n=u[2893]|0;if(n|0?(s=u[2891]|0,_=s+l|0,_>>>0<=s>>>0|_>>>0>n>>>0):0){k=0;v=g;return k|0}n:do{if(!(u[2894]&4)){r=u[2789]|0;e:do{if(r){t=11580;while(1){n=u[t>>2]|0;if(n>>>0<=r>>>0?(b=t+4|0,(n+(u[b>>2]|0)|0)>>>0>r>>>0):0)break;n=u[t+8>>2]|0;if(!n){M=118;break e}else t=n}e=o-a&i;if(e>>>0<2147483647){n=fC(e|0)|0;if((n|0)==((u[t>>2]|0)+(u[b>>2]|0)|0)){if((n|0)!=(-1|0)){a=e;o=n;M=135;break n}}else{t=n;M=126}}else e=0}else M=118}while(0);do{if((M|0)==118){r=fC(0)|0;if((r|0)!=(-1|0)?(e=r,p=u[2902]|0,m=p+-1|0,e=((m&e|0)==0?0:(m+e&0-p)-e|0)+l|0,p=u[2891]|0,m=e+p|0,e>>>0>d>>>0&e>>>0<2147483647):0){b=u[2893]|0;if(b|0?m>>>0<=p>>>0|m>>>0>b>>>0:0){e=0;break}n=fC(e|0)|0;if((n|0)==(r|0)){a=e;o=r;M=135;break n}else{t=n;M=126}}else e=0}}while(0);do{if((M|0)==126){r=0-e|0;if(!(f>>>0>e>>>0&(e>>>0<2147483647&(t|0)!=(-1|0))))if((t|0)==(-1|0)){e=0;break}else{a=e;o=t;M=135;break n}n=u[2903]|0;n=c-e+n&0-n;if(n>>>0>=2147483647){a=e;o=t;M=135;break n}if((fC(n|0)|0)==(-1|0)){fC(r|0)|0;e=0;break}else{a=n+e|0;o=t;M=135;break n}}}while(0);u[2894]=u[2894]|4;M=133}else{e=0;M=133}}while(0);if(((M|0)==133?l>>>0<2147483647:0)?(w=fC(l|0)|0,b=fC(0)|0,h=b-w|0,y=h>>>0>(d+40|0)>>>0,!((w|0)==(-1|0)|y^1|w>>>0<b>>>0&((w|0)!=(-1|0)&(b|0)!=(-1|0))^1)):0){a=y?h:e;o=w;M=135}if((M|0)==135){e=(u[2891]|0)+a|0;u[2891]=e;if(e>>>0>(u[2892]|0)>>>0)u[2892]=e;c=u[2789]|0;do{if(c){e=11580;while(1){n=u[e>>2]|0;r=e+4|0;t=u[r>>2]|0;if((o|0)==(n+t|0)){M=145;break}i=u[e+8>>2]|0;if(!i)break;else e=i}if(((M|0)==145?(u[e+12>>2]&8|0)==0:0)?c>>>0<o>>>0&c>>>0>=n>>>0:0){u[r>>2]=t+a;k=c+8|0;k=(k&7|0)==0?0:0-k&7;M=c+k|0;k=(u[2786]|0)+(a-k)|0;u[2789]=M;u[2786]=k;u[M+4>>2]=k|1;u[M+k+4>>2]=40;u[2790]=u[2905];break}if(o>>>0<(u[2787]|0)>>>0)u[2787]=o;r=o+a|0;e=11580;while(1){if((u[e>>2]|0)==(r|0)){M=153;break}n=u[e+8>>2]|0;if(!n)break;else e=n}if((M|0)==153?(u[e+12>>2]&8|0)==0:0){u[e>>2]=o;s=e+4|0;u[s>>2]=(u[s>>2]|0)+a;s=o+8|0;s=o+((s&7|0)==0?0:0-s&7)|0;e=r+8|0;e=r+((e&7|0)==0?0:0-e&7)|0;l=s+d|0;f=e-s-d|0;u[s+4>>2]=d|3;do{if((e|0)!=(c|0)){if((e|0)==(u[2788]|0)){k=(u[2785]|0)+f|0;u[2785]=k;u[2788]=l;u[l+4>>2]=k|1;u[l+k>>2]=k;break}n=u[e+4>>2]|0;if((n&3|0)==1){a=n&-8;t=n>>>3;n:do{if(n>>>0<256){n=u[e+8>>2]|0;r=u[e+12>>2]|0;if((r|0)==(n|0)){u[2783]=u[2783]&~(1<<t);break}else{u[n+12>>2]=r;u[r+8>>2]=n;break}}else{o=u[e+24>>2]|0;n=u[e+12>>2]|0;do{if((n|0)==(e|0)){t=e+16|0;r=t+4|0;n=u[r>>2]|0;if(!n){n=u[t>>2]|0;if(!n){n=0;break}else r=t}while(1){t=n+20|0;i=u[t>>2]|0;if(i|0){n=i;r=t;continue}t=n+16|0;i=u[t>>2]|0;if(!i)break;else{n=i;r=t}}u[r>>2]=0}else{k=u[e+8>>2]|0;u[k+12>>2]=n;u[n+8>>2]=k}}while(0);if(!o)break;r=u[e+28>>2]|0;t=11436+(r<<2)|0;do{if((e|0)!=(u[t>>2]|0)){u[o+16+(((u[o+16>>2]|0)!=(e|0)&1)<<2)>>2]=n;if(!n)break n}else{u[t>>2]=n;if(n|0)break;u[2784]=u[2784]&~(1<<r);break n}}while(0);u[n+24>>2]=o;r=e+16|0;t=u[r>>2]|0;if(t|0){u[n+16>>2]=t;u[t+24>>2]=n}r=u[r+4>>2]|0;if(!r)break;u[n+20>>2]=r;u[r+24>>2]=n}}while(0);e=e+a|0;i=a+f|0}else i=f;e=e+4|0;u[e>>2]=u[e>>2]&-2;u[l+4>>2]=i|1;u[l+i>>2]=i;e=i>>>3;if(i>>>0<256){r=11172+(e<<1<<2)|0;n=u[2783]|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=l;u[e+12>>2]=l;u[l+8>>2]=e;u[l+12>>2]=r;break}e=i>>>8;do{if(!e)e=0;else{if(i>>>0>16777215){e=31;break}M=(e+1048320|0)>>>16&8;k=e<<M;w=(k+520192|0)>>>16&4;k=k<<w;e=(k+245760|0)>>>16&2;e=14-(w|M|e)+(k<<e>>>15)|0;e=i>>>(e+7|0)&1|e<<1}}while(0);t=11436+(e<<2)|0;u[l+28>>2]=e;n=l+16|0;u[n+4>>2]=0;u[n>>2]=0;n=u[2784]|0;r=1<<e;if(!(n&r)){u[2784]=n|r;u[t>>2]=l;u[l+24>>2]=t;u[l+12>>2]=l;u[l+8>>2]=l;break}n=i<<((e|0)==31?0:25-(e>>>1)|0);r=u[t>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(i|0)){M=194;break}t=r+16+(n>>>31<<2)|0;e=u[t>>2]|0;if(!e){M=193;break}else{n=n<<1;r=e}}if((M|0)==193){u[t>>2]=l;u[l+24>>2]=r;u[l+12>>2]=l;u[l+8>>2]=l;break}else if((M|0)==194){M=r+8|0;k=u[M>>2]|0;u[k+12>>2]=l;u[M>>2]=l;u[l+8>>2]=k;u[l+12>>2]=r;u[l+24>>2]=0;break}}else{k=(u[2786]|0)+f|0;u[2786]=k;u[2789]=l;u[l+4>>2]=k|1}}while(0);k=s+8|0;v=g;return k|0}e=11580;while(1){n=u[e>>2]|0;if(n>>>0<=c>>>0?(k=n+(u[e+4>>2]|0)|0,k>>>0>c>>>0):0)break;e=u[e+8>>2]|0}i=k+-47|0;n=i+8|0;n=i+((n&7|0)==0?0:0-n&7)|0;i=c+16|0;n=n>>>0<i>>>0?c:n;e=n+8|0;r=o+8|0;r=(r&7|0)==0?0:0-r&7;M=o+r|0;r=a+-40-r|0;u[2789]=M;u[2786]=r;u[M+4>>2]=r|1;u[M+r+4>>2]=40;u[2790]=u[2905];r=n+4|0;u[r>>2]=27;u[e>>2]=u[2895];u[e+4>>2]=u[2896];u[e+8>>2]=u[2897];u[e+12>>2]=u[2898];u[2895]=o;u[2896]=a;u[2898]=0;u[2897]=e;e=n+24|0;do{M=e;e=e+4|0;u[e>>2]=7}while((M+8|0)>>>0<k>>>0);if((n|0)!=(c|0)){o=n-c|0;u[r>>2]=u[r>>2]&-2;u[c+4>>2]=o|1;u[n>>2]=o;e=o>>>3;if(o>>>0<256){r=11172+(e<<1<<2)|0;n=u[2783]|0;e=1<<e;if(!(n&e)){u[2783]=n|e;e=r;n=r+8|0}else{n=r+8|0;e=u[n>>2]|0}u[n>>2]=c;u[e+12>>2]=c;u[c+8>>2]=e;u[c+12>>2]=r;break}e=o>>>8;if(e){if(o>>>0>16777215)r=31;else{M=(e+1048320|0)>>>16&8;k=e<<M;w=(k+520192|0)>>>16&4;k=k<<w;r=(k+245760|0)>>>16&2;r=14-(w|M|r)+(k<<r>>>15)|0;r=o>>>(r+7|0)&1|r<<1}}else r=0;t=11436+(r<<2)|0;u[c+28>>2]=r;u[c+20>>2]=0;u[i>>2]=0;e=u[2784]|0;n=1<<r;if(!(e&n)){u[2784]=e|n;u[t>>2]=c;u[c+24>>2]=t;u[c+12>>2]=c;u[c+8>>2]=c;break}n=o<<((r|0)==31?0:25-(r>>>1)|0);r=u[t>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(o|0)){M=216;break}t=r+16+(n>>>31<<2)|0;e=u[t>>2]|0;if(!e){M=215;break}else{n=n<<1;r=e}}if((M|0)==215){u[t>>2]=c;u[c+24>>2]=r;u[c+12>>2]=c;u[c+8>>2]=c;break}else if((M|0)==216){M=r+8|0;k=u[M>>2]|0;u[k+12>>2]=c;u[M>>2]=c;u[c+8>>2]=k;u[c+12>>2]=r;u[c+24>>2]=0;break}}}else{k=u[2787]|0;if((k|0)==0|o>>>0<k>>>0)u[2787]=o;u[2895]=o;u[2896]=a;u[2898]=0;u[2792]=u[2901];u[2791]=-1;e=0;do{k=11172+(e<<1<<2)|0;u[k+12>>2]=k;u[k+8>>2]=k;e=e+1|0}while((e|0)!=32);k=o+8|0;k=(k&7|0)==0?0:0-k&7;M=o+k|0;k=a+-40-k|0;u[2789]=M;u[2786]=k;u[M+4>>2]=k|1;u[M+k+4>>2]=40;u[2790]=u[2905]}}while(0);e=u[2786]|0;if(e>>>0>d>>>0){w=e-d|0;u[2786]=w;k=u[2789]|0;M=k+d|0;u[2789]=M;u[M+4>>2]=w|1;u[k+4>>2]=d|3;k=k+8|0;v=g;return k|0}}u[(QS()|0)>>2]=12;k=0;v=g;return k|0}function zS(n){n=n|0;var e=0,r=0,t=0,i=0,o=0,a=0,f=0,c=0;if(!n)return;r=n+-8|0;i=u[2787]|0;n=u[n+-4>>2]|0;e=n&-8;c=r+e|0;do{if(!(n&1)){t=u[r>>2]|0;if(!(n&3))return;a=r+(0-t)|0;o=t+e|0;if(a>>>0<i>>>0)return;if((a|0)==(u[2788]|0)){n=c+4|0;e=u[n>>2]|0;if((e&3|0)!=3){f=a;e=o;break}u[2785]=o;u[n>>2]=e&-2;u[a+4>>2]=o|1;u[a+o>>2]=o;return}r=t>>>3;if(t>>>0<256){n=u[a+8>>2]|0;e=u[a+12>>2]|0;if((e|0)==(n|0)){u[2783]=u[2783]&~(1<<r);f=a;e=o;break}else{u[n+12>>2]=e;u[e+8>>2]=n;f=a;e=o;break}}i=u[a+24>>2]|0;n=u[a+12>>2]|0;do{if((n|0)==(a|0)){r=a+16|0;e=r+4|0;n=u[e>>2]|0;if(!n){n=u[r>>2]|0;if(!n){n=0;break}else e=r}while(1){r=n+20|0;t=u[r>>2]|0;if(t|0){n=t;e=r;continue}r=n+16|0;t=u[r>>2]|0;if(!t)break;else{n=t;e=r}}u[e>>2]=0}else{f=u[a+8>>2]|0;u[f+12>>2]=n;u[n+8>>2]=f}}while(0);if(i){e=u[a+28>>2]|0;r=11436+(e<<2)|0;if((a|0)==(u[r>>2]|0)){u[r>>2]=n;if(!n){u[2784]=u[2784]&~(1<<e);f=a;e=o;break}}else{u[i+16+(((u[i+16>>2]|0)!=(a|0)&1)<<2)>>2]=n;if(!n){f=a;e=o;break}}u[n+24>>2]=i;e=a+16|0;r=u[e>>2]|0;if(r|0){u[n+16>>2]=r;u[r+24>>2]=n}e=u[e+4>>2]|0;if(e){u[n+20>>2]=e;u[e+24>>2]=n;f=a;e=o}else{f=a;e=o}}else{f=a;e=o}}else{f=r;a=r}}while(0);if(a>>>0>=c>>>0)return;n=c+4|0;t=u[n>>2]|0;if(!(t&1))return;if(!(t&2)){n=u[2788]|0;if((c|0)==(u[2789]|0)){c=(u[2786]|0)+e|0;u[2786]=c;u[2789]=f;u[f+4>>2]=c|1;if((f|0)!=(n|0))return;u[2788]=0;u[2785]=0;return}if((c|0)==(n|0)){c=(u[2785]|0)+e|0;u[2785]=c;u[2788]=a;u[f+4>>2]=c|1;u[a+c>>2]=c;return}i=(t&-8)+e|0;r=t>>>3;do{if(t>>>0<256){e=u[c+8>>2]|0;n=u[c+12>>2]|0;if((n|0)==(e|0)){u[2783]=u[2783]&~(1<<r);break}else{u[e+12>>2]=n;u[n+8>>2]=e;break}}else{o=u[c+24>>2]|0;n=u[c+12>>2]|0;do{if((n|0)==(c|0)){r=c+16|0;e=r+4|0;n=u[e>>2]|0;if(!n){n=u[r>>2]|0;if(!n){r=0;break}else e=r}while(1){r=n+20|0;t=u[r>>2]|0;if(t|0){n=t;e=r;continue}r=n+16|0;t=u[r>>2]|0;if(!t)break;else{n=t;e=r}}u[e>>2]=0;r=n}else{r=u[c+8>>2]|0;u[r+12>>2]=n;u[n+8>>2]=r;r=n}}while(0);if(o|0){n=u[c+28>>2]|0;e=11436+(n<<2)|0;if((c|0)==(u[e>>2]|0)){u[e>>2]=r;if(!r){u[2784]=u[2784]&~(1<<n);break}}else{u[o+16+(((u[o+16>>2]|0)!=(c|0)&1)<<2)>>2]=r;if(!r)break}u[r+24>>2]=o;n=c+16|0;e=u[n>>2]|0;if(e|0){u[r+16>>2]=e;u[e+24>>2]=r}n=u[n+4>>2]|0;if(n|0){u[r+20>>2]=n;u[n+24>>2]=r}}}}while(0);u[f+4>>2]=i|1;u[a+i>>2]=i;if((f|0)==(u[2788]|0)){u[2785]=i;return}}else{u[n>>2]=t&-2;u[f+4>>2]=e|1;u[a+e>>2]=e;i=e}n=i>>>3;if(i>>>0<256){r=11172+(n<<1<<2)|0;e=u[2783]|0;n=1<<n;if(!(e&n)){u[2783]=e|n;n=r;e=r+8|0}else{e=r+8|0;n=u[e>>2]|0}u[e>>2]=f;u[n+12>>2]=f;u[f+8>>2]=n;u[f+12>>2]=r;return}n=i>>>8;if(n){if(i>>>0>16777215)n=31;else{a=(n+1048320|0)>>>16&8;c=n<<a;o=(c+520192|0)>>>16&4;c=c<<o;n=(c+245760|0)>>>16&2;n=14-(o|a|n)+(c<<n>>>15)|0;n=i>>>(n+7|0)&1|n<<1}}else n=0;t=11436+(n<<2)|0;u[f+28>>2]=n;u[f+20>>2]=0;u[f+16>>2]=0;e=u[2784]|0;r=1<<n;do{if(e&r){e=i<<((n|0)==31?0:25-(n>>>1)|0);r=u[t>>2]|0;while(1){if((u[r+4>>2]&-8|0)==(i|0)){n=73;break}t=r+16+(e>>>31<<2)|0;n=u[t>>2]|0;if(!n){n=72;break}else{e=e<<1;r=n}}if((n|0)==72){u[t>>2]=f;u[f+24>>2]=r;u[f+12>>2]=f;u[f+8>>2]=f;break}else if((n|0)==73){a=r+8|0;c=u[a>>2]|0;u[c+12>>2]=f;u[a>>2]=f;u[f+8>>2]=c;u[f+12>>2]=r;u[f+24>>2]=0;break}}else{u[2784]=e|r;u[t>>2]=f;u[f+24>>2]=t;u[f+12>>2]=f;u[f+8>>2]=f}}while(0);c=(u[2791]|0)+-1|0;u[2791]=c;if(!c)n=11588;else return;while(1){n=u[n>>2]|0;if(!n)break;else n=n+8|0}u[2791]=-1;return}function GS(){return 11628}function KS(n){n=n|0;var e=0,r=0;e=v;v=v+16|0;r=e;u[r>>2]=eE(u[n+60>>2]|0)|0;n=ZS(ae(6,r|0)|0)|0;v=e;return n|0}function XS(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0;d=v;v=v+48|0;l=d+16|0;o=d;i=d+32|0;f=n+28|0;t=u[f>>2]|0;u[i>>2]=t;c=n+20|0;t=(u[c>>2]|0)-t|0;u[i+4>>2]=t;u[i+8>>2]=e;u[i+12>>2]=r;t=t+r|0;a=n+60|0;u[o>>2]=u[a>>2];u[o+4>>2]=i;u[o+8>>2]=2;o=ZS(le(146,o|0)|0)|0;n:do{if((t|0)!=(o|0)){e=2;while(1){if((o|0)<0)break;t=t-o|0;p=u[i+4>>2]|0;_=o>>>0>p>>>0;i=_?i+8|0:i;e=(_<<31>>31)+e|0;p=o-(_?p:0)|0;u[i>>2]=(u[i>>2]|0)+p;_=i+4|0;u[_>>2]=(u[_>>2]|0)-p;u[l>>2]=u[a>>2];u[l+4>>2]=i;u[l+8>>2]=e;o=ZS(le(146,l|0)|0)|0;if((t|0)==(o|0)){s=3;break n}}u[n+16>>2]=0;u[f>>2]=0;u[c>>2]=0;u[n>>2]=u[n>>2]|32;if((e|0)==2)r=0;else r=r-(u[i+4>>2]|0)|0}else s=3}while(0);if((s|0)==3){p=u[n+44>>2]|0;u[n+16>>2]=p+(u[n+48>>2]|0);u[f>>2]=p;u[c>>2]=p}v=d;return r|0}function JS(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0;i=v;v=v+32|0;o=i;t=i+20|0;u[o>>2]=u[n+60>>2];u[o+4>>2]=0;u[o+8>>2]=e;u[o+12>>2]=t;u[o+16>>2]=r;if((ZS(ce(140,o|0)|0)|0)<0){u[t>>2]=-1;n=-1}else n=u[t>>2]|0;v=i;return n|0}function ZS(n){n=n|0;if(n>>>0>4294963200){u[(QS()|0)>>2]=0-n;n=-1}return n|0}function QS(){return($S()|0)+64|0}function $S(){return nE()|0}function nE(){return 2084}function eE(n){n=n|0;return n|0}function rE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0;o=v;v=v+32|0;i=o;u[n+36>>2]=1;if((u[n>>2]&64|0)==0?(u[i>>2]=u[n+60>>2],u[i+4>>2]=21523,u[i+8>>2]=o+16,Qn(54,i|0)|0):0)t[n+75>>0]=-1;i=XS(n,e,r)|0;v=o;return i|0}function tE(n,e){n=n|0;e=e|0;var r=0,i=0;r=t[n>>0]|0;i=t[e>>0]|0;if(r<<24>>24==0?1:r<<24>>24!=i<<24>>24)n=i;else{do{n=n+1|0;e=e+1|0;r=t[n>>0]|0;i=t[e>>0]|0}while(!(r<<24>>24==0?1:r<<24>>24!=i<<24>>24));n=i}return(r&255)-(n&255)|0}function iE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,u=0;n:do{if(!r)n=0;else{while(1){i=t[n>>0]|0;u=t[e>>0]|0;if(i<<24>>24!=u<<24>>24)break;r=r+-1|0;if(!r){n=0;break n}else{n=n+1|0;e=e+1|0}}n=(i&255)-(u&255)|0}}while(0);return n|0}function uE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0;h=v;v=v+224|0;d=h+120|0;_=h+80|0;m=h;b=h+136|0;i=_;o=i+40|0;do{u[i>>2]=0;i=i+4|0}while((i|0)<(o|0));u[d>>2]=u[r>>2];if((oE(0,e,d,m,_)|0)<0)r=-1;else{if((u[n+76>>2]|0)>-1)p=aE(n)|0;else p=0;r=u[n>>2]|0;s=r&32;if((t[n+74>>0]|0)<1)u[n>>2]=r&-33;i=n+48|0;if(!(u[i>>2]|0)){o=n+44|0;a=u[o>>2]|0;u[o>>2]=b;f=n+28|0;u[f>>2]=b;c=n+20|0;u[c>>2]=b;u[i>>2]=80;l=n+16|0;u[l>>2]=b+80;r=oE(n,e,d,m,_)|0;if(a){yL[u[n+36>>2]&7](n,0,0)|0;r=(u[c>>2]|0)==0?-1:r;u[o>>2]=a;u[i>>2]=0;u[l>>2]=0;u[f>>2]=0;u[c>>2]=0}}else r=oE(n,e,d,m,_)|0;i=u[n>>2]|0;u[n>>2]=i|s;if(p|0)fE(n);r=(i&32|0)==0?r:-1}v=h;return r|0}function oE(n,e,r,o,a){n=n|0;e=e|0;r=r|0;o=o|0;a=a|0;var f=0,c=0,s=0,d=0,_=0,p=0,m=0,b=0,h=0,y=0,w=0,M=0,k=0,g=0,T=0,A=0,S=0,E=0,C=0,R=0,P=0,B=0,O=0;O=v;v=v+64|0;C=O+16|0;R=O;S=O+24|0;P=O+8|0;B=O+20|0;u[C>>2]=e;g=(n|0)!=0;T=S+40|0;A=T;S=S+39|0;E=P+4|0;c=0;f=0;p=0;n:while(1){do{if((f|0)>-1)if((c|0)>(2147483647-f|0)){u[(QS()|0)>>2]=75;f=-1;break}else{f=c+f|0;break}}while(0);c=t[e>>0]|0;if(!(c<<24>>24)){k=87;break}else s=e;e:while(1){switch(c<<24>>24){case 37:{c=s;k=9;break e}case 0:{c=s;break e}default:{}}M=s+1|0;u[C>>2]=M;c=t[M>>0]|0;s=M}e:do{if((k|0)==9)while(1){k=0;if((t[s+1>>0]|0)!=37)break e;c=c+1|0;s=s+2|0;u[C>>2]=s;if((t[s>>0]|0)==37)k=9;else break}}while(0);c=c-e|0;if(g)cE(n,e,c);if(c|0){e=s;continue}d=s+1|0;c=(t[d>>0]|0)+-48|0;if(c>>>0<10){M=(t[s+2>>0]|0)==36;w=M?c:-1;p=M?1:p;d=M?s+3|0:d}else w=-1;u[C>>2]=d;c=t[d>>0]|0;s=(c<<24>>24)+-32|0;e:do{if(s>>>0<32){_=0;m=c;while(1){c=1<<s;if(!(c&75913)){c=m;break e}_=c|_;d=d+1|0;u[C>>2]=d;c=t[d>>0]|0;s=(c<<24>>24)+-32|0;if(s>>>0>=32)break;else m=c}}else _=0}while(0);if(c<<24>>24==42){s=d+1|0;c=(t[s>>0]|0)+-48|0;if(c>>>0<10?(t[d+2>>0]|0)==36:0){u[a+(c<<2)>>2]=10;c=u[o+((t[s>>0]|0)+-48<<3)>>2]|0;p=1;d=d+3|0}else{if(p|0){f=-1;break}if(g){p=(u[r>>2]|0)+(4-1)&~(4-1);c=u[p>>2]|0;u[r>>2]=p+4;p=0;d=s}else{c=0;p=0;d=s}}u[C>>2]=d;M=(c|0)<0;c=M?0-c|0:c;_=M?_|8192:_}else{c=lE(C)|0;if((c|0)<0){f=-1;break}d=u[C>>2]|0}do{if((t[d>>0]|0)==46){if((t[d+1>>0]|0)!=42){u[C>>2]=d+1;s=lE(C)|0;d=u[C>>2]|0;break}m=d+2|0;s=(t[m>>0]|0)+-48|0;if(s>>>0<10?(t[d+3>>0]|0)==36:0){u[a+(s<<2)>>2]=10;s=u[o+((t[m>>0]|0)+-48<<3)>>2]|0;d=d+4|0;u[C>>2]=d;break}if(p|0){f=-1;break n}if(g){M=(u[r>>2]|0)+(4-1)&~(4-1);s=u[M>>2]|0;u[r>>2]=M+4}else s=0;u[C>>2]=m;d=m}else s=-1}while(0);y=0;while(1){if(((t[d>>0]|0)+-65|0)>>>0>57){f=-1;break n}M=d+1|0;u[C>>2]=M;m=t[(t[d>>0]|0)+-65+(5178+(y*58|0))>>0]|0;b=m&255;if((b+-1|0)>>>0<8){y=b;d=M}else break}if(!(m<<24>>24)){f=-1;break}h=(w|0)>-1;do{if(m<<24>>24==19){if(h){f=-1;break n}else k=49}else{if(h){u[a+(w<<2)>>2]=b;h=o+(w<<3)|0;w=u[h+4>>2]|0;k=R;u[k>>2]=u[h>>2];u[k+4>>2]=w;k=49;break}if(!g){f=0;break n}sE(R,b,r)}}while(0);if((k|0)==49?(k=0,!g):0){c=0;e=M;continue}d=t[d>>0]|0;d=(y|0)!=0&(d&15|0)==3?d&-33:d;h=_&-65537;w=(_&8192|0)==0?_:h;e:do{switch(d|0){case 110:switch((y&255)<<24>>24){case 0:{u[u[R>>2]>>2]=f;c=0;e=M;continue n}case 1:{u[u[R>>2]>>2]=f;c=0;e=M;continue n}case 2:{c=u[R>>2]|0;u[c>>2]=f;u[c+4>>2]=((f|0)<0)<<31>>31;c=0;e=M;continue n}case 3:{i[u[R>>2]>>1]=f;c=0;e=M;continue n}case 4:{t[u[R>>2]>>0]=f;c=0;e=M;continue n}case 6:{u[u[R>>2]>>2]=f;c=0;e=M;continue n}case 7:{c=u[R>>2]|0;u[c>>2]=f;u[c+4>>2]=((f|0)<0)<<31>>31;c=0;e=M;continue n}default:{c=0;e=M;continue n}}case 112:{d=120;s=s>>>0>8?s:8;e=w|8;k=61;break}case 88:case 120:{e=w;k=61;break}case 111:{d=R;e=u[d>>2]|0;d=u[d+4>>2]|0;b=_E(e,d,T)|0;h=A-b|0;_=0;m=5642;s=(w&8|0)==0|(s|0)>(h|0)?s:h+1|0;h=w;k=67;break}case 105:case 100:{d=R;e=u[d>>2]|0;d=u[d+4>>2]|0;if((d|0)<0){e=$E(0,0,e|0,d|0)|0;d=L;_=R;u[_>>2]=e;u[_+4>>2]=d;_=1;m=5642;k=66;break e}else{_=(w&2049|0)!=0&1;m=(w&2048|0)==0?(w&1|0)==0?5642:5644:5643;k=66;break e}}case 117:{d=R;_=0;m=5642;e=u[d>>2]|0;d=u[d+4>>2]|0;k=66;break}case 99:{t[S>>0]=u[R>>2];e=S;_=0;m=5642;b=T;d=1;s=h;break}case 109:{d=pE(u[(QS()|0)>>2]|0)|0;k=71;break}case 115:{d=u[R>>2]|0;d=d|0?d:5652;k=71;break}case 67:{u[P>>2]=u[R>>2];u[E>>2]=0;u[R>>2]=P;b=-1;d=P;k=75;break}case 83:{e=u[R>>2]|0;if(!s){bE(n,32,c,0,w);e=0;k=84}else{b=s;d=e;k=75}break}case 65:case 71:case 70:case 69:case 97:case 103:case 102:case 101:{c=yE(n,+l[R>>3],c,s,w,d)|0;e=M;continue n}default:{_=0;m=5642;b=T;d=s;s=w}}}while(0);e:do{if((k|0)==61){w=R;y=u[w>>2]|0;w=u[w+4>>2]|0;b=dE(y,w,T,d&32)|0;m=(e&8|0)==0|(y|0)==0&(w|0)==0;_=m?0:2;m=m?5642:5642+(d>>4)|0;h=e;e=y;d=w;k=67}else if((k|0)==66){b=vE(e,d,T)|0;h=w;k=67}else if((k|0)==71){k=0;w=mE(d,0,s)|0;y=(w|0)==0;e=d;_=0;m=5642;b=y?d+s|0:w;d=y?s:w-d|0;s=h}else if((k|0)==75){k=0;m=d;e=0;s=0;while(1){_=u[m>>2]|0;if(!_)break;s=hE(B,_)|0;if((s|0)<0|s>>>0>(b-e|0)>>>0)break;e=s+e|0;if(b>>>0>e>>>0)m=m+4|0;else break}if((s|0)<0){f=-1;break n}bE(n,32,c,e,w);if(!e){e=0;k=84}else{_=0;while(1){s=u[d>>2]|0;if(!s){k=84;break e}s=hE(B,s)|0;_=s+_|0;if((_|0)>(e|0)){k=84;break e}cE(n,B,s);if(_>>>0>=e>>>0){k=84;break}else d=d+4|0}}}}while(0);if((k|0)==67){k=0;d=(e|0)!=0|(d|0)!=0;w=(s|0)!=0|d;d=((d^1)&1)+(A-b)|0;e=w?b:T;b=T;d=w?(s|0)>(d|0)?s:d:s;s=(s|0)>-1?h&-65537:h}else if((k|0)==84){k=0;bE(n,32,c,e,w^8192);c=(c|0)>(e|0)?c:e;e=M;continue}y=b-e|0;h=(d|0)<(y|0)?y:d;w=h+_|0;c=(c|0)<(w|0)?w:c;bE(n,32,c,w,s);cE(n,m,_);bE(n,48,c,w,s^65536);bE(n,48,h,y,0);cE(n,e,y);bE(n,32,c,w,s^8192);e=M}n:do{if((k|0)==87)if(!n)if(!p)f=0;else{f=1;while(1){e=u[a+(f<<2)>>2]|0;if(!e)break;sE(o+(f<<3)|0,e,r);f=f+1|0;if((f|0)>=10){f=1;break n}}while(1){if(u[a+(f<<2)>>2]|0){f=-1;break n}f=f+1|0;if((f|0)>=10){f=1;break}}}}while(0);v=O;return f|0}function aE(n){n=n|0;return 0}function fE(n){n=n|0;return}function cE(n,e,r){n=n|0;e=e|0;r=r|0;if(!(u[n>>2]&32))PE(e,r,n)|0;return}function lE(n){n=n|0;var e=0,r=0,i=0;r=u[n>>2]|0;i=(t[r>>0]|0)+-48|0;if(i>>>0<10){e=0;do{e=i+(e*10|0)|0;r=r+1|0;u[n>>2]=r;i=(t[r>>0]|0)+-48|0}while(i>>>0<10)}else e=0;return e|0}function sE(n,e,r){n=n|0;e=e|0;r=r|0;var t=0,i=0,o=0.0;n:do{if(e>>>0<=20)do{switch(e|0){case 9:{t=(u[r>>2]|0)+(4-1)&~(4-1);e=u[t>>2]|0;u[r>>2]=t+4;u[n>>2]=e;break n}case 10:{t=(u[r>>2]|0)+(4-1)&~(4-1);e=u[t>>2]|0;u[r>>2]=t+4;t=n;u[t>>2]=e;u[t+4>>2]=((e|0)<0)<<31>>31;break n}case 11:{t=(u[r>>2]|0)+(4-1)&~(4-1);e=u[t>>2]|0;u[r>>2]=t+4;t=n;u[t>>2]=e;u[t+4>>2]=0;break n}case 12:{t=(u[r>>2]|0)+(8-1)&~(8-1);e=t;i=u[e>>2]|0;e=u[e+4>>2]|0;u[r>>2]=t+8;t=n;u[t>>2]=i;u[t+4>>2]=e;break n}case 13:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;t=(t&65535)<<16>>16;i=n;u[i>>2]=t;u[i+4>>2]=((t|0)<0)<<31>>31;break n}case 14:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;i=n;u[i>>2]=t&65535;u[i+4>>2]=0;break n}case 15:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;t=(t&255)<<24>>24;i=n;u[i>>2]=t;u[i+4>>2]=((t|0)<0)<<31>>31;break n}case 16:{i=(u[r>>2]|0)+(4-1)&~(4-1);t=u[i>>2]|0;u[r>>2]=i+4;i=n;u[i>>2]=t&255;u[i+4>>2]=0;break n}case 17:{i=(u[r>>2]|0)+(8-1)&~(8-1);o=+l[i>>3];u[r>>2]=i+8;l[n>>3]=o;break n}case 18:{i=(u[r>>2]|0)+(8-1)&~(8-1);o=+l[i>>3];u[r>>2]=i+8;l[n>>3]=o;break n}default:break n}}while(0)}while(0);return}function dE(n,e,r,i){n=n|0;e=e|0;r=r|0;i=i|0;if(!((n|0)==0&(e|0)==0))do{r=r+-1|0;t[r>>0]=o[5694+(n&15)>>0]|0|i;n=tC(n|0,e|0,4)|0;e=L}while(!((n|0)==0&(e|0)==0));return r|0}function _E(n,e,r){n=n|0;e=e|0;r=r|0;if(!((n|0)==0&(e|0)==0))do{r=r+-1|0;t[r>>0]=n&7|48;n=tC(n|0,e|0,3)|0;e=L}while(!((n|0)==0&(e|0)==0));return r|0}function vE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0;if(e>>>0>0|(e|0)==0&n>>>0>4294967295){while(1){i=lC(n|0,e|0,10,0)|0;r=r+-1|0;t[r>>0]=i&255|48;i=n;n=aC(n|0,e|0,10,0)|0;if(!(e>>>0>9|(e|0)==9&i>>>0>4294967295))break;else e=L}e=n}else e=n;if(e)while(1){r=r+-1|0;t[r>>0]=(e>>>0)%10|0|48;if(e>>>0<10)break;else e=(e>>>0)/10|0}return r|0}function pE(n){n=n|0;return SE(n,u[(AE()|0)+188>>2]|0)|0}function mE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0;a=e&255;i=(r|0)!=0;n:do{if(i&(n&3|0)!=0){o=e&255;while(1){if((t[n>>0]|0)==o<<24>>24){f=6;break n}n=n+1|0;r=r+-1|0;i=(r|0)!=0;if(!(i&(n&3|0)!=0)){f=5;break}}}else f=5}while(0);if((f|0)==5)if(i)f=6;else r=0;n:do{if((f|0)==6){o=e&255;if((t[n>>0]|0)!=o<<24>>24){i=j(a,16843009)|0;e:do{if(r>>>0>3)while(1){a=u[n>>2]^i;if((a&-2139062144^-2139062144)&a+-16843009|0)break;n=n+4|0;r=r+-4|0;if(r>>>0<=3){f=11;break e}}else f=11}while(0);if((f|0)==11)if(!r){r=0;break}while(1){if((t[n>>0]|0)==o<<24>>24)break n;n=n+1|0;r=r+-1|0;if(!r){r=0;break}}}}}while(0);return(r|0?n:0)|0}function bE(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var u=0,o=0;o=v;v=v+256|0;u=o;if((r|0)>(t|0)&(i&73728|0)==0){i=r-t|0;eC(u|0,e|0,(i>>>0<256?i:256)|0)|0;if(i>>>0>255){e=r-t|0;do{cE(n,u,256);i=i+-256|0}while(i>>>0>255);i=e&255}cE(n,u,i)}v=o;return}function hE(n,e){n=n|0;e=e|0;if(!n)n=0;else n=gE(n,e,0)|0;return n|0}function yE(n,e,r,i,a,f){n=n|0;e=+e;r=r|0;i=i|0;a=a|0;f=f|0;var c=0,l=0,s=0,d=0,_=0,p=0,m=0,b=0.0,h=0,y=0,w=0,M=0,k=0,g=0,T=0,A=0,S=0,E=0,C=0,R=0,P=0,B=0,O=0;O=v;v=v+560|0;s=O+8|0;w=O;B=O+524|0;P=B;d=O+512|0;u[w>>2]=0;R=d+12|0;wE(e)|0;if((L|0)<0){e=-e;E=1;S=5659}else{E=(a&2049|0)!=0&1;S=(a&2048|0)==0?(a&1|0)==0?5660:5665:5662}wE(e)|0;C=L&2146435072;do{if(C>>>0<2146435072|(C|0)==2146435072&0<0){b=+ME(e,w)*2.0;c=b!=0.0;if(c)u[w>>2]=(u[w>>2]|0)+-1;k=f|32;if((k|0)==97){h=f&32;m=(h|0)==0?S:S+9|0;p=E|2;c=12-i|0;do{if(!(i>>>0>11|(c|0)==0)){e=8.0;do{c=c+-1|0;e=e*16.0}while((c|0)!=0);if((t[m>>0]|0)==45){e=-(e+(-b-e));break}else{e=b+e-e;break}}else e=b}while(0);l=u[w>>2]|0;c=(l|0)<0?0-l|0:l;c=vE(c,((c|0)<0)<<31>>31,R)|0;if((c|0)==(R|0)){c=d+11|0;t[c>>0]=48}t[c+-1>>0]=(l>>31&2)+43;_=c+-2|0;t[_>>0]=f+15;d=(i|0)<1;s=(a&8|0)==0;c=B;do{C=~~e;l=c+1|0;t[c>>0]=o[5694+C>>0]|h;e=(e-+(C|0))*16.0;if((l-P|0)==1?!(s&(d&e==0.0)):0){t[l>>0]=46;c=c+2|0}else c=l}while(e!=0.0);C=c-P|0;P=R-_|0;R=(i|0)!=0&(C+-2|0)<(i|0)?i+2|0:C;c=P+p+R|0;bE(n,32,r,c,a);cE(n,m,p);bE(n,48,r,c,a^65536);cE(n,B,C);bE(n,48,R-C|0,0,0);cE(n,_,P);bE(n,32,r,c,a^8192);break}l=(i|0)<0?6:i;if(c){c=(u[w>>2]|0)+-28|0;u[w>>2]=c;e=b*268435456.0}else{e=b;c=u[w>>2]|0}C=(c|0)<0?s:s+288|0;s=C;do{T=~~e>>>0;u[s>>2]=T;s=s+4|0;e=(e-+(T>>>0))*1.0e9}while(e!=0.0);if((c|0)>0){d=C;p=s;while(1){_=(c|0)<29?c:29;c=p+-4|0;if(c>>>0>=d>>>0){s=0;do{g=rC(u[c>>2]|0,0,_|0)|0;g=nC(g|0,L|0,s|0,0)|0;T=L;M=lC(g|0,T|0,1e9,0)|0;u[c>>2]=M;s=aC(g|0,T|0,1e9,0)|0;c=c+-4|0}while(c>>>0>=d>>>0);if(s){d=d+-4|0;u[d>>2]=s}}s=p;while(1){if(s>>>0<=d>>>0)break;c=s+-4|0;if(!(u[c>>2]|0))s=c;else break}c=(u[w>>2]|0)-_|0;u[w>>2]=c;if((c|0)>0)p=s;else break}}else d=C;if((c|0)<0){i=((l+25|0)/9|0)+1|0;y=(k|0)==102;do{h=0-c|0;h=(h|0)<9?h:9;if(d>>>0<s>>>0){_=(1<<h)+-1|0;p=1e9>>>h;m=0;c=d;do{T=u[c>>2]|0;u[c>>2]=(T>>>h)+m;m=j(T&_,p)|0;c=c+4|0}while(c>>>0<s>>>0);c=(u[d>>2]|0)==0?d+4|0:d;if(!m){d=c;c=s}else{u[s>>2]=m;d=c;c=s+4|0}}else{d=(u[d>>2]|0)==0?d+4|0:d;c=s}s=y?C:d;s=(c-s>>2|0)>(i|0)?s+(i<<2)|0:c;c=(u[w>>2]|0)+h|0;u[w>>2]=c}while((c|0)<0);c=d;i=s}else{c=d;i=s}T=C;if(c>>>0<i>>>0){s=(T-c>>2)*9|0;_=u[c>>2]|0;if(_>>>0>=10){d=10;do{d=d*10|0;s=s+1|0}while(_>>>0>=d>>>0)}}else s=0;y=(k|0)==103;M=(l|0)!=0;d=l-((k|0)!=102?s:0)+((M&y)<<31>>31)|0;if((d|0)<(((i-T>>2)*9|0)+-9|0)){d=d+9216|0;h=C+4+(((d|0)/9|0)+-1024<<2)|0;d=((d|0)%9|0)+1|0;if((d|0)<9){_=10;do{_=_*10|0;d=d+1|0}while((d|0)!=9)}else _=10;p=u[h>>2]|0;m=(p>>>0)%(_>>>0)|0;d=(h+4|0)==(i|0);if(!(d&(m|0)==0)){b=(((p>>>0)/(_>>>0)|0)&1|0)==0?9007199254740992.0:9007199254740994.0;g=(_|0)/2|0;e=m>>>0<g>>>0?.5:d&(m|0)==(g|0)?1.0:1.5;if(E){g=(t[S>>0]|0)==45;e=g?-e:e;b=g?-b:b}d=p-m|0;u[h>>2]=d;if(b+e!=b){g=d+_|0;u[h>>2]=g;if(g>>>0>999999999){s=h;while(1){d=s+-4|0;u[s>>2]=0;if(d>>>0<c>>>0){c=c+-4|0;u[c>>2]=0}g=(u[d>>2]|0)+1|0;u[d>>2]=g;if(g>>>0>999999999)s=d;else break}}else d=h;s=(T-c>>2)*9|0;p=u[c>>2]|0;if(p>>>0>=10){_=10;do{_=_*10|0;s=s+1|0}while(p>>>0>=_>>>0)}}else d=h}else d=h;d=d+4|0;d=i>>>0>d>>>0?d:i;g=c}else{d=i;g=c}k=d;while(1){if(k>>>0<=g>>>0){w=0;break}c=k+-4|0;if(!(u[c>>2]|0))k=c;else{w=1;break}}i=0-s|0;do{if(y){c=((M^1)&1)+l|0;if((c|0)>(s|0)&(s|0)>-5){_=f+-1|0;l=c+-1-s|0}else{_=f+-2|0;l=c+-1|0}c=a&8;if(!c){if(w?(A=u[k+-4>>2]|0,(A|0)!=0):0){if(!((A>>>0)%10|0)){d=0;c=10;do{c=c*10|0;d=d+1|0}while(!((A>>>0)%(c>>>0)|0|0))}else d=0}else d=9;c=((k-T>>2)*9|0)+-9|0;if((_|32|0)==102){h=c-d|0;h=(h|0)>0?h:0;l=(l|0)<(h|0)?l:h;h=0;break}else{h=c+s-d|0;h=(h|0)>0?h:0;l=(l|0)<(h|0)?l:h;h=0;break}}else h=c}else{_=f;h=a&8}}while(0);y=l|h;p=(y|0)!=0&1;m=(_|32|0)==102;if(m){M=0;c=(s|0)>0?s:0}else{c=(s|0)<0?i:s;c=vE(c,((c|0)<0)<<31>>31,R)|0;d=R;if((d-c|0)<2)do{c=c+-1|0;t[c>>0]=48}while((d-c|0)<2);t[c+-1>>0]=(s>>31&2)+43;c=c+-2|0;t[c>>0]=_;M=c;c=d-c|0}c=E+1+l+p+c|0;bE(n,32,r,c,a);cE(n,S,E);bE(n,48,r,c,a^65536);if(m){_=g>>>0>C>>>0?C:g;h=B+9|0;p=h;m=B+8|0;d=_;do{s=vE(u[d>>2]|0,0,h)|0;if((d|0)==(_|0)){if((s|0)==(h|0)){t[m>>0]=48;s=m}}else if(s>>>0>B>>>0){eC(B|0,48,s-P|0)|0;do{s=s+-1|0}while(s>>>0>B>>>0)}cE(n,s,p-s|0);d=d+4|0}while(d>>>0<=C>>>0);if(y|0)cE(n,5710,1);if(d>>>0<k>>>0&(l|0)>0)while(1){s=vE(u[d>>2]|0,0,h)|0;if(s>>>0>B>>>0){eC(B|0,48,s-P|0)|0;do{s=s+-1|0}while(s>>>0>B>>>0)}cE(n,s,(l|0)<9?l:9);d=d+4|0;s=l+-9|0;if(!(d>>>0<k>>>0&(l|0)>9)){l=s;break}else l=s}bE(n,48,l+9|0,9,0)}else{y=w?k:g+4|0;if((l|0)>-1){w=B+9|0;h=(h|0)==0;i=w;p=0-P|0;m=B+8|0;_=g;do{s=vE(u[_>>2]|0,0,w)|0;if((s|0)==(w|0)){t[m>>0]=48;s=m}do{if((_|0)==(g|0)){d=s+1|0;cE(n,s,1);if(h&(l|0)<1){s=d;break}cE(n,5710,1);s=d}else{if(s>>>0<=B>>>0)break;eC(B|0,48,s+p|0)|0;do{s=s+-1|0}while(s>>>0>B>>>0)}}while(0);P=i-s|0;cE(n,s,(l|0)>(P|0)?P:l);l=l-P|0;_=_+4|0}while(_>>>0<y>>>0&(l|0)>-1)}bE(n,48,l+18|0,18,0);cE(n,M,R-M|0)}bE(n,32,r,c,a^8192)}else{B=(f&32|0)!=0;c=E+3|0;bE(n,32,r,c,a&-65537);cE(n,S,E);cE(n,e!=e|0.0!=0.0?B?5686:5690:B?5678:5682,3);bE(n,32,r,c,a^8192)}}while(0);v=O;return((c|0)<(r|0)?r:c)|0}function wE(n){n=+n;var e=0;l[d>>3]=n;e=u[d>>2]|0;L=u[d+4>>2]|0;return e|0}function ME(n,e){n=+n;e=e|0;return+ +kE(n,e)}function kE(n,e){n=+n;e=e|0;var r=0,t=0,i=0;l[d>>3]=n;r=u[d>>2]|0;t=u[d+4>>2]|0;i=tC(r|0,t|0,52)|0;switch(i&2047){case 0:{if(n!=0.0){n=+kE(n*18446744073709551616.0,e);r=(u[e>>2]|0)+-64|0}else r=0;u[e>>2]=r;break}case 2047:break;default:{u[e>>2]=(i&2047)+-1022;u[d>>2]=r;u[d+4>>2]=t&-2146435073|1071644672;n=+l[d>>3]}}return+n}function gE(n,e,r){n=n|0;e=e|0;r=r|0;do{if(n){if(e>>>0<128){t[n>>0]=e;n=1;break}if(!(u[u[(TE()|0)+188>>2]>>2]|0))if((e&-128|0)==57216){t[n>>0]=e;n=1;break}else{u[(QS()|0)>>2]=84;n=-1;break}if(e>>>0<2048){t[n>>0]=e>>>6|192;t[n+1>>0]=e&63|128;n=2;break}if(e>>>0<55296|(e&-8192|0)==57344){t[n>>0]=e>>>12|224;t[n+1>>0]=e>>>6&63|128;t[n+2>>0]=e&63|128;n=3;break}if((e+-65536|0)>>>0<1048576){t[n>>0]=e>>>18|240;t[n+1>>0]=e>>>12&63|128;t[n+2>>0]=e>>>6&63|128;t[n+3>>0]=e&63|128;n=4;break}else{u[(QS()|0)>>2]=84;n=-1;break}}else n=1}while(0);return n|0}function TE(){return nE()|0}function AE(){return nE()|0}function SE(n,e){n=n|0;e=e|0;var r=0,i=0;i=0;while(1){if((o[5712+i>>0]|0)==(n|0)){n=2;break}r=i+1|0;if((r|0)==87){r=5800;i=87;n=5;break}else i=r}if((n|0)==2)if(!i)r=5800;else{r=5800;n=5}if((n|0)==5)while(1){do{n=r;r=r+1|0}while((t[n>>0]|0)!=0);i=i+-1|0;if(!i)break;else n=5}return EE(r,u[e+20>>2]|0)|0}function EE(n,e){n=n|0;e=e|0;return CE(n,e)|0}function CE(n,e){n=n|0;e=e|0;if(!e)e=0;else e=LE(u[e>>2]|0,u[e+4>>2]|0,n)|0;return(e|0?e:n)|0}function LE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,v=0;v=(u[n>>2]|0)+1794895138|0;a=RE(u[n+8>>2]|0,v)|0;i=RE(u[n+12>>2]|0,v)|0;o=RE(u[n+16>>2]|0,v)|0;n:do{if((a>>>0<e>>>2>>>0?(_=e-(a<<2)|0,i>>>0<_>>>0&o>>>0<_>>>0):0)?((o|i)&3|0)==0:0){_=i>>>2;d=o>>>2;s=0;while(1){c=a>>>1;l=s+c|0;f=l<<1;o=f+_|0;i=RE(u[n+(o<<2)>>2]|0,v)|0;o=RE(u[n+(o+1<<2)>>2]|0,v)|0;if(!(o>>>0<e>>>0&i>>>0<(e-o|0)>>>0)){i=0;break n}if(t[n+(o+i)>>0]|0){i=0;break n}i=tE(r,n+o|0)|0;if(!i)break;i=(i|0)<0;if((a|0)==1){i=0;break n}else{s=i?s:l;a=i?c:a-c|0}}i=f+d|0;o=RE(u[n+(i<<2)>>2]|0,v)|0;i=RE(u[n+(i+1<<2)>>2]|0,v)|0;if(i>>>0<e>>>0&o>>>0<(e-i|0)>>>0)i=(t[n+(i+o)>>0]|0)==0?n+i|0:0;else i=0}else i=0}while(0);return i|0}function RE(n,e){n=n|0;e=e|0;var r=0;r=sC(n|0)|0;return((e|0)==0?n:r)|0}function PE(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0,c=0;i=r+16|0;o=u[i>>2]|0;if(!o){if(!(BE(r)|0)){o=u[i>>2]|0;a=5}else i=0}else a=5;n:do{if((a|0)==5){c=r+20|0;f=u[c>>2]|0;i=f;if((o-f|0)>>>0<e>>>0){i=yL[u[r+36>>2]&7](r,n,e)|0;break}e:do{if((t[r+75>>0]|0)>-1){f=e;while(1){if(!f){a=0;o=n;break e}o=f+-1|0;if((t[n+o>>0]|0)==10)break;else f=o}i=yL[u[r+36>>2]&7](r,n,f)|0;if(i>>>0<f>>>0)break n;a=f;o=n+f|0;e=e-f|0;i=u[c>>2]|0}else{a=0;o=n}}while(0);iC(i|0,o|0,e|0)|0;u[c>>2]=(u[c>>2]|0)+e;i=a+e|0}}while(0);return i|0}function BE(n){n=n|0;var e=0,r=0;e=n+74|0;r=t[e>>0]|0;t[e>>0]=r+255|r;e=u[n>>2]|0;if(!(e&8)){u[n+8>>2]=0;u[n+4>>2]=0;r=u[n+44>>2]|0;u[n+28>>2]=r;u[n+20>>2]=r;u[n+16>>2]=r+(u[n+48>>2]|0);n=0}else{u[n>>2]=e|32;n=-1}return n|0}function OE(n,e){n=K(n);e=K(e);var r=0,t=0;r=NE(n)|0;do{if((r&2147483647)>>>0<=2139095040){t=NE(e)|0;if((t&2147483647)>>>0<=2139095040)if((t^r|0)<0){n=(r|0)<0?e:n;break}else{n=n<e?e:n;break}}else n=e}while(0);return K(n)}function NE(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function IE(n,e){n=K(n);e=K(e);var r=0,t=0;r=FE(n)|0;do{if((r&2147483647)>>>0<=2139095040){t=FE(e)|0;if((t&2147483647)>>>0<=2139095040)if((t^r|0)<0){n=(r|0)<0?n:e;break}else{n=n<e?n:e;break}}else n=e}while(0);return K(n)}function FE(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function xE(n,e){n=K(n);e=K(e);var r=0,t=0,i=0,o=0,a=0,f=0,l=0,s=0;o=(c[d>>2]=n,u[d>>2]|0);f=(c[d>>2]=e,u[d>>2]|0);r=o>>>23&255;a=f>>>23&255;l=o&-2147483648;i=f<<1;n:do{if((i|0)!=0?!((r|0)==255|((UE(e)|0)&2147483647)>>>0>2139095040):0){t=o<<1;if(t>>>0<=i>>>0){e=K(n*K(0.0));return K((t|0)==(i|0)?e:n)}if(!r){r=o<<9;if((r|0)>-1){t=r;r=0;do{r=r+-1|0;t=t<<1}while((t|0)>-1)}else r=0;t=o<<1-r}else t=o&8388607|8388608;if(!a){o=f<<9;if((o|0)>-1){i=0;do{i=i+-1|0;o=o<<1}while((o|0)>-1)}else i=0;a=i;f=f<<1-i}else f=f&8388607|8388608;i=t-f|0;o=(i|0)>-1;e:do{if((r|0)>(a|0)){while(1){if(o)if(!i)break;else t=i;t=t<<1;r=r+-1|0;i=t-f|0;o=(i|0)>-1;if((r|0)<=(a|0))break e}e=K(n*K(0.0));break n}}while(0);if(o)if(!i){e=K(n*K(0.0));break}else t=i;if(t>>>0<8388608)do{t=t<<1;r=r+-1|0}while(t>>>0<8388608);if((r|0)>0)r=t+-8388608|r<<23;else r=t>>>(1-r|0);e=(u[d>>2]=r|l,K(c[d>>2]))}else s=3}while(0);if((s|0)==3){e=K(n*e);e=K(e/e)}return K(e)}function UE(n){n=K(n);return(c[d>>2]=n,u[d>>2]|0)|0}function HE(n,e){n=n|0;e=e|0;return uE(u[582]|0,n,e)|0}function DE(n){n=n|0;Xn()}function WE(n){n=n|0;return}function YE(n,e){n=n|0;e=e|0;return 0}function VE(n){n=n|0;if((jE(n+4|0)|0)==-1){vL[u[(u[n>>2]|0)+8>>2]&127](n);n=1}else n=0;return n|0}function jE(n){n=n|0;var e=0;e=u[n>>2]|0;u[n>>2]=e+-1;return e+-1|0}function qE(n){n=n|0;if(VE(n)|0)zE(n);return}function zE(n){n=n|0;var e=0;e=n+8|0;if(!((u[e>>2]|0)!=0?(jE(e)|0)!=-1:0))vL[u[(u[n>>2]|0)+16>>2]&127](n);return}function GE(n){n=n|0;var e=0;e=(n|0)==0?1:n;while(1){n=qS(e)|0;if(n|0)break;n=ZE()|0;if(!n){n=0;break}BL[n&0]()}return n|0}function KE(n){n=n|0;return GE(n)|0}function XE(n){n=n|0;zS(n);return}function JE(n){n=n|0;if((t[n+11>>0]|0)<0)XE(u[n>>2]|0);return}function ZE(){var n=0;n=u[2923]|0;u[2923]=n+0;return n|0}function QE(){}function $E(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;t=e-t-(r>>>0>n>>>0|0)>>>0;return(L=t,n-r>>>0|0)|0}function nC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;r=n+r>>>0;return(L=e+t+(r>>>0<n>>>0|0)>>>0,r|0)|0}function eC(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0,f=0;a=n+r|0;e=e&255;if((r|0)>=67){while(n&3){t[n>>0]=e;n=n+1|0}i=a&-4|0;o=i-64|0;f=e|e<<8|e<<16|e<<24;while((n|0)<=(o|0)){u[n>>2]=f;u[n+4>>2]=f;u[n+8>>2]=f;u[n+12>>2]=f;u[n+16>>2]=f;u[n+20>>2]=f;u[n+24>>2]=f;u[n+28>>2]=f;u[n+32>>2]=f;u[n+36>>2]=f;u[n+40>>2]=f;u[n+44>>2]=f;u[n+48>>2]=f;u[n+52>>2]=f;u[n+56>>2]=f;u[n+60>>2]=f;n=n+64|0}while((n|0)<(i|0)){u[n>>2]=f;n=n+4|0}}while((n|0)<(a|0)){t[n>>0]=e;n=n+1|0}return a-r|0}function rC(n,e,r){n=n|0;e=e|0;r=r|0;if((r|0)<32){L=e<<r|(n&(1<<r)-1<<32-r)>>>32-r;return n<<r}L=n<<r-32;return 0}function tC(n,e,r){n=n|0;e=e|0;r=r|0;if((r|0)<32){L=e>>>r;return n>>>r|(e&(1<<r)-1)<<32-r}L=0;return e>>>r-32|0}function iC(n,e,r){n=n|0;e=e|0;r=r|0;var i=0,o=0,a=0;if((r|0)>=8192)return jn(n|0,e|0,r|0)|0;a=n|0;o=n+r|0;if((n&3)==(e&3)){while(n&3){if(!r)return a|0;t[n>>0]=t[e>>0]|0;n=n+1|0;e=e+1|0;r=r-1|0}r=o&-4|0;i=r-64|0;while((n|0)<=(i|0)){u[n>>2]=u[e>>2];u[n+4>>2]=u[e+4>>2];u[n+8>>2]=u[e+8>>2];u[n+12>>2]=u[e+12>>2];u[n+16>>2]=u[e+16>>2];u[n+20>>2]=u[e+20>>2];u[n+24>>2]=u[e+24>>2];u[n+28>>2]=u[e+28>>2];u[n+32>>2]=u[e+32>>2];u[n+36>>2]=u[e+36>>2];u[n+40>>2]=u[e+40>>2];u[n+44>>2]=u[e+44>>2];u[n+48>>2]=u[e+48>>2];u[n+52>>2]=u[e+52>>2];u[n+56>>2]=u[e+56>>2];u[n+60>>2]=u[e+60>>2];n=n+64|0;e=e+64|0}while((n|0)<(r|0)){u[n>>2]=u[e>>2];n=n+4|0;e=e+4|0}}else{r=o-4|0;while((n|0)<(r|0)){t[n>>0]=t[e>>0]|0;t[n+1>>0]=t[e+1>>0]|0;t[n+2>>0]=t[e+2>>0]|0;t[n+3>>0]=t[e+3>>0]|0;n=n+4|0;e=e+4|0}}while((n|0)<(o|0)){t[n>>0]=t[e>>0]|0;n=n+1|0;e=e+1|0}return a|0}function uC(n){n=n|0;var e=0;e=t[m+(n&255)>>0]|0;if((e|0)<8)return e|0;e=t[m+(n>>8&255)>>0]|0;if((e|0)<8)return e+8|0;e=t[m+(n>>16&255)>>0]|0;if((e|0)<8)return e+16|0;return(t[m+(n>>>24)>>0]|0)+24|0}function oC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;var o=0,a=0,f=0,c=0,l=0,s=0,d=0,_=0,v=0,p=0;s=n;c=e;l=c;a=r;_=t;f=_;if(!l){o=(i|0)!=0;if(!f){if(o){u[i>>2]=(s>>>0)%(a>>>0);u[i+4>>2]=0}_=0;i=(s>>>0)/(a>>>0)>>>0;return(L=_,i)|0}else{if(!o){_=0;i=0;return(L=_,i)|0}u[i>>2]=n|0;u[i+4>>2]=e&0;_=0;i=0;return(L=_,i)|0}}o=(f|0)==0;do{if(a){if(!o){o=(G(f|0)|0)-(G(l|0)|0)|0;if(o>>>0<=31){d=o+1|0;f=31-o|0;e=o-31>>31;a=d;n=s>>>(d>>>0)&e|l<<f;e=l>>>(d>>>0)&e;o=0;f=s<<f;break}if(!i){_=0;i=0;return(L=_,i)|0}u[i>>2]=n|0;u[i+4>>2]=c|e&0;_=0;i=0;return(L=_,i)|0}o=a-1|0;if(o&a|0){f=(G(a|0)|0)+33-(G(l|0)|0)|0;p=64-f|0;d=32-f|0;c=d>>31;v=f-32|0;e=v>>31;a=f;n=d-1>>31&l>>>(v>>>0)|(l<<d|s>>>(f>>>0))&e;e=e&l>>>(f>>>0);o=s<<p&c;f=(l<<p|s>>>(v>>>0))&c|s<<d&f-33>>31;break}if(i|0){u[i>>2]=o&s;u[i+4>>2]=0}if((a|0)==1){v=c|e&0;p=n|0|0;return(L=v,p)|0}else{p=uC(a|0)|0;v=l>>>(p>>>0)|0;p=l<<32-p|s>>>(p>>>0)|0;return(L=v,p)|0}}else{if(o){if(i|0){u[i>>2]=(l>>>0)%(a>>>0);u[i+4>>2]=0}v=0;p=(l>>>0)/(a>>>0)>>>0;return(L=v,p)|0}if(!s){if(i|0){u[i>>2]=0;u[i+4>>2]=(l>>>0)%(f>>>0)}v=0;p=(l>>>0)/(f>>>0)>>>0;return(L=v,p)|0}o=f-1|0;if(!(o&f)){if(i|0){u[i>>2]=n|0;u[i+4>>2]=o&l|e&0}v=0;p=l>>>((uC(f|0)|0)>>>0);return(L=v,p)|0}o=(G(f|0)|0)-(G(l|0)|0)|0;if(o>>>0<=30){e=o+1|0;f=31-o|0;a=e;n=l<<f|s>>>(e>>>0);e=l>>>(e>>>0);o=0;f=s<<f;break}if(!i){v=0;p=0;return(L=v,p)|0}u[i>>2]=n|0;u[i+4>>2]=c|e&0;v=0;p=0;return(L=v,p)|0}}while(0);if(!a){l=f;c=0;f=0}else{d=r|0|0;s=_|t&0;l=nC(d|0,s|0,-1,-1)|0;r=L;c=f;f=0;do{t=c;c=o>>>31|c<<1;o=f|o<<1;t=n<<1|t>>>31|0;_=n>>>31|e<<1|0;$E(l|0,r|0,t|0,_|0)|0;p=L;v=p>>31|((p|0)<0?-1:0)<<1;f=v&1;n=$E(t|0,_|0,v&d|0,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&s|0)|0;e=L;a=a-1|0}while((a|0)!=0);l=c;c=0}a=0;if(i|0){u[i>>2]=n;u[i+4>>2]=e}v=(o|0)>>>31|(l|a)<<1|(a<<1|o>>>31)&0|c;p=(o<<1|0>>>31)&-2|f;return(L=v,p)|0}function aC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;return oC(n,e,r,t,0)|0}function fC(n){n=n|0;var e=0,r=0;r=n+15&-16|0;e=u[s>>2]|0;n=e+r|0;if((r|0)>0&(n|0)<(e|0)|(n|0)<0){$()|0;zn(12);return-1}u[s>>2]=n;if((n|0)>(Q()|0)?(Z()|0)==0:0){u[s>>2]=e;zn(12);return-1}return e|0}function cC(n,e,r){n=n|0;e=e|0;r=r|0;var i=0;if((e|0)<(n|0)&(n|0)<(e+r|0)){i=n;e=e+r|0;n=n+r|0;while((r|0)>0){n=n-1|0;e=e-1|0;r=r-1|0;t[n>>0]=t[e>>0]|0}n=i}else iC(n,e,r)|0;return n|0}function lC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;var i=0,o=0;o=v;v=v+16|0;i=o|0;oC(n,e,r,t,i)|0;v=o;return(L=u[i+4>>2]|0,u[i>>2]|0)|0}function sC(n){n=n|0;return(n&255)<<24|(n>>8&255)<<16|(n>>16&255)<<8|n>>>24|0}function dC(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;lL[n&1](e|0,r|0,t|0,i|0,u|0)}function _C(n,e,r){n=n|0;e=e|0;r=K(r);sL[n&1](e|0,K(r))}function vC(n,e,r){n=n|0;e=e|0;r=+r;dL[n&31](e|0,+r)}function pC(n,e,r,t){n=n|0;e=e|0;r=K(r);t=K(t);return K(_L[n&0](e|0,K(r),K(t)))}function mC(n,e){n=n|0;e=e|0;vL[n&127](e|0)}function bC(n,e,r){n=n|0;e=e|0;r=r|0;pL[n&31](e|0,r|0)}function hC(n,e){n=n|0;e=e|0;return mL[n&31](e|0)|0}function yC(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;bL[n&1](e|0,+r,+t,i|0)}function wC(n,e,r,t){n=n|0;e=e|0;r=+r;t=+t;hL[n&1](e|0,+r,+t)}function MC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;return yL[n&7](e|0,r|0,t|0)|0}function kC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;return+wL[n&1](e|0,r|0,t|0)}function gC(n,e){n=n|0;e=e|0;return+ML[n&15](e|0)}function TC(n,e,r){n=n|0;e=e|0;r=+r;return kL[n&1](e|0,+r)|0}function AC(n,e,r){n=n|0;e=e|0;r=r|0;return gL[n&15](e|0,r|0)|0}function SC(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=+t;i=+i;u=u|0;TL[n&1](e|0,r|0,+t,+i,u|0)}function EC(n,e,r,t,i,u,o){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;o=o|0;AL[n&1](e|0,r|0,t|0,i|0,u|0,o|0)}function CC(n,e,r){n=n|0;e=e|0;r=r|0;return+SL[n&7](e|0,r|0)}function LC(n){n=n|0;return EL[n&7]()|0}function RC(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;return CL[n&1](e|0,r|0,t|0,i|0,u|0)|0}function PC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=+i;LL[n&1](e|0,r|0,t|0,+i)}function BC(n,e,r,t,i,u,o){n=n|0;e=e|0;r=r|0;t=K(t);i=i|0;u=K(u);o=o|0;RL[n&1](e|0,r|0,K(t),i|0,K(u),o|0)}function OC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;PL[n&15](e|0,r|0,t|0)}function NC(n){n=n|0;BL[n&0]()}function IC(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;OL[n&15](e|0,r|0,+t)}function FC(n,e,r){n=n|0;e=+e;r=+r;return NL[n&1](+e,+r)|0}function xC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;IL[n&15](e|0,r|0,t|0,i|0)}function UC(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;X(0)}function HC(n,e){n=n|0;e=K(e);X(1)}function DC(n,e){n=n|0;e=+e;X(2)}function WC(n,e,r){n=n|0;e=K(e);r=K(r);X(3);return de}function YC(n){n=n|0;X(4)}function VC(n,e){n=n|0;e=e|0;X(5)}function jC(n){n=n|0;X(6);return 0}function qC(n,e,r,t){n=n|0;e=+e;r=+r;t=t|0;X(7)}function zC(n,e,r){n=n|0;e=+e;r=+r;X(8)}function GC(n,e,r){n=n|0;e=e|0;r=r|0;X(9);return 0}function KC(n,e,r){n=n|0;e=e|0;r=r|0;X(10);return 0.0}function XC(n){n=n|0;X(11);return 0.0}function JC(n,e){n=n|0;e=+e;X(12);return 0}function ZC(n,e){n=n|0;e=e|0;X(13);return 0}function QC(n,e,r,t,i){n=n|0;e=e|0;r=+r;t=+t;i=i|0;X(14)}function $C(n,e,r,t,i,u){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;u=u|0;X(15)}function nL(n,e){n=n|0;e=e|0;X(16);return 0.0}function eL(){X(17);return 0}function rL(n,e,r,t,i){n=n|0;e=e|0;r=r|0;t=t|0;i=i|0;X(18);return 0}function tL(n,e,r,t){n=n|0;e=e|0;r=r|0;t=+t;X(19)}function iL(n,e,r,t,i,u){n=n|0;e=e|0;r=K(r);t=t|0;i=K(i);u=u|0;X(20)}function uL(n,e,r){n=n|0;e=e|0;r=r|0;X(21)}function oL(){X(22)}function aL(n,e,r){n=n|0;e=e|0;r=+r;X(23)}function fL(n,e){n=+n;e=+e;X(24);return 0}function cL(n,e,r,t){n=n|0;e=e|0;r=r|0;t=t|0;X(25)}var lL=[UC,gk];var sL=[HC,qi];var dL=[DC,bu,hu,yu,wu,Mu,ku,gu,Au,Su,Cu,Lu,Ru,Pu,Bu,Ou,Nu,Iu,Fu,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC,DC];var _L=[WC];var vL=[YC,WE,pf,mf,bf,Xd,Jd,Zd,hw,yw,ww,uk,ok,ak,oS,aS,fS,Me,Ji,eu,Tu,Eu,Ho,Do,Xa,Af,Vf,vc,Nc,il,El,zl,ds,Ns,$s,hd,xd,b_,F_,ev,wv,Hv,ip,Sp,jp,am,Cm,Yi,lb,Lb,Zb,hh,Fh,uy,by,wy,Dy,Vy,aw,gw,Sw,zw,_M,Sf,Rg,_T,PT,XT,wA,UA,JA,$A,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC,YC];var pL=[VC,ru,tu,ou,au,fu,cu,lu,su,vu,pu,mu,$u,ro,to,io,uo,oo,ao,_o,bo,Xo,Rp,Gp,kh,Og,MM,nT,VC,VC,VC,VC];var mL=[jC,KS,Xi,Du,ju,qu,zu,Gu,Ku,Xu,Zu,Qu,vo,po,Wo,Pm,Dh,Xw,Ug,Dg,jC,jC,jC,jC,jC,jC,jC,jC,jC,jC,jC,jC];var bL=[qC,Yo];var hL=[zC,lw];var yL=[GC,XS,JS,rE,fl,M_,vb,$T];var wL=[KC,td];var ML=[XC,no,eo,fo,Vo,jo,qo,zo,Go,Ko,XC,XC,XC,XC,XC,XC];var kL=[JC,_y];var gL=[ZC,YE,mo,ef,hc,Pl,Jl,Wd,D_,sm,zi,IT,ZC,ZC,ZC,ZC];var TL=[QC,Gf];var AL=[$C,TA];var SL=[nL,co,Jo,Zo,Qo,kd,nL,nL];var EL=[eL,$o,Gi,Di,Ay,Gy,Pw,tS];var CL=[rL,Ft];var LL=[tL,Tv];var RL=[iL,yo];var PL=[uL,Wu,Ju,lo,so,Uc,ms,Vv,fp,ji,Qk,bT,YA,uL,uL,uL];var BL=[oL];var OL=[aL,iu,uu,du,_u,xu,Uu,Hu,uv,Ob,fy,aL,aL,aL,aL,aL];var NL=[fL,pw];var IL=[cL,Us,Hm,eh,Xh,Py,$y,Uw,hM,qg,vS,cL,cL,cL,cL,cL];return{_llvm_bswap_i32:sC,dynCall_idd:FC,dynCall_i:LC,_i64Subtract:$E,___udivdi3:aC,dynCall_vif:_C,setThrew:be,dynCall_viii:OC,_bitshift64Lshr:tC,_bitshift64Shl:rC,dynCall_vi:mC,dynCall_viiddi:SC,dynCall_diii:kC,dynCall_iii:AC,_memset:eC,_sbrk:fC,_memcpy:iC,__GLOBAL__sub_I_Yoga_cpp:Hi,dynCall_vii:bC,___uremdi3:lC,dynCall_vid:vC,stackAlloc:_e,_nbind_init:LS,getTempRet0:ye,dynCall_di:gC,dynCall_iid:TC,setTempRet0:he,_i64Add:nC,dynCall_fiff:pC,dynCall_iiii:MC,_emscripten_get_global_libc:GS,dynCall_viid:IC,dynCall_viiid:PC,dynCall_viififi:BC,dynCall_ii:hC,__GLOBAL__sub_I_Binding_cc:Mg,dynCall_viiii:xC,dynCall_iiiiii:RC,stackSave:ve,dynCall_viiiii:dC,__GLOBAL__sub_I_nbind_cc:na,dynCall_vidd:wC,_free:zS,runPostSets:QE,dynCall_viiiiii:EC,establishStackSpace:me,_memmove:cC,stackRestore:pe,_malloc:qS,__GLOBAL__sub_I_common_cc:iM,dynCall_viddi:yC,dynCall_dii:CC,dynCall_v:NC}}(Module.asmGlobalArg,Module.asmLibraryArg,buffer),_llvm_bswap_i32=Module._llvm_bswap_i32=asm._llvm_bswap_i32,getTempRet0=Module.getTempRet0=asm.getTempRet0,___udivdi3=Module.___udivdi3=asm.___udivdi3,setThrew=Module.setThrew=asm.setThrew,_bitshift64Lshr=Module._bitshift64Lshr=asm._bitshift64Lshr,_bitshift64Shl=Module._bitshift64Shl=asm._bitshift64Shl,_memset=Module._memset=asm._memset,_sbrk=Module._sbrk=asm._sbrk,_memcpy=Module._memcpy=asm._memcpy,stackAlloc=Module.stackAlloc=asm.stackAlloc,___uremdi3=Module.___uremdi3=asm.___uremdi3,_nbind_init=Module._nbind_init=asm._nbind_init,_i64Subtract=Module._i64Subtract=asm._i64Subtract,setTempRet0=Module.setTempRet0=asm.setTempRet0,_i64Add=Module._i64Add=asm._i64Add,_emscripten_get_global_libc=Module._emscripten_get_global_libc=asm._emscripten_get_global_libc,__GLOBAL__sub_I_Yoga_cpp=Module.__GLOBAL__sub_I_Yoga_cpp=asm.__GLOBAL__sub_I_Yoga_cpp,__GLOBAL__sub_I_Binding_cc=Module.__GLOBAL__sub_I_Binding_cc=asm.__GLOBAL__sub_I_Binding_cc,stackSave=Module.stackSave=asm.stackSave,__GLOBAL__sub_I_nbind_cc=Module.__GLOBAL__sub_I_nbind_cc=asm.__GLOBAL__sub_I_nbind_cc,_free=Module._free=asm._free,runPostSets=Module.runPostSets=asm.runPostSets,establishStackSpace=Module.establishStackSpace=asm.establishStackSpace,_memmove=Module._memmove=asm._memmove,stackRestore=Module.stackRestore=asm.stackRestore,_malloc=Module._malloc=asm._malloc,__GLOBAL__sub_I_common_cc=Module.__GLOBAL__sub_I_common_cc=asm.__GLOBAL__sub_I_common_cc,dynCall_viiiii=Module.dynCall_viiiii=asm.dynCall_viiiii,dynCall_vif=Module.dynCall_vif=asm.dynCall_vif,dynCall_vid=Module.dynCall_vid=asm.dynCall_vid,dynCall_fiff=Module.dynCall_fiff=asm.dynCall_fiff,dynCall_vi=Module.dynCall_vi=asm.dynCall_vi,dynCall_vii=Module.dynCall_vii=asm.dynCall_vii,dynCall_ii=Module.dynCall_ii=asm.dynCall_ii,dynCall_viddi=Module.dynCall_viddi=asm.dynCall_viddi,dynCall_vidd=Module.dynCall_vidd=asm.dynCall_vidd,dynCall_iiii=Module.dynCall_iiii=asm.dynCall_iiii,dynCall_diii=Module.dynCall_diii=asm.dynCall_diii,dynCall_di=Module.dynCall_di=asm.dynCall_di,dynCall_iid=Module.dynCall_iid=asm.dynCall_iid,dynCall_iii=Module.dynCall_iii=asm.dynCall_iii,dynCall_viiddi=Module.dynCall_viiddi=asm.dynCall_viiddi,dynCall_viiiiii=Module.dynCall_viiiiii=asm.dynCall_viiiiii,dynCall_dii=Module.dynCall_dii=asm.dynCall_dii,dynCall_i=Module.dynCall_i=asm.dynCall_i,dynCall_iiiiii=Module.dynCall_iiiiii=asm.dynCall_iiiiii,dynCall_viiid=Module.dynCall_viiid=asm.dynCall_viiid,dynCall_viififi=Module.dynCall_viififi=asm.dynCall_viififi,dynCall_viii=Module.dynCall_viii=asm.dynCall_viii,dynCall_v=Module.dynCall_v=asm.dynCall_v,dynCall_viid=Module.dynCall_viid=asm.dynCall_viid,dynCall_idd=Module.dynCall_idd=asm.dynCall_idd,dynCall_viiii=Module.dynCall_viiii=asm.dynCall_viiii,initialStackTop;function ExitStatus(n){this.name="ExitStatus",this.message="Program terminated with exit("+n+")",this.status=n}Runtime.stackAlloc=Module.stackAlloc,Runtime.stackSave=Module.stackSave,Runtime.stackRestore=Module.stackRestore,Runtime.establishStackSpace=Module.establishStackSpace,Runtime.setTempRet0=Module.setTempRet0,Runtime.getTempRet0=Module.getTempRet0,Module.asm=asm,ExitStatus.prototype=new Error,ExitStatus.prototype.constructor=ExitStatus;var preloadStartTime=null,calledMain=!1;function run(n){function e(){Module.calledRun||(Module.calledRun=!0,ABORT||(ensureInitRuntime(),preMain(),Module.onRuntimeInitialized&&Module.onRuntimeInitialized(),Module._main&&shouldRunNow&&Module.callMain(n),postRun()))}n=n||Module.arguments,null===preloadStartTime&&(preloadStartTime=Date.now()),runDependencies>0||(preRun(),runDependencies>0||Module.calledRun||(Module.setStatus?(Module.setStatus("Running..."),setTimeout((function(){setTimeout((function(){Module.setStatus("")}),1),e()}),1)):e()))}function exit(n,e){e&&Module.noExitRuntime||(Module.noExitRuntime||(ABORT=!0,EXITSTATUS=n,STACKTOP=initialStackTop,exitRuntime(),Module.onExit&&Module.onExit(n)),ENVIRONMENT_IS_NODE&&process.exit(n),Module.quit(n,new ExitStatus(n)))}dependenciesFulfilled=function n(){Module.calledRun||run(),Module.calledRun||(dependenciesFulfilled=n)},Module.callMain=Module.callMain=function(n){n=n||[],ensureInitRuntime();var e=n.length+1;function r(){for(var n=0;n<3;n++)t.push(0)}var t=[allocate(intArrayFromString(Module.thisProgram),"i8",ALLOC_NORMAL)];r();for(var i=0;i<e-1;i+=1)t.push(allocate(intArrayFromString(n[i]),"i8",ALLOC_NORMAL)),r();t.push(0),t=allocate(t,"i32",ALLOC_NORMAL);try{exit(Module._main(e,t,0),!0)}catch(n){if(n instanceof ExitStatus)return;if("SimulateInfiniteLoop"==n)return void(Module.noExitRuntime=!0);var u=n;n&&"object"==typeof n&&n.stack&&(u=[n,n.stack]),Module.printErr("exception thrown: "+u),Module.quit(1,n)}finally{calledMain=!0}},Module.run=Module.run=run,Module.exit=Module.exit=exit;var abortDecorators=[];function abort(n){Module.onAbort&&Module.onAbort(n),void 0!==n?(Module.print(n),Module.printErr(n),n=JSON.stringify(n)):n="",ABORT=!0,EXITSTATUS=1;var e="abort("+n+") at "+stackTrace()+"\\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw abortDecorators&&abortDecorators.forEach((function(r){e=r(e,n)})),e}if(Module.abort=Module.abort=abort,Module.preInit)for("function"==typeof Module.preInit&&(Module.preInit=[Module.preInit]);Module.preInit.length>0;)Module.preInit.pop()();var shouldRunNow=!0;Module.noInitialRun&&(shouldRunNow=!1),run()}));`))($module);
	              var nbind = $module.exports;

	  /**
	   * Copyright (c) 2014-present, Facebook, Inc.
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * 
	   * @format
	   */




	  var ran = false;
	  var ret = null;

	  nbind({}, function (err, result) {
	    if (ran) {
	      return;
	    }

	    ran = true;

	    if (err) {
	      throw err;
	    }

	    ret = result;
	  });

	  if (!ran) {
	    throw new Error("Failed to load the yoga module - it needed to be loaded synchronously, but didn't");
	  }

	  // $FlowFixMe ret will not be null here
	  var entryBrowser = entryCommon(ret.bind, ret.lib);

	  return entryBrowser;

	}());


	  return Yoga
	}

	/**
	 * Main entry point. This issues a request to the web worker to perform flexbox layout
	 * on the given `styleTree`, calling the `callback` function with the results when finished.
	 *
	 * @param {FlexLayoutStyleNode} styleTree
	 * @param {function(FlexLayoutResult)} callback
	 */
	function requestFlexLayout(styleTree, callback) {
	  flexLayoutProcessorWorkerModule(styleTree).then(callback);
	}

	/**
	 * @typedef {object<FlexLayoutResultNode>} FlexLayoutResult
	 * Mapping of node ids to layout results.
	 */

	/**
	 * @typedef {object} FlexLayoutResultNode - layout result for a single flex node.
	 * @property {number} left - the node's computed left position
	 * @property {number} top - the node's computed top position
	 * @property {number} width - the node's computed width
	 * @property {number} height - the node's computed height
	 */


	/**
	 * @typedef {object} MeasureFunctionParams - Parameters for the `measureFunction`.
	 * @property {string} text
	 * @property {string} font
	 * @property {number} fontSize
	 * @property {number} lineHeight
	 * @property {number} letterSpacing
	 * @property {string} whiteSpace
	 * @property {string} overflowWrap
	 * @property {number} maxWidth
	 */

	/**
	 * Factory for the flex layout processing function. This is injected into a web worker so it
	 * must be entirely self-contained other than specific dependencies passed in as arguments.
	 * @param {object} Yoga - The yoga-layout implementation object.
	 * @param {function(fontUrl:string, callback:function)} loadFontFn - A function that
	 *        loads a given font URL, invoking a callback when complete.
	 * @param {function(MeasureFunctionParams):{width:number}} measureFunction - A function that
	 *        measures the intrinsic dimensions for a block of text with given styles and
	 *        constraints. The measurement must occur synchronously.
	 * @return {function(FlexLayoutStyleNode):FlexLayoutResult}
	 */
	function createFlexLayoutProcessor(Yoga, loadFontFn, measureFunction) {

	  const YOGA_VALUE_MAPPINGS = {
	    align: {
	      'auto': 'ALIGN_AUTO',
	      'baseline': 'ALIGN_BASELINE',
	      'center': 'ALIGN_CENTER',
	      'flex-end': 'ALIGN_FLEX_END',
	      'flex-start': 'ALIGN_FLEX_START',
	      'stretch': 'ALIGN_STRETCH'
	    },
	    direction: {
	      'column': 'FLEX_DIRECTION_COLUMN',
	      'column-reverse': 'FLEX_DIRECTION_COLUMN_REVERSE',
	      'row': 'FLEX_DIRECTION_ROW',
	      'row-reverse': 'FLEX_DIRECTION_ROW_REVERSE'
	    },
	    edge: {
	      top: 'EDGE_TOP',
	      right: 'EDGE_RIGHT',
	      bottom: 'EDGE_BOTTOM',
	      left: 'EDGE_LEFT',
	    },
	    justify: {
	      'center': 'JUSTIFY_CENTER',
	      'flex-end': 'JUSTIFY_FLEX_END',
	      'flex-start': 'JUSTIFY_FLEX_START',
	      'space-around': 'JUSTIFY_SPACE_AROUND',
	      'space-between': 'JUSTIFY_SPACE_BETWEEN'
	    },
	    position: {
	      'absolute': 'POSITION_TYPE_ABSOLUTE',
	      'relative': 'POSITION_TYPE_RELATIVE'
	    },
	    wrap: {
	      'nowrap': 'WRAP_NO_WRAP',
	      'wrap': 'WRAP_WRAP'
	    }
	  };

	  const sides = ['Top', 'Right', 'Bottom', 'Left'];

	  // Create functions for setting each supported style property on a Yoga node
	  const YOGA_SETTERS = Object.create(null)
	  // Simple properties
	  ;[
	    'width',
	    'height',
	    'minWidth',
	    'minHeight',
	    'maxWidth',
	    'maxHeight',
	    'aspectRatio',
	    ['flexDirection', YOGA_VALUE_MAPPINGS.direction],
	    'flex',
	    ['flexWrap', YOGA_VALUE_MAPPINGS.wrap],
	    'flexBasis',
	    'flexGrow',
	    'flexShrink',
	    ['alignContent', YOGA_VALUE_MAPPINGS.align],
	    ['alignItems', YOGA_VALUE_MAPPINGS.align],
	    ['alignSelf', YOGA_VALUE_MAPPINGS.align],
	    ['justifyContent', YOGA_VALUE_MAPPINGS.justify]
	  ].forEach(styleProp => {
	    let mapping = null;
	    if (Array.isArray(styleProp)) {
	      mapping = styleProp[1];
	      styleProp = styleProp[0];
	    }
	    const setter = `set${styleProp.charAt(0).toUpperCase()}${styleProp.substr(1)}`;
	    YOGA_SETTERS[styleProp] = mapping ?
	      (yogaNode, value) => {
	        if (mapping.hasOwnProperty(value)) {
	          value = Yoga[mapping[value]];
	          yogaNode[setter](value);
	        }
	      } :
	      (yogaNode, value) => {
	        yogaNode[setter](value);
	      };
	  });

	  // Position-related properties
	  YOGA_SETTERS.position = (yogaNode, value) => {
	    yogaNode.setPositionType(Yoga[YOGA_VALUE_MAPPINGS.position[value]]);
	  };
	  sides.forEach(side => {
	    const edgeConst = YOGA_VALUE_MAPPINGS.edge[side.toLowerCase()];
	    YOGA_SETTERS[side.toLowerCase()] = (yogaNode, value) => {
	      yogaNode.setPosition(Yoga[edgeConst], value);
	    };
	  })

	  // Multi-side properties
	  ;[
	    'margin',
	    'padding',
	    'border'
	  ].forEach(styleProp => {
	    sides.forEach(side => {
	      const edgeConst = YOGA_VALUE_MAPPINGS.edge[side.toLowerCase()];
	      const setter = `set${styleProp.charAt(0).toUpperCase()}${styleProp.substr(1)}`;
	      YOGA_SETTERS[`${styleProp}${side}`] = (yogaNode, value) => {
	        yogaNode[setter](Yoga[edgeConst], value);
	      };
	    });
	  });



	  function ensureAllFontsLoaded(styleTree, callback) {
	    const fonts = [];
	    let loadedCount = 0;
	    walkStyleTree(styleTree, node => {
	      if (node.text) fonts.push(node.font); //may be undef
	    });
	    if (fonts.length) {
	      for (let i = 0; i < fonts.length; i++) {
	        loadFontFn(fonts[i], () => {
	          loadedCount++;
	          if (loadedCount === fonts.length) {
	            callback();
	          }
	        });
	      }
	    } else {
	      callback();
	    }
	  }

	  function walkStyleTree(styleTree, callback) {
	    callback(styleTree);
	    if (styleTree.children) {
	      for (let i = 0, len = styleTree.children.length; i < len; i++) {
	        walkStyleTree(styleTree.children[i], callback);
	      }
	    }
	  }

	  function process(styleTree, callback) {
	    // Init common node config
	    const yogaConfig = Yoga.Config.create();
	    yogaConfig.setPointScaleFactor(0); //disable value rounding

	    // Ensure all fonts required for measuring text nodes within this layout are pre-loaded,
	    // so that all text measurement calls can happen synchronously
	    ensureAllFontsLoaded(styleTree, () => {
	      // TODO for now, just to keep things simple, we'll rebuild the entire Yoga tree on every
	      // call, but we should look into persisting it across calls for more efficient updates

	      function populateNode(yogaNode, styleNode) {
	        if (!styleNode) {
	          throw new Error('Style node with no id')
	        }

	        for (let prop in styleNode) {
	          if (styleNode.hasOwnProperty(prop)) {
	            // Look for a style setter, and invoke it
	            const setter = YOGA_SETTERS[prop];
	            if (setter) {
	              setter(yogaNode, styleNode[prop]);
	            }
	            // If the node has text, set up its measurement function
	            else if (prop === 'text') {
	              yogaNode.setMeasureFunc((innerWidth, widthMeasureMode, innerHeight, heightMeasureMode) => {
	                const params = {
	                  text: styleNode.text,
	                  font: styleNode.font,
	                  fontSize: styleNode.fontSize,
	                  lineHeight: styleNode.lineHeight,
	                  letterSpacing: styleNode.letterSpacing,
	                  whiteSpace: styleNode.whiteSpace,
	                  overflowWrap: styleNode.overflowWrap,
	                  maxWidth: isNaN(innerWidth) ? Infinity : innerWidth
	                };
	                // NOTE: this assumes the measureFunction will exec the callback synchronously; this works
	                // with current impl since we preload all needed fonts above, but it would be good to
	                // formalize that contract in the LayoutEngine
	                let result = measureFunction(params);
	                if (result) {
	                  // Apply a fudge factor to avoid issues where the flexbox layout result using this
	                  // measurement ends up slightly smaller (due to rounding?) and making text wrap
	                  result.width += styleNode.fontSize * 0.00001;
	                }
	                return result || {width: 0, height: 0}
	              });
	            }
	          }
	        }

	        // Recurse to children
	        if (styleNode.children) {
	          for (let i = 0, len = styleNode.children.length; i < len; i++) {
	            const childYogaNode = Yoga.Node.createWithConfig(yogaConfig);
	            populateNode(childYogaNode, styleNode.children[i]);
	            yogaNode.insertChild(childYogaNode, i);
	          }
	        }

	        // Store the Yoga node on the style object, so we can access each Yoga node's original
	        // context when traversing post-layout
	        styleNode.yogaNode = yogaNode;
	      }
	      const root = Yoga.Node.createWithConfig(yogaConfig);
	      populateNode(root, styleTree);

	      // Perform the layout and collect the results as a flat id-to-computed-layout map
	      root.calculateLayout();
	      const results = Object.create(null);
	      walkStyleTree(styleTree, styleNode => {
	        const {id, yogaNode} = styleNode;
	        results[id] = {
	          left: yogaNode.getComputedLeft(),
	          top: yogaNode.getComputedTop(),
	          width: yogaNode.getComputedWidth(),
	          height: yogaNode.getComputedHeight()
	        };
	      });
	      root.freeRecursive();

	      callback(results);
	    });
	  }

	  return process
	}


	const flexLayoutProcessorWorkerModule = defineWorkerModule({
	  name: 'FlexLayoutProcessor',
	  dependencies: [
	    yogaFactory,
	    typesetterWorkerModule,
	    createFlexLayoutProcessor,
	  ],
	  init(yogaFactory, layoutEngine, create) {
	    const Yoga = yogaFactory();
	    function measure(params) {
	      let result = null;
	      layoutEngine.measure(params, r => {result = r;});
	      return result
	    }
	    const process = create(Yoga, layoutEngine.loadFont, measure);
	    return function(styleTree) {
	      return new Promise(resolve => {
	        process(styleTree, resolve);
	      })
	    }
	  }
	});

	const { assign, createClassExtender } = utils;

	/**
	 * Extends a given Facade class to become a `FlexNode`, giving it the ability to participate
	 * in flexbox layout. The resulting class behaves just like the original facade class, except:
	 *
	 * - It now accepts a full set of flexbox-related input properties, defined below
	 * - Those input properties get evaluated by a flexbox layout algorithm in the background
	 * - The resulting layout metrics get written to the object as properties that the extended
	 *   facade class can use in its `afterUpdate` method to affect its position/size/styling.
	 *
	 * The flexbox layout algorithm is performed asynchronously within a web worker, so the result
	 * metrics will probably not be available the first time `afterUpdate` is called. This can
	 * sometimes cause issues with rendering due to NaNs, so it's good to check first that the
	 * object has a nonzero `offsetWidth` and `offsetHeight` before displaying the node's object(s).
	 *
	 * Currently the flexbox algorithm implementation is Facebook's Yoga. (https://yogalayout.com/)
	 *
	 * *Supported input flexbox style properties:*
	 * - width (number, string percentage, or 'auto')
	 * - height (number, string percentage, or 'auto')
	 * - minWidth (number, string percentage, or 'auto')
	 * - minHeight (number, string percentage, or 'auto')
	 * - maxWidth (number, string percentage, or 'auto')
	 * - maxHeight (number, string percentage, or 'auto')
	 * - aspectRatio (number, as width divided by height, or 'auto')
	 * - flexDirection ('column', 'column-reverse', 'row', or 'row-reverse')
	 * - flexWrap ('wrap' or 'nowrap')
	 * - flex (number, where positive becomes flexGrow and negative becomes flexShrink)
	 * - flexGrow (number)
	 * - flexShrink (number)
	 * - flexBasis (number, string percentage, or 'auto')
	 * - alignContent ('auto', 'baseline', 'center', 'flex-end', 'flex-start', or 'stretch')
	 * - alignItems ('auto', 'baseline', 'center', 'flex-end', 'flex-start', or 'stretch')
	 * - alignSelf ('auto', 'baseline', 'center', 'flex-end', 'flex-start', or 'stretch')
	 * - justifyContent ('center', 'flex-end', 'flex-start', 'space-around', or 'space-between')
	 * - position ('relative' or 'absolute')
	 * - top (number, string percentage, or 'auto')
	 * - right (number, string percentage, or 'auto')
	 * - bottom (number, string percentage, or 'auto')
	 * - left (number, string percentage, or 'auto')
	 * - margin (number, or array of up to four numbers in t-r-b-l order)
	 * - padding (number, or array of up to four numbers in t-r-b-l order)
	 * - borderWidth (number, or array of up to four numbers in t-r-b-l order)
	 * - overflow ('visible', 'hidden', or 'scroll')
	 *
	 * *Computed layout result properties:*
	 * - offsetLeft
	 * - offsetTop
	 * - offsetWidth
	 * - offsetHeight
	 * - clientLeft
	 * - clientTop
	 * - clientWidth
	 * - clientHeight
	 * - scrollLeft
	 * - scrollTop
	 * - scrollWidth
	 * - scrollHeight
	 * - clipLeft
	 * - clipTop
	 * - clipRight
	 * - clipBottom
	 * (All of these are `null` initially and then numbers after the layout completes, except
	 * scrollLeft and scrollTop which are `0` initially.)
	 *
	 * *Additional FlexNode-specific properties:*
	 * - isFlexNode (`true`, can be used to find FlexNodes in the facade tree)
	 * - flexNodeDepth (number, where topmost FlexNode's depth is `0` and children increase by 1)
	 * - parentFlexNode (the nearest parent FlexNode instance, or `null` if this is the root FlexNode)
	 * - needsFlexLayout (boolean, can be set to force a recalculation of the full flexbox layout)
	 *
	 * If the base class implements an `onAfterFlexLayoutApplied`, that will be invoked after the
	 * results of a flex layout pass have been written to the object. This is a good place to put
	 * custom logic that depends on a completed layout, rather than in `afterUpdate` which may have
	 * layout properties queued but not yet evaluated.
	 *
	 * @param {class} BaseFacadeClass
	 * @return {FlexNode} a new class that extends the BaseFacadeClass
	 */
	const extendAsFlexNode = createClassExtender('flexNode', BaseFacadeClass => {

	  class FlexNode extends BaseFacadeClass {
	    constructor(parent) {
	      super(parent);
	      this.isFlexNode = true;
	      this.needsFlexLayout = true;

	      // Object holding all input styles for this node in the flex tree; see the style object
	      // format in troika-flex-layout
	      this._flexStyles = {
	        id: this.$facadeId
	      };

	      // Look for the nearest flex layout ancestor; if there is one, add to its layout children,
	      // otherwise we're a flex layout root.
	      let parentFlexFacade = parent;
	      while (parentFlexFacade && !parentFlexFacade.isFlexNode) {parentFlexFacade = parentFlexFacade.parent;}
	      if (parentFlexFacade) {
	        this.parentFlexNode = parentFlexFacade;
	        this.flexNodeDepth = parentFlexFacade.flexNodeDepth + 1;
	      } else {
	        this.flexNodeDepth = 0;
	      }
	    }

	    afterUpdate() {
	      // Keep max scroll and clip rects in sync
	      if (this.offsetWidth != null) {
	        this._checkOverscroll();
	        this._updateClipRect();
	      }

	      super.afterUpdate();

	      // Did something change that requires a layout recalc?
	      if (this.needsFlexLayout) {
	        // If we're managed by an ancestor layout root, let it know
	        if (this.parentFlexNode) {
	          this.notifyWorld('needsFlexLayout');
	          this.needsFlexLayout = false;
	        }
	        // If we're the layout root, perform the layout
	        else {
	          this._performRootLayout();
	        }
	      }
	    }

	    destructor() {
	      if (this.parentFlexNode) {
	        this.notifyWorld('needsFlexLayout');
	      }
	      super.destructor();
	    }

	    onNotifyWorld(source, message, data) {
	      if (message === 'needsFlexLayout' && !this.parentFlexNode) {
	        this.needsFlexLayout = true;
	        if (!this._rootLayoutReq) {
	          this._rootLayoutReq = setTimeout(this._performRootLayout.bind(this), 0);
	        }
	        return
	      }
	      super.onNotifyWorld(source, message, data);
	    }

	    _performRootLayout() {
	      // If there's a request in progress, don't queue another one yet; that will happen
	      // automatically after the current one finishes and it calls afterUpdate again
	      if (this._hasActiveFlexRequest) return

	      this._hasActiveFlexRequest = true;
	      this.needsFlexLayout = false;
	      clearTimeout(this._rootLayoutReq);
	      delete this._rootLayoutReq;

	      // Traverse the flex node tree in document order and add the ordered child
	      // relationships to the style nodes at each level
	      this.traverse(facade => {
	        if (facade.isFlexNode) {
	          const parent = facade.parentFlexNode;
	          if (parent) {
	            const siblings = parent._flexStyles.children || (parent._flexStyles.children = []);
	            siblings.push(facade._flexStyles);
	          }
	          facade._flexStyles.children = null; //clear own leftover children from last time
	        }
	      });

	      requestFlexLayout(this._flexStyles, results => {
	        if (!this.isDestroying) {
	          this._applyRootLayoutResults(results);

	          // Final afterUpdate on the whole subtree
	          this._hasActiveFlexRequest = false;
	          this.afterUpdate();
	          this.requestRender();
	        }
	      });
	    }

	    _applyRootLayoutResults(results) {
	      // Results will be a flat map of facade id to computed layout; traverse the tree
	      // and math them up, applying them as `computedXYZ` properties
	      this.traverse(facade => {
	        if (facade.isFlexNode) {
	          const computedLayout = results[facade.$facadeId];
	          if (computedLayout) {
	            const {left, top, width, height} = computedLayout;
	            const {borderWidth, padding} = facade;

	            // Outer metrics
	            facade.offsetLeft = left;
	            facade.offsetTop = top;
	            facade.offsetWidth = width;
	            facade.offsetHeight = height;

	            // Inner metrics
	            facade.clientLeft = borderWidth[3] + padding[3];
	            facade.clientTop = borderWidth[0] + padding[0];
	            facade.clientWidth = width - borderWidth[1] - borderWidth[3] - padding[1] - padding[3];
	            facade.clientHeight = height - borderWidth[0] - borderWidth[2] - padding[0] - padding[2];

	            // Scrolling metrics
	            facade.scrollHeight = facade.scrollWidth = 0;
	            const parent = facade.parentFlexNode;
	            if (parent) {
	              let w = left + width - parent.clientLeft;
	              let h = top + height - parent.clientTop;
	              // Note: allowing a small tolerance here between scrollWidth/Height and clientWidth/Height,
	              // to account for very slight overflows due to floating point math errors
	              if (w > parent.scrollWidth) {
	                if (Math.abs(w - parent.clientWidth) < w / 10000) {
	                  w = parent.clientWidth;
	                }
	                parent.scrollWidth = w;
	              }
	              if (h > parent.scrollHeight) {
	                if (Math.abs(h - parent.clientHeight) < h / 10000) {
	                  h = parent.clientHeight;
	                }
	                parent.scrollHeight = h;
	              }
	            }

	            if (facade.onAfterFlexLayoutApplied) {
	              facade.onAfterFlexLayoutApplied();
	            }
	          }
	        }
	      });
	    }

	    _checkOverscroll() {
	      const {scrollLeft, scrollTop} = this;
	      if (scrollLeft || scrollTop) {
	        const maxScrollLeft = Math.max(0, this.scrollWidth - this.clientWidth);
	        const maxScrollTop = Math.max(0, this.scrollHeight - this.clientHeight);
	        if (maxScrollLeft < scrollLeft) {
	          this.scrollLeft = maxScrollLeft;
	        }
	        if (maxScrollTop < scrollTop) {
	          this.scrollTop = maxScrollTop;
	        }
	      }
	    }

	    _updateClipRect() {
	      const {offsetWidth, offsetHeight, parentFlexNode:parent} = this;
	      const INF = Infinity;
	      let clipLeft, clipTop, clipRight, clipBottom;

	      if (parent && this.position !== 'absolute') {
	        const scrolledLeft = this.offsetLeft - parent.scrollLeft;
	        const scrolledTop = this.offsetTop - parent.scrollTop;
	        const doesParentClip = parent.overflow !== 'visible';
	        clipLeft = Math.max(doesParentClip ? parent.clientLeft : -INF, parent.clipLeft) - scrolledLeft;
	        clipTop = Math.max(doesParentClip ? parent.clientTop : -INF, parent.clipTop) - scrolledTop;
	        clipRight = Math.min(doesParentClip ? parent.clientLeft + parent.clientWidth : INF, parent.clipRight) - scrolledLeft;
	        clipBottom = Math.min(doesParentClip ? parent.clientTop + parent.clientHeight : INF, parent.clipBottom) - scrolledTop;
	      } else {
	        clipLeft = clipTop = -INF;
	        clipRight = clipBottom = INF;
	      }

	      this.clipLeft = clipLeft;
	      this.clipTop = clipTop;
	      this.clipRight = clipRight;
	      this.clipBottom = clipBottom;
	      this.isFullyClipped = clipLeft >= offsetWidth || clipTop >= offsetHeight ||
	        clipRight <= 0 || clipBottom <= 0 ||
	        clipLeft === clipRight || clipTop === clipBottom;
	    }
	  }

	  // Define computed layout properties. Those that depend on a layout computation will be null
	  // initially, and set to numbers after layout calculation is completed. Derived facades should
	  // use these to update their rendering.
	  assign(FlexNode.prototype, {
	    offsetLeft: null,
	    offsetTop: null,
	    offsetWidth: null,
	    offsetHeight: null,
	    clientLeft: null,
	    clientTop: null,
	    clientWidth: null,
	    clientHeight: null,
	    scrollLeft: 0,
	    scrollTop: 0,
	    scrollWidth: null,
	    scrollHeight: null,
	    clipLeft: null,
	    clipTop: null,
	    clipRight: null,
	    clipBottom: null,
	    isFullyClipped: false,
	    overflow: 'visible'
	  })

	  // Setters for simple flex layout properties that can be copied directly into the
	  // flex node's style input object
	  ;[
	    'width',
	    'height',
	    'minWidth',
	    'minHeight',
	    'maxWidth',
	    'maxHeight',
	    'aspectRatio',
	    'flexDirection',
	    'flex',
	    'flexWrap',
	    'flexBasis',
	    'flexGrow',
	    'flexShrink',
	    'alignContent',
	    'alignItems',
	    'alignSelf',
	    'justifyContent',
	    'position',
	    'left',
	    'right',
	    'top',
	    'bottom'
	  ].forEach(prop => {
	    Object.defineProperty(FlexNode.prototype, prop, {
	      get() {
	        return this._flexStyles[prop]
	      },
	      set(value) {
	        if (value !== this._flexStyles[prop]) {
	          this._flexStyles[prop] = value;
	          this.needsFlexLayout = true;
	        }
	      },
	      configurable: true
	    });
	  })

	  // Add setters to normalize top/right/bottom/left properties which can be a single
	  // number or an array of up to 4 numbers, like their corresponding CSS shorthands
	  ;[
	    'margin',
	    'padding',
	    'borderWidth'
	  ].forEach(prop => {
	    const privateProp = `_priv_${prop}`;
	    const styleBase = prop === 'borderWidth' ? 'border' : prop;
	    const topStyle = styleBase + 'Top';
	    const rightStyle = styleBase + 'Right';
	    const bottomStyle = styleBase + 'Bottom';
	    const leftStyle = styleBase + 'Left';
	    Object.defineProperty(FlexNode.prototype, prop, {
	      get() {
	        return this[privateProp] || (this[privateProp] = Object.freeze([0, 0, 0, 0]))
	      },
	      set(value) {
	        let t, r, b, l;
	        if (Array.isArray(value)) {
	          const len = value.length;
	          t = value[0] || 0;
	          r = (len > 1 ? value[1] : value[0]) || 0;
	          b = (len > 2 ? value[2] : value[0]) || 0;
	          l = (len > 3 ? value[3] : len > 1 ? value[1] : value[0]) || 0;
	        } else {
	          t = r = b = l = value;
	        }
	        const arr = this[prop];
	        if (t !== arr[0] || r !== arr[1] || b !== arr[2] || l !== arr[3]) {
	          this[privateProp] = Object.freeze([t, r, b, l]);
	          const styles = this._flexStyles;
	          styles[topStyle] = t;
	          styles[rightStyle] = r;
	          styles[bottomStyle] = b;
	          styles[leftStyle] = l;
	          this.needsFlexLayout = true;
	        }
	      }
	    });
	  });

	  return FlexNode
	});

	const tempVec4$1 = new Vector4();

	let getMeshes = function() {
	  let material = createDerivedMaterial(
	    new MeshBasicMaterial({
	      transparent: true,
	      opacity: 0.3,
	      depthWrite: false
	    }),
	    {
	      uniforms: {
	        rect: {value: new Vector4()},
	        depthAndCurveRadius: {value: new Vector2()}
	      },
	      vertexDefs: `
uniform vec4 rect;
uniform vec2 depthAndCurveRadius;
`,
	      vertexTransform: `
float depth = depthAndCurveRadius.x;
float rad = depthAndCurveRadius.y;
position.x = mix(rect.x, rect.z, position.x);
position.y = mix(rect.w, rect.y, position.y);
position.z = mix(-depth * 0.5, depth * 0.5, position.z);
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * (rad - position.z), rad - cos(angle) * (rad - position.z));
  // TODO fix normals: normal.xz = vec2(sin(angle), cos(angle));
}
`
	    }
	  );
	  const meshes = {
	    normal: new Mesh(
	      new BoxGeometry(1, 1, 1).translate(0.5, 0.5, 0.5),
	      material
	    ),
	    curved: new Mesh(
	      new BoxGeometry(1, 1, 1, 32).translate(0.5, 0.5, 0.5),
	      material
	    )
	  };
	  return (getMeshes = () => meshes)()
	};


	// TODO make instanceable or a single updated geometry to limit to a single draw call

	class RangeRectFacade extends Instanceable3DFacade {
	  constructor (parent) {
	    super(parent);
	    this.depth = 0;
	    this.curveRadius = 0;
	    this._color = new Color();
	    this._rect = new Vector4();
	  }

	  afterUpdate() {
	    const {top, right, bottom, left, color, depth, curveRadius} = this;
	    this.instancedThreeObject = getMeshes()[curveRadius ? 'curved' : 'normal'];

	    if (!this._color.equals(color)) {
	      this.setInstanceUniform('diffuse', this._color = new Color(color));
	    }

	    if (!this._rect.equals(tempVec4$1.set(left, top, right, bottom))) {
	      this.setInstanceUniform('rect', tempVec4$1.clone());
	    }
	    if (!depth !== this._depth || curveRadius !== this._curveRadius) {
	      this.setInstanceUniform('depthAndCurveRadius', new Vector2(this._depth = depth, this._curveRadius = curveRadius));
	    }
	    super.afterUpdate();
	  }

	  getBoundingSphere () {
	    return null
	  }
	}

	const THICKNESS = 0.25; //rect depth as percentage of height

	const tempMat4$1 = new Matrix4();
	const tempPlane$1 = new Plane();
	const tempVec2 = new Vector2();
	const tempVec3 = new Vector3();
	const noClip = Object.freeze([-Infinity, -Infinity, Infinity, Infinity]);

	/**
	 * Manager facade for selection rects and user selection behavior
	 */
	class SelectionManagerFacade extends List {
	  constructor (parent, onSelectionChange) {
	    super(parent);
	    const textMesh = parent.threeObject;

	    this.rangeColor = 0x00ccff;
	    this.clipRect = noClip;
	    this.curveRadius = 0;

	    this.template = {
	      key: (d, i) => `rect${i}`,
	      facade: RangeRectFacade,
	      top: d => clamp(d.top, this.clipRect[1], this.clipRect[3]),
	      right: d => clamp(d.right, this.clipRect[0], this.clipRect[2]),
	      bottom: d => clamp(d.bottom, this.clipRect[1], this.clipRect[3]),
	      left: d => clamp(d.left, this.clipRect[0], this.clipRect[2]),
	      depth: d => (d.top - d.bottom) * THICKNESS,
	      color: d => this.rangeColor,
	      curveRadius: d => this.curveRadius,
	      visible: d => {
	        let r = this.clipRect;
	        return d.right > r[0] && d.top > r[1] && d.left < r[2] && d.bottom < r[3]
	      },
	      renderOrder: d => this.renderOrder || 0
	    };

	    const onDragStart = e => {
	      const textRenderInfo = textMesh.textRenderInfo;
	      if (textRenderInfo) {
	        const textPos = textMesh.worldPositionToTextCoords(e.intersection.point, tempVec2);
	        const caret = getCaretAtPoint(textRenderInfo, textPos.x, textPos.y);
	        if (caret) {
	          onSelectionChange(caret.charIndex, caret.charIndex);
	          parent.addEventListener('drag', onDrag);
	          parent.addEventListener('dragend', onDragEnd);
	        }
	        e.preventDefault();
	      }
	    };

	    const onDrag = e => {
	      const textRenderInfo = textMesh.textRenderInfo;
	      if (e.ray && textRenderInfo) {
	        // If it's hitting on the Text mesh, do an exact translation; otherwise raycast to an
	        // infinite plane so dragging outside the text bounds will work
	        let textPos;
	        const ix = e.intersection;
	        if (ix && ix.object === textMesh && ix.point) {
	          textPos = textMesh.worldPositionToTextCoords(ix.point, tempVec2);
	        } else {
	          const ray = e.ray.clone().applyMatrix4(invertMatrix4(textMesh.matrixWorld, tempMat4$1));
	          textPos = ray.intersectPlane(tempPlane$1.setComponents(0, 0, 1, 0), tempVec3);
	        }
	        if (textPos) {
	          const caret = getCaretAtPoint(textRenderInfo, textPos.x, textPos.y);
	          if (caret) {
	            onSelectionChange(this.selectionStart, caret.charIndex);
	          }
	        }
	        e.preventDefault();
	      }
	    };

	    const onDragEnd = e => {
	      parent.removeEventListener('drag', onDrag);
	      parent.removeEventListener('dragend', onDragEnd);
	    };

	    parent.addEventListener('dragstart', onDragStart);
	    parent.addEventListener('mousedown', onDragStart);

	    this._cleanupEvents = () => {
	      onDragEnd();
	      parent.removeEventListener('dragstart', onDragStart);
	      parent.removeEventListener('mousedown', onDragStart);
	    };
	  }

	  afterUpdate() {
	    this.data = getSelectionRects(this.textRenderInfo, this.selectionStart, this.selectionEnd);
	    super.afterUpdate();
	  }

	  // normalize clipRect
	  set clipRect(clipRect) {
	    this._clipRect = (clipRect && Array.isArray(clipRect) && clipRect.length === 4) ? clipRect : noClip;
	  }
	  get clipRect() {
	    return this._clipRect
	  }

	  destructor () {
	    this._cleanupEvents();
	    super.destructor();
	  }
	}

	function clamp(val, min, max) {
	  return Math.min(max, Math.max(min, val))
	}

	// Properties that will simply be forwarded to the TextMesh:
	const TEXT_MESH_PROPS = [
	  'text',
	  'anchorX',
	  'anchorY',
	  'font',
	  'fontSize',
	  'letterSpacing',
	  'lineHeight',
	  'maxWidth',
	  'overflowWrap',
	  'direction',
	  'textAlign',
	  'textIndent',
	  'whiteSpace',
	  'material',
	  'color',
	  'colorRanges',
	  'fillOpacity',
	  'outlineOpacity',
	  'outlineColor',
	  'outlineWidth',
	  'outlineOffsetX',
	  'outlineOffsetY',
	  'outlineBlur',
	  'strokeColor',
	  'strokeWidth',
	  'strokeOpacity',
	  'curveRadius',
	  'depthOffset',
	  'clipRect',
	  'orientation',
	  'glyphGeometryDetail',
	  'sdfGlyphSize',
	  'gpuAccelerateSDF',
	  'debugSDF'
	];


	/**
	 * Facade wrapper for a TextMesh. All configuration properties of TextMesh
	 * are accepted and proxied through directly.
	 */
	class Text3DFacade extends Object3DFacade {
	  constructor(parent) {
	    const mesh = new Text();
	    mesh.geometry.boundingSphere.version = 0;
	    super(parent, mesh);

	    /* TODO mirroring to DOM...?
	    const el = this._domEl = document.createElement('section')
	    el.style = 'position:fixed;left:-99px;overflow:hidden;width:10px;height:10px;'
	    document.body.appendChild(el) //should insert into local element
	    */

	    this.selectable = false;
	    this.selectionStart = this.selectionEnd = -1;
	    this.onSyncStart = null;
	    this.onSyncComplete = null;
	    this.gpuAccelerateSDF = true;

	    mesh.addEventListener('syncstart', e => {
	      this.notifyWorld('text3DSyncStart');
	      if (this.onSyncStart) {
	        this.onSyncStart();
	      }
	    });
	    mesh.addEventListener('synccomplete', e => {
	      if (!this.isDestroying) {
	        mesh.geometry.boundingSphere.version++;
	        this.afterUpdate();
	        this.notifyWorld('text3DSyncComplete');
	        this.requestRender();
	        if (this.onSyncComplete) {
	          this.onSyncComplete();
	        }
	      }
	    });
	  }

	  get textRenderInfo() {
	    return this.threeObject.textRenderInfo
	  }

	  afterUpdate() {
	    const textMesh = this.threeObject;
	    TEXT_MESH_PROPS.forEach(prop => {
	      textMesh[prop] = this[prop];
	    });
	    textMesh.sync();

	    super.afterUpdate();

	    if (this.text !== this._prevText) {
	      // TODO mirror to DOM... this._domEl.textContent = this.text
	      // Clear selection when text changes
	      this.selectionStart = this.selectionEnd = -1;
	      this._prevText = this.text;
	    }

	    this._updateSelection();
	  }

	  _updateSelection() {
	    const {selectable, selectionStart, selectionEnd} = this;
	    let selFacade = this._selectionFacade;
	    if (selectable !== this._selectable) {
	      this._selectable = selectable;
	      if (selectable) {
	        selFacade = this._selectionFacade = new SelectionManagerFacade(this, (start, end) => {
	          this.selectionStart = start;
	          this.selectionEnd = end;
	          this._updateSelection();
	          this.requestRender();
	        });
	      } else {
	        if (selFacade) {
	          selFacade.destructor();
	          selFacade = this._selectionFacade = null;
	        }
	        this.selectionStart = this.selectionEnd = -1;
	      }
	    }
	    if (selFacade) {
	      selFacade.textRenderInfo = this.threeObject.textRenderInfo;
	      selFacade.selectionStart = selectionStart;
	      selFacade.selectionEnd = selectionEnd;
	      selFacade.curveRadius = this.curveRadius || 0;
	      selFacade.clipRect = this.clipRect;
	      selFacade.renderOrder = this.renderOrder;
	      selFacade.afterUpdate();
	    }

	    /* TODO update selection in DOM...
	    const {selectionStart, selectionEnd} = this
	    if (selectionStart !== this._prevSelStart || selectionEnd !== this._prevSelEnd) {
	      this._prevSelStart = selectionStart
	      this._prevSelEnd = selectionEnd
	      const sel = document.getSelection()
	      sel.removeAllRanges()
	      if (this.selectable && selectionStart > -1 && selectionEnd > selectionStart) {
	        const range = document.createRange()
	        range.setStart(this._domEl.firstChild, this.selectionStart)
	        range.setEnd(this._domEl.firstChild, this.selectionEnd)
	        sel.addRange(range)
	      }
	    }
	    */
	  }

	  destructor() {
	    this.threeObject.dispose();
	    //this._domEl.parentNode.removeChild(this._domEl)
	    if (this._selectionFacade) {
	      this._selectionFacade.destructor();
	    }
	    super.destructor();
	  }
	}

	const UNDEF = undefined;

	// List of UI flex node properties that should be inherited by default:
	const INHERITABLES = [
	  'font',
	  'fontSize',
	  'textAlign',
	  'textIndent',
	  'lineHeight',
	  'letterSpacing',
	  'whiteSpace',
	  'overflowWrap',
	  'color'
	];

	function getInheritable(owner, prop, defaultValue) {
	  let val;
	  while (owner && (val = owner[prop]) === 'inherit') {
	    owner = owner.parentFlexNode;
	    val = UNDEF;
	  }
	  if (val === UNDEF) {
	    val = defaultValue;
	  }
	  return val
	}

	function getComputedFontSize(owner, defaultFontSize) {
	  let val;
	  while (owner && typeof (val = owner.fontSize) === 'string') {
	    if (val === 'inherit') {
	      owner = owner.parentFlexNode;
	      val = UNDEF;
	    } else if (/%$/.test(val)) {
	      const multiplier = parseFloat(val) / 100;
	      val = getComputedFontSize(owner.parentFlexNode, defaultFontSize);
	      if (val !== UNDEF) {
	        val *= multiplier;
	      }
	      break
	    } else {
	      val = UNDEF;
	      break
	    }
	  }
	  if (val === UNDEF) {
	    val = defaultFontSize;
	  }
	  return val
	}

	const flexLayoutTextProps = ['text', 'textIndent', 'font', 'fontSize', 'lineHeight', 'letterSpacing', 'whiteSpace', 'overflowWrap'];
	const noop = () => {};

	/**
	 * Wrapper for Text3DFacade that lets it act as a flex layout node. This shouldn't be used
	 * directly, but will be created as an implicit child by {@link UIBlock3DFacade} when
	 * configured with a `text` property.
	 */
	class UITextNode3DFacadeBase extends Text3DFacade {
	  constructor (props) {
	    super(props);

	    // Override the sync method so we can have control over when it's called
	    let mesh = this.threeObject;
	    mesh._actuallySync = mesh.sync;
	    mesh.sync = noop;
	  }

	  afterUpdate() {
	    // Read computed layout
	    const {
	      offsetLeft,
	      offsetTop,
	      offsetWidth
	    } = this;

	    // Update position and size if flex layout has been completed
	    const hasLayout = offsetWidth !== null;
	    if (hasLayout) {
	      let parent = this.parentFlexNode;
	      this.x = offsetLeft - parent.scrollLeft;
	      this.y = -(offsetTop - parent.scrollTop);

	      // Update clip rect based on parent
	      const clipRect = this.clipRect || (this.clipRect = [0, 0, 0, 0]);
	      clipRect[0] = this.clipLeft;
	      clipRect[1] = -this.clipBottom;
	      clipRect[2] = this.clipRight;
	      clipRect[3] = -this.clipTop;

	      // If fully hidden by parent clipping rect, cull this object out of the scene
	      this.threeObject.visible = !this.isFullyClipped;
	    }

	    // Check text props that could affect flex layout
	    // TODO seems odd that this happens here rather than FlexLayoutNode
	    const flexStyles = this._flexStyles;
	    for (let i = 0, len = flexLayoutTextProps.length; i < len; i++) {
	      const prop = flexLayoutTextProps[i];
	      const val = prop === 'text' ? this.text : getInheritable(this, prop);
	      if (val !== flexStyles[prop]) {
	        flexStyles[prop] = this[prop];
	        this.needsFlexLayout = true;
	      }
	    }

	    super.afterUpdate();
	  }

	  onAfterFlexLayoutApplied() {
	    this.threeObject.maxWidth = this.offsetWidth;
	    this.threeObject._actuallySync(this._afterSync);
	  }

	  getBoundingSphere() {
	    return null //parent UIBlock3DFacade will handle bounding sphere and raycasting
	  }
	}

	// Extend as FlexNode
	const UITextNode3DFacade = extendAsFlexNode(UITextNode3DFacadeBase);

	INHERITABLES.forEach(prop => {
	  UITextNode3DFacade.prototype[prop] = 'inherit';
	});

	// Redefine the maxWidth property so it's not treated as a setter that affects flexbox layout
	Object.defineProperty(UITextNode3DFacade.prototype, 'maxWidth', {
	  value: Infinity,
	  enumerable: true,
	  writable: true
	});

	// language=GLSL
	const VERTEX_DEFS = `
uniform vec2 uTroikaBlockSize;
uniform vec4 uTroikaClipRect;
varying vec2 vTroikaPosInBlock;
`;

	// language=GLSL prefix="void main() {" suffix="}"
	const VERTEX_TRANSFORM = `
vec2 xy = position.xy * uTroikaBlockSize;
xy.y *= -1.0;
xy = clamp(xy, uTroikaClipRect.xy, uTroikaClipRect.zw);
vTroikaPosInBlock = xy;
xy.y *= -1.0;
position.xy = xy;
`;

	// language=GLSL
	const FRAGMENT_DEFS = `
uniform vec2 uTroikaBlockSize;
uniform vec4 uTroikaCornerRadii;
uniform vec4 uTroikaBorderWidth;
varying vec2 vTroikaPosInBlock;
const vec4 NO_BORDER = vec4(0.,0.,0.,0.);

float troikaEllipseRadiusAtAngle(in float angle, in float rx, in float ry) {
  if (rx == ry) {return rx;}
  float _cos = cos(angle);
  float _sin = sin(angle);
  return 1.0 / sqrt((_cos*_cos)/(rx*rx) + (_sin*_sin)/(ry*ry));
}

void troikaGetCurveDists(
  in vec2 pos, in vec2 radCenter, in float outerR, in float xBorder, in float yBorder, 
  out float dOuter, out float dInner
) {
  vec2 adjPos = pos - radCenter;
  float angle = atan(adjPos.y, adjPos.x);
  dOuter = troikaEllipseRadiusAtAngle(angle, outerR, outerR) - length(adjPos);
  dInner = uTroikaBorderWidth == NO_BORDER ? dInner : 
    troikaEllipseRadiusAtAngle(angle, max(0.0, outerR - xBorder), max(0.0, outerR - yBorder)) - length(adjPos);
}

float troikaGetAlphaMultiplier() {
  // Short aliases
  vec2 dim = uTroikaBlockSize;
  vec4 rad = uTroikaCornerRadii;
  vec4 bdr = uTroikaBorderWidth;
  vec2 pos = vTroikaPosInBlock;

  float dOuter;
  float dInner;
  bool isOnCurve = true;
  bool isBorder = uTroikaBorderWidth != NO_BORDER;

  // Top left
  if (pos.x < rad[0] && pos.y < rad[0]) {
    troikaGetCurveDists(pos, vec2(rad[0], rad[0]), rad[0], bdr[3], bdr[0], dOuter, dInner);
  }
  // Top Right
  else if (pos.x > dim.x - rad[1] && pos.y < rad[1]) {
    troikaGetCurveDists(pos, vec2(dim.x - rad[1], rad[1]), rad[1], bdr[1], bdr[0], dOuter, dInner);
  }
  // Bottom Right
  else if (pos.x > dim.x - rad[2] && pos.y > dim.y - rad[2]) {
    troikaGetCurveDists(pos, vec2(dim.x - rad[2], dim.y - rad[2]), rad[2], bdr[1], bdr[2], dOuter, dInner);
  }
  // Bottom Left
  else if (pos.x < rad[3] && pos.y > dim.y - rad[3]) {
    troikaGetCurveDists(pos, vec2(rad[3], dim.y - rad[3]), rad[3], bdr[3], bdr[2], dOuter, dInner);
  }
  // Not on a curve, use closest side
  else {
    isOnCurve = false;
    dOuter = min(min(pos.x, pos.y), min(dim.x - pos.x, dim.y - pos.y));
    dInner = isBorder ? min(min(pos.x - bdr[3], pos.y - bdr[0]), min(dim.x - pos.x - bdr[1], dim.y - pos.y - bdr[2])) : dInner;
  }

  float alpha;
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
    float aa = length(fwidth(pos)) * 0.5;
    alpha = isOnCurve ? smoothstep(-aa, aa, dOuter) : 1.0;
    alpha = isBorder ? min(alpha, (dOuter == dInner) ? 0.0 : smoothstep(aa, -aa, dInner)) : alpha;
    return alpha;
  #else
    alpha = step(0.0, dOuter);
    alpha = isBorder ? min(alpha, step(0.0, -dInner)) : alpha;
  #endif
  return alpha;
}
`;

	// language=GLSL prefix="void main() {" suffix="}"
	const FRAGMENT_COLOR_TRANSFORM = `
float troikaAlphaMult = troikaGetAlphaMultiplier();
if (troikaAlphaMult == 0.0) {
  discard;
} else {
  gl_FragColor.a *= troikaAlphaMult;
}
`;


	function createUIBlockLayerDerivedMaterial(baseMaterial) {
	  const material = createDerivedMaterial(baseMaterial, {
	    defines: {
	      TROIKA_UI_BLOCK: ''
	    },
	    extensions: {
	      derivatives: true
	    },
	    uniforms: {
	      uTroikaBlockSize: {value: new Vector2()},
	      uTroikaClipRect: {value: new Vector4(0,0,0,0)},
	      uTroikaCornerRadii: {value: new Vector4(0,0,0,0)},
	      uTroikaBorderWidth: {value: new Vector4(0,0,0,0)}
	    },
	    vertexDefs: VERTEX_DEFS,
	    vertexTransform: VERTEX_TRANSFORM,
	    fragmentDefs: FRAGMENT_DEFS,
	    fragmentColorTransform: FRAGMENT_COLOR_TRANSFORM
	  });

	  // WebGLShadowMap reverses the side of the shadow material by default, which fails
	  // for planes, so here we force the `shadowSide` to always match the main side.
	  Object.defineProperty(material, 'shadowSide', {
	    get() {
	      return this.side
	    },
	    set() {
	      //no-op
	    }
	  });

	  //force transparency - TODO is this reasonable?
	  material.transparent = true;

	  return material
	}

	const geometry$1 = new PlaneGeometry(1, 1).translate(0.5, -0.5, 0);
	const defaultMaterial$1 = new MeshBasicMaterial({color: 0});
	const emptyVec2 = Object.freeze(new Vector2());
	const emptyVec4$1 = Object.freeze(new Vector4(0,0,0,0));

	const shadowMaterialPropDefs = {
	  // Create and update materials for shadows upon request:
	  customDepthMaterial: {
	    get() {
	      return this.material.getDepthMaterial()
	    }
	  },
	  customDistanceMaterial: {
	    get() {
	      return this.material.getDistanceMaterial()
	    }
	  }
	};

	const instanceMeshesByKey = new Map();

	/**
	 * A single layer in a UI Block's rendering, e.g. background or border. All layers honor
	 * border radius, which is calculated shader-side for perfectly smooth curves at any scale,
	 * with antialiasing.
	 *
	 * Layer meshes are rendered via GPU instancing when possible -- specifically when they share
	 * the same Material instance, layering depth, and shadow behavior.
	 *
	 * You shouldn't have to use this directly; UIBlock3DFacade will create these as needed
	 * based on background/border styles.
	 */
	class UIBlockLayer3DFacade extends Instanceable3DFacade {
	  constructor(parent) {
	    super(parent);

	    this._colorObj = new Color();

	    // Properties
	    this.size = emptyVec2;
	    this.borderRadius = emptyVec4$1;
	    this.borderWidth = emptyVec4$1;
	    this.color = 0;
	    this.isBorder = false;
	    this.material = defaultMaterial$1;
	  }

	  afterUpdate() {
	    let {material, depthOffset, castShadow, receiveShadow, color, renderOrder} = this;
	    if (!material) { material = defaultMaterial$1; }

	    // Find or create the instanced mesh
	    let meshKey = `${material.id}|${renderOrder}|${depthOffset}|${castShadow}|${receiveShadow}`;
	    if (meshKey !== this._prevMeshKey) {
	      let mesh = instanceMeshesByKey.get(meshKey);
	      if (!mesh) {
	        let derivedMaterial = createUIBlockLayerDerivedMaterial(material);
	        derivedMaterial.polygonOffset = !!this.depthOffset;
	        derivedMaterial.polygonOffsetFactor = derivedMaterial.polygonOffsetUnits = this.depthOffset || 0;
	        // dispose the derived material when its base material is disposed:
	        material.addEventListener('dispose', function onDispose() {
	          material.removeEventListener('dispose', onDispose);
	          derivedMaterial.dispose();
	        });

	        mesh = new Mesh(geometry$1, derivedMaterial);
	        mesh._instanceKey = meshKey;
	        mesh.castShadow = castShadow;
	        mesh.receiveShadow = receiveShadow;
	        mesh.renderOrder = renderOrder;
	        Object.defineProperties(mesh, shadowMaterialPropDefs);
	        instanceMeshesByKey.set(meshKey, mesh);
	      }
	      this.instancedThreeObject = mesh;
	      this._prevMeshKey = meshKey;
	    }

	    // Set material uniform values
	    this.setInstanceUniform('uTroikaBlockSize', this.size);
	    this.setInstanceUniform('uTroikaCornerRadii', this.borderRadius);
	    this.setInstanceUniform('uTroikaClipRect', this.clipRect);
	    this.setInstanceUniform('uTroikaBorderWidth', this.isBorder ? this.borderWidth : emptyVec4$1);
	    if (color !== this._lastColor) {
	      this._lastColor = color;
	      this.setInstanceUniform('diffuse', new Color(color));
	    }

	    super.afterUpdate();
	  }

	  getBoundingSphere() {
	    return null //parent will handle bounding sphere and raycasting
	  }
	}

	let barGeometry;


	class ScrollbarBarFacade extends Object3DFacade {
	  constructor(parent) {
	    const mesh = new Mesh(
	      barGeometry || (barGeometry =
	        new CylinderGeometry(0.5, 0.5, 1, 8).translate(0, -0.5, 0)
	      ),
	      // TODO allow overriding material
	      new MeshBasicMaterial({
	        color: 0xffffff,
	        transparent: true,
	        opacity: 0
	      })
	    );
	    super(parent, mesh);
	    this.girth = 0;
	    this.length = 0;
	  }

	  afterUpdate () {
	    this.scaleX = this.scaleZ = this.girth;
	    this.scaleY = this.length;
	    this.rotateZ = this.horizontal ? Math.PI / 2 : 0;
	    this.threeObject.material.opacity = this.opacity;
	    super.afterUpdate();
	  }
	}

	const targets = new WeakMap();

	const opacityTransition = {
	  opacity: {duration: 300}
	};

	class ScrollbarsFacade extends ParentFacade {
	  constructor(parent) {
	    super(parent);
	    this._onOver = e => {
	      this.hovering = true;
	      this.afterUpdate();
	    };
	    this._onOut = e => {
	      this.hovering = false;
	      this.afterUpdate();
	    };
	  }

	  set target(target) {
	    const oldTarget = targets.get(this);
	    if (target !== oldTarget) {
	      if (oldTarget) {
	        oldTarget.removeEventListener('mouseover', this._onOver);
	        oldTarget.removeEventListener('mouseout', this._onOut);
	      }
	      if (target) {
	        target.addEventListener('mouseover', this._onOver);
	        target.addEventListener('mouseout', this._onOut);
	      }
	      targets.set(this, target);
	    }
	  }
	  get target() {
	    return targets.get(this)
	  }

	  describeChildren() {
	    const {target} = this;
	    const children = this._childArr || (this._childArr = []);
	    children.length = 0;
	    if (target) {
	      const {
	        offsetWidth,
	        offsetHeight,
	        scrollHeight,
	        scrollWidth,
	        clientWidth,
	        clientHeight
	      } = target;
	      const fontSize = target.getComputedFontSize();

	      if (scrollWidth > clientWidth) {
	        const hScrollbar = this._hDef || (this._hDef = {
	          key: 'h',
	          facade: ScrollbarBarFacade,
	          horizontal: true,
	          transition: opacityTransition
	        });
	        hScrollbar.girth = Math.min( fontSize / 4, offsetHeight / 10);
	        hScrollbar.length = Math.max(clientWidth * clientWidth / scrollWidth, fontSize);
	        hScrollbar.x = target.clientLeft + (clientWidth - hScrollbar.length) * (target.scrollLeft / (scrollWidth - clientWidth));
	        hScrollbar.y = -offsetHeight;
	        hScrollbar.opacity = this.hovering ? 0.5 : 0;
	        hScrollbar.renderOrder = this.renderOrder;
	        children.push(hScrollbar);
	      }
	      if (scrollHeight > clientHeight) {
	        const vScrollbar = this._vDef || (this._vDef = {
	          key: 'v',
	          facade: ScrollbarBarFacade,
	          transition: opacityTransition
	        });
	        vScrollbar.girth = Math.min( fontSize / 4, offsetWidth / 10);
	        vScrollbar.length = Math.max(clientHeight * clientHeight / scrollHeight, fontSize);
	        vScrollbar.x = offsetWidth;
	        vScrollbar.y = -(target.clientTop + (clientHeight - vScrollbar.length) * (target.scrollTop / (scrollHeight - clientHeight)));
	        vScrollbar.opacity = this.hovering ? 0.5 : 0;
	        vScrollbar.renderOrder = this.renderOrder;
	        children.push(vScrollbar);
	      }
	    }
	    return children
	  }

	  destructor () {
	    this.target = null;
	    super.destructor();
	  }
	}

	const raycastMesh = new Mesh(new PlaneGeometry(1, 1).translate(0.5, -0.5, 0));
	const tempMat4 = new Matrix4();
	const tempVec4 = new Vector4(0,0,0,0);
	const emptyVec4 = Object.freeze(new Vector4(0,0,0,0));
	const tempPlane = new Plane();
	const DEFAULT_FONT_SIZE = 16;
	const DEFAULT_LINE_HEIGHT = 'normal';

	const groupVisiblePropDef = {
	  get() {
	    return !this._priv_hidden && !this.$facade.isFullyClipped
	  },
	  set(value) {
	    this._priv_hidden = !value;
	  }
	};

	/**
	 * Represents a single block UI element, essentially just a 2D rectangular block that
	 * can contain text, be styled with background/border, and participate in flexbox layout.
	 * Its behavior and styling is very much like an HTML element using flexbox.
	 */
	class UIBlock3DFacadeBase extends Group3DFacade {
	  constructor(parent) {
	    super(parent);

	    // If fully hidden by parent clipping rect, cull the whole Group out of the scene
	    Object.defineProperty(this.threeObject, 'visible', groupVisiblePropDef);

	    // Anonymous container for bg/border/scrollbar child objects; these live separate
	    // from the main `children` tree
	    this.layers = new Group3DFacade(this);
	    this.layers.children = [null, null, null];

	    // Shared objects for passing down to layers - treated as immutable
	    this._sizeVec2 = Object.freeze(new Vector2());
	    this._clipRectVec4 = emptyVec4;
	    this._borderWidthVec4 = emptyVec4;
	    this._borderRadiiVec4 = emptyVec4

	    ;(this._geomBoundingSphere = new Sphere()).version = 0;
	    this._wasFullyClipped = true;
	  }

	  /**
	   * @override When fully clipped out of view, skip updating children entirely. We do this by
	   * overriding `updateChildren` instead of using the `shouldUpdateChildren` hook, because the
	   * latter would still traverse the child tree to sync matrices, which we don't need here.
	   * TODO this doesn't work so well when descendants are absolutely positioned or overflow outside our bounds
	   */
	  updateChildren(children) {
	    if (!this.isFullyClipped || !this._wasFullyClipped) {
	      super.updateChildren(children);
	    }
	  }

	  updateMatrices() {
	    super.updateMatrices();
	    this.layers.traverse(updateMatrices);
	  }

	  afterUpdate() {
	    let {
	      layers,
	      backgroundColor,
	      backgroundMaterial,
	      borderWidth,
	      borderColor,
	      borderMaterial,
	      text,
	      offsetLeft,
	      offsetTop,
	      offsetWidth,
	      offsetHeight,
	      parentFlexNode,
	      flexNodeDepth,
	      isFullyClipped,
	      _wasFullyClipped,
	      _borderWidthVec4,
	      _clipRectVec4,
	      _sizeVec2
	    } = this;
	    const hasLayout = offsetWidth !== null;
	    const hasNonZeroSize = !!(offsetWidth && offsetHeight);
	    const hasBg = hasNonZeroSize && !isFullyClipped && (backgroundColor != null || backgroundMaterial != null);
	    const hasBorder = hasNonZeroSize && !isFullyClipped && (borderColor != null || borderMaterial != null) && Math.max(...borderWidth) > 0;
	    const canScroll = hasNonZeroSize && (this.overflow === 'scroll' || this.overflow === 'auto') && (
	      this.scrollHeight > this.clientHeight || this.scrollWidth > this.clientWidth
	    );

	    // Update the block's element and size from flexbox computed values
	    if (hasLayout) {
	      if (parentFlexNode) {
	        const isAbsPos = this.position === 'absolute';
	        this.x = offsetLeft - (isAbsPos ? 0 : parentFlexNode.scrollLeft);
	        this.y = -(offsetTop - (isAbsPos ? 0 : parentFlexNode.scrollTop));
	      }
	      if (offsetWidth !== _sizeVec2.x || offsetHeight !== _sizeVec2.y) {
	        _sizeVec2 = this._sizeVec2 = Object.freeze(new Vector2(offsetWidth, offsetHeight));

	        // Update pre-worldmatrix bounding sphere
	        const sphere = this._geomBoundingSphere;
	        sphere.radius = Math.sqrt(offsetWidth * offsetWidth / 4 + offsetHeight * offsetHeight / 4);
	        sphere.center.set(offsetWidth / 2, -offsetHeight / 2, 0);
	        sphere.version++;
	      }
	    }

	    if (!isFullyClipped || !_wasFullyClipped) {
	      // Update shared vector objects for the sublayers
	      const radii = (hasBg || hasBorder) ? this._normalizeBorderRadius() : null;

	      tempVec4.fromArray(borderWidth);
	      if (!tempVec4.equals(_borderWidthVec4)) {
	        _borderWidthVec4 = this._borderWidthVec4 = Object.freeze(tempVec4.clone());
	      }
	      tempVec4.set(
	        Math.max(this.clipLeft, 0),
	        Math.max(this.clipTop, 0),
	        Math.min(this.clipRight, offsetWidth),
	        Math.min(this.clipBottom, offsetHeight)
	      );
	      if (!tempVec4.equals(_clipRectVec4)) {
	        _clipRectVec4 = this._clipRectVec4 = Object.freeze(tempVec4.clone());
	      }

	      // Update rendering layers...
	      let bgLayer = null;
	      if (hasBg) {
	        bgLayer = this._bgLayerDef || (this._bgLayerDef = {
	          key: 'bg',
	          facade: UIBlockLayer3DFacade
	        });
	        bgLayer.size = _sizeVec2;
	        bgLayer.color = backgroundColor;
	        bgLayer.borderRadius = radii;
	        bgLayer.material = backgroundMaterial;
	        bgLayer.clipRect = _clipRectVec4;
	        bgLayer.depthOffset = -flexNodeDepth;
	        bgLayer.renderOrder = flexNodeDepth; //TODO how can we make this play with the rest of the scene?
	        bgLayer.castShadow = this.castShadow;
	        bgLayer.receiveShadow = this.receiveShadow;
	      }
	      layers.children[0] = bgLayer;

	      let borderLayer = null;
	      if (hasBorder) {
	        borderLayer = this._borderLayerDef || (this._borderLayerDef = {
	          key: 'border',
	          facade: UIBlockLayer3DFacade,
	          isBorder: true
	        });
	        borderLayer.size = _sizeVec2;
	        borderLayer.color = borderColor;
	        borderLayer.borderWidth = _borderWidthVec4;
	        borderLayer.borderRadius = radii;
	        borderLayer.material = borderMaterial;
	        borderLayer.clipRect = _clipRectVec4;
	        borderLayer.depthOffset = -flexNodeDepth - 1;
	        borderLayer.renderOrder = flexNodeDepth + 1; //TODO how can we make this play with the rest of the scene?
	        borderLayer.castShadow = this.castShadow;
	        borderLayer.receiveShadow = this.receiveShadow;
	      }
	      layers.children[1] = borderLayer;

	      // Scrollbars if scrollable:
	      let scrollbarsLayer = null;
	      if (canScroll) {
	        scrollbarsLayer = this._scrollbarsDef || (this._scrollbarsDef = {
	          key: 'sb',
	          facade: ScrollbarsFacade,
	          target: this
	        });
	        scrollbarsLayer.renderOrder = flexNodeDepth + 2; //TODO how can we make this play with the rest of the scene?
	      }
	      layers.children[2] = scrollbarsLayer;

	      // Allow text to be specified as a single string child
	      if (!text && isTextNodeChild(this.children)) {
	        text = '' + this.children;
	      }
	      // Update text child...
	      if (text) {
	        const textChild = this._textChildDef || (this._textChildDef = {
	          key: 'text',
	          facade: UITextNode3DFacade
	        });
	        textChild.text = text;
	        textChild.font = getInheritable(this, 'font');
	        textChild.fontSize = this.getComputedFontSize();
	        textChild.textAlign = getInheritable(this, 'textAlign');
	        textChild.textIndent = getInheritable(this, 'textIndent');
	        textChild.lineHeight = getInheritable(this, 'lineHeight', DEFAULT_LINE_HEIGHT);
	        textChild.letterSpacing = getInheritable(this, 'letterSpacing', 0);
	        textChild.whiteSpace = getInheritable(this, 'whiteSpace');
	        textChild.overflowWrap = getInheritable(this, 'overflowWrap');
	        textChild.color = getInheritable(this, 'color');
	        textChild.colorRanges = this.colorRanges;
	        textChild.outlineWidth = this.textOutlineWidth || 0;
	        textChild.outlineColor = this.textOutlineColor;
	        textChild.outlineOpacity = this.textOutlineOpacity;
	        textChild.outlineBlur = this.textOutlineBlur || 0;
	        textChild.outlineOffsetX = this.textOutlineOffsetX || 0;
	        textChild.outlineOffsetY = this.textOutlineOffsetY || 0;
	        textChild.strokeWidth = this.textStrokeWidth || 0;
	        textChild.strokeColor = this.textStrokeColor;
	        textChild.strokeOpacity = this.textStrokeOpacity;
	        textChild.fillOpacity = this.textFillOpacity;
	        textChild.material = this.textMaterial;
	        textChild.depthOffset = -flexNodeDepth - 1;
	        textChild.renderOrder = flexNodeDepth + 1;
	        textChild.castShadow = this.castShadow;
	        textChild.receiveShadow = this.receiveShadow;
	        this._actualChildren = textChild; //NOTE: text content will clobber any other defined children
	      } else {
	        // Convert any children specified as plain strings to nested text blocks; handy for JSX style
	        let children = this.children;
	        if (Array.isArray(children)) {
	          for (let i = 0, len = children.length; i < len; i++) {
	            if (isTextNodeChild(children[i])) {
	              children = children.slice();
	              for (; i < len; i++) { //continue from here
	                if (isTextNodeChild(children[i])) {
	                  children[i] = {
	                    facade: UIBlock3DFacade,
	                    text: '' + children[i],
	                    textMaterial: this.textMaterial
	                  };
	                }
	              }
	              break
	            }
	          }
	        }
	        this._actualChildren = children;
	      }
	    }

	    // Add mousewheel and drag listeners if scrollable
	    if (canScroll !== this._couldScroll) {
	      this._couldScroll = canScroll;
	      this[`${canScroll ? 'add' : 'remove'}EventListener`]('wheel', wheelHandler);
	      this[`${canScroll ? 'add' : 'remove'}EventListener`]('dragstart', dragHandler);
	      this[`${canScroll ? 'add' : 'remove'}EventListener`]('drag', dragHandler);
	    }

	    super.afterUpdate();
	    if (!isFullyClipped || !_wasFullyClipped) {
	      layers.afterUpdate();
	    }
	    this._wasFullyClipped = isFullyClipped;
	  }

	  describeChildren () {
	    return this._actualChildren
	  }

	  getComputedFontSize() {
	    return getComputedFontSize(this, DEFAULT_FONT_SIZE)
	  }

	  _normalizeBorderRadius() {
	    let {
	      borderRadius:input,
	      offsetWidth=0,
	      offsetHeight=0,
	      _borderRadiiVec4:prevVec4
	    } = this;

	    // Normalize to four corner values
	    let tl, tr, br, bl;
	    if (Array.isArray(input)) {
	      const len = input.length;
	      tl = input[0] || 0;
	      tr = (len > 1 ? input[1] : input[0]) || 0;
	      br = (len > 2 ? input[2] : input[0]) || 0;
	      bl = (len > 3 ? input[3] : len > 1 ? input[1] : input[0]) || 0;
	    } else {
	      tl = tr = br = bl = input || 0;
	    }

	    if (tl !== 0 || tr !== 0 || br !== 0 || bl !== 0) { //avoid work for common no-radius case
	      // Resolve percentages
	      const minDimension = Math.min(offsetWidth, offsetHeight);
	      if (typeof tl === 'string' && /%$/.test(tl)) {
	        tl = parseInt(tl, 10) / 100 * minDimension;
	      }
	      if (typeof tr === 'string' && /%$/.test(tr)) {
	        tr = parseInt(tr, 10) / 100 * minDimension;
	      }
	      if (typeof bl === 'string' && /%$/.test(bl)) {
	        bl = parseInt(bl, 10) / 100 * minDimension;
	      }
	      if (typeof br === 'string' && /%$/.test(br)) {
	        br = parseInt(br, 10) / 100 * minDimension;
	      }

	      // If any radii overlap based on the block's current size, reduce them all by the same ratio, ala CSS3.
	      let radiiAdjRatio = Math.min(
	        offsetWidth / (tl + tr),
	        offsetHeight / (tr + br),
	        offsetWidth / (br + bl),
	        offsetHeight / (bl + tl)
	      );
	      if (radiiAdjRatio < 1) {
	        tl *= radiiAdjRatio;
	        tr *= radiiAdjRatio;
	        bl *= radiiAdjRatio;
	        br *= radiiAdjRatio;
	      }
	    }

	    // Update the Vector4 if anything changed
	    tempVec4.set(tl, tr, br, bl);
	    if (!tempVec4.equals(prevVec4)) {
	      prevVec4 = this._borderRadiiVec4 = Object.freeze(tempVec4.clone());
	    }
	    return prevVec4
	  }

	  /**
	   * @override Use our private boundingSphere which we keep updated as we get new
	   * layout metrics.
	   */
	  _getGeometryBoundingSphere() {
	    return this._geomBoundingSphere.radius && !this.isFullyClipped ? this._geomBoundingSphere : null
	  }

	  /**
	   * @override Custom raycaster to test against the layout block
	   */
	  raycast(raycaster) {
	    const {offsetWidth, offsetHeight, clipTop, clipRight, clipBottom, clipLeft} = this;
	    let hits = null;
	    if (offsetWidth && offsetHeight) {
	      raycastMesh.matrixWorld.multiplyMatrices(
	        this.threeObject.matrixWorld,
	        tempMat4.makeScale(offsetWidth, offsetHeight, 1)
	      );
	      hits = this._raycastObject(raycastMesh, raycaster);
	      if (hits) {
	        // Filter out hits that occurred on clipped areas
	        hits = hits.filter(hit => {
	          const x = hit.uv.x * offsetWidth;
	          const y = (1 - hit.uv.y) * offsetHeight;
	          return x > clipLeft && x < clipRight && y > clipTop && y < clipBottom
	        });

	        // Add a distance bias (used as secondary sort for equidistant intersections) to prevent
	        // container blocks from intercepting pointer events for their children. Also apply a
	        // slight rounding prevent floating point precision irregularities from reporting different
	        // distances for coplanar blocks.
	        hits.forEach(hit => {
	          hit.distance = parseFloat(hit.distance.toFixed(12));
	          hit.distanceBias = -this.flexNodeDepth;
	        });
	      }
	    }
	    return hits && hits.length ? hits : null
	  }


	  destructor() {
	    this.layers.destructor();
	    super.destructor();
	  }
	}

	// Extend as FlexNode
	const UIBlock3DFacade = extendAsFlexNode(UIBlock3DFacadeBase);

	INHERITABLES.forEach(prop => {
	  UIBlock3DFacade.prototype[prop] = 'inherit';
	});



	function wheelHandler(e) {
	  if (!e._didScroll) {
	    const facade = e.currentTarget;
	    let {deltaX, deltaY, deltaMode} = e.nativeEvent;
	    let deltaMultiplier;
	    if (deltaMode === 0x01) { //line mode
	      deltaMultiplier = getComputedFontSize(facade, DEFAULT_FONT_SIZE) *
	        getInheritable(facade, 'lineHeight', 1.2); //Note: fixed default since we can't resolve 'normal' here
	    } else { //pixel mode
	      //TODO can we more accurately scale to visual expectation?
	      deltaMultiplier = getComputedFontSize(facade, DEFAULT_FONT_SIZE) / 12;
	    }
	    deltaX *= deltaMultiplier;
	    deltaY *= deltaMultiplier;

	    const scrollLeft = Math.max(0, Math.min(
	      facade.scrollWidth - facade.clientWidth,
	      facade.scrollLeft + deltaX
	    ));
	    const scrollTop = Math.max(0, Math.min(
	      facade.scrollHeight - facade.clientHeight,
	      facade.scrollTop + deltaY
	    ));

	    // Only scroll if the major scroll direction would actually result in a scroll change
	    const abs = Math.abs;
	    if (
	      (scrollLeft !== facade.scrollLeft && abs(deltaX) > abs(deltaY)) ||
	      (scrollTop !== facade.scrollTop && abs(deltaY) > abs(deltaX))
	    ) {
	      facade.scrollLeft = scrollLeft;
	      facade.scrollTop = scrollTop;
	      facade.afterUpdate();
	      facade.requestRender();
	      e._didScroll = true;
	    }
	    e.preventDefault();
	  }
	}

	function dragHandler(e) {
	  if (!e._didScroll && !e.defaultPrevented) {
	    const facade = e.currentTarget;
	    const ray = e.ray.clone().applyMatrix4(invertMatrix4(facade.threeObject.matrixWorld, tempMat4));
	    const localPos = ray.intersectPlane(tempPlane.setComponents(0, 0, 1, 0), new Vector3());
	    const prevPos = facade._prevDragPos;
	    if (localPos && prevPos && e.type === 'drag') {
	      const deltaX = localPos.x - prevPos.x;
	      const deltaY = localPos.y - prevPos.y;
	      if (deltaX || deltaY) {
	        const scrollLeft = Math.max(0, Math.min(
	          facade.scrollWidth - facade.clientWidth,
	          facade.scrollLeft + deltaX
	        ));
	        const scrollTop = Math.max(0, Math.min(
	          facade.scrollHeight - facade.clientHeight,
	          facade.scrollTop + deltaY
	        ));
	        if (scrollLeft !== facade.scrollLeft || scrollTop !== facade.scrollTop) {
	          facade.scrollLeft = scrollLeft;
	          facade.scrollTop = scrollTop;
	          facade.afterUpdate();
	          facade.requestRender();
	          e._didScroll = true;
	        }
	      }
	    }
	    facade._prevDragPos = localPos;
	  }
	}


	function isTextNodeChild(child) {
	  return typeof child === 'string' || typeof child === 'number'
	}

	function updateMatrices(obj) {
	  if (obj.updateMatrices) {
	    obj.updateMatrices();
	  }
	}

	const geometry = new PlaneGeometry(1, 1).translate(0.5, -0.5, 0);
	const defaultMaterial = new MeshBasicMaterial();
	const loader = new TextureLoader();

	class UIImage3DFacade extends Object3DFacade {
	  constructor(parent, texture) {
	    const mesh = new Mesh(geometry, defaultMaterial.clone());
	    mesh.visible = false; //hidden until image is ready
	    super(parent, mesh);
	  }

	  afterUpdate() {
	    const {offsetLeft, offsetTop, offsetWidth, offsetHeight, src, threeObject:mesh, transparent} = this;
	    const material = mesh.material;
	    const hasLayout = !!(offsetWidth && offsetHeight);
	    if (hasLayout) {
	      this.x = offsetLeft;
	      this.y = -offsetTop;
	      this.scaleX = offsetWidth;
	      this.scaleY = offsetHeight;

	      const depth = this.flexNodeDepth;
	      material.polygonOffset = !!depth;
	      material.polygonOffsetFactor = material.polygonOffsetUnits = -depth || 0;
	      mesh.renderOrder = depth;
	    }

	    if (src !== this._lastSrc) {
	      loader.load(src, texture => {
	        if (material.map) {
	          material.map.dispose();
	        }
	        material.map = texture;
	        if (transparent) material.transparent = true;
	        this.aspectRatio = texture.image.width / texture.image.height;
	        this.afterUpdate();
	        this.requestRender();
	      });
	      this._lastSrc = src;
	    }

	    mesh.visible = !!(hasLayout && material.map && material.map.image.complete);

	    super.afterUpdate();
	  }

	  destructor() {
	    const texture = this.threeObject.material.map;
	    if (texture) {
	      texture.dispose();
	    }
	    super.destructor();
	  }
	}

	var UIImage3DFacade$1 = extendAsFlexNode(UIImage3DFacade);

	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Group3DFacade = Group3DFacade;
	exports.LinearFilter = LinearFilter;
	exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
	exports.LinearSRGBMaterial = LinearSRGBMaterial;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.Object3DFacade = Object3DFacade;
	exports.PlaneGeometry = PlaneGeometry;
	exports.RGBAFormat = RGBAFormat;
	exports.SRGBColorSpace = SRGBColorSpace;
	exports.Scene = Scene;
	exports.ShaderMaterial = ShaderMaterial;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.UIBlock3DFacade = UIBlock3DFacade;
	exports.UIImage3DFacade = UIImage3DFacade$1;
	exports.VideoTexture = VideoTexture;
	exports.WebGPU = WebGPU;
	exports.WebGPURenderer = WebGPURenderer;
	exports.World3DFacade = World3DFacade;
	exports.extendAsFlexNode = extendAsFlexNode;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({});
